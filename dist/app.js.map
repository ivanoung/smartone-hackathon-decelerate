{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/buffer/node_modules/isarray/index.js","webpack:///./src/Page/Dashboard/dashboard.scss","webpack:///./node_modules/css-loader/lib/css-base.js","webpack:///./node_modules/d3-array/src/array.js","webpack:///./node_modules/d3-array/src/ascending.js","webpack:///./node_modules/d3-array/src/bisect.js","webpack:///./node_modules/d3-array/src/bisector.js","webpack:///./node_modules/d3-array/src/constant.js","webpack:///./node_modules/d3-array/src/cross.js","webpack:///./node_modules/d3-array/src/descending.js","webpack:///./node_modules/d3-array/src/deviation.js","webpack:///./node_modules/d3-array/src/extent.js","webpack:///./node_modules/d3-array/src/histogram.js","webpack:///./node_modules/d3-array/src/identity.js","webpack:///./node_modules/d3-array/src/index.js","webpack:///./node_modules/d3-array/src/max.js","webpack:///./node_modules/d3-array/src/mean.js","webpack:///./node_modules/d3-array/src/median.js","webpack:///./node_modules/d3-array/src/merge.js","webpack:///./node_modules/d3-array/src/min.js","webpack:///./node_modules/d3-array/src/number.js","webpack:///./node_modules/d3-array/src/pairs.js","webpack:///./node_modules/d3-array/src/permute.js","webpack:///./node_modules/d3-array/src/quantile.js","webpack:///./node_modules/d3-array/src/range.js","webpack:///./node_modules/d3-array/src/scan.js","webpack:///./node_modules/d3-array/src/shuffle.js","webpack:///./node_modules/d3-array/src/sum.js","webpack:///./node_modules/d3-array/src/threshold/freedmanDiaconis.js","webpack:///./node_modules/d3-array/src/threshold/scott.js","webpack:///./node_modules/d3-array/src/threshold/sturges.js","webpack:///./node_modules/d3-array/src/ticks.js","webpack:///./node_modules/d3-array/src/transpose.js","webpack:///./node_modules/d3-array/src/variance.js","webpack:///./node_modules/d3-array/src/zip.js","webpack:///./node_modules/d3-collection/src/entries.js","webpack:///./node_modules/d3-collection/src/index.js","webpack:///./node_modules/d3-collection/src/keys.js","webpack:///./node_modules/d3-collection/src/map.js","webpack:///./node_modules/d3-collection/src/nest.js","webpack:///./node_modules/d3-collection/src/set.js","webpack:///./node_modules/d3-collection/src/values.js","webpack:///./node_modules/d3-color/src/color.js","webpack:///./node_modules/d3-color/src/cubehelix.js","webpack:///./node_modules/d3-color/src/define.js","webpack:///./node_modules/d3-color/src/index.js","webpack:///./node_modules/d3-color/src/lab.js","webpack:///./node_modules/d3-color/src/math.js","webpack:///./node_modules/d3-contour/src/area.js","webpack:///./node_modules/d3-contour/src/array.js","webpack:///./node_modules/d3-contour/src/ascending.js","webpack:///./node_modules/d3-contour/src/blur.js","webpack:///./node_modules/d3-contour/src/constant.js","webpack:///./node_modules/d3-contour/src/contains.js","webpack:///./node_modules/d3-contour/src/contours.js","webpack:///./node_modules/d3-contour/src/density.js","webpack:///./node_modules/d3-contour/src/index.js","webpack:///./node_modules/d3-contour/src/noop.js","webpack:///./node_modules/d3-dispatch/src/dispatch.js","webpack:///./node_modules/d3-dispatch/src/index.js","webpack:///./node_modules/d3-dsv/src/csv.js","webpack:///./node_modules/d3-dsv/src/dsv.js","webpack:///./node_modules/d3-dsv/src/index.js","webpack:///./node_modules/d3-dsv/src/tsv.js","webpack:///./node_modules/d3-force/src/center.js","webpack:///./node_modules/d3-force/src/collide.js","webpack:///./node_modules/d3-force/src/constant.js","webpack:///./node_modules/d3-force/src/index.js","webpack:///./node_modules/d3-force/src/jiggle.js","webpack:///./node_modules/d3-force/src/link.js","webpack:///./node_modules/d3-force/src/manyBody.js","webpack:///./node_modules/d3-force/src/radial.js","webpack:///./node_modules/d3-force/src/simulation.js","webpack:///./node_modules/d3-force/src/x.js","webpack:///./node_modules/d3-force/src/y.js","webpack:///./node_modules/d3-format/src/defaultLocale.js","webpack:///./node_modules/d3-format/src/exponent.js","webpack:///./node_modules/d3-format/src/formatDecimal.js","webpack:///./node_modules/d3-format/src/formatGroup.js","webpack:///./node_modules/d3-format/src/formatNumerals.js","webpack:///./node_modules/d3-format/src/formatPrefixAuto.js","webpack:///./node_modules/d3-format/src/formatRounded.js","webpack:///./node_modules/d3-format/src/formatSpecifier.js","webpack:///./node_modules/d3-format/src/formatTrim.js","webpack:///./node_modules/d3-format/src/formatTypes.js","webpack:///./node_modules/d3-format/src/identity.js","webpack:///./node_modules/d3-format/src/index.js","webpack:///./node_modules/d3-format/src/locale.js","webpack:///./node_modules/d3-format/src/precisionFixed.js","webpack:///./node_modules/d3-format/src/precisionPrefix.js","webpack:///./node_modules/d3-format/src/precisionRound.js","webpack:///./node_modules/d3-geo/src/adder.js","webpack:///./node_modules/d3-geo/src/area.js","webpack:///./node_modules/d3-geo/src/bounds.js","webpack:///./node_modules/d3-geo/src/cartesian.js","webpack:///./node_modules/d3-geo/src/centroid.js","webpack:///./node_modules/d3-geo/src/circle.js","webpack:///./node_modules/d3-geo/src/clip/antimeridian.js","webpack:///./node_modules/d3-geo/src/clip/buffer.js","webpack:///./node_modules/d3-geo/src/clip/circle.js","webpack:///./node_modules/d3-geo/src/clip/extent.js","webpack:///./node_modules/d3-geo/src/clip/index.js","webpack:///./node_modules/d3-geo/src/clip/line.js","webpack:///./node_modules/d3-geo/src/clip/rectangle.js","webpack:///./node_modules/d3-geo/src/clip/rejoin.js","webpack:///./node_modules/d3-geo/src/compose.js","webpack:///./node_modules/d3-geo/src/constant.js","webpack:///./node_modules/d3-geo/src/contains.js","webpack:///./node_modules/d3-geo/src/distance.js","webpack:///./node_modules/d3-geo/src/graticule.js","webpack:///./node_modules/d3-geo/src/identity.js","webpack:///./node_modules/d3-geo/src/index.js","webpack:///./node_modules/d3-geo/src/interpolate.js","webpack:///./node_modules/d3-geo/src/length.js","webpack:///./node_modules/d3-geo/src/math.js","webpack:///./node_modules/d3-geo/src/noop.js","webpack:///./node_modules/d3-geo/src/path/area.js","webpack:///./node_modules/d3-geo/src/path/bounds.js","webpack:///./node_modules/d3-geo/src/path/centroid.js","webpack:///./node_modules/d3-geo/src/path/context.js","webpack:///./node_modules/d3-geo/src/path/index.js","webpack:///./node_modules/d3-geo/src/path/measure.js","webpack:///./node_modules/d3-geo/src/path/string.js","webpack:///./node_modules/d3-geo/src/pointEqual.js","webpack:///./node_modules/d3-geo/src/polygonContains.js","webpack:///./node_modules/d3-geo/src/projection/albers.js","webpack:///./node_modules/d3-geo/src/projection/albersUsa.js","webpack:///./node_modules/d3-geo/src/projection/azimuthal.js","webpack:///./node_modules/d3-geo/src/projection/azimuthalEqualArea.js","webpack:///./node_modules/d3-geo/src/projection/azimuthalEquidistant.js","webpack:///./node_modules/d3-geo/src/projection/conic.js","webpack:///./node_modules/d3-geo/src/projection/conicConformal.js","webpack:///./node_modules/d3-geo/src/projection/conicEqualArea.js","webpack:///./node_modules/d3-geo/src/projection/conicEquidistant.js","webpack:///./node_modules/d3-geo/src/projection/cylindricalEqualArea.js","webpack:///./node_modules/d3-geo/src/projection/equalEarth.js","webpack:///./node_modules/d3-geo/src/projection/equirectangular.js","webpack:///./node_modules/d3-geo/src/projection/fit.js","webpack:///./node_modules/d3-geo/src/projection/gnomonic.js","webpack:///./node_modules/d3-geo/src/projection/identity.js","webpack:///./node_modules/d3-geo/src/projection/index.js","webpack:///./node_modules/d3-geo/src/projection/mercator.js","webpack:///./node_modules/d3-geo/src/projection/naturalEarth1.js","webpack:///./node_modules/d3-geo/src/projection/orthographic.js","webpack:///./node_modules/d3-geo/src/projection/resample.js","webpack:///./node_modules/d3-geo/src/projection/stereographic.js","webpack:///./node_modules/d3-geo/src/projection/transverseMercator.js","webpack:///./node_modules/d3-geo/src/rotation.js","webpack:///./node_modules/d3-geo/src/stream.js","webpack:///./node_modules/d3-geo/src/transform.js","webpack:///./node_modules/d3-hierarchy/src/accessors.js","webpack:///./node_modules/d3-hierarchy/src/array.js","webpack:///./node_modules/d3-hierarchy/src/cluster.js","webpack:///./node_modules/d3-hierarchy/src/constant.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/ancestors.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/count.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/descendants.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/each.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/eachAfter.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/eachBefore.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/index.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/leaves.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/links.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/path.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/sort.js","webpack:///./node_modules/d3-hierarchy/src/hierarchy/sum.js","webpack:///./node_modules/d3-hierarchy/src/index.js","webpack:///./node_modules/d3-hierarchy/src/pack/enclose.js","webpack:///./node_modules/d3-hierarchy/src/pack/index.js","webpack:///./node_modules/d3-hierarchy/src/pack/siblings.js","webpack:///./node_modules/d3-hierarchy/src/partition.js","webpack:///./node_modules/d3-hierarchy/src/stratify.js","webpack:///./node_modules/d3-hierarchy/src/tree.js","webpack:///./node_modules/d3-hierarchy/src/treemap/binary.js","webpack:///./node_modules/d3-hierarchy/src/treemap/dice.js","webpack:///./node_modules/d3-hierarchy/src/treemap/index.js","webpack:///./node_modules/d3-hierarchy/src/treemap/resquarify.js","webpack:///./node_modules/d3-hierarchy/src/treemap/round.js","webpack:///./node_modules/d3-hierarchy/src/treemap/slice.js","webpack:///./node_modules/d3-hierarchy/src/treemap/sliceDice.js","webpack:///./node_modules/d3-hierarchy/src/treemap/squarify.js","webpack:///./node_modules/d3-interpolate/src/array.js","webpack:///./node_modules/d3-interpolate/src/basis.js","webpack:///./node_modules/d3-interpolate/src/basisClosed.js","webpack:///./node_modules/d3-interpolate/src/color.js","webpack:///./node_modules/d3-interpolate/src/constant.js","webpack:///./node_modules/d3-interpolate/src/cubehelix.js","webpack:///./node_modules/d3-interpolate/src/date.js","webpack:///./node_modules/d3-interpolate/src/discrete.js","webpack:///./node_modules/d3-interpolate/src/hcl.js","webpack:///./node_modules/d3-interpolate/src/hsl.js","webpack:///./node_modules/d3-interpolate/src/hue.js","webpack:///./node_modules/d3-interpolate/src/index.js","webpack:///./node_modules/d3-interpolate/src/lab.js","webpack:///./node_modules/d3-interpolate/src/number.js","webpack:///./node_modules/d3-interpolate/src/object.js","webpack:///./node_modules/d3-interpolate/src/piecewise.js","webpack:///./node_modules/d3-interpolate/src/quantize.js","webpack:///./node_modules/d3-interpolate/src/rgb.js","webpack:///./node_modules/d3-interpolate/src/round.js","webpack:///./node_modules/d3-interpolate/src/string.js","webpack:///./node_modules/d3-interpolate/src/transform/decompose.js","webpack:///./node_modules/d3-interpolate/src/transform/index.js","webpack:///./node_modules/d3-interpolate/src/transform/parse.js","webpack:///./node_modules/d3-interpolate/src/value.js","webpack:///./node_modules/d3-interpolate/src/zoom.js","webpack:///./node_modules/d3-path/src/index.js","webpack:///./node_modules/d3-path/src/path.js","webpack:///./node_modules/d3-quadtree/src/add.js","webpack:///./node_modules/d3-quadtree/src/cover.js","webpack:///./node_modules/d3-quadtree/src/data.js","webpack:///./node_modules/d3-quadtree/src/extent.js","webpack:///./node_modules/d3-quadtree/src/find.js","webpack:///./node_modules/d3-quadtree/src/index.js","webpack:///./node_modules/d3-quadtree/src/quad.js","webpack:///./node_modules/d3-quadtree/src/quadtree.js","webpack:///./node_modules/d3-quadtree/src/remove.js","webpack:///./node_modules/d3-quadtree/src/root.js","webpack:///./node_modules/d3-quadtree/src/size.js","webpack:///./node_modules/d3-quadtree/src/visit.js","webpack:///./node_modules/d3-quadtree/src/visitAfter.js","webpack:///./node_modules/d3-quadtree/src/x.js","webpack:///./node_modules/d3-quadtree/src/y.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/Accent.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/Dark2.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/Paired.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/Pastel1.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/Pastel2.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/Set1.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/Set2.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/Set3.js","webpack:///./node_modules/d3-scale-chromatic/src/categorical/category10.js","webpack:///./node_modules/d3-scale-chromatic/src/colors.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/BrBG.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/PRGn.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/PiYG.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/PuOr.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/RdBu.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/RdGy.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js","webpack:///./node_modules/d3-scale-chromatic/src/diverging/Spectral.js","webpack:///./node_modules/d3-scale-chromatic/src/index.js","webpack:///./node_modules/d3-scale-chromatic/src/ramp.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-single/Blues.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-single/Greens.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-single/Greys.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-single/Purples.js","webpack:///./node_modules/d3-scale-chromatic/src/sequential-single/Reds.js","webpack:///./node_modules/d3-scale/src/array.js","webpack:///./node_modules/d3-scale/src/band.js","webpack:///./node_modules/d3-scale/src/constant.js","webpack:///./node_modules/d3-scale/src/continuous.js","webpack:///./node_modules/d3-scale/src/diverging.js","webpack:///./node_modules/d3-scale/src/identity.js","webpack:///./node_modules/d3-scale/src/index.js","webpack:///./node_modules/d3-scale/src/linear.js","webpack:///./node_modules/d3-scale/src/log.js","webpack:///./node_modules/d3-scale/src/nice.js","webpack:///./node_modules/d3-scale/src/number.js","webpack:///./node_modules/d3-scale/src/ordinal.js","webpack:///./node_modules/d3-scale/src/pow.js","webpack:///./node_modules/d3-scale/src/quantile.js","webpack:///./node_modules/d3-scale/src/quantize.js","webpack:///./node_modules/d3-scale/src/sequential.js","webpack:///./node_modules/d3-scale/src/threshold.js","webpack:///./node_modules/d3-scale/src/tickFormat.js","webpack:///./node_modules/d3-scale/src/time.js","webpack:///./node_modules/d3-scale/src/utcTime.js","webpack:///./node_modules/d3-shape/src/arc.js","webpack:///./node_modules/d3-shape/src/area.js","webpack:///./node_modules/d3-shape/src/areaRadial.js","webpack:///./node_modules/d3-shape/src/array.js","webpack:///./node_modules/d3-shape/src/constant.js","webpack:///./node_modules/d3-shape/src/curve/basis.js","webpack:///./node_modules/d3-shape/src/curve/basisClosed.js","webpack:///./node_modules/d3-shape/src/curve/basisOpen.js","webpack:///./node_modules/d3-shape/src/curve/bundle.js","webpack:///./node_modules/d3-shape/src/curve/cardinal.js","webpack:///./node_modules/d3-shape/src/curve/cardinalClosed.js","webpack:///./node_modules/d3-shape/src/curve/cardinalOpen.js","webpack:///./node_modules/d3-shape/src/curve/catmullRom.js","webpack:///./node_modules/d3-shape/src/curve/catmullRomClosed.js","webpack:///./node_modules/d3-shape/src/curve/catmullRomOpen.js","webpack:///./node_modules/d3-shape/src/curve/linear.js","webpack:///./node_modules/d3-shape/src/curve/linearClosed.js","webpack:///./node_modules/d3-shape/src/curve/monotone.js","webpack:///./node_modules/d3-shape/src/curve/natural.js","webpack:///./node_modules/d3-shape/src/curve/radial.js","webpack:///./node_modules/d3-shape/src/curve/step.js","webpack:///./node_modules/d3-shape/src/descending.js","webpack:///./node_modules/d3-shape/src/identity.js","webpack:///./node_modules/d3-shape/src/index.js","webpack:///./node_modules/d3-shape/src/line.js","webpack:///./node_modules/d3-shape/src/lineRadial.js","webpack:///./node_modules/d3-shape/src/link/index.js","webpack:///./node_modules/d3-shape/src/math.js","webpack:///./node_modules/d3-shape/src/noop.js","webpack:///./node_modules/d3-shape/src/offset/diverging.js","webpack:///./node_modules/d3-shape/src/offset/expand.js","webpack:///./node_modules/d3-shape/src/offset/none.js","webpack:///./node_modules/d3-shape/src/offset/silhouette.js","webpack:///./node_modules/d3-shape/src/offset/wiggle.js","webpack:///./node_modules/d3-shape/src/order/ascending.js","webpack:///./node_modules/d3-shape/src/order/descending.js","webpack:///./node_modules/d3-shape/src/order/insideOut.js","webpack:///./node_modules/d3-shape/src/order/none.js","webpack:///./node_modules/d3-shape/src/order/reverse.js","webpack:///./node_modules/d3-shape/src/pie.js","webpack:///./node_modules/d3-shape/src/point.js","webpack:///./node_modules/d3-shape/src/pointRadial.js","webpack:///./node_modules/d3-shape/src/stack.js","webpack:///./node_modules/d3-shape/src/symbol.js","webpack:///./node_modules/d3-shape/src/symbol/circle.js","webpack:///./node_modules/d3-shape/src/symbol/cross.js","webpack:///./node_modules/d3-shape/src/symbol/diamond.js","webpack:///./node_modules/d3-shape/src/symbol/square.js","webpack:///./node_modules/d3-shape/src/symbol/star.js","webpack:///./node_modules/d3-shape/src/symbol/triangle.js","webpack:///./node_modules/d3-shape/src/symbol/wye.js","webpack:///./node_modules/d3-time-format/src/defaultLocale.js","webpack:///./node_modules/d3-time-format/src/index.js","webpack:///./node_modules/d3-time-format/src/isoFormat.js","webpack:///./node_modules/d3-time-format/src/isoParse.js","webpack:///./node_modules/d3-time-format/src/locale.js","webpack:///./node_modules/d3-time/src/day.js","webpack:///./node_modules/d3-time/src/duration.js","webpack:///./node_modules/d3-time/src/hour.js","webpack:///./node_modules/d3-time/src/index.js","webpack:///./node_modules/d3-time/src/interval.js","webpack:///./node_modules/d3-time/src/millisecond.js","webpack:///./node_modules/d3-time/src/minute.js","webpack:///./node_modules/d3-time/src/month.js","webpack:///./node_modules/d3-time/src/second.js","webpack:///./node_modules/d3-time/src/utcDay.js","webpack:///./node_modules/d3-time/src/utcHour.js","webpack:///./node_modules/d3-time/src/utcMinute.js","webpack:///./node_modules/d3-time/src/utcMonth.js","webpack:///./node_modules/d3-time/src/utcWeek.js","webpack:///./node_modules/d3-time/src/utcYear.js","webpack:///./node_modules/d3-time/src/week.js","webpack:///./node_modules/d3-time/src/year.js","webpack:///./node_modules/d3-timer/src/index.js","webpack:///./node_modules/d3-timer/src/interval.js","webpack:///./node_modules/d3-timer/src/timeout.js","webpack:///./node_modules/d3-timer/src/timer.js","webpack:///./node_modules/d3-voronoi/src/Beach.js","webpack:///./node_modules/d3-voronoi/src/Cell.js","webpack:///./node_modules/d3-voronoi/src/Circle.js","webpack:///./node_modules/d3-voronoi/src/Diagram.js","webpack:///./node_modules/d3-voronoi/src/Edge.js","webpack:///./node_modules/d3-voronoi/src/RedBlackTree.js","webpack:///./node_modules/d3-voronoi/src/constant.js","webpack:///./node_modules/d3-voronoi/src/index.js","webpack:///./node_modules/d3-voronoi/src/point.js","webpack:///./node_modules/d3-voronoi/src/voronoi.js","webpack:///./node_modules/history/es/DOMUtils.js","webpack:///./node_modules/history/es/LocationUtils.js","webpack:///./node_modules/history/es/PathUtils.js","webpack:///./node_modules/history/es/createBrowserHistory.js","webpack:///./node_modules/history/es/createHashHistory.js","webpack:///./node_modules/history/es/createMemoryHistory.js","webpack:///./node_modules/history/es/createTransitionManager.js","webpack:///./node_modules/history/es/index.js","webpack:///./node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/invariant/browser.js","webpack:///./node_modules/isarray/index.js","webpack:///./node_modules/json-stable-stringify/index.js","webpack:///./node_modules/jsonify/index.js","webpack:///./node_modules/jsonify/lib/parse.js","webpack:///./node_modules/jsonify/lib/stringify.js","webpack:///./node_modules/object-assign/index.js","webpack:///./node_modules/path-to-regexp/index.js","webpack:///./node_modules/prop-types/checkPropTypes.js","webpack:///./node_modules/prop-types/factoryWithTypeCheckers.js","webpack:///./node_modules/prop-types/index.js","webpack:///./node_modules/prop-types/lib/ReactPropTypesSecret.js","webpack:///./node_modules/react-dom/cjs/react-dom.development.js","webpack:///./node_modules/react-dom/index.js","webpack:///./node_modules/react-router-dom/es/BrowserRouter.js","webpack:///./node_modules/react-router-dom/es/HashRouter.js","webpack:///./node_modules/react-router-dom/es/Link.js","webpack:///./node_modules/react-router-dom/es/MemoryRouter.js","webpack:///./node_modules/react-router-dom/es/NavLink.js","webpack:///./node_modules/react-router-dom/es/Prompt.js","webpack:///./node_modules/react-router-dom/es/Redirect.js","webpack:///./node_modules/react-router-dom/es/Route.js","webpack:///./node_modules/react-router-dom/es/Router.js","webpack:///./node_modules/react-router-dom/es/StaticRouter.js","webpack:///./node_modules/react-router-dom/es/Switch.js","webpack:///./node_modules/react-router-dom/es/generatePath.js","webpack:///./node_modules/react-router-dom/es/index.js","webpack:///./node_modules/react-router-dom/es/matchPath.js","webpack:///./node_modules/react-router-dom/es/withRouter.js","webpack:///./node_modules/react-router-dom/node_modules/warning/warning.js","webpack:///./node_modules/react-router/es/MemoryRouter.js","webpack:///./node_modules/react-router/es/Prompt.js","webpack:///./node_modules/react-router/es/Redirect.js","webpack:///./node_modules/react-router/es/Route.js","webpack:///./node_modules/react-router/es/Router.js","webpack:///./node_modules/react-router/es/StaticRouter.js","webpack:///./node_modules/react-router/es/Switch.js","webpack:///./node_modules/react-router/es/generatePath.js","webpack:///./node_modules/react-router/es/matchPath.js","webpack:///./node_modules/react-router/es/withRouter.js","webpack:///./node_modules/react-router/node_modules/warning/warning.js","webpack:///./node_modules/react-vega-lite/dist/react-vega-lite.min.js","webpack:///./node_modules/react-vega/dist/react-vega.min.js","webpack:///./node_modules/react/cjs/react.development.js","webpack:///./node_modules/react/index.js","webpack:///./node_modules/resolve-pathname/index.js","webpack:///./node_modules/schedule/cjs/schedule-tracing.development.js","webpack:///./node_modules/schedule/cjs/schedule.development.js","webpack:///./node_modules/schedule/index.js","webpack:///./node_modules/schedule/tracing.js","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js","webpack:///./node_modules/topojson-client/index.js","webpack:///./node_modules/topojson-client/src/bbox.js","webpack:///./node_modules/topojson-client/src/bisect.js","webpack:///./node_modules/topojson-client/src/feature.js","webpack:///./node_modules/topojson-client/src/identity.js","webpack:///./node_modules/topojson-client/src/merge.js","webpack:///./node_modules/topojson-client/src/mesh.js","webpack:///./node_modules/topojson-client/src/neighbors.js","webpack:///./node_modules/topojson-client/src/quantize.js","webpack:///./node_modules/topojson-client/src/reverse.js","webpack:///./node_modules/topojson-client/src/stitch.js","webpack:///./node_modules/topojson-client/src/transform.js","webpack:///./node_modules/topojson-client/src/untransform.js","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./node_modules/value-equal/index.js","webpack:///./node_modules/vega-canvas/index.browser.js","webpack:///./node_modules/vega-canvas/src/domCanvas.js","webpack:///./node_modules/vega-crossfilter/index.js","webpack:///./node_modules/vega-crossfilter/src/Bitmaps.js","webpack:///./node_modules/vega-crossfilter/src/CrossFilter.js","webpack:///./node_modules/vega-crossfilter/src/Dimension.js","webpack:///./node_modules/vega-crossfilter/src/ResolveFilter.js","webpack:///./node_modules/vega-crossfilter/src/SortedIndex.js","webpack:///./node_modules/vega-crossfilter/src/arrays.js","webpack:///./node_modules/vega-dataflow/index.js","webpack:///./node_modules/vega-dataflow/src/ChangeSet.js","webpack:///./node_modules/vega-dataflow/src/EventStream.js","webpack:///./node_modules/vega-dataflow/src/MultiPulse.js","webpack:///./node_modules/vega-dataflow/src/Operator.js","webpack:///./node_modules/vega-dataflow/src/Parameters.js","webpack:///./node_modules/vega-dataflow/src/Pulse.js","webpack:///./node_modules/vega-dataflow/src/Transform.js","webpack:///./node_modules/vega-dataflow/src/Tuple.js","webpack:///./node_modules/vega-dataflow/src/dataflow/Dataflow.js","webpack:///./node_modules/vega-dataflow/src/dataflow/add.js","webpack:///./node_modules/vega-dataflow/src/dataflow/connect.js","webpack:///./node_modules/vega-dataflow/src/dataflow/events.js","webpack:///./node_modules/vega-dataflow/src/dataflow/load.js","webpack:///./node_modules/vega-dataflow/src/dataflow/on.js","webpack:///./node_modules/vega-dataflow/src/dataflow/rank.js","webpack:///./node_modules/vega-dataflow/src/dataflow/run.js","webpack:///./node_modules/vega-dataflow/src/dataflow/update.js","webpack:///./node_modules/vega-dataflow/src/register.js","webpack:///./node_modules/vega-dataflow/src/util/Heap.js","webpack:///./node_modules/vega-dataflow/src/util/UniqueList.js","webpack:///./node_modules/vega-encode/index.js","webpack:///./node_modules/vega-encode/src/AxisTicks.js","webpack:///./node_modules/vega-encode/src/DataJoin.js","webpack:///./node_modules/vega-encode/src/Encode.js","webpack:///./node_modules/vega-encode/src/LegendEntries.js","webpack:///./node_modules/vega-encode/src/LinkPath.js","webpack:///./node_modules/vega-encode/src/Pie.js","webpack:///./node_modules/vega-encode/src/Scale.js","webpack:///./node_modules/vega-encode/src/SortItems.js","webpack:///./node_modules/vega-encode/src/Stack.js","webpack:///./node_modules/vega-encode/src/labels.js","webpack:///./node_modules/vega-encode/src/legend-types.js","webpack:///./node_modules/vega-encode/src/scale-types.js","webpack:///./node_modules/vega-encode/src/ticks.js","webpack:///./node_modules/vega-event-selector/index.js","webpack:///./node_modules/vega-event-selector/src/event-selector.js","webpack:///./node_modules/vega-expression/index.js","webpack:///./node_modules/vega-expression/src/ast.js","webpack:///./node_modules/vega-expression/src/codegen.js","webpack:///./node_modules/vega-expression/src/constants.js","webpack:///./node_modules/vega-expression/src/functions.js","webpack:///./node_modules/vega-expression/src/parser.js","webpack:///./node_modules/vega-force/index.js","webpack:///./node_modules/vega-force/src/Force.js","webpack:///./node_modules/vega-geo/index.js","webpack:///./node_modules/vega-geo/src/Contour.js","webpack:///./node_modules/vega-geo/src/GeoJSON.js","webpack:///./node_modules/vega-geo/src/GeoPath.js","webpack:///./node_modules/vega-geo/src/GeoPoint.js","webpack:///./node_modules/vega-geo/src/GeoShape.js","webpack:///./node_modules/vega-geo/src/Graticule.js","webpack:///./node_modules/vega-geo/src/Projection.js","webpack:///./node_modules/vega-geo/src/constants.js","webpack:///./node_modules/vega-hierarchy/index.js","webpack:///./node_modules/vega-hierarchy/src/HierarchyLayout.js","webpack:///./node_modules/vega-hierarchy/src/Nest.js","webpack:///./node_modules/vega-hierarchy/src/Pack.js","webpack:///./node_modules/vega-hierarchy/src/Partition.js","webpack:///./node_modules/vega-hierarchy/src/Stratify.js","webpack:///./node_modules/vega-hierarchy/src/Tree.js","webpack:///./node_modules/vega-hierarchy/src/TreeLinks.js","webpack:///./node_modules/vega-hierarchy/src/Treemap.js","webpack:///./node_modules/vega-hierarchy/src/lookup.js","webpack:///./node_modules/vega-lib/index.js","webpack:///../../src/aggregate.ts","webpack:///../../src/axis.ts","webpack:///../../src/bin.ts","webpack:///../../src/channel.ts","webpack:///../../../../src/compile/axis/assemble.ts","webpack:///../../../../src/compile/axis/component.ts","webpack:///../../../../src/compile/axis/config.ts","webpack:///../../../../src/compile/axis/encode.ts","webpack:///../../../../src/compile/axis/parse.ts","webpack:///../../../../src/compile/axis/properties.ts","webpack:///../../../src/compile/baseconcat.ts","webpack:///../../../src/compile/buildmodel.ts","webpack:///../../../src/compile/common.ts","webpack:///../../../src/compile/compile.ts","webpack:///../../../src/compile/concat.ts","webpack:///../../../../src/compile/data/aggregate.ts","webpack:///../../../../src/compile/data/assemble.ts","webpack:///../../../../src/compile/data/bin.ts","webpack:///../../../../src/compile/data/calculate.ts","webpack:///../../../../src/compile/data/dataflow.ts","webpack:///../../../../src/compile/data/expressions.ts","webpack:///../../../../src/compile/data/facet.ts","webpack:///../../../../src/compile/data/filter.ts","webpack:///../../../../src/compile/data/flatten.ts","webpack:///../../../../src/compile/data/fold.ts","webpack:///../../../../src/compile/data/formatparse.ts","webpack:///../../../../src/compile/data/geojson.ts","webpack:///../../../../src/compile/data/geopoint.ts","webpack:///../../../../src/compile/data/identifier.ts","webpack:///../../../../src/compile/data/impute.ts","webpack:///../../../../src/compile/data/index.ts","webpack:///../../../../src/compile/data/lookup.ts","webpack:///../../../../src/compile/data/optimize.ts","webpack:///../../../../src/compile/data/optimizers.ts","webpack:///../../../../src/compile/data/parse.ts","webpack:///../../../../src/compile/data/sample.ts","webpack:///../../../../src/compile/data/source.ts","webpack:///../../../../src/compile/data/stack.ts","webpack:///../../../../src/compile/data/timeunit.ts","webpack:///../../../../src/compile/data/window.ts","webpack:///../../../src/compile/facet.ts","webpack:///../../../../src/compile/header/index.ts","webpack:///../../../src/compile/layer.ts","webpack:///../../../../src/compile/layoutsize/assemble.ts","webpack:///../../../../src/compile/layoutsize/parse.ts","webpack:///../../../../src/compile/legend/assemble.ts","webpack:///../../../../src/compile/legend/component.ts","webpack:///../../../../src/compile/legend/encode.ts","webpack:///../../../../src/compile/legend/parse.ts","webpack:///../../../../src/compile/legend/properties.ts","webpack:///../../../../src/compile/mark/area.ts","webpack:///../../../../src/compile/mark/bar.ts","webpack:///../../../../src/compile/mark/geoshape.ts","webpack:///../../../../src/compile/mark/init.ts","webpack:///../../../../src/compile/mark/line.ts","webpack:///../../../../src/compile/mark/mark.ts","webpack:///../../../../src/compile/mark/mixins.ts","webpack:///../../../../src/compile/mark/point.ts","webpack:///../../../../src/compile/mark/rect.ts","webpack:///../../../../src/compile/mark/rule.ts","webpack:///../../../../src/compile/mark/text.ts","webpack:///../../../../src/compile/mark/tick.ts","webpack:///../../../../src/compile/mark/valueref.ts","webpack:///../../../src/compile/model.ts","webpack:///../../../../src/compile/projection/assemble.ts","webpack:///../../../../src/compile/projection/component.ts","webpack:///../../../../src/compile/projection/parse.ts","webpack:///../../../src/compile/repeat.ts","webpack:///../../../src/compile/repeater.ts","webpack:///../../../src/compile/resolve.ts","webpack:///../../../../src/compile/scale/assemble.ts","webpack:///../../../../src/compile/scale/component.ts","webpack:///../../../../src/compile/scale/domain.ts","webpack:///../../../../src/compile/scale/parse.ts","webpack:///../../../../src/compile/scale/properties.ts","webpack:///../../../../src/compile/scale/range.ts","webpack:///../../../../src/compile/scale/type.ts","webpack:///../../../../src/compile/selection/interval.ts","webpack:///../../../../src/compile/selection/multi.ts","webpack:///../../../../src/compile/selection/selection.ts","webpack:///../../../../src/compile/selection/single.ts","webpack:///../../../../../src/compile/selection/transforms/inputs.ts","webpack:///../../../../../src/compile/selection/transforms/nearest.ts","webpack:///../../../../../src/compile/selection/transforms/project.ts","webpack:///../../../../../src/compile/selection/transforms/scales.ts","webpack:///../../../../../src/compile/selection/transforms/toggle.ts","webpack:///../../../../../src/compile/selection/transforms/transforms.ts","webpack:///../../../../../src/compile/selection/transforms/translate.ts","webpack:///../../../../../src/compile/selection/transforms/zoom.ts","webpack:///../../../src/compile/split.ts","webpack:///../../../src/compile/unit.ts","webpack:///../../../src/compositemark/boxplot.ts","webpack:///../../../src/compositemark/common.ts","webpack:///../../../src/compositemark/errorband.ts","webpack:///../../../src/compositemark/errorbar.ts","webpack:///../../../src/compositemark/index.ts","webpack:///../../src/config.ts","webpack:///../../src/data.ts","webpack:///../../src/datetime.ts","webpack:///../../src/encoding.ts","webpack:///../../src/facet.ts","webpack:///../../src/fielddef.ts","webpack:///../../src/guide.ts","webpack:///../../src/header.ts","webpack:///../../src/index.ts","webpack:///../../src/legend.ts","webpack:///../../src/log.ts","webpack:///../../src/logical.ts","webpack:///../../src/mark.ts","webpack:///../../src/normalize.ts","webpack:///../../src/predicate.ts","webpack:///../../src/projection.ts","webpack:///../../src/scale.ts","webpack:///../../src/selection.ts","webpack:///../../src/sort.ts","webpack:///../../src/spec.ts","webpack:///../../src/stack.ts","webpack:///../../src/timeunit.ts","webpack:///../../src/title.ts","webpack:///../../src/toplevelprops.ts","webpack:///../../src/transform.ts","webpack:///../../src/type.ts","webpack:///../../src/util.ts","webpack:///../../src/validate.ts","webpack:///../../src/vega.schema.ts","webpack:///./node_modules/vega-loader/index.js","webpack:///./node_modules/vega-loader/src/formats/dsv.js","webpack:///./node_modules/vega-loader/src/formats/index.js","webpack:///./node_modules/vega-loader/src/formats/json.js","webpack:///./node_modules/vega-loader/src/formats/topojson.js","webpack:///./node_modules/vega-loader/src/loader.js","webpack:///./node_modules/vega-loader/src/read.js","webpack:///./node_modules/vega-loader/src/type.js","webpack:///./node_modules/vega-parser/index.js","webpack:///./node_modules/vega-parser/src/DataScope.js","webpack:///./node_modules/vega-parser/src/Scope.js","webpack:///./node_modules/vega-parser/src/config.js","webpack:///./node_modules/vega-parser/src/parse.js","webpack:///./node_modules/vega-parser/src/parsers/autosize.js","webpack:///./node_modules/vega-parser/src/parsers/axis.js","webpack:///./node_modules/vega-parser/src/parsers/data.js","webpack:///./node_modules/vega-parser/src/parsers/encode.js","webpack:///./node_modules/vega-parser/src/parsers/encode/adjust-spatial.js","webpack:///./node_modules/vega-parser/src/parsers/encode/color.js","webpack:///./node_modules/vega-parser/src/parsers/encode/encode-util.js","webpack:///./node_modules/vega-parser/src/parsers/encode/entry.js","webpack:///./node_modules/vega-parser/src/parsers/encode/expression.js","webpack:///./node_modules/vega-parser/src/parsers/encode/field.js","webpack:///./node_modules/vega-parser/src/parsers/encode/gradient.js","webpack:///./node_modules/vega-parser/src/parsers/encode/property.js","webpack:///./node_modules/vega-parser/src/parsers/encode/rule.js","webpack:///./node_modules/vega-parser/src/parsers/encode/scale.js","webpack:///./node_modules/vega-parser/src/parsers/encode/set.js","webpack:///./node_modules/vega-parser/src/parsers/expression.js","webpack:///./node_modules/vega-parser/src/parsers/expression/arrays.js","webpack:///./node_modules/vega-parser/src/parsers/expression/ast.js","webpack:///./node_modules/vega-parser/src/parsers/expression/codegen.js","webpack:///./node_modules/vega-parser/src/parsers/expression/data.js","webpack:///./node_modules/vega-parser/src/parsers/expression/encode.js","webpack:///./node_modules/vega-parser/src/parsers/expression/flush.js","webpack:///./node_modules/vega-parser/src/parsers/expression/format.js","webpack:///./node_modules/vega-parser/src/parsers/expression/geo.js","webpack:///./node_modules/vega-parser/src/parsers/expression/inscope.js","webpack:///./node_modules/vega-parser/src/parsers/expression/log.js","webpack:///./node_modules/vega-parser/src/parsers/expression/merge.js","webpack:///./node_modules/vega-parser/src/parsers/expression/modify.js","webpack:///./node_modules/vega-parser/src/parsers/expression/pinch.js","webpack:///./node_modules/vega-parser/src/parsers/expression/prefixes.js","webpack:///./node_modules/vega-parser/src/parsers/expression/quarter.js","webpack:///./node_modules/vega-parser/src/parsers/expression/scale-gradient.js","webpack:///./node_modules/vega-parser/src/parsers/expression/scale.js","webpack:///./node_modules/vega-parser/src/parsers/expression/selection.deprecated.js","webpack:///./node_modules/vega-parser/src/parsers/expression/selection.js","webpack:///./node_modules/vega-parser/src/parsers/expression/shape.js","webpack:///./node_modules/vega-parser/src/parsers/expression/tree.js","webpack:///./node_modules/vega-parser/src/parsers/expression/window.js","webpack:///./node_modules/vega-parser/src/parsers/guides/axis-config.js","webpack:///./node_modules/vega-parser/src/parsers/guides/axis-domain.js","webpack:///./node_modules/vega-parser/src/parsers/guides/axis-grid.js","webpack:///./node_modules/vega-parser/src/parsers/guides/axis-labels.js","webpack:///./node_modules/vega-parser/src/parsers/guides/axis-ticks.js","webpack:///./node_modules/vega-parser/src/parsers/guides/axis-title.js","webpack:///./node_modules/vega-parser/src/parsers/guides/constants.js","webpack:///./node_modules/vega-parser/src/parsers/guides/guide-group.js","webpack:///./node_modules/vega-parser/src/parsers/guides/guide-mark.js","webpack:///./node_modules/vega-parser/src/parsers/guides/guide-util.js","webpack:///./node_modules/vega-parser/src/parsers/guides/legend-gradient-discrete.js","webpack:///./node_modules/vega-parser/src/parsers/guides/legend-gradient-labels.js","webpack:///./node_modules/vega-parser/src/parsers/guides/legend-gradient.js","webpack:///./node_modules/vega-parser/src/parsers/guides/legend-symbol-groups.js","webpack:///./node_modules/vega-parser/src/parsers/guides/legend-title.js","webpack:///./node_modules/vega-parser/src/parsers/legend.js","webpack:///./node_modules/vega-parser/src/parsers/mark.js","webpack:///./node_modules/vega-parser/src/parsers/marks/clip.js","webpack:///./node_modules/vega-parser/src/parsers/marks/data.js","webpack:///./node_modules/vega-parser/src/parsers/marks/definition.js","webpack:///./node_modules/vega-parser/src/parsers/marks/facet.js","webpack:///./node_modules/vega-parser/src/parsers/marks/interactive.js","webpack:///./node_modules/vega-parser/src/parsers/marks/marktypes.js","webpack:///./node_modules/vega-parser/src/parsers/marks/role.js","webpack:///./node_modules/vega-parser/src/parsers/marks/roles.js","webpack:///./node_modules/vega-parser/src/parsers/marks/subflow.js","webpack:///./node_modules/vega-parser/src/parsers/padding.js","webpack:///./node_modules/vega-parser/src/parsers/projection.js","webpack:///./node_modules/vega-parser/src/parsers/scale.js","webpack:///./node_modules/vega-parser/src/parsers/signal-updates.js","webpack:///./node_modules/vega-parser/src/parsers/signal.js","webpack:///./node_modules/vega-parser/src/parsers/spec.js","webpack:///./node_modules/vega-parser/src/parsers/stream.js","webpack:///./node_modules/vega-parser/src/parsers/title.js","webpack:///./node_modules/vega-parser/src/parsers/transform.js","webpack:///./node_modules/vega-parser/src/parsers/trigger.js","webpack:///./node_modules/vega-parser/src/parsers/update.js","webpack:///./node_modules/vega-parser/src/parsers/view.js","webpack:///./node_modules/vega-parser/src/transforms.js","webpack:///./node_modules/vega-parser/src/util.js","webpack:///./node_modules/vega-projection/index.js","webpack:///./node_modules/vega-projection/src/projections.js","webpack:///./node_modules/vega-runtime/index.js","webpack:///./node_modules/vega-runtime/src/context.js","webpack:///./node_modules/vega-runtime/src/dataflow.js","webpack:///./node_modules/vega-runtime/src/expression.js","webpack:///./node_modules/vega-runtime/src/operator.js","webpack:///./node_modules/vega-runtime/src/parameters.js","webpack:///./node_modules/vega-runtime/src/state.js","webpack:///./node_modules/vega-runtime/src/stream.js","webpack:///./node_modules/vega-runtime/src/update.js","webpack:///./node_modules/vega-runtime/src/util.js","webpack:///./node_modules/vega-scale/index.js","webpack:///./node_modules/vega-scale/src/bandSpace.js","webpack:///./node_modules/vega-scale/src/interpolate.js","webpack:///./node_modules/vega-scale/src/invertRange.js","webpack:///./node_modules/vega-scale/src/invertRangeExtent.js","webpack:///./node_modules/vega-scale/src/palettes.js","webpack:///./node_modules/vega-scale/src/scaleBand.js","webpack:///./node_modules/vega-scale/src/scaleBin.js","webpack:///./node_modules/vega-scale/src/scaleSequential.js","webpack:///./node_modules/vega-scale/src/scales.js","webpack:///./node_modules/vega-scale/src/schemes.js","webpack:///./node_modules/vega-scale/src/timeInterval.js","webpack:///./node_modules/vega-scenegraph/index.js","webpack:///./node_modules/vega-scenegraph/src/Bounds.js","webpack:///./node_modules/vega-scenegraph/src/CanvasHandler.js","webpack:///./node_modules/vega-scenegraph/src/CanvasRenderer.js","webpack:///./node_modules/vega-scenegraph/src/Gradient.js","webpack:///./node_modules/vega-scenegraph/src/GroupItem.js","webpack:///./node_modules/vega-scenegraph/src/Handler.js","webpack:///./node_modules/vega-scenegraph/src/Item.js","webpack:///./node_modules/vega-scenegraph/src/Renderer.js","webpack:///./node_modules/vega-scenegraph/src/ResourceLoader.js","webpack:///./node_modules/vega-scenegraph/src/SVGHandler.js","webpack:///./node_modules/vega-scenegraph/src/SVGRenderer.js","webpack:///./node_modules/vega-scenegraph/src/SVGStringRenderer.js","webpack:///./node_modules/vega-scenegraph/src/Scenegraph.js","webpack:///./node_modules/vega-scenegraph/src/bound/boundClip.js","webpack:///./node_modules/vega-scenegraph/src/bound/boundContext.js","webpack:///./node_modules/vega-scenegraph/src/bound/boundItem.js","webpack:///./node_modules/vega-scenegraph/src/bound/boundMark.js","webpack:///./node_modules/vega-scenegraph/src/bound/boundStroke.js","webpack:///./node_modules/vega-scenegraph/src/marks/arc.js","webpack:///./node_modules/vega-scenegraph/src/marks/area.js","webpack:///./node_modules/vega-scenegraph/src/marks/group.js","webpack:///./node_modules/vega-scenegraph/src/marks/image.js","webpack:///./node_modules/vega-scenegraph/src/marks/index.js","webpack:///./node_modules/vega-scenegraph/src/marks/line.js","webpack:///./node_modules/vega-scenegraph/src/marks/markItemPath.js","webpack:///./node_modules/vega-scenegraph/src/marks/markMultiItemPath.js","webpack:///./node_modules/vega-scenegraph/src/marks/path.js","webpack:///./node_modules/vega-scenegraph/src/marks/rect.js","webpack:///./node_modules/vega-scenegraph/src/marks/rule.js","webpack:///./node_modules/vega-scenegraph/src/marks/shape.js","webpack:///./node_modules/vega-scenegraph/src/marks/symbol.js","webpack:///./node_modules/vega-scenegraph/src/marks/text.js","webpack:///./node_modules/vega-scenegraph/src/marks/trail.js","webpack:///./node_modules/vega-scenegraph/src/modules.js","webpack:///./node_modules/vega-scenegraph/src/path/arc.js","webpack:///./node_modules/vega-scenegraph/src/path/curves.js","webpack:///./node_modules/vega-scenegraph/src/path/parse.js","webpack:///./node_modules/vega-scenegraph/src/path/rectangle.js","webpack:///./node_modules/vega-scenegraph/src/path/render.js","webpack:///./node_modules/vega-scenegraph/src/path/shapes.js","webpack:///./node_modules/vega-scenegraph/src/path/symbols.js","webpack:///./node_modules/vega-scenegraph/src/path/trail.js","webpack:///./node_modules/vega-scenegraph/src/util/canvas/clip.js","webpack:///./node_modules/vega-scenegraph/src/util/canvas/color.js","webpack:///./node_modules/vega-scenegraph/src/util/canvas/draw.js","webpack:///./node_modules/vega-scenegraph/src/util/canvas/fill.js","webpack:///./node_modules/vega-scenegraph/src/util/canvas/gradient.js","webpack:///./node_modules/vega-scenegraph/src/util/canvas/pick.js","webpack:///./node_modules/vega-scenegraph/src/util/canvas/resize.js","webpack:///./node_modules/vega-scenegraph/src/util/canvas/stroke.js","webpack:///./node_modules/vega-scenegraph/src/util/dom.js","webpack:///./node_modules/vega-scenegraph/src/util/equal.js","webpack:///./node_modules/vega-scenegraph/src/util/events.js","webpack:///./node_modules/vega-scenegraph/src/util/pickPath.js","webpack:///./node_modules/vega-scenegraph/src/util/point.js","webpack:///./node_modules/vega-scenegraph/src/util/resolveItem.js","webpack:///./node_modules/vega-scenegraph/src/util/serialize.js","webpack:///./node_modules/vega-scenegraph/src/util/svg/clip.js","webpack:///./node_modules/vega-scenegraph/src/util/svg/metadata.js","webpack:///./node_modules/vega-scenegraph/src/util/svg/styles.js","webpack:///./node_modules/vega-scenegraph/src/util/svg/translate.js","webpack:///./node_modules/vega-scenegraph/src/util/svg/translateItem.js","webpack:///./node_modules/vega-scenegraph/src/util/tags.js","webpack:///./node_modules/vega-scenegraph/src/util/text.js","webpack:///./node_modules/vega-scenegraph/src/util/visit.js","webpack:///./node_modules/vega-statistics/index.js","webpack:///./node_modules/vega-statistics/src/bin.js","webpack:///./node_modules/vega-statistics/src/bootstrapCI.js","webpack:///./node_modules/vega-statistics/src/integer.js","webpack:///./node_modules/vega-statistics/src/kde.js","webpack:///./node_modules/vega-statistics/src/mixture.js","webpack:///./node_modules/vega-statistics/src/normal.js","webpack:///./node_modules/vega-statistics/src/numbers.js","webpack:///./node_modules/vega-statistics/src/quartiles.js","webpack:///./node_modules/vega-statistics/src/random.js","webpack:///./node_modules/vega-statistics/src/uniform.js","webpack:///./node_modules/vega-transforms/index.js","webpack:///./node_modules/vega-transforms/src/Aggregate.js","webpack:///./node_modules/vega-transforms/src/Bin.js","webpack:///./node_modules/vega-transforms/src/Collect.js","webpack:///./node_modules/vega-transforms/src/Compare.js","webpack:///./node_modules/vega-transforms/src/CountPattern.js","webpack:///./node_modules/vega-transforms/src/Cross.js","webpack:///./node_modules/vega-transforms/src/Density.js","webpack:///./node_modules/vega-transforms/src/Expression.js","webpack:///./node_modules/vega-transforms/src/Extent.js","webpack:///./node_modules/vega-transforms/src/Facet.js","webpack:///./node_modules/vega-transforms/src/Field.js","webpack:///./node_modules/vega-transforms/src/Filter.js","webpack:///./node_modules/vega-transforms/src/Flatten.js","webpack:///./node_modules/vega-transforms/src/Fold.js","webpack:///./node_modules/vega-transforms/src/Formula.js","webpack:///./node_modules/vega-transforms/src/Generate.js","webpack:///./node_modules/vega-transforms/src/Impute.js","webpack:///./node_modules/vega-transforms/src/JoinAggregate.js","webpack:///./node_modules/vega-transforms/src/Key.js","webpack:///./node_modules/vega-transforms/src/Load.js","webpack:///./node_modules/vega-transforms/src/Lookup.js","webpack:///./node_modules/vega-transforms/src/MultiExtent.js","webpack:///./node_modules/vega-transforms/src/MultiValues.js","webpack:///./node_modules/vega-transforms/src/Params.js","webpack:///./node_modules/vega-transforms/src/Pivot.js","webpack:///./node_modules/vega-transforms/src/PreFacet.js","webpack:///./node_modules/vega-transforms/src/Project.js","webpack:///./node_modules/vega-transforms/src/Proxy.js","webpack:///./node_modules/vega-transforms/src/Relay.js","webpack:///./node_modules/vega-transforms/src/Sample.js","webpack:///./node_modules/vega-transforms/src/Sequence.js","webpack:///./node_modules/vega-transforms/src/Sieve.js","webpack:///./node_modules/vega-transforms/src/Subflow.js","webpack:///./node_modules/vega-transforms/src/TupleIndex.js","webpack:///./node_modules/vega-transforms/src/Values.js","webpack:///./node_modules/vega-transforms/src/Window.js","webpack:///./node_modules/vega-transforms/src/util/AggregateKeys.js","webpack:///./node_modules/vega-transforms/src/util/AggregateOps.js","webpack:///./node_modules/vega-transforms/src/util/Distributions.js","webpack:///./node_modules/vega-transforms/src/util/SortedList.js","webpack:///./node_modules/vega-transforms/src/util/TupleStore.js","webpack:///./node_modules/vega-transforms/src/util/WindowOps.js","webpack:///./node_modules/vega-transforms/src/util/WindowState.js","webpack:///./node_modules/vega-transforms/src/util/util.js","webpack:///./node_modules/vega-util/index.js","webpack:///./node_modules/vega-util/src/accessor.js","webpack:///./node_modules/vega-util/src/accessors.js","webpack:///./node_modules/vega-util/src/array.js","webpack:///./node_modules/vega-util/src/compare.js","webpack:///./node_modules/vega-util/src/constant.js","webpack:///./node_modules/vega-util/src/debounce.js","webpack:///./node_modules/vega-util/src/error.js","webpack:///./node_modules/vega-util/src/extend.js","webpack:///./node_modules/vega-util/src/extentIndex.js","webpack:///./node_modules/vega-util/src/fastmap.js","webpack:///./node_modules/vega-util/src/field.js","webpack:///./node_modules/vega-util/src/inherits.js","webpack:///./node_modules/vega-util/src/isArray.js","webpack:///./node_modules/vega-util/src/isBoolean.js","webpack:///./node_modules/vega-util/src/isDate.js","webpack:///./node_modules/vega-util/src/isFunction.js","webpack:///./node_modules/vega-util/src/isNumber.js","webpack:///./node_modules/vega-util/src/isObject.js","webpack:///./node_modules/vega-util/src/isRegExp.js","webpack:///./node_modules/vega-util/src/isString.js","webpack:///./node_modules/vega-util/src/key.js","webpack:///./node_modules/vega-util/src/logger.js","webpack:///./node_modules/vega-util/src/merge.js","webpack:///./node_modules/vega-util/src/pad.js","webpack:///./node_modules/vega-util/src/peek.js","webpack:///./node_modules/vega-util/src/repeat.js","webpack:///./node_modules/vega-util/src/splitAccessPath.js","webpack:///./node_modules/vega-util/src/stringValue.js","webpack:///./node_modules/vega-util/src/toBoolean.js","webpack:///./node_modules/vega-util/src/toDate.js","webpack:///./node_modules/vega-util/src/toNumber.js","webpack:///./node_modules/vega-util/src/toSet.js","webpack:///./node_modules/vega-util/src/toString.js","webpack:///./node_modules/vega-util/src/transform.js","webpack:///./node_modules/vega-util/src/truncate.js","webpack:///./node_modules/vega-util/src/visitArray.js","webpack:///./node_modules/vega-view-transforms/index.js","webpack:///./node_modules/vega-view-transforms/src/Bound.js","webpack:///./node_modules/vega-view-transforms/src/Identifier.js","webpack:///./node_modules/vega-view-transforms/src/Mark.js","webpack:///./node_modules/vega-view-transforms/src/Overlap.js","webpack:///./node_modules/vega-view-transforms/src/Render.js","webpack:///./node_modules/vega-view-transforms/src/ViewLayout.js","webpack:///./node_modules/vega-view-transforms/src/constants.js","webpack:///./node_modules/vega-view-transforms/src/gridLayout.js","webpack:///./node_modules/vega-view/index.js","webpack:///./node_modules/vega-view/src/View.js","webpack:///./node_modules/vega-view/src/bind.js","webpack:///./node_modules/vega-view/src/cursor.js","webpack:///./node_modules/vega-view/src/data.js","webpack:///./node_modules/vega-view/src/element.js","webpack:///./node_modules/vega-view/src/events-extend.js","webpack:///./node_modules/vega-view/src/events.js","webpack:///./node_modules/vega-view/src/finalize.js","webpack:///./node_modules/vega-view/src/hover.js","webpack:///./node_modules/vega-view/src/initialize-handler.js","webpack:///./node_modules/vega-view/src/initialize-renderer.js","webpack:///./node_modules/vega-view/src/initialize.js","webpack:///./node_modules/vega-view/src/render-headless.js","webpack:///./node_modules/vega-view/src/render-size.js","webpack:///./node_modules/vega-view/src/render-to-canvas.js","webpack:///./node_modules/vega-view/src/render-to-image-url.js","webpack:///./node_modules/vega-view/src/render-to-svg.js","webpack:///./node_modules/vega-view/src/runtime.js","webpack:///./node_modules/vega-view/src/scale.js","webpack:///./node_modules/vega-view/src/size.js","webpack:///./node_modules/vega-view/src/state.js","webpack:///./node_modules/vega-view/src/timer.js","webpack:///./node_modules/vega-view/src/tooltip.js","webpack:///./node_modules/vega-view/src/trap.js","webpack:///./node_modules/vega-voronoi/index.js","webpack:///./node_modules/vega-voronoi/src/Voronoi.js","webpack:///./node_modules/vega-wordcloud/index.js","webpack:///./node_modules/vega-wordcloud/src/CloudLayout.js","webpack:///./node_modules/vega-wordcloud/src/Wordcloud.js","webpack:///./node_modules/warning/browser.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/App.tsx","webpack:///./src/Page/Dashboard/Dashboard.tsx","webpack:///./src/Page/Dashboard/Map.tsx","webpack:///./src/Page/Dashboard/dashboard.scss?37b8","webpack:///./src/index.tsx","webpack:///./src/routes/homepage.tsx","webpack:///node-fetch (ignored)","webpack:///fs (ignored)"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,oDAAW;AAChC,cAAc,mBAAO,CAAC,gDAAS;AAC/B,cAAc,mBAAO,CAAC,oEAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5vDA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;;;;ACJA,2BAA2B,mBAAO,CAAC,mGAAkD;AACrF;;;AAGA;AACA,cAAc,QAAS,OAAO,kBAAkB,EAAE;;AAElD;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD,IAAI;AACJ;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;;AAElE;AACA;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;;AAEO;AACA;;;;;;;;;;;;;ACHP;AAAe;AACf;AACA,CAAC;;;;;;;;;;;;;ACFD;AAAA;AAAA;AAAA;AAAA;AAAoC;AACF;;AAElC,sBAAsB,yDAAQ,CAAC,kDAAS;AACjC;AACA;AACQ,0EAAW,EAAC;;;;;;;;;;;;;ACN3B;AAAA;AAAoC;;AAErB;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,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,CAAC;;;;;;;;;;;;;ACFD;AAAA;AAAA;AAAA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAwB;;AAET;AACf;AACA,uBAAuB,oDAAG,2CAA2C,SAAS;AAC9E,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAA8B;;AAEf;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,uDAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,uDAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AChCD;AAAA;AAAoC;;AAErB;AACf,SAAS,0DAAS;AAClB,CAAC;;;;;;;;;;;;;ACJD;AAAe;AACf;AACA,qCAAqC,0BAA0B;AAC/D;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACF;AACA;AACE;AACI;AACE;;;;;;;;;;;;;ACL7C;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yEAAyE,8CAA8C;AACvH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+DAA+D,qBAAqB,EAAE;;AAEtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEe,kEAAG,EAAC;;;;;;;;;;;;;AC1EnB;AAAA;AAAwB;;AAET;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAG;AACzB;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,aAAa,kCAAkC,EAAE,EAAE;AACjG,wDAAwD,8BAA8B,EAAE;AACxF;;AAEA;AACA,6BAA6B,iDAAiD,EAAE;AAChF,0BAA0B,2CAA2C,EAAE;AACvE,8BAA8B,uDAAuD,EAAE;AACvF,sBAAsB,cAAc,aAAa,EAAE;AACnD,+BAA+B,mCAAmC,aAAa,EAAE;AACjF,iCAAiC,oBAAoB,aAAa,EAAE;AACpE,yBAAyB,YAAY,aAAa;AAClD;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,oDAAG;AACZ;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAA6C;;AAE7C;;AAEA,YAAY,4CAAG;;AAEf;AACA;AACA;AACA;AACA;AACA,SAAS,2CAAM;AACf;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0DAA0D,gBAAgB,EAAE;;AAE5E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe,kEAAG,EAAC;;;;;;;;;;;;;ACtCnB;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;;AAEjC;;AAEA;AACA;;AAEP;AACA;AACA;AACA,0BAA0B,EAAE;AAC5B,0BAA0B,EAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAEc;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA,uDAAM,WAAW,sDAAM;AACvB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAM,WAAW,sDAAM;AACvB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACyB;AACzB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,0CAAG,OAAO,yDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6CAAO;AACzC;AACA;;AAEe;AACf;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA,uDAAM,uBAAuB,sDAAM,CAAC,4CAAK;AACzC;AACA,oBAAoB,+CAAQ,YAAY,+CAAQ;AAChD;AACA,GAAG;AACH;AACA,oBAAoB,6CAAM,YAAY,6CAAM;AAC5C;AACA,GAAG;AACH;AACA,iDAAiD,6CAAO;AACxD;AACA;AACA;AACA;AACA,eAAe,0CAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC5DD;AAAA;AAAe;AACf;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmD;AACE;AACJ;;;;;;;;;;;;;ACFjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACO;AACP;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,6CAAO;AACzB;AACA;AACA,qBAAqB,0CAAG,OAAO,yDAAU;AACzC;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEe;AACf;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA,uDAAM,WAAW,sDAAM,CAAC,4CAAK;AAC7B;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,6CAAO;AACxC;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA,uDAAM,WAAW,sDAAM,CAAC,4CAAK;AAC7B;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACxHD;AAAA;AAAA;AAAO;AACA;;;;;;;;;;;;;ACDP;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;;AAEO;;;;;;;;;;;;;ACFP;AAAe;AACf;AACA,CAAC;;;;;;;;;;;;;ACFD;AAAA;AAAA;AAAA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,2BAA2B,WAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAe;AACf;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmE;AACrC;AACM;AACV;AACQ;AACA;AACR;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA,kBAAkB,yDAAgB;AAClC;;AAEA;AACA;;AAEA;AACA;AACA,mBAAmB,uDAAM;AACzB,WAAW,yDAAQ;AACnB,WAAW,sDAAK;AAChB,KAAK;AACL,2BAA2B,kDAAS;AACpC;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,qDAAI;AACd;AACA,KAAK;;AAEL;AACA,mDAAmD,OAAO;AAC1D,YAAY,yDAAQ;AACpB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,+DAA+D;AAC/D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,+DAA+D;AAC/D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,iEAAiE;AACjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4FAA4F,yDAAQ,CAAC,4CAAK,YAAY,yDAAQ;AAC9H;;AAEA;AACA,2DAA2D,6CAAI;AAC/D;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC1MD;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AAChB;AACM;AACF;AACA;;AAElC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAQ;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,IAAI,mDAAK,EAAE,mCAAmC,GAAG,mCAAmC;AACpF,IAAI,mDAAK,EAAE,mCAAmC,GAAG,mCAAmC;AACpF,IAAI,mDAAK,EAAE,mCAAmC,GAAG,mCAAmC;AACpF,IAAI,mDAAK,EAAE,mCAAmC,GAAG,mCAAmC;AACpF,IAAI,mDAAK,EAAE,mCAAmC,GAAG,mCAAmC;AACpF,IAAI,mDAAK,EAAE,mCAAmC,GAAG,mCAAmC;;AAEpF;;AAEA;AACA;AACA,iBAAiB,oDAAG;AACpB,WAAW,yDAAQ;AACnB,WAAW,sDAAK;AAChB;AACA;;AAEA,WAAW,yDAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE,yDAAQ;AACzE;;AAEA;AACA,iEAAiE,yDAAQ;AACzE;;AAEA;AACA,sEAAsE,yDAAQ;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4FAA4F,yDAAQ,CAAC,4CAAK,YAAY,yDAAQ;AAC9H;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACpID;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACK;;;;;;;;;;;;;ACDpD;AAAe,4EAAa;;;;;;;;;;;;;ACA5B;AAAA,YAAY;;AAEZ;AACA,8CAA8C,IAAI,OAAO;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,iBAAiB;AACjB;AACA;AACA,GAAG;AACH;AACA,kFAAkF,OAAO;AACzF;AACA,+CAA+C,OAAO;AACtD,GAAG;AACH;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;;AAEA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;;AAEe,uEAAQ,EAAC;;;;;;;;;;;;;ACnFxB;AAAA;AAAA;AAAA;AAA+C;;;;;;;;;;;;;ACA/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwB;;AAExB,UAAU,oDAAG;;AAEN;AACA;AACA;AACA;;;;;;;;;;;;;ACPP;AAAA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA,GAAG,gBAAgB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY,yCAAyC;AACrF;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,YAAY,yCAAyC;AACrF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC9HD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AAC4B;AACA;;;;;;;;;;;;;ACFvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwB;;AAExB,UAAU,oDAAG;;AAEN;AACA;AACA;AACA;;;;;;;;;;;;;ACPP;AAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;;AAEA,iDAAiD,OAAO;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACnCD;AAAA;AAAA;AAAA;AAAkC;AACJ;AACO;;AAErC;AACA;AACA;;AAEA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;;AAEA,6CAA6C,yDAAQ;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC,aAAa,4DAAQ;AACrB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAM;AACnC,6BAA6B,uDAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sEAAsE,yDAAQ;AAC9E;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACjGD;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACE;AACN;AACQ;AACJ;AACQ;AAClB;AACA;;;;;;;;;;;;;ACPtC;AAAe;AACf;AACA,CAAC;;;;;;;;;;;;;ACFD;AAAA;AAAA;AAAA;AAAkC;AACJ;AACI;;AAElC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+DAAe;AACf;AACA;AACA;AACA,iBAAiB,yDAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,gBAAgB;AACrD,uDAAuD,OAAO;AAC9D;AACA,2DAA2D,uDAAM;AACjE,2DAA2D,uDAAM;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,yDAAG;AACtB;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wEAAwE,yDAAQ;AAChF;;AAEA;AACA,wEAAwE,yDAAQ;AAChF;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACnHD;AAAA;AAAA;AAAA;AAAA;AAAkC;AACJ;AACO;AACH;;AAElC,+DAAe;AACf;AACA;AACA;AACA,iBAAiB,yDAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,4DAAQ,QAAQ,6CAAC,EAAE,6CAAC;AACxD,0BAA0B,OAAO;AACjC;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA,yBAAyB,uDAAM;AAC/B,yBAAyB,uDAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC;AACzC;AACA,uBAAuB,uDAAM;AAC7B,uBAAuB,uDAAM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,yDAAQ;AAChF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACjHD;AAAA;AAAkC;;AAEnB;AACf;AACA,iBAAiB,yDAAQ;AACzB;AACA;;AAEA,6CAA6C,yDAAQ;AACrD;AACA;;AAEA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wEAAwE,yDAAQ;AAChF;;AAEA;AACA,sEAAsE,yDAAQ;AAC9E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACxDD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqC;AACH;AACH;;AAExB;AACP;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAG;AAClB,gBAAgB,sDAAK;AACrB,cAAc,4DAAQ;;AAEtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC9ID;AAAA;AAAkC;;AAEnB;AACf,iBAAiB,yDAAQ;AACzB;AACA;AACA;;AAEA,mCAAmC,yDAAQ;;AAE3C;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,yDAAQ;AAChF;;AAEA;AACA,iEAAiE,yDAAQ;AACzE;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACxCD;AAAA;AAAkC;;AAEnB;AACf,iBAAiB,yDAAQ;AACzB;AACA;AACA;;AAEA,mCAAmC,yDAAQ;;AAE3C;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE,yDAAQ;AAChF;;AAEA;AACA,iEAAiE,yDAAQ;AACzE;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACxCD;AAAA;AAAA;AAAA;AAAA;AAAoC;;AAEpC;AACO;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEc;AACf,WAAW,uDAAY;AACvB;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAA4C;;AAE7B;AACf,aAAa,8DAAa;AAC1B,CAAC;;;;;;;;;;;;;ACJD;AAAA;AACA;AACA;AACe;AACf,+FAA+F;AAC/F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACbD;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;ACjBD;AAAe;AACf;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;;;;;;;;;;;;ACND;AAAA;AAAA;AAA4C;;AAErC;;AAEQ;AACf,UAAU,8DAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8DAAa,+BAA+B;AACxF,CAAC;;;;;;;;;;;;;ACfD;AAAA;AAA4C;;AAE7B;AACf,UAAU,8DAAa;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACVD;AAAA;AAAA;AACA;;AAEe;AACf;AACA;;AAEA,sDAAsD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AACe;AACf,iDAAiD,OAAO;AACxD;AACA,4BAA4B;AAC5B,qCAAqC,QAAQ;AAC7C,4BAA4B,uBAAuB,QAAQ,EAAE;AAC7D;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACVD;AAAA;AAAA;AAAkD;AACN;;AAE7B;AACf,uBAAuB,6BAA6B,EAAE;AACtD,oBAAoB,kCAAkC,EAAE;AACxD,oBAAoB,eAAe,EAAE;AACrC,oBAAoB,mCAAmC,EAAE;AACzD,uBAAuB,2BAA2B,EAAE;AACpD,uBAAuB,qBAAqB,EAAE;AAC9C,uBAAuB,yBAAyB,EAAE;AAClD,oBAAoB,kCAAkC,EAAE;AACxD,uBAAuB,QAAQ,8DAAa,aAAa,EAAE;AAC3D,OAAO,sDAAa;AACpB,OAAO,yDAAgB;AACvB,oBAAoB,iDAAiD,EAAE;AACvE,oBAAoB,mCAAmC;AACvD,CAAC,EAAC;;;;;;;;;;;;;ACjBF;AAAe;AACf;AACA,CAAC;;;;;;;;;;;;;ACFD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqF;AACpC;AACY;AACF;AACE;AACF;;;;;;;;;;;;;ACL3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACM;AACM;AACE;AACV;AACE;AACU;AAChB;;AAElC;;AAEe;AACf,oDAAoD,4DAAW,sCAAsC,iDAAQ;AAC7G;AACA;AACA,mCAAmC,+DAAc,oBAAoB,iDAAQ;AAC7E;;AAEA;AACA,gBAAgB,gEAAe;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc,oDAAW;;AAEzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,oDAAW;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,2DAAU;;AAEpC;AACA;;AAEA;AACA;AACA,mDAAmD,gEAAc;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sEAAsE;AACtE,sEAAsE;AACtE,qIAAqI;AACrI,qEAAqE;AACrE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,gEAAe;AAClD,gDAAgD,yDAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC7ID;AAAA;AAAkC;;AAEnB;AACf,sBAAsB,yDAAQ;AAC9B,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAkC;;AAEnB;AACf,yDAAyD,yDAAQ,qBAAqB,yDAAQ;AAC9F,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAkC;;AAEnB;AACf;AACA,qBAAqB,yDAAQ,QAAQ,yDAAQ;AAC7C,CAAC;;;;;;;;;;;;;ACLD;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACoC;AACtC;AACI;;AAEvB,kBAAkB,sDAAK;;AAE9B,cAAc,sDAAK;AACnB;AACA;AACA;AACA;AACA;;AAEO;AACP,SAAS,6CAAI;AACb,aAAa,6CAAI;AACjB,WAAW,6CAAI;AACf;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,+BAA+B,yCAAG;AAClC,iDAAiD,6CAAI;AACrD,GAAG;AACH;AACA,gBAAgB,yCAAG;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,6CAAO,SAAS,6CAAO;AACnC,8BAA8B,iDAAG,iBAAiB,+CAAS,aAAa,iDAAG;AAC3E;;AAEA;AACA,YAAY,6CAAO,SAAS,6CAAO;AACnC,kBAAkB,+CAAS,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAG;AAClB,eAAe,iDAAG;AAClB;AACA,iCAAiC,iDAAG;AACpC,yBAAyB,iDAAG;AAC5B,kBAAkB,mDAAK;;AAEvB;AACA;AACA;;AAEe;AACf;AACA,EAAE,uDAAM;AACR;AACA,CAAC;;;;;;;;;;;;;ACzED;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4B;AACmB;AAC6C;AACtC;AACxB;;AAE9B;AACA;AACA;AACA;AACA,eAAe,sDAAK;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAU;AACd,GAAG;AACH;AACA,IAAI,gDAAU;AACd;AACA;AACA;AACA,QAAQ,iDAAW;AACnB,wBAAwB,6CAAO;AAC/B,yBAAyB,6CAAO;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,4DAAS,WAAW,6CAAO,QAAQ,6CAAO;AACpD;AACA,iBAAiB,iEAAc;AAC/B;AACA,qBAAqB,iEAAc;AACnC,IAAI,4EAAyB;AAC7B,iBAAiB,4DAAS;AAC1B;AACA;AACA,kCAAkC,6CAAO;AACzC;AACA,uBAAuB,iDAAG;AAC1B;AACA,6BAA6B,6CAAO;AACpC;AACA,KAAK;AACL,8BAA8B,6CAAO;AACrC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,iDAAG;AACpB,GAAG;AACH;AACA;AACA,EAAE,gDAAU;AACZ;AACA;;AAEA;AACA,EAAE,gDAAU;AACZ;;AAEA;AACA;AACA,EAAE,gDAAU;AACZ,MAAM,iDAAG,aAAa,6CAAO;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEe;AACf;;AAEA;AACA;AACA,EAAE,uDAAM;;AAER;AACA;AACA;;AAEA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,QAAQ;AACnF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC/KD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmD;;AAE5C;AACP,UAAU,mDAAK,8BAA8B,kDAAI;AACjD;;AA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AAW,iDAAG;AAC5B;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,wCAAE,IAAI,wCAAE;AACxD;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAU,oBAAoB,2DAAU;AACjE,yBAAyB,6CAAO;AAChC,yBAAyB,6CAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAU;AACxC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,4DAAS;AACtB,aAAa,4DAAS;;AAEtB;AACA;AACA;AACA,aAAa,iEAAc;AAC3B,eAAe,+DAAY;AAC3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,iEAAc;AAC9B,YAAY,iEAAc;AAC1B,YAAY,iEAAc;AAC1B,IAAI,sEAAmB;;AAEvB;AACA;AACA,YAAY,+DAAY;AACxB,aAAa,+DAAY;AACzB,2BAA2B,+DAAY;;AAEvC;;AAEA,YAAY,kDAAI;AAChB,YAAY,iEAAc;AAC1B,IAAI,sEAAmB;AACvB,QAAQ,4DAAS;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,iDAAG,SAAS,wCAAE,IAAI,6CAAO;AACzC,oCAAoC,6CAAO;;AAE3C;;AAEA;AACA;AACA;AACA,sCAAsC,iDAAG,mBAAmB,6CAAO;AACnE;AACA,kBAAkB,wCAAE;AACpB,eAAe,iEAAc;AAC7B,MAAM,sEAAmB;AACzB,iBAAiB,4DAAS;AAC1B;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,wCAAE;AACrC;AACA,+BAA+B;AAC/B,mCAAmC;AACnC,4BAA4B;AAC5B,gCAAgC;AAChC;AACA;;AAEA,SAAS,sDAAI,gEAAgE,wCAAE,WAAW,wCAAE;AAC5F,CAAC;;;;;;;;;;;;;ACrLD;AAAA;AAAwC;;AAEzB;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D,0DAAa;AAC5E,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACnBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACA;AACM;AACS;AAClB;;AAEhB;AACf;AACA;AACA,qBAAqB,uDAAU;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,mBAAmB,sDAAK;AACxB,0BAA0B,gEAAe;AACzC;AACA;AACA,UAAU,uDAAU;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,4CAAM,GAAG,6CAAO,GAAG,4CAAM;AAC7D,oCAAoC,4CAAM,GAAG,6CAAO,GAAG,4CAAM;AAC7D;;;;;;;;;;;;;AClIA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC1DD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqC;AACH;AACJ;AACI;AACH;;AAE/B;;AAEA;AACA;;AAEe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,WAAW,iDAAG,cAAc,6CAAO;AACnC,UAAU,iDAAG,cAAc,6CAAO;AAClC,UAAU,iDAAG,cAAc,6CAAO;AAClC,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,OAAO;AAChD,kHAAkH,OAAO;AACzH;AACA,yBAAyB,yEAAyE;AAClG,gBAAgB,0EAA0E;AAC1F;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,sDAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,uDAAU;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,cAAc,qDAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvKA;AAAA;AAAuC;;AAEvC;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,yBAAyB;AACzB;;AAEA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,2DAAU;AAClB;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA,8BAA8B,OAAO;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,qCAAqC,QAAQ;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpGA;AAAe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACXD;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAA;AAA6D;AACd;AACP;;AAExC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,yDAAQ;AACjB;;AAEA;AACA,WAAW,yDAAQ;AACnB,WAAW,yDAAQ;AACnB,WAAW,yDAAQ;AACnB,yBAAyB,6CAAO;AAChC;;AAEA;AACA,WAAW,gEAAe;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,6CAAO,aAAa,6CAAO;AAChD;;AAEe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACnFD;AAAA;AAA8B;;AAE9B;AACA,cAAc;;AAEC;AACf;AACA;AACA,SAAS,uDAAM;AACf,CAAC;;;;;;;;;;;;;ACTD;AAAA;AAAA;AAAA;AAAA;AAA+B;AACW;;AAE1C;AACA,UAAU,sDAAK,UAAU,6CAAO;AAChC,sBAAsB,2BAA2B,eAAe,EAAE,EAAE;AACpE;;AAEA;AACA,UAAU,sDAAK,UAAU,6CAAO;AAChC,sBAAsB,2BAA2B,eAAe,EAAE,EAAE;AACpE;;AAEe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,WAAW,sDAAK,CAAC,kDAAI;AACrB,gBAAgB,sDAAK,CAAC,kDAAI;AAC1B,gBAAgB,sDAAK,CAAC,kDAAI,4CAA4C,QAAQ,iDAAG,WAAW,6CAAO,CAAC,EAAE;AACtG,gBAAgB,sDAAK,CAAC,kDAAI,4CAA4C,QAAQ,iDAAG,WAAW,6CAAO,CAAC,EAAE;AACtG;;AAEA;AACA,8CAA8C,SAAS,8CAA8C,EAAE;AACvG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC,6CAAO,cAAc,6CAAO;AAC7D,iCAAiC,6CAAO,cAAc,6CAAO;AAC7D;;AAEO;AACP;AACA;;;;;;;;;;;;;ACxGA;AAAe;AACf;AACA,CAAC;;;;;;;;;;;;;ACFD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACI;AACI;AACJ;AACqB;AACZ;AACA;AACM;AACX;AACA;AACiC;AAC3B;AACV;AACE;AACS;AACM;AACqE;AACQ;AACxB;AACA;AACQ;AACxB;AACoB;AAC5B;AAC/B;AAC0C;AACX;AACoB;AACJ;AACI;AACoB;AAClF;AACJ;AACM;;;;;;;;;;;;;ACjCpD;AAAA;AAA+E;;AAEhE;AACf,kBAAkB,6CAAO;AACzB,kBAAkB,6CAAO;AACzB,kBAAkB,6CAAO;AACzB,kBAAkB,6CAAO;AACzB,YAAY,iDAAG;AACf,YAAY,iDAAG;AACf,YAAY,iDAAG;AACf,YAAY,iDAAG;AACf,kBAAkB,iDAAG;AACrB,kBAAkB,iDAAG;AACrB,kBAAkB,iDAAG;AACrB,kBAAkB,iDAAG;AACrB,cAAc,kDAAI,CAAC,kDAAI,CAAC,sDAAQ,wBAAwB,sDAAQ;AAChE,UAAU,iDAAG;;AAEb;AACA,YAAY,iDAAG;AACf,YAAY,iDAAG;AACf;AACA;AACA;AACA;AACA,MAAM,mDAAK,SAAS,6CAAO;AAC3B,MAAM,mDAAK,IAAI,kDAAI,mBAAmB,6CAAO;AAC7C;AACA,GAAG;AACH,iBAAiB,6CAAO,OAAO,6CAAO;AACtC;;AAEA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACnCD;AAAA;AAAA;AAAA;AAAA;AAA4B;AAC+B;AACjC;AACI;;AAE9B,gBAAgB,sDAAK;AACrB;AACA;AACA;;AAEA;AACA,UAAU,6CAAI;AACd,SAAS,6CAAI;AACb;AACA,WAAW,6CAAI;AACf,gBAAgB,6CAAI;AACpB,cAAc,6CAAI;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,6CAAI;AAClD;;AAEA;AACA,YAAY,6CAAO,SAAS,6CAAO;AACnC,8BAA8B,iDAAG,iBAAiB,iDAAG;AACrD;AACA;;AAEA;AACA,YAAY,6CAAO,SAAS,6CAAO;AACnC,eAAe,iDAAG;AAClB,eAAe,iDAAG;AAClB,cAAc,iDAAG;AACjB,iBAAiB,iDAAG;AACpB,iBAAiB,iDAAG;AACpB;AACA;AACA;AACA,gBAAgB,mDAAK,CAAC,kDAAI;AAC1B;AACA;;AAEe;AACf;AACA,EAAE,uDAAM;AACR;AACA,CAAC;;;;;;;;;;;;;ACpDD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,mCAAmC;AACxE;AACA;;AAEA;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAe;;;;;;;;;;;;;ACAf;AAAA;AAAA;AAAA;AAA6B;AACD;AACD;;AAE3B,cAAc,sDAAK;AACnB,kBAAkB,sDAAK;AACvB;AACA;AACA;AACA;;AAEA;AACA,SAAS,6CAAI;AACb,aAAa,6CAAI;AACjB,WAAW,6CAAI;AACf;AACA;AACA;AACA,GAAG;AACH;AACA,mEAAmE,6CAAI;AACvE,gBAAgB,iDAAG;AACnB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEe,yEAAU,EAAC;;;;;;;;;;;;;ACjD1B;AAAA;AAA2B;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,6CAAI;AACjB,WAAW,6CAAI;AACf,gBAAgB,6CAAI;AACpB,cAAc,6CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe,2EAAY,EAAC;;;;;;;;;;;;;AC3B5B;AAAA;AAA6B;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,kDAAI;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,kDAAI;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe,6EAAc,EAAC;;;;;;;;;;;;;ACnG9B;AAAA;AAAA;AAAA;AAA4B;AACD;;AAEZ;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yCAAG;AACpD;AACA;AACA;AACA,GAAG;AACH,UAAU,6CAAI;AACd;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;AACJ;AACD;AACI;AACI;AACF;AACA;AACF;;AAElC,+DAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,uDAAM;AACZ;AACA;AACA;;AAEA;AACA,IAAI,uDAAM,0BAA0B,6CAAQ;AAC5C,WAAW,6CAAQ;AACnB;;AAEA;AACA,IAAI,uDAAM,0BAA0B,gDAAW;AAC/C,WAAW,gDAAW;AACtB;;AAEA;AACA,IAAI,uDAAM,0BAA0B,+CAAU;AAC9C,WAAW,+CAAU;AACrB;;AAEA;AACA,IAAI,uDAAM,0BAA0B,iDAAY;AAChD,WAAW,iDAAY;AACvB;;AAEA;AACA,kFAAkF,iDAAQ;AAC1F;;AAEA;AACA;AACA,qDAAqD,+CAAU,QAAQ,gDAAW;AAClF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC5DD;AAAA;AAAA;AAAA;AAA6B;AACA;AACF;;AAE3B,gBAAgB,sDAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,6CAAI;AACb;AACA;AACA,GAAG;AACH;AACA;AACA,yBAAyB,6CAAI;AAC7B,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,kDAAI;AACpB;AACA;;AAEe,2EAAY,EAAC;;;;;;;;;;;;;AC5C5B;AAAA;AAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1DA;AAAA;AAAoC;;AAErB;AACf,SAAS,iDAAG,gBAAgB,6CAAO,IAAI,iDAAG,gBAAgB,6CAAO;AACjE,CA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CA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;;;;;;;;;;;ACpED;AAAA;AAAe;AACf;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,yBAAyB,yBAAyB,EAAE;AACpD,sBAAsB,sBAAsB,EAAE;AAC9C,yBAAyB,yBAAyB,EAAE;AACpD,uBAAuB,uBAAuB,EAAE;AAChD,4BAA4B,4BAA4B,EAAE;AAC1D,0BAA0B,0BAA0B;AACpD;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAO;AACP;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAO;;AAEA;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACfA;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACnFD;AAAA;AAAO;AACP;AACA;;AAEe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACRD;AAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACND;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA,CAAC;;;;;;;;;;;;;ACXD;AAAe;AACf;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;;ACND;AAAe;AACf;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;;ACZD;AAAe;AACf;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACZD;AAAe;AACf;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACTD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiC;AACF;AACY;AACF;AACZ;AACE;AACA;AACU;AACI;AACV;AACF;;AAElB;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,8CAAU;AACnB,QAAQ,6CAAS;AACjB,aAAa,kDAAc;AAC3B,cAAc,mDAAe;AAC7B,OAAO,4CAAQ;AACf,QAAQ,6CAAS;AACjB,QAAQ,6CAAS;AACjB,aAAa,kDAAc;AAC3B,eAAe,oDAAgB;AAC/B,UAAU,+CAAW;AACrB,SAAS,+CAAU;AACnB;AACA;;;;;;;;;;;;;AC9EA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;;ACRD;AAAe;AACf;AACA;AACA,wBAAwB;AACxB,kBAAkB,kCAAkC;AACpD;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;;ACRD;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAe;AACf;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;;ACND;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;;;;;;;;;;;;ACRD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6C;AACU;AACV;AACW;AACF;AACL;AACF;AACR;AACY;AACO;AACJ;AACE;AACQ;AACF;AACI;;;;;;;;;;;;;ACdlE;AAAA;AAAwC;;AAEzB;AACf,4BAA4B,sDAAO,CAAC,4CAAK;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,kBAAkB;AAC/B,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrHA;AAAA;AAAA;AAAA;AAAuC;AACD;AACa;;AAEnD;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA,gBAAgB,sDAAY;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kCAAkC,sDAAY;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,2DAAQ;AAChD;;AAEA;AACA;AACA;;AAEA;AACA,uEAAuE,yDAAQ;AAC/E;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B,UAAU,6DAAW;AACrB,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9EA;AAAA;AAAA;AAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wCAAwC,KAAK,wDAAO;;AAEvE;AACA,aAAa,OAAO;;AAEpB;AACA;;AAEe;AACf;AACA;AACA,CAAC;;;;;;;;;;;;;ACrHD;AAAA;AAAA;AAAwC;AACC;;AAE1B;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAS;AACxC;AACA;;AAEA;AACA;AACA;AACA,QAAQ,6DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACnDD;AAAA;AAAA;AAAqC;AACiB;;AAEtD;AACA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB,yCAAyC,qDAAI;AAC7C;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,oCAAoC,KAAK,EAAE,aAAa,8DAAa;AACzG;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,2DAAQ;AAC5C;;AAEA;AACA,0CAA0C,2DAAQ;AAClD;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACxED;AAAA;AAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,gBAAgB;AAChB,aAAa;AACb;;AAEA,mCAAmC,qDAAI;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACe;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC5OD;AAAe;AACf;AACA;AACA;;AAEA,6BAA6B,OAAO;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC7CD;AAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACXD;AAAA;AAAA;AAAA;AAAA;AAAgC;AACE;AACI;AACa;;AAEpC;A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AqB,8CAAK,GAAG,4CAAG;AAChC,4BAA4B,6CAAI;AAChC,2BAA2B,8CAAK;AAChC,0FAA0F,+CAAM;AAChG,QAAQ,+CAAM;AACd,CAAC;;;;;;;;;;;;;ACnBD;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC/DD;AAAA;AAAA;AAAA;AAAuC;;;;;;;;;;;;;ACAvC;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;ACjIpB;AAAA;AAAe;AACf;AACA;AACA;AACA,CAAC;;AAED;AACA,wCAAwC;;AAExC;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD;AACnD,oDAAoD;AACpD,GAAG;AACH;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;;;;;;;;;;;;;ACpFA;AAAe;AACf,kDAAkD;;AAElD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACzDD;AAAe;AACf;AACA;AACA,8CAA8C;AAC9C,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;;ACND;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAA0B;;AAEX;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,6CAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,6CAAI;AAChB,YAAY,6CAAI;AAChB,YAAY,6CAAI;AAChB,YAAY,6CAAI;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;A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,4CAA4C,4CAAK;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS,yDAAS;AAClB;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAmC;;AAEpB;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS,yDAAS;AAClB;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAgC;AACF;;AAEf;AACf;AACA;AACA;;AAEA;AACA,6BAA6B,uDAAM;AACnC;;AAEA;AACA,wCAAwC,4CAAK;AAC7C;;AAEA;AACA,uCAAuC,4CAAK;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAkC;AAC+E;;AAElG;AACf;AACA;AACA,aAAa,yDAAQ;AACrB;AACA,cAAc,iEAAe;AAC7B;AACA;AACA;AACA,4DAA4D,iEAAe;AAC3E,aAAa,8DAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gEAAc;AAC1E;AACA;AACA;AACA;AACA,4DAA4D,gEAAc;AAC1E;AACA;AACA;AACA,SAAS,wDAAM;AACf,CAAC;;;;;;;;;;;;;AC9BD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACsB;AACgD;AACxE;AACd;AACmE;AACrE;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP,cAAc,2DAAU,CAAC,+DAAa,EAAE,gEAAa;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA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ACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B,oFAAoF,0EAA0E;AAC5L,8BAA8B;AAC9B,eAAe,oDAAK,aAAa;AACjC;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA,CAAC;;;;;;;;;;;;;ACtCD;AAAA;AAA8B;;AAE9B;AACA,oBAAoB,4CAAK;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEe;;AAEf;AACA,4BAA4B,4CAAK;AACjC;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,OAAO,EAAC;;;;;;;;;;;;;ACvDT;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uDAAuD;AACvD,8CAA8C;AAC9C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B,4BAA4B;AAC1D,8BAA8B;AAC9B,iCAAiC;AACjC;AACA;AACA;AACA;AACA;;AAEe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,IAAI,EAAC;;;;;;;;;;;;;AC5DN;AAAA;AAAA;AAAA;AAA2B;AACM;;AAE1B;AACP;AACA;AACA;;AAEA;AACA,aAAa,6CAAI;AACjB,WAAW,6CAAI;AACf;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D,8BAA8B,kDAAkD;AAChF,8BAA8B,4BAA4B;AAC1D,eAAe,uDAAK,aAAa;AACjC;AACA;AACA;AACA;AACA;;AAEe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,IAAI,EAAC;;;;;;;;;;;;;AC5DN;AAAA;AAAA;AAAiC;;AAE1B;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B,kGAAkG;AAChI,8BAA8B;AAC9B,eAAe,uDAAK,aAAa;AACjC;AACA;AACA;AACA;AACA;;AAEe;;AAEf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,IAAI,EAAC;;;;;;;;;;;;;AChDN;AAAA;AAAA;AAAA;AAAgC;AACI;;AAE7B;AACP;AACA;AACA;AACA;;AAEA,oBAAoB,6CAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,6CAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uDAAuD;AACvD,6CAA6C;AAC7C;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B;AAC9B,8BAA8B;AAC9B,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe;;AAEf;AACA,wDAAwD,kDAAQ;AAChE;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,MAAM,EAAC;;;;;;;;;;;;;ACvFR;AAAA;AAAA;AAAA;AAAgD;AACrB;AACQ;;AAEnC;AACA;AACA;AACA;;AAEA;AACA,aAAa,6CAAI;AACjB,WAAW,6CAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,4BAA4B;AAC1D,8BAA8B,kDAAkD;AAChF,8BAA8B,4BAA4B;AAC1D,eAAe,yDAAK,aAAa;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe;;AAEf;AACA,8DAA8D,8DAAc;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,MAAM,EAAC;;;;;;;;;;;;;ACzER;AAAA;AAAA;AAA4C;AACT;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B,kGAAkG;AAChI,8BAA8B;AAC9B,eAAe,yDAAK,aAAa;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe;;AAEf;AACA,4DAA4D,0DAAY;AACxE;;AAEA;AACA;AACA;;AAEA;AACA,CAAC,MAAM,EAAC;;;;;;;;;;;;;AC7DR;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B;AAC9B,0CAA0C;AAC1C;AACA;AACA;;AAEe;AACf;AACA,CAAC;;;;;;;;;;;;;AC9BD;AAAA;AAA2B;;AAE3B;AACA;AACA;;AAEA;AACA,aAAa,6CAAI;AACjB,WAAW,6CAAI;AACf;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA,CAAC;;;;;;;;;;;;;ACxBD;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uDAAuD;AACvD,4DAA4D;AAC5D;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA,8BAA8B,sEAAsE;AACpG,8BAA8B;AAC9B,8BAA8B,wDAAwD;AACtF,8DAA8D;AAC9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,4BAA4B,EAAE;AACxD,yBAAyB,2BAA2B,EAAE;AACtD,0BAA0B,4BAA4B,EAAE;AACxD,iDAAiD,mDAAmD;AACpG;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;ACvGA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB;AACA,aAAa,OAAO;AACpB;AACA,iBAAiB,QAAQ;AACzB;AACA,aAAa,WAAW;AACxB;AACA;;AAEe;AACf;AACA,CAAC;;;;;;;;;;;;;AChED;AAAA;AAAA;AAAA;AAAmC;;AAE5B,oCAAoC,+CAAW;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,G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cAAc,yCAAG;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACvBF;AAAA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACVF;AAAA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACzBF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;;AAEpC;AACO;AACA;AACA;AACA;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEc;AACf,WAAW,uDAAY;AACvB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+G;AAC1D;AACJ;AACF;;;;;;;;;;;;;ACH/C;AAAA;AAAA;AAA0C;;AAEnC;;AAEP;AACA;AACA;;AAEA;AACA;AACA,MAAM,gEAAS;;AAEA,wEAAS,EAAC;;;;;;;;;;;;;ACZzB;AAAA;AAAA;AAAyC;AACA;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,+DAAQ,CAAC,uDAAY;;AAEZ,uEAAQ,EAAC;;;;;;;;;;;;;ACZxB;AAAA;AAAA;AAWiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iDAAS,cAAc,yDAAS;AACxE,iBAAiB,8CAAM;AACvB;AACA;AACA;AACA,SAAS;AACT;AACA,wCAAwC,kDAAU,cAAc,0DAAU;AAC1E,iBAAiB,+CAAO;AACxB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA,KAAK;AACL;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA,KAAK;AACL;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA,KAAK;AACL;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;;AAEA,YAAY,4BAA4B;AACxC;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,+CAAO,OAAO,wDAAQ;AACvC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,kDAAU,OAAO,wDAAQ;AACtC;;AAEA;AACA;AACA,gCAAgC,4DAAY,MAAM,oDAAY;AAC9D,aAAa,oDAAY,OAAO,wDAAQ,WAAW,wDAAQ;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,kDAAU,OAAO,wDAAQ;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAC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AACf,cAAc,4CAAK;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;;;;;;;;;;;ACVD;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qIAAqI,mBAAmB;;AAEjJ;AACP;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP,QAAQ;AACR,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;;AC7GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACV;AACkB;AACN;AACH;;AAE3C;;AAEA;AACA,EAAE,kEAAY;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,4DAAY;AACd,EAAE,gDAAO;AACT;AACA,EAAE,kEAAY;AACd;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,gDAAO;AAC9C,wCAAwC,gDAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,4DAAY;;AAEd;AACA;AACA,uCAAuC,gDAAO;AAC9C,wCAAwC,gDAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,4DAAY;;AAEd;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA,IAAI,wDAAU;AACd;;AAEA;AACA;A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AAe,OAAO;AAClC;AACA;;AAEA,EAAE,gDAAO;AACT;AACA;;AAEO;AACP;AACA;AACA;AACA,IAAI,gDAAO;AACX;AACA,IAAI,kEAAY;AAChB;AACA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACyB;AAClC;AACJ;AACS;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,qDAAY;AAC5B,gBAAgB,qDAAY;;AAE5B;AACA,aAAa,mDAAW;AACxB;AACA;AACA,QAAQ,uDAAQ;AAChB;AACA;AACA;AACA,KAAK;AACL,MAAM,0DAAW;AACjB,KAAK;AACL;AACA;AACA;;AAEA,EAAE,+DAAiB;;AAEnB;AACA;AACA;AACA;AACA;AACA,IAAI,uDAAS;AACb,IAAI,uDAAS;AACb;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oDAAoD,QAAQ,+DAAiB,iBAAiB,EAAE;AAChG;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;;AAEA;AACA;AACA;;;;;;;;;;;;;AC7IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;;AAEzC;AACP;AACA,cAAc,8CAAK;AACnB;AACA;AACA;AACA;AACA,EAAE,8CAAK;AACP,EAAE,8CAAK;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,0CAA0C;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEO;AACP,UAAU,8CAAK;AACf;;AAEA;AACA,4BAA4B,8CAAK;AACjC;AACA,iDAAiD,gDAAO;AACxD,mDAAmD,gDAAO;AAC1D,aAAa,8CAAK;AAClB;AACA;AACA;;;;;;;;;;;;;ACvKA;AAAA;AAAA;AACA,gBAAgB;AAChB;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,gBAAgB,QAAQ;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEe,2EAAY,EAAC;;;;;;;;;;;;;AC5O5B;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAA;AAA6C;;;;;;;;;;;;;ACA7C;AAAA;AAAA;AAAO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAkC;AACe;AACN;;AAE5B;AACf,UAAU,wCAAM;AAChB,UAAU,wCAAM;AAChB;;AAEA;AACA,eAAe,gDAAO;AACtB,0CAA0C,gDAAO,IAAI,gDAAO,6BAA6B,gDAAO,IAAI,gDAAO;AAC3G;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAiE,yDAAQ;AACzE;;AAEA;AACA,iEAAiE,yDAAQ;AACzE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC/CD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;;AAEA;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,E;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mDAAmD,gBAAgB,sBAAsB,OAAO,2BAA2B,0BAA0B,yDAAyD,2BAA2B,EAAE,EAAE,EAAE,eAAe;;AAE/M;AACV;AACG;;AAEjC;AACP;AACA;AACA;AACA,eAAe,4DAAS;AACxB;AACA,GAAG;AACH;AACA,0BAA0B;;AAE1B;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,gEAAe;AACzC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP,uGAAuG,2DAAU;AACjH,E;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA,E;;;;;;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EX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,UAAU,8CAAO;;AAEjB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,mEAAmE,aAAa;AAChF;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,sFAAuB,E;;;;;;;;;;;;AC5EtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2D;AACF;AACJ;AACF;AACM;AACF;;AAEa;;;;;;;;;;;;;ACPvD;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,IAAqC;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C,yBAAyB,EAAE;AACrE;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;;;;;;;;;;;AChDA;AACA;AACA;;;;;;;;;;;;ACFA,gDAAgD,mBAAO,CAAC,gDAAS;;AAEjE;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,0DAA0D,cAAc;;AAExE;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD;AACA,KAAK,GAAG,UAAU;AAClB;;AAEA;AACA,aAAa;AACb;;AAEA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnFA,gBAAgB,mBAAO,CAAC,wDAAa;AACrC,oBAAoB,mBAAO,CAAC,gEAAiB;;;;;;;;;;;;ACD7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA,qBAAqB;AACrB,mBAAmB;AACnB;AACA,yBAAyB;AACzB,uBAAuB;AACvB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE,WAAW;AAClB;;;;;;;;;;;;AChRA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC;AACtC,cAAc,wDAAwD;AACtE,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,UAAU;AAC9B;;;;;;;;;;;;;ACzJA;AACA;AACA;AACA;AACA;;AAEa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;ACzFA,cAAc,mBAAO,CAAC,gDAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,gBAAgB;AAC5B,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAA6D;AAC3E;AACA,YAAY,sBAAsB;AAClC,YAAY,gBAAgB;AAC5B,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;;AAEA;;AAEA;AACA,2CAA2C,OAAO;AAClD;;AAEA;AACA,oCAAoC,OAAO,uBAAuB,OAAO;AACzE;;AAEA,mCAAmC,OAAO,uBAAuB,OAAO;AACxE;;;;;;;;;;;;;ACzaA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,IAAI,IAAqC;AACzC,6BAA6B,mBAAO,CAAC,yFAA4B;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA;AACA;AACA,MAAM,IAAqC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb,aAAa,mBAAO,CAAC,4DAAe;;AAEpC,2BAA2B,mBAAO,CAAC,yFAA4B;AAC/D,qBAAqB,mBAAO,CAAC,qEAAkB;;AAE/C;;AAEA,IAAI,IAAqC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,6BAA6B;AAC7B,QAAQ;AACR;AACA;AACA;AACA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B;AAC5B,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,IAAqC;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,UAAU,aAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,KAAqC,wFAAwF,SAAM;AACzI;AACA;;AAEA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,KAAqC,4FAA4F,SAAM;AAC7I;AACA;;AAEA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;AC1iBA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAI,IAAqC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAO,CAAC,uFAA2B;AACtD,CAAC,MAAM,EAIN;;;;;;;;;;;;;AC3BD;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;;;AAIb,IAAI,IAAqC;AACzC;AACA;;AAEA,YAAY,mBAAO,CAAC,4CAAO;AAC3B,cAAc,mBAAO,CAAC,4DAAe;AACrC,qBAAqB,mBAAO,CAAC,8EAA2B;AACxD,eAAe,mBAAO,CAAC,kDAAU;AACjC,cAAc,mBAAO,CAAC,4DAAkB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd;;;AAGA;AACA,WAAW,eAAe;AAC1B,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,YAAY,WAAW;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,UAAU;AACtB;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,iBAAiB;AACjB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;;AAEA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH;AACvH,yHAAyH;AACzH;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,mCAAmC;AACnC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;AAClD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,sBAAsB;AACjD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,EAAE;AACb,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8KAA8K,YAAY;AAC1L;AACA;AACA;AACA;AACA,uLAAuL,+BAA+B;AACtN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iKAAiK,iBAAiB;AAClL,OAAO;AACP,iKAAiK,iBAAiB,wDAAwD,mBAAmB,gBAAgB,8BAA8B;AAC3S;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+GAA+G,GAAG;AAClH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,4IAA4I,mBAAmB,gBAAgB,8BAA8B;AAC7M,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA,sDAAsD,eAAe;AACrE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,iEAAiE;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,4FAA4F,eAAe;AAC3G;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wCAAwC;AACxC,iDAAiD;AACjD,qDAAqD;AACrD,0DAA0D;AAC1D,8DAA8D;AAC9D,2DAA2D;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH,sCAAsC;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kGAAkG;AAClG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kKAAkK,yCAAyC;AAC3M;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,kDAAkD;AAC5D;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,6BAA6B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU,iCAAiC;AAC3C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,MAAM;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAiE,mBAAmB;AACpF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;;AAGH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;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EA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,4FAA4F,eAAe;AAC3G;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qOAAqO;AACrO;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sFAAsF,aAAa;AACnG;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,cAAc;AACzB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wBAAwB;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0IAA0I,yCAAyC;AACnL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,iBAAiB;AAC5B,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,iBAAiB;AAC5B,WAAW,EAAE;AACb,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;;;;;;;AC7rDa;;AAEb,IAAI,KAAqC,EAAE,EAE1C;AACD,mBAAmB,mBAAO,CAAC,iFAA4B;AACvD;;;;;;;;;;;;;ACNA;AAAA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,gCAAgC,QAAQ;AACxC;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,yBAAyB,MAAM;AAC/B;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEe,8EAAe,E;;;;;;;;;;;;ACrE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;;;AAIb,IAAI,IAAqC;AACzC;AACA;;AAEA,8CAA8C,cAAc;;AAE5D;;;AAGA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA,kDAAkD;;;AAGlD;;;AAGA;;;AAGA;AACA;;AAEA;;;AAGA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC1aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;;;AAIb,IAAI,IAAqC;AACzC;AACA;;AAEA,8CAA8C,cAAc;;AAE5D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACraa;;AAEb,IAAI,KAAqC,EAAE,EAE1C;AACD,mBAAmB,mBAAO,CAAC,0FAA+B;AAC1D;;;;;;;;;;;;;ACNa;;AAEb,IAAI,KAAqC,EAAE,EAE1C;AACD,mBAAmB,mBAAO,CAAC,0GAAuC;AAClE;;;;;;;;;;;;ACNA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,uDAAQ;;AAE9B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA,mBAAmB,2BAA2B;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA;;AAEA,QAAQ,uBAAuB;AAC/B;AACA;AACA,GAAG;AACH;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd,kDAAkD,sBAAsB;AACxE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD;;AAEA,6BAA6B,mBAAmB;;AAEhD;;AAEA;;AAEA;AACA;;;;;;;;;;;;;AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,EAAE;AACrD,wCAAwC,WAAW,EAAE;;AAErD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,sCAAsC;AACtC,GAAG;AACH;AACA,8DAA8D;AAC9D;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACM;AACI;AACG;AACH;AACF;AACE;AACI;;;;;;;;;;;;;ACPzD;AAAA;AAAoC;;AAErB;AACf,UAAU,0DAAS;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE,6CAA6C;AAC7C,0DAA0D;AAC1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACtCD;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACRD;AAAA;AAAA;AAAA;AAAA;AAAgC;AACI;;AAEpC,+DAAe;AACf;AACA,SAAS,mEAAmE,6BAA6B,EAAE;AAC3G;AACA,CAAC;;AAEM;AACP;AACA;AACA,4CAA4C;AAC5C;AACA,uCAAuC;AACvC,wBAAwB;AACxB,SAAS;AACT;;AAEO;AACP,uBAAuB,0DAAS;AAChC;;AAEA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA,eAAe,wDAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,OAAO;AAC3C,kDAAkD;AAClD;AACA;;AAEA;AACA;AACA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC,uDAAuD;AACvD,gEAAgE;AAChE,oDAAoD;AACpD,6DAA6D;AAC7D,oDAAoD;AACpD,6DAA6D;AAC7D;AACA;AACA,YAAY;AACZ;;AAEA;AACA;;;;;;;;;;;;;ACpEA;AAAe;AACf;AACA,CAAC;;;;;;;;;;;;;ACFD;AAAA;AAAA;AAAA;AAAiC;AACH;;AAE9B;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA,+DAAe;AACf,SAAS,uDAAM;AACf,CAAC;;AAEM;AACP,wBAAwB;AACxB;AACA;;AAEA;;AAEA;AACA;AACA,gEAAgE;AAChE,sCAAsC;AACtC,mDAAmD;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA,0BAA0B,uDAAM,YAAY,8BAA8B;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;;AAEP;AACA,aAAa,uDAAM;;AAEnB;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;ACpGA;AAAA;AAAA;AAAA;AAAiC;AACH;;AAE9B,+DAAe;AACf,SAAS,uDAAM;AACf,CAAC;;AAEM;AACP;AACA;AACA,8DAA8D,OAAO;AACrE,UAAU,+BAA+B,uDAAM;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,cAAc;AAChE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE;AAChE,0CAA0C;AAC1C,+DAA+D;AAC/D,4CAA4C;AAC5C;AACA;;AAEA;;AAEA;AACA,yBAAyB,uBAAuB;AAChD,yBAAyB,0EAA0E,EAAE;;AAErG;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAA8B;;AAEf;AACf,uBAAuB;AACvB,0CAA0C,WAAW,EAAE;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,gCAAgC,cAAc,EAAE;AAChD;;AAEA;AACA,2EAA2E,gBAAgB,EAAE;AAC7F;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,6BAA6B,iBAAiB,EAAE,EAAE;AACvF;;AAEA;;AAEA;AACA,kEAAkE,OAAO;AACzE,yBAAyB,OAAO;AAChC;AACA,oCAAoC,uDAAM;AAC1C,oCAAoC,uDAAM;AAC1C;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC5CD;AAAA;AAAA;AAA0B;AACc;;AAEzB;AACf;;AAEA;AACA;AACA,2BAA2B,qDAAI;AAC/B;AACA,iBAAiB;AACjB,GAAG;AACH;AACA;;AAEA,UAAU,4DAAW;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,gFAAgF;AAC3H,8BAA8B,8DAA8D;AAC5F,mCAAmC,uEAAuE;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iEAAiE;AACjE;AACA,yEAAyE;AACzE,sCAAsC;AACtC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACrDD;AAAe;AACf;AACA;AACA,CAAC;;;;;;;;;;;;;ACHD;AAAe;AACf,uBAAuB;AACvB,0BAA0B;AAC1B,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,mEAAmE,gCAAgC,EAAE;AACrG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kCAAkC,EAAE;AACjE;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,wDAAwD,EAAE;;AAEtF;AACA,CAAC;;;;;;;;;;;;;ACxED;AAAA;AAAkC;;AAEnB;AACf,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AClBD;AAAA;AAAkC;;AAEnB;AACf,gCAAgC,iDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACtBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;A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ACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,+BAA+B,4DAAW;AAC1C;AACA;AACA,gBAAgB,0DAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC,oBAAoB;AACpB;AACA,KAAK,gCAAgC;AACrC;AACA,KAAK,yCAAyC;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA,QAAQ,KAAK;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,4BAA4B,KAAK;AACjC;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,iCAAiC,OAAO,QAAQ;AAChD;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA,GAAG;AACH,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA,GAAG;AACH,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC/XA;AAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB,gBAAgB,MAAM;AACtB;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACxBD;AAAA;AAAA;AAAA;AAAwC;AACL;;AAEnC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,0CAA0C,kBAAkB;AAC5D;AACe;AACf,EAAE,uDAAS;AACX;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA,KAAK;AACL,uEAAuE;AACvE,KAAK;AACL;AACA;AACA;;AAEA,gBAAgB,0DAAQ,gBAAgB,uDAAS;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,KAAK;;AAEL,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,mDAAmD,uBAAuB,EAAE;AAC5E;;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAiC;AACyB;;AAE1D;AACA;AACA;AACe;AACf,cAAc,uDAAO;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,uDAAO;AACtB;;AAEA,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,uDAAO;AACrB;AACA,KAAK;AACL,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,uBAAuB;;AAEpC;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM,2DAAU;AAChB,MAAM,4DAAW;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc,EAAE;AACzC,yBAAyB,aAAa;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,SAAS,wDAAO;AAChB;;AAEA;AACA;;AAEA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,SAAS;AACjB;AACA;AACA;;AAEA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;;;;;;;;;;;;;AC7HA;AAAA;AAAA;AAAA;AAAO,oBAAoB,0BAA0B;;AAE9C,qBAAqB,2BAA2B;;AAEhD,qBAAqB,2BAA2B;;;;;;;;;;;;;ACJvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAC4D;;AAE5D;AACkE;AACN;AACH;AACF;AACV;AACU;AACJ;AACE;AAC2B;;AAEhF;AAKwB;;;;;;;;;;;;;ACnBxB;AAAA;AAAA;AAAA;AAAA;AAAwC;AACc;;AAE/C;AACP;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,uDAAK;AACnB,YAAY,KAAK;AACjB;AACA,KAAK;AACL;AACA,cAAc,4DAAU;AACxB,cAAc,uDAAK;AACnB,YAAY,KAAK;AACjB;AACA,KAAK;AACL;AACA,eAAe,qBAAqB,0DAAQ;AAC5C,UAAU,4DAAU;AACpB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,UAAU,4DAAU,gBAAgB,sBAAsB;AAC1D,qBAAqB,qBAAqB;AAC1C;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,UAAU;;AAE5B;AACA,gCAAgC,KAAK;AACrC,YAAY,sDAAO;AACnB;;AAEA;AACA,6BAA6B,KAAK;AAClC;AACA,YAAY,sDAAO;AACnB;;AAEA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA,wBAAwB,sDAAO;AAC/B,SAAS;AACT;;AAEA;AACA,6BAA6B,KAAK;AAClC;AACA,aAAa,sDAAO;AACpB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,yBAAyB,qDAAM;AAC/B;AACA;;AAEA;AACA,gCAAgC,KAAK;AACrC;AACA,gBAAgB,sDAAO;AACvB;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,sDAAO;AAChC;;AAEA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA,iBAAiB,sDAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA,0BAA0B,sDAAO;AACjC;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC,YAAY,sDAAO,SAAS,EAAE;AACrE;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACzIA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACc;;AAEzD;;AAEA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C;AACA,WAAW,oBAAoB;AAC/B;AACA,WAAW,iBAAiB;AAC5B;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,kCAAkC;AAC7C;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACO;AACP;AACA;;AAEA;;AAEA,oBAAoB,gDAAM;;AAE1B,mBAAmB,kDAAQ;;AAE3B;AACA,2CAA2C,gEAAU,CAAC,4CAAE;AACxD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,KAAK;;AAEf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,KAAK;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA,IAAI,0DAAQ;AACZ;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,iDAAiD,eAAe,EAAE;AAClE,iDAAiD,gBAAgB,EAAE;AACnE,iCAAiC,eAAe,EAAE;AAClD;;;;;;;;;;;;;AC3HA;AAAA;AAAA;AAAA;AAA4B;AACuB;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB;AACe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,KAAK;AACjC;AACA;;AAEA;AACA,uCAAuC;AACvC,+BAA+B,aAAa;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB,0DAAQ,aAAa,8CAAK;;AAE1C;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc,8CAAK;AACnB;AACA;AACA,qCAAqC,sBAAsB,EAAE;AAC7D;AACA;AACA,qCAAqC,sBAAsB,EAAE;AAC7D;AACA;AACA,qCAAqC,sBAAsB,EAAE;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,yDAAO,0BAA0B,kBAAkB,EAAE;AAC3D;AACA;;AAEA;AACA,EAAE,uDAAK;AACP;;AAEA;AACA,EAAE,uDAAK;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,KAAK;AACf;AACA;AACA,GAAG;AACH,UAAU,KAAK;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACK;AACS;;AAEpD;AACA;AACA,oBAAoB,mDAAU;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,wBAAwB;AACnC;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,2CAA2C,gEAAU,CAAC,4CAAE;AACxD;;AAEA;AACA;AACA,WAAW,EAAE;AACb,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA,mDAAmD,mDAAU;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM,uDAAK;AACX;AACA,UAAU,uDAAK;AACf,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK,UAAU,yDAAO;AACtB;AACA,eAAe,KAAK;AACpB,KAAK;AACL;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD,OAAO,eAAe;AACtB,4DAA4D,eAAe;AAC3E,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5NA;AAAA;AAAA;AAAkC;;AAElC;;AAEA;AACA;AACA;AACA;AACe;AACf,sCAAsC,yBAAyB;AAC/D;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,EAAE;AACb,WAAW,QAAQ;AACnB;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,gBAAgB,yDAAO;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA,GAAG,UAAU,yDAAO;AACpB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACqB;;AAErD;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,oDAAoD,eAAe;AACnE,yCAAyC,eAAe;AACxD;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,YAAY,MAAM;AAClB;AACA;AACA,eAAe,uDAAK;AACpB,6CAA6C;AAC7C,8BAA8B,gBAAgB,EAAE;AAChD;AACA;;AAEA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,yDAAO,0BAA0B,kBAAkB,EAAE;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,mBAAmB;AAC9B;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,yBAAyB,EAAE;AACvD;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,4DAAU,4BAA4B,aAAa,EAAE;AACvD;AACA;;AAEA;AACA;AACA,kCAAkC,KAAK,sDAAO,SAAS,EAAE;AACzD,sBAAsB,YAAY,sDAAO,gBAAgB;AACzD;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA,IAAI,4DAAU;AACd;AACA;;AAEA,mBAAmB,4DAAU;AAC7B,mBAAmB,4DAAU;AAC7B,mBAAmB,4DAAU;;AAE7B;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,4DAAU;AAChB,KAAK;AACL;AACA,MAAM,4DAAU;AAChB;AACA;;AAEA;AACA;;;;;;;;;;;;;AC1YA;AAAA;AAAA;AAAA;AAAkC;AACC;;AAEnC;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA,W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lB,WAAW,QAAQ;AACnB;AACA,YAAY,SAAS;AACrB;AACA,+DAAe;AACf;AACA;;AAEA,sBAAsB,iDAAQ;AAC9B;AACA,GAAG,4CAA4C,iDAAQ;AACvD;AACA,GAAG,UAAU,4DAAU;AACvB,aAAa,iDAAQ;AACrB,GAAG;AACH;AACA,aAAa,iDAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC3CD;AAAA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,gBAAgB;AAC3B;AACA;AACe;AACf;;AAEA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACjBD;AAAA;AAAA;AAAsC;AACN;;AAEhC;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,WAAW,0BAA0B;AACrC,WAAW,oBAAoB;AAC/B;AACA;AACA,YAAY;AACZ;AACe;AACf;AACA,UAAU,2DAAM;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,GAAG;AACH,cAAc,uDAAK;AACnB;;AAEA,iCAAiC,KAAK;AACtC;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACxCD;AAAA;AAAA;AAAA;AAAA;AAAiC;AACA;;AAEjC;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,EAAE;AACb;AACA,WAAW,OAAO;AAClB;AACA,aAAa;AACb;AACO;AACP,oDAAoD,wDAAI;AACxD;;AAEA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA,eAAe,wDAAI;AACnB,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6CAA6C,gDAAM;AACnD;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;ACvFA;AAAA;AAAA;AAAA;AAAmC;AACM;AACc;;AAEvD,YAAY;;AAEZ;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,WAAW,qBAAqB;AAChC;AACA,WAAW,mCAAmC;AAC9C;AACA;AACA;AACA,WAAW,8BAA8B;AACzC;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,YAAY;AACZ;AACe;AACf,6BAA6B,iDAAQ;AACrC;AACA;AACA,CAAC;;AAED;AACA,YAAY,wDAAM,GAAG;;AAErB,OAAO,4DAAU,mBAAmB,0DAAQ;;AAE5C;AACA;AACA;AACA;AACA,GAAG,UAAU,4DAAU;AACvB,aAAa,iDAAQ;AACrB;AACA;AACA;AACA,MAAM,8DAAW;AACjB;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH,WAAW,4DAAU,oBAAoB,0DAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,iDAAQ;AACrB;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC1FA;AAAA;AAAA;AAAA;AAAgC;;AAEhC;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA,wBAAwB,uDAAK;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2D;AACpB;AACK;AACO;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,8CAAK;;AAEvB,eAAe,8CAAI;AACnB;AACA;AACA;;AAEA;AACA,oCAAoC,uBAAuB,EAAE;AAC7D,gBAAgB,gEAAU,CAAC,4CAAE;;AAE7B;AACA;AACA;;AAEA;AACA,iCAAiC,uBAAuB,UAAU;;AAElE;AACA;;AAEA,mBAAmB,+CAAK;AACxB,iCAAiC,sDAAe;AAChD;;AAEA;AACA,mBAAmB,sDAAe;AAClC;AACA,2DAA2D,iBAAiB,EAAE;AAC9E;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,8CAAI;AACnB;AACA,gEAAgE;AAChE;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS,6BAA6B,EAAE,cAAc,eAAe;AACrE;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC,EAAE;AAC9D,4BAA4B,gCAAgC,EAAE;AAC9D;;AAEA;AACA;;AAEA;AACA,OAAO,cAAc,EAAE,cAAc,eAAe;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,uCAAuC,UAAU;AACjD;AACO;AACP;AACA;AACA;;AAEA,WAAW,yDAAO;AAClB,2BAA2B,gBAAgB,EAAE;AAC7C,eAAe,mDAAU;AACzB;;AAEA;AACA;AACA;AACA,oBAAoB,sDAAe;AACnC;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC/MA;AAAA;AAAA;AAAA;AAAA;AAA6B;;AAE7B,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,YAAY;AACZ;AACO;AACP;;AAEA,cAAc,8CAAK;AACnB;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAA;AAAO;;AAEA;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAe;AACf;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;A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tD,KAAK;AACL,oEAAoE;AACpE,KAAK,sCAAsC;AAC3C,KAAK;AACL;AACA;;AAEA,gBAAgB,0DAAQ,WAAW,uDAAS;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,uDAAK;AACT;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3KA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACA;AACJ;;AAEpC;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACe;AACf,EAAE,uDAAS;AACX;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,KAAK,mCAAmC;AACxC,KAAK,uDAAuD;AAC5D,KAAK,qEAAqE;AAC1E,KAAK,sDAAsD;AAC3D,KAAK;AACL;AACA;;AAEA,gBAAgB,0DAAQ,MAAM,uDAAS;;AAEvC;AACA;AACA;AACA;AACA,yBAAyB,6CAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAG;AAC9B,cAAc,sDAAK;AACnB;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;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ACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,KAAK;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,aAAa,EAAE;AACxC;;AAEA;AACA;AACA;AACA,GAAG;AACH,eAAe,qBAAqB,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,KAAK;AACxC;AACA,8BAA8B,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACpIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiD;AACkC;AAChD;AACJ;;AAE/B;AACA,QAAQ,qDAAQ;AAChB,QAAQ,qDAAQ;AAChB,QAAQ,sDAAS;AACjB,QAAQ,sDAAS,YAAY,uDAAU;;AAEhC;AACP;AACA,kCAAkC,yDAAU;AAC5C;;AAEA;AACA;AACA;AACA,WAAW,sDAAI;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEO;AACP,kBAAkB,qDAAO;AACzB,eAAe,sDAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,YAAY,sDAAI;AAChB;;AAEA,qBAAqB,sDAAS;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpGA;AAAA;AAAA;AAAA;AAAO;AACA;AACA;;;;;;;;;;;;;ACFP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACmB;AACK;AAIvC;;AAEnB;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,YAAY,EAAE;AACd;AACO;AACP;;AAEA,MAAM,0DAAQ;AACd;AACA;AACA;;AAEA,MAAM,0DAAQ;AACd,oCAAoC,+DAAY;AAChD,+BAA+B,8DAAW;AAC1C,QAAQ,uDAAK;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,EAAE;AACb,YAAY,SAAS;AACrB;AACO;AACP;AACA;AACA,WAAW,sDAAI;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,+BAA+B,sDAAI;AACnC;AACA,2CAA2C,iBAAiB,EAAE;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,YAAY,SAAS;AACrB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,EAAE;AACb,WAAW,OAAO;AAClB;AACA,YAAY,mBAAmB;AAC/B;AACO;AACP;AACA,kBAAkB,wDAAY;AAC9B;;AAEA,yBAAyB,gDAAG;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,iEAAe;;AAEzB;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACA,MAAM,wDAAY;AAClB,MAAM,wDAAY;AAClB;AACA,GAAG;AACH,WAAW,wDAAY;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+CAA+C,OAAO,OAAO;;AAE7D;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,yCAAyC;AACzC;AACA;;;;;;;;;;;;;ACxJA;AAAA;AAAA;AAAA;AAAyD;;;;;;;;;;;;;ACAzD;AAAA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,KAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC/MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACA;AACI;AACI;AACA;;;;;;;;;;;;;ACJvD;AAAA;AAAe;AACf;AACA;;AAEA;AACA;;AAEA;;AAEA,yCAAyC,KAAK;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AAAoC;AACA;AACyB;;AAE9C;AACf;;AAEA,kCAAkC,uDAAK,oBAAoB;AAC3D,kCAAkC,uDAAK,oBAAoB;AAC3D,mCAAmC,kDAAS;AAC5C,oCAAoC,kDAAS;AAC7C;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;;AAEA,qBAAqB,4DAAU;AAC/B;AACA,qBAAqB,qCAAqC;;AAE1D;AACA,QAAQ,0DAAQ;AAChB;AACA,2BAA2B,uDAAK;AAChC;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP,eAAe,uDAAK;AACpB,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe,EAAE;AAC9C;AACA;AACA,OAAO;;AAEP;AACA;AACA,UAAU,uDAAK;AACf;AACA;AACA;AACA;AACA,iBAAiB,uDAAK;AACtB,eAAe,4DAAU;AACzB;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA,iBAAiB,0CAA0C;AAC3D,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC1HD;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACZF;AAAA;AAAgC;;AAEjB;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,uDAAK;AAChC,2BAA2B,uDAAK;AAChC;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,uDAAK;AAClC,6BAA6B,uDAAK;AAClC;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACzGD;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AAC4B;;AAE5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe;AACf,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB;AACnB;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,GAAG;AAC7D;AACA;AACA;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA,qBAAqB;AACrB,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK;AACL,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,4CAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA,WAAW;;AAEX,kBAAkB;AAClB;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,KAAK;AACL;AACA;;AAEA;;AAEA,iBAAiB;AACjB;AACA;AACA;;AAEA,WAAW;;AAEX;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC39CD;AAAA;AAAA;AAAA;AAA6C;;;;;;;;;;;;;ACA7C;AAAA;AAAA;AAAA;AAAA;AAAwC;AACqC;AAI3D;;AAElB;AACA,UAAU,oDAAW;AACrB,WAAW,qDAAY;AACvB,SAAS,sDAAa;AACtB,QAAQ,kDAAS;AACjB,KAAK,+CAAM;AACX,KAAK,+CAAM;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACe;AACf,EAAE,uDAAS;AACX;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,KAAK,wDAAwD;AAC7D,KAAK,yDAAyD;AAC9D,KAAK,yDAAyD;AAC9D,KAAK,kDAAkD;AACvD,KAAK,yDAAyD;AAC9D,KAAK,wDAAwD;AAC7D,KAAK,4DAA4D;AACjE,KAAK;AACL;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA,aAAa,8CAA8C;AAC3D,aAAa;AACb;AACA,SAAS;AACT;AACA,kBAAkB,mBAAmB;AACrC;AACA,aAAa,mDAAmD;AAChE,aAAa,uDAAuD;AACpE,aAAa;AACb;AACA,SAAS;AACT;AACA,kBAAkB,iBAAiB;AACnC;AACA,aAAa,uDAAuD;AACpE,aAAa,oDAAoD;AACjE,aAAa,wDAAwD;AACrE,aAAa;AACb;AACA,SAAS;AACT;AACA,kBAAkB,gBAAgB;AAClC;AACA,aAAa,kCAAkC;AAC/C,aAAa,gCAAgC;AAC7C,aAAa,oEAAoE;AACjF,aAAa,qDAAqD;AAClE,aAAa;AACb;AACA,SAAS;AACT;AACA,kBAAkB,aAAa;AAC/B;AACA,aAAa,uDAAuD;AACpE,aAAa;AACb;AACA,SAAS;AACT;AACA,kBAAkB,aAAa;AAC/B;AACA,aAAa,uDAAuD;AACpE,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,0DAAQ,QAAQ,uDAAS;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,cAAc;AACpC,KAAK;AACL;AACA,gDAAgD;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA,uDAAuD,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,oBAAoB;AACzC;;AAEA;AACA,YAAY,gEAAe;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,gBAAgB,EAAE;AACrE;;AAEA;AACA,UAAU,uDAAK;;AAEf,iCAAiC,KAAK;AACtC;AACA;AACA;;AAEA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,KAAK;AACnC,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,4DAAU,6BAA6B,gE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;AACpD;AACA;;AAEe;AACf,2CAA2C,uDAAK,oBAAoB,kDAAQ;AAC5E,SAAS,0DAAQ;AACjB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAA0B;AACoB;AACd;;AAEjB;AACf;AACA,SAAS,qDAAI;;AAEb,qDAAqD,uDAAO;AAC5D,6CAA6C,oDAAI;AACjD,MAAM,uDAAK;;AAEX;AACA;AACA,MAAM,uDAAK;;AAEX;AACA,CAAC;;;;;;;;;;;;;ACjBD;AAAA;AAA0D;;AAE1D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACe;AACf;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,mCAAmC,eAAe;AAClD,sBAAsB,WAAW,wBAAwB,WAAW;AACpE;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wDAAM,GAAG;;AAErB;AACA,kBAAkB,WAAW;AAC7B;;AAEA;AACA,iDAAiD,6DAAW;AAC5D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,kBAAkB;;AAElE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA,sBAAsB,wDAAM,GAAG;AAC/B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QA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A;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AAIpB;AACmC;AAC2C;AACC;;AAEhF;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,kBAAkB,EAAE;AACvD;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,2CAAK,GAAG,iDAAG;AACtC,kBAAkB,yDAAK,EAAE,YAAY;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oBAAoB,iDAAG,UAAU,yDAAK,EAAE,cAAc;AACtD;AACA,6BAA6B,iDAAG;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,sDAAI;AACb;;AAEA;AACA,SAAS,sDAAI;AACb;;AAEA;AACA,SAAS,sDAAI;AACb;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM,0DAAQ,gBAAgB,sDAAQ;AACtC;AACA,IAAI,uDAAK,mCAAmC,6DAAW;AACvD;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA,wBAAwB,iDAAG,UAAU,yDAAK;AAC1C;AACA;AACA;;AAEA;AACA;AA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;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtOA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACX;AACI;AACU;;AAE3B;AACf,OAAO,0DAAQ,QAAQ,uDAAK;AAC5B,SAAS,6DAAS,WAAW,8CAAK,CAAC,uDAAQ;AAC3C;AACA,CAAC;;;;;;;;;;;;;ACTD;AAAA;AAAmC;;AAEpB;AACf;AACA,MAAM,0DAAQ;AACd;AACA,GAAG;AACH;AACA,YAAY;AACZ;AACA,CAAC;;;;;;;;;;;;;ACVD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8C;AACA;AACJ;AACE;AACE;AACF;AACE;AACH;AACJ;AACR;AAC4B;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A;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,6CAA6C;AAC3D;AACA,KAAK,IAAI;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,cAAc;AACd,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa,MAAM;AACnB;AACO;AACP;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,SAAS,4BAA4B,EAAE;AAC7E,cAAc;;AAEd;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA;AACA,gBAAgB;AAChB,iBAAiB;AACjB;AACA;;AAEA,QAAQ,KAAK;AACb;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA,QAAQ,wDAAM,iCAAiC,kDAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiC;AACH;AACK;AACI;AACkC;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA,eAAe,+CAAK,WAAW,uDAAK;AACpC;;AAEA,QAAQ,wDAAM,eAAe,0DAAQ;AACrC,QAAQ,wDAAM,yBAAyB,0DAAQ;AAC/C,QAAQ,wDAAM,0CAA0C,kDAAQ;;AAEhE;AACA;AACA;AACA,SAAS,yDAAO;AAChB;AACA;AACA,KAAK;AACL;AACA,aAAa,uDAAO;AACpB,OAAO;AACP;AACA,aAAa,uDAAO;AACpB,OAAO,sCAAsC;AAC7C,aAAa,uDAAO;AACpB,OAAO;AACP,aAAa,uDAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA,oBAAoB,wDAAwD;AAC5E;AACA,oBAAoB,gDAAgD;AACpE;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP,uBAAuB,4CAAO,EAAE,uDAAK;;AAErC;AACA;AACA;AACA,kBAAkB,qDAAW;;AAE7B;AACA;AACA;;AAEA,EAAE,yDAAW;AACb;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA,aAAa,OAAO;AACpB;AACO;AACP;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA,QAAQ,OAAO;AACf;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA,gEAAgE;AAChE;AACA;AACA;AACA,iCAAiC,uDAAK;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,8BAA8B,EAAE;AAC5D;AACA;AACA;AACA,OAAO;AACP,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,KAAK;AACf;AACA,GAAG;;AAEH;AACA;AACA,gCAAgC,8BAA8B,EAAE;AAChE,GAAG;;AAEH;AACA,aAAa,0DAAQ,iBAAiB,0DAAQ;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,aAAa,0DAAQ,iBAAiB,0DAAQ;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrNA;AAAA;AAAA;AAAA;AAAA;AAAiC;AACqB;;AAE/C;AACP,UAAU,uDAAQ;AAClB;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA,QAAQ,kEAAU,oBAAoB,iEAAS;AAC/C;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAA4B;;AAE5B;;AAEA,mBAAmB,eAAe;;AAElC;AACA,aAAa,0CAAI;AACjB;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAwC;AACP;;AAElB;AACf;AACA;AACA,uBAAuB,8CAAG,eAAe,iDAAM;AAC/C;AACA;;AAEA;AACA,MAAM,wDAAM,GAAG;AACf;AACA,C;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACH;AACD;AACQ;AACE;AACE;;AAEjC;AACf;AACA,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE,qEAAS,0BAA0B,0DAAM;AAC3C,EAAE,qEAAS,0BAA0B,0DAAM;AAC3C,EAAE,qEAAS,0BAA0B,0DAAM;;AAE3C,iBAAiB,8CAAG,eAAe,iDAAM;AACzC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS,2DAAS,CAAC,yDAAQ,EAAE,2DAAc;AAC3C,CAAC;;AAED;AACA,UAAU;AACV;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqD;AAChB;AACD;AACQ;AACA;AACI;;AAEjC;AACf;AACA;AACA,yBAAyB,+CAAI,eAAe,8CAAG;AAC/C;AACA,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE,qEAAS,0BAA0B,0DAAM;AAC3C,EAAE,qEAAS,0BAA0B,0DAAM;AAC3C,EAAE,qEAAS,0BAA0B,0DAAM;AAC3C,EAAE,qEAAS,0BAA0B,0DAAM;;AAE3C;AACA;AACA,YAAY,gDAAK;AACjB,YAAY,0DAAM;AAClB,YAAY,0DAAM;AAClB,YAAY,0DAAM;AAClB,YAAY,0DAAM;AAClB;;AAEA,iBAAiB,8CAAG,eAAe,iDAAM;AACzC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB;AAChB,8BAA8B;AAC9B,GAAG;AACH,gBAAgB;AAChB,8BAA8B;AAC9B;;AAEA,SAAS,2DAAS,CAAC,yDAAQ,EAAE,yDAAY,QAAQ,gDAAK;AACtD,CAAC;;;;;;;;;;;;;AC9DD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoF;AAC/C;AACD;AACQ;AACC;AACY;AACxB;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA,yBAAyB,+CAAI,eAAe,8CAAG;AAC/C,4BAA4B,8CAAG,eAAe,iDAAM;AACpD;AACA,cAAc,mDAAK,CAAC,0DAAM;AAC1B,oBAAoB,mDAAK,CAAC,0DAAM;AAChC;AACA,mBAAmB,0DAAM;AACzB,sBAAsB,0DAAM;AAC5B,cAAc,SAAS;AACvB;;AAEA,aAAa,mEAAO;AACpB;AACA,oBAAoB,mEAAO,CAAC,0DAAM;AAClC;;AAEA;AACA;AACA,YAAY,gDAAK;AACjB;AACA,YAAY,0DAAM;AAClB;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,8CAAG;AAC/C;AACA,GAAG;;AAEH,sCAAsC,gDAAK;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB,aAAa,OAAO,gDAAK,CAAC;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,qEAAS;AACX,EAAE,qEAAS;AACX,EAAE,qEAAS;AACX,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,YAAY,0DAAM;AAClB,YAAY,0DAAM;;AAElB,SAAS,2DAAS,CAAC,yDAAQ,EAAE,0DAAa,EAAE,0DAAe,EAAE,gDAAK;;AAElE;AACA;AACA;AACA;AACA;AACA,uBAAuB,+CAA+C;AACtE;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACxGD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqD;AAChB;AACD;AACQ;AACA;AACa;;AAE1C;AACf;AACA,yBAAyB,+CAAI,eAAe,8CAAG;AAC/C,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE,qEAAS,0BAA0B,0DAAM;AAC3C,EAAE,qEAAS,0BAA0B,0DAAM;AAC3C,EAAE,qEAAS,0BAA0B,0DAAM;;AAE3C,aAAa,mEAAO;AACpB;;AAEA;AACA;AACA,YAAY,gDAAK;AACjB,YAAY,0DAAM;AAClB,YAAY,0DAAM;AAClB,YAAY,0DAAM;AAClB,YAAY,0DAAM;AAClB;;AAEA,iBAAiB,8CAAG,eAAe,iDAAM;AACzC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,SAAS,2DAAS,CAAC,yDAAQ,EAAE,yDAAY,QAAQ,gDAAK;AACtD,CAAC;;;;;;;;;;;;;ACnDD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+D;AAC1B;AACD;AACe;AACP;AACC;AACG;;AAEjC;AACf;AACA,yBAAyB,+CAAI,eAAe,8CAAG;AAC/C,+BAA+B,8CAAG,eAAe,iDAAM;AACvD,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB,YAAY,mEAAO;AACnB,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,sBAAsB,kBAAkB,8CAAG;AAC3C,GAAG;AACH;AACA,mBAAmB;AACnB,sBAAsB;AACtB;;AAEA,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;;AAEzC,GAAG,qEAAS,cAAc,0DAAM;AAChC,sBAAsB,+DAAG;AACzB,6BAA6B,YAAY;;AAEzC,GAAG,qEAAS,cAAc,0DAAM;AAChC,uBAAuB,+DAAG;AAC1B,6BAA6B,YAAY;;AAEzC,SAAS,2DAAS,CAAC,yDAAQ,EAAE,0DAAa,EAAE,0DAAe;AAC3D,CAAC;;;;;;;;;;;;;AC9DD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAA6C;;AAE9B;AACf;AACA,UAAU,0DAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACdD;AAAA;AAAA;AAAiC;AACkB;;AAEpC;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAY,iBAAiB,+CAAI;AAC7C;AACA,CAAC;;;;;;;;;;;;;ACdD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqC;AACJ;;AAE1B;AACP,SAAS,mDAAK;AACd;;AAEO;AACP,SAAS,mDAAK,gCAAgC,mDAAQ;AACtD;;AAEO;AACP,SAAS,mDAAK;AACd;AACA;AACA;AACA;;AAEO;AACP,SAAS,mDAAK;AACd;AACA;AACA;AACA;;AAEO;AACP,SAAS,mDAAK;AACd;AACA,IAAI,mDAAK;AACT;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+C;AACV;AAC8C;AACvC;AACE;AACW;AACxB;;AAElB;AACf,cAAc,SAAS;AACvB,iBAAiB,8DAAU;AAC3B,kBAAkB,qEAAiB;AACnC,eAAe,kEAAc;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,qBAAqB,gDAAK;AACrC;AACA,eAAe,4BAA4B,+CAAI;AAC/C;AACA,eAAe,4BAA4B,gDAAK;AAChD,cAAc,mEAAO;;AAErB;AACA;AACA,YAAY,wDAAM,GAAG,UAAU,UAAU,UAAU;AACnD,WAAW;AACX;AACA,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;;AAEzC,SAAS,2DAAS,CAAC,yDAAQ,EAAE,2DAAc,QAAQ,gDAAK;AACxD,CAAC;;;;;;;;;;;;;ACtCD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuE;AAClC;AAC8C;AACvC;AACG;AACU;AACxB;;AAEjC,2BAA2B,+CAAI;AAC/B,gBAAgB,+CAAI;;AAEpB,8BAA8B,+CAAI;AAClC,gBAAgB,+CAAI;;AAEL;AACf,cAAc,SAAS;AACvB,iBAAiB,8DAAU;AAC3B,kBAAkB,mEAAO,CAAC,qEAAiB;AAC3C,eAAe,kEAAc;AAC7B,gBAAgB,0DAAM;AACtB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB,aAAa,OAAO,gDAAK;AACzB,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,mDAAK;;AAExC;AACA,mBAAmB;AACnB,wCAAwC;AACxC,YAAY,SAAS;AACrB,GAAG;AACH,kCAAkC;AAClC,sBAAsB;AACtB,YAAY;AACZ;;AAEA,0BAA0B,4BAA4B,+CAAI;;AAE1D;AACA,qBAAqB,mDAAK;;AAE1B,SAAS,2DAAS,CAAC,yDAAQ,EAAE,4DAAe,EAAE,0DAAe,EAAE,gDAAK;AACpE,+BAA+B,oCAAoC,gDAAK;AACxE;AACA,CAAC;;;;;;;;;;;;;AC3DD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqC;AAC8C;AACvC;AACM;AACO;AACxB;;AAElB;AACf,cAAc,SAAS;AACvB,iBAAiB,8DAAU;AAC3B,kBAAkB,qEAAiB;AACnC,eAAe,kEAAc;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAO;AACpB,cAAc,mEAAO;AACrB,KAAK;AACL,YAAY,wDAAM,GAAG;AACrB,gBAAgB,SAAS;AACzB,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;;AAEzC,SAAS,2DAAS,CAAC,yDAAQ,EAAE,+DAAkB;AAC/C,CAAC;;;;;;;;;;;;;AC/CD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGqB;AACkB;AACF;AACyB;AACN;AACoB;AACL;;AAEvE,YAAY;;AAEZ;AACA,+DAAe;AACf;AACA;AACA;AACA,eAAe,0DAAM;AACrB,qBAAqB,0DAAM;AAC3B,kBAAkB,cAAc;AAChC,iBAAiB;AACjB,2CAA2C,iDAAM,oBAAoB,+CAAI;AACzE,yBAAyB,mEAAO,YAAY,OAAO,+CAAI,CAAC;AACxD,yBAAyB,gDAAK;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU,iDAAiD;AAC3D;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,IAAI,qEAAS;AACb,IAAI,qEAAS;AACb;AACA,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;;AAEzC,EAAE,uDAAY;AACd;AACA,sCAAsC,2BAA2B,gDAAK;AACtE;AACA,GAAG;;AAEH,YAAY,2DAAS;AACrB,IAAI,2DAAU,EAAE,6DAAgB;AAChC,IAAI,gDAAK;AACT;AACA;;AAEA;AACA,gBAAgB,mEAAO;AACvB,uBAAuB,0DAAM;;AAE7B;AACA;AACA;AACA,UAAU,qCAAqC;AAC/C;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB,aAAa,OAAO,gDAAK,CAAC;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;;AAEzC,WAAW,2DAAS;AACpB,IAAI,yDAAQ,EAAE,4DAAe,EAAE,0DAAe;AAC9C,IAAI,gDAAK;AACT;;AAEA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA,uBAAuB,mEAAO;AAC9B;AACA,KAAK;AACL,WAAW,cAAc;AACzB;AACA,gBAAgB,SAAS;AACzB,YAAY,aAAa;AACzB,eAAe;AACf;AACA;;AAEA;AACA,MAAM,8DAAU;AAChB;AACA;AACA;AACA,YAAY;AACZ,GAAG;AACH;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA,aAAa,QAAQ,uCAAuC,gDAAK;;AAEjE,SAAS,4DAAU;AACnB,IAAI,sDAAS;AACb,IAAI,wEAAY,kBAAkB,+CAAI;AACtC;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA,aAAa,0DAAM;AACnB,cAAc,yBAAyB;AACvC,aAAa,gEAAY;AACzB;AACA,cAAc,0DAAM;AACpB,cAAc,0DAAM;AACpB;AACA;AACA;;;;;;;;;;;;;AC7JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACP;AACD;AACQ;AACG;AACU;;AAE1C;AACf,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA,UAAU,QAAQ,kBAAkB;AACpC,UAAU,QAAQ;AAClB,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB,YAAY,mEAAO;AACnB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;AACzC,EAAE,qEAAS,wBAAwB,0DAAM;;AAEzC,SAAS,2DAAS,CAAC,yDAAQ,EAAE,4DAAe,EAAE,0DAAe;AAC7D,CAAC;;;;;;;;;;;;;ACrCD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAG4B;AAC0B;AACiB;AACJ;AAC6B;AAChD;AACF;AACoC;AACvC;AACZ;AACsB;AACK;AACG;AAC1B;AACkB;AACrB;;AAEhC,+DAAe;AACf;AACA,gCAAgC;AAChC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,8DAAY,wBAAwB,qBAAqB,EAAE;AACzE,cAAc,wDAAK;;AAEnB;AACA;;AAEA;AACA;AACA,YAAY,iEAAM;AAClB;AACA;AACA;AACA,YAAY,kDAAG,WAAW,4DAAO;;AAEjC;AACA,iBAAiB,yEAAY;AAC7B,kDAAkD,sDAAI;AACtD;;AAEA;AACA,iBAAiB,QAAQ,IAAI,SAAS,MAAM;;AAE5C;AACA,aAAa,kDAAG,WAAW,kEAAa;AACxC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,eAAe,0DAAQ;AACvB;AACA,MAAM,uEAAc;AACpB,MAAM,8EAAoB;AAC1B;AACA;AACA;AACA,0BAA0B,oDAAK,CAAC,yEAAc;AAC9C;AACA;;AAEA;AACA,oBAAoB,0DAAQ;AAC5B;AACA,MAAM,gFAAsB;AAC5B,MAAM,8EAAoB;AAC1B;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,uFAAkB;AACpC;AACA,MAAM,4EAAkB,iCAAiC,oDAAK;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,mEAAU,CAAC,6DAAe;AAC9B;AACA;;AAEA;AACA;AACA,kBAAkB,oEAAW;AAC7B;;AAEA;AACA,UAAU,mEAAU,CAAC,wDAAU;AAC/B;;AAEA;AACA,SAAS,qDAAS;AAClB,CAAC;;AAED;AACA,0BAA0B,yDAAO;;AAEjC;AACA,WAAW,4DAAY,cAAc,0DAAQ;AAC7C,QAAQ,8DAAc,cAAc,0DAAQ;AAC5C,QAAQ,yDAAO;AACf;;AAEA,kBAAkB,0DAAQ;AAC1B,MAAM,8DAAc,cAAc,0DAAQ;AAC1C,MAAM,0DAAQ;AACd;;AAEA;AACA,SAAS,8DAAY;AACrB;AACA,GAAG;AACH;;AAEA;AACA,gBAAgB,SAAS;;AAEzB,EAAE,sEAAS,yBAAyB,iEAAM;AAC1C,EAAE,sEAAS,yBAAyB,iEAAM;AAC1C,EAAE,sEAAS,yBAAyB,iEAAM;AAC1C,EAAE,sEAAS,yBAAyB,iEAAM;AAC1C,EAAE,sEAAS,yBAAyB,iEAAM;AAC1C,EAAE,sEAAS,yBAAyB,iEAAM;AAC1C,EAAE,sEAAS,yBAAyB,iEAAM;AAC1C,EAAE,sEAAS;;AAEX;AACA;;AAEA;AACA;;AAEA,gBAAgB,sEAAW;;AAE3B;AACA,MAAM,sEAAW;;AAEjB,iDAAiD,iEAAe;;AAEhE;AACA,qBAAqB,oDAAK,gBAAgB,oDAAK;AAC/C,MAAM,oDAAK;AACX;;AAEA,SAAS,2DAAe;AACxB;;AAEA;AACA,SAAS,sEAAW,wBAAwB,mEAAQ;AACpD;;;;;;;;;;;;;ACvKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACY;AACE;AACT;AACE;AACI;AACR;AACS;AACiB;AACf;AACL;AACJ;AACN;AACM;AACW;AAChB;AACoF;;AAErG;AACf,aAAa,2DAAO;AACpB,4BAA4B,0DAAS;AACrC;AACA,uCAAuC,sDAAS,aAAa,sDAAS;AACtE,wBAAwB,qDAAQ;AAChC;AACA;AACA;;AAEA;AACA,UAAU,2DAAS;;AAEnB;AACA,iBAAiB,6DAAQ;AACzB,oCAAoC,uDAAQ;AAC5C;AACA;AACA,GAAG;AACH,YAAY,kDAAG;;AAEf;AACA,yBAAyB,4DAAO,EAAE,eAAe;;AAEjD;AACA,iBAAiB,yDAAI;AACrB,iBAAiB,iEAAU;AAC3B,iBAAiB,kEAAW;AAC5B,iBAAiB,2DAAI;AACrB,kBAAkB,eAAe;AACjC;AACA;AACA;AACA,iBAAiB,kDAAG;AACpB,GAAG;AACH,YAAY,kDAAG;;AAEf;AACA,iBAAiB,2DAAM;AACvB,IAAI,oEAAQ,mDAAmD,eAAe;AAC9E;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,2DAAc;AAC7B;AACA,QAAQ,wDAAK;AACb;AACA,wBAAwB,kDAAG;AAC3B;AACA,KAAK;AACL;;AAEA;AACA;AACA,mBAAmB,8DAAS;AAC5B;AACA,aAAa,kDAAG;AAChB,KAAK;AACL;;AAEA,cAAc,kDAAG;;AAEjB;AACA;AACA,uBAAuB,+DAAU;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB,kDAAG;AACnB;;AAEA;AACA,oBAAoB,0DAAK,EAAE,6CAA6C;AACxE,aAAa,kDAAG;;AAEhB;AACA;AACA;AACA,iBAAiB,uBAAuB,WAAW,uBAAuB;;AAE1E;AACA,YAAY,4DAAU;AACtB,mBAAmB,8DAAY;AAC/B,UAAU,sDAAS,cAAc;AACjC;;AAEA,iBAAiB,8BAA8B,iBAAiB;AAChE;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,2DAAM,EAAE,gBAAgB;AAC7C,oBAAoB,0DAAK,EAAE,OAAO,kDAAG,SAAS;;AAE9C;AACA;AACA;AACA;AACA,4BAA4B,mDAAS;AACrC;AACA;AACA,QAAQ,wDAAK;AACb;AACA,MAAM,yDAAY;AAClB,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,YAAY,uDAAQ;AACpB;AACA;;AAEA;AACA,oCAAoC,qBAAqB;AACzD;;AAEA;AACA;AACA,4BAA4B,uDAAQ;AACpC;AACA;AACA;;AAEA,SAAS,kDAAG,WAAW,4DAAO;AAC9B;;;;;;;;;;;;;AC9JA;AAAA;AAAgD;;AAEjC;AACf;;AAEA,MAAM,0DAAQ;AACd;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,oDAAoD,eAAe;AACnE;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA,SAAS,0DAAQ;AACjB;AACA,MAAM,6DAAW;AACjB,C;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACX;AACU;AACM;;AAE/C,+DAAe;AACf;;AAEA;AACA;AACA,cAAc,iDAAG,WAAW,2DAAO,UAAU;AAC7C;;AAEA;AACA;AACA,gBAAgB,uDAAK;;AAErB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,aAAa,0DAAc,CAAC,wDAAM;AAClC;AACA,mBAAmB,uDAAK;AACxB,SAAS;AACT;AACA;AACA,2BAA2B,iDAAG;AAC9B,OAAO;AACP,iBAAiB,iDAAG;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;AACA,MAAM,iDAAG;AACT,C;;;;;;;;;;;;ACtDA;AAAA;AAA0B;;AAEX;AACf;AACA;AACA;AACA,8BAA8B,qDAAI;AAClC;AACA;AACA,CAAC;;;;;;;;;;;;;ACTD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACF;AACQ;AACT;AACkC;AACpB;;AAE9B;AACf;AACA;AACA,aAAa,wDAAU;AACvB;;AAEA;AACA,IAAI,uDAAK,8BAA8B,6DAAW;AAClD;AACA;AACA,IAAI,uDAAK,uCAAuC,6DAAW;AAC3D;;AAEA;AACA,mBAAmB,4DAAQ;AAC3B;AACA;AACA,KAAK;AACL,GAAG;AACH,mBAAmB,yDAAK;AACxB;AACA,aAAa,iDAAG;AAChB;AACA,KAAK;AACL,GAAG;AACH,IAAI,uDAAK,2CAA2C,6DAAW;AAC/D;;AAEA;AACA;AACA,wBAAwB,2DAAO;AAC/B,wBAAwB,yDAAK,EAAE,OAAO,iDAAG,SAAS;AAClD,6BAA6B,kDAAS;AACtC;;AAEA;AACA;AACA,cAAc,qDAAS;AACvB;AACA,CAAC;;;;;;;;;;;;;AC9CD;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJP;AAAA;AAAA;AAAsC;AACM;;AAE7B;AACf;AACA;AACA;AACA,oBAAoB,oDAAS,GAAG,gDAAS,YAAY,+CAAQ;AAC7D,CAAC;;;;;;;;;;;;;ACRD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACnBP;AAAA;AAAA;AAAgC;AACiB;;AAElC;AACf,qBAAqB,4DAAQ,EAAE,mBAAmB;AAClD;;AAEA,eAAe,yDAAK;AACpB;;AAEA;AACA;AACA,cAAc,qDAAS;AACvB;AACA,CAAC;;;;;;;;;;;;;ACdD;AAAA;AAAmC;;AAEpB;AACf;AACA,SAAS,0DAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,UAAU;AACV;;;;;;;;;;;;;ACpBA;AAAA;AAAgE;;AAEjD;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA,SAAS,yDAAO,yBAAyB,uCAAuC,EAAE;AAClF,OAAO,0DAAQ;AACf;AACA;AACA,MAAM,uDAAK,oCAAoC,6DAAW;AAC1D;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACiD;AACD;;AAEzF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,uDAAK;AACpB,oBAAoB,uDAAK;AACzB,sBAAsB,uDAAK;AAC3B,mBAAmB,uDAAK;;AAEjB;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;;AAEA;AACA,IAAI,uDAAK,+BAA+B,6DAAW;AACnD;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,0DAAQ;AAClB;AACA,MAAM,uDAAK,0BAA0B,6DAAW;AAChD;;AAEA;AACA;AACA;AACA,yBAAyB,+BAA+B,EAAE;AAC1D;;AAEA;AACA,EAAE,uDAAK,6BAA6B,6DAAW;AAC/C;;AAEA;;AAEA;AACA;AACA;AACA,MAAM,uDAAK;AACX;AACA,WAAW;AACX;;AAEA;AACA,OAAO,yDAAO;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,0DAAQ,OAAO;AAC3B,aAAa,yDAAO;AACpB;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,2DAAO,GAAG;;AAEvB,MAAM,yDAAO;AACb,kBAAkB;AAClB,GAAG;AACH,4BAA4B,6DAAW;AACvC;AACA;AACA,qCAAqC,yDAAK,GAAG;AAC7C,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,gBAAgB,6DAAS;AACzB,aAAa,iDAAW;AACxB;AACA;AACA,GAAG;;AAEH;AACA,gBAAgB,2DAAO,EAAE,OAAO,iDAAG,IAAI;;AAEvC;AACA,gBAAgB,0DAAM;AACtB,WAAW,iDAAW;AACtB;AACA,WAAW,iDAAG;AACd,GAAG;;AAEH,SAAS,iDAAG;AACZ;;AAEA;AACA;AACA;AACA,UAAU,0DAAQ;AAClB,mBAAmB;AACnB,KAAK;AACL,MAAM,uDAAK;AACX,KAAK;AACL,MAAM,uDAAK;AACX,KAAK;AACL,MAAM,uDAAK;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,SAAS,iDAAG,WAAW,+DAAW,EAAE,eAAe;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,SAAS,iDAAG,WAAW,+DAAW,EAAE,iBAAiB;AACrD;;AAEA;;AAEA;AACA,gBAAgB,0DAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG,UAAU,0DAAQ;AACrB;AACA,aAAa,wDAAM,GAAG,SAAS,qBAAqB;AACpD;AACA,KAAK;AACL,mBAAmB,gBAAgB;AACnC,KAAK;AACL;AACA,eAAe,iBAAiB;AAChC,YAAY,iBAAiB;AAC7B,KAAK;AACL,MAAM,uDAAK,sCAAsC,6DAAW;AAC5D;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,mCAAmC,yDAAO;AAC7C;AACA,GAAG,WAAW,yDAAO;AACrB,IAAI,uDAAK,8BAA8B,6DAAW;AAClD;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACtRA;AAAA;AAAA;AAA2C;AACR;;AAEpB;AACf;;AAEA;AACA,eAAe,2DAAe;AAC9B;AACA;AACA;;AAEA;AACA;AACA,MAAM,uDAAW;AACjB,KAAK;AACL;AACA,CAAC;;;;;;;;;;;;;ACjBD;AAAA;AAA6C;;AAE7C;AACA;;AAEA;AACA,EAAE,uDAAK,kCAAkC,6DAAW;AACpD;;AAEe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACzBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkD;AACJ;AACH;AACR;AACA;AACF;AACF;AACA;AACA;AACC;;AAEjB;AACf,gBAAgB,uDAAK;AACrB,eAAe,uDAAK;;AAEpB;AACA,IAAI,uDAAW;AACf,GAAG;;AAEH,EAAE,uDAAK;AACP,IAAI,2DAAe;AACnB,GAAG;;AAEH;AACA,IAAI,wDAAS;AACb,GAAG;;AAEH,EAAE,uDAAK;AACP,IAAI,qDAAS;AACb,GAAG;;AAEH;AACA,IAAI,yDAAU;AACd,GAAG;;AAEH;AACA,IAAI,+DAAkB;AACtB,GAAG;;AAEH,EAAE,uDAAK;AACP,IAAI,qDAAS;AACb,GAAG;;AAEH,EAAE,uDAAK;AACP,IAAI,qDAAS;AACb,GAAG;;AAEH,EAAE,uDAAK;AACP,IAAI,uDAAW;AACf,GAAG;;AAEH;AACA,IAAI,sDAAU;AACd;;AAEA;AACA;AACA,CAAC;;;;;;;;;;;;;ACzDD;AAAA;AAAA;AAAA;AAAA;AAA2C;AACP;AACgB;;AAEpD;;AAEe;AACf;AACA;AACA;AACA,MAAM,uDAAK,oCAAoC,6DAAW;;AAE1D;AACA;;AAEA;AACA,qBAAqB,2CAAK,GAAG,0CAAI,cAAc,0CAAI;AACnD;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,gCAAgC,YAAY;AAC5C;AACA;;AAEA;AACA;AACA,gCAAgC,WAAW;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd,GAAG;AACH;AACA;;AAEA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM,uDAAK,sDAAsD,6DAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,uDAAK;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,2CAAK;AAC7B;AACA;AACA;AACA;AACA,mBAAmB,2DAAe;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAG4B;AACgB;AACD;AACZ;AACY;AACH;AACgB;AAC5B;AACU;AACkB;;AAExD;AACA,6BAA6B,uDAAK;AAClC,2BAA2B,qDAAG;AAC9B;AACA;;AAEA;AACA;AACA,EAAE,6DAAW,CAAC,sDAAI,GAAG,6DAAW,CAAC,uDAAK,GAAG,6DAAW,CAAC,wDAAM;AAC3D;;AAEA;AACA;AACA,wBAAwB,uDAAK;AAC7B,wBAAwB,sDAAI;AAC5B;AACA;;AAEe;AACf,SAAS,0DAAQ,UAAU,WAAW;;AAEtC;AACA,eAAe,wDAAM,GAAG;AACxB;;AAEA;AACA;AACA,YAAY,iEAAM;AAClB;AACA,YAAY,iDAAG,WAAW,2DAAO;;AAEjC;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,qDAAS;AAClB,CAAC;;AAED;AACA,cAAc,SAAS;AACvB;AACA,eAAe,iEAAM;AACrB,eAAe,iEAAM;AACrB,yBAAyB,sDAAI,eAAe,qDAAG;AAC/C,+BAA+B,qDAAG,eAAe,wDAAM;AACvD,gBAAgB,yCAAyC;AACzD;;AAEA;AACA,SAAS,sBAAsB;;AAE/B;AACA;AACA,oBAAoB,QAAQ;AAC5B,OAAO,QAAQ;;AAEf;AACA;AACA;AACA,KAAK;AACL;AACA,gBAAgB,SAAS;AACzB,cAAc,mEAAO;AACrB,cAAc,mEAAO;AACrB,cAAc,mEAAO;AACrB,eAAe,cAAc;AAC7B,eAAe;AACf,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB,qDAAG,GAAG,wDAAM,GAAG,qDAAG;AAC1D,GAAG;AACH;AACA;AACA,mBAAmB;AACnB,sBAAsB,OAAO,wDAAM;AACnC;;AAEA,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;AACxC,EAAE,qEAAS,uBAAuB,iEAAM;;AAExC,SAAS,kEAAS,CAAC,yDAAQ,EAAE,sDAAS,gBAAgB,iEAAe;AACrE;AACA;;;;;;;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACY;AAClB;AACI;AAC+B;;AAExE;AACA;AACA;AACA,+DAAe;AACf,YAAY,gEAAU;AACtB,YAAY,uDAAK,mCAAmC,6DAAW;;AAE/D,UAAU,mDAAK;AACf;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,MAAM,uDAAK,uBAAuB,6DAAW;AAC7C,6BAA6B,6DAAW;AACxC;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA,uBAAuB,sDAAQ;AAC/B,6BAA6B,sCAAsC,EAAE;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAM,sDAAQ;AACd,0BAA0B,uDAAK;AAC/B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,uCAAuC,sDAAQ;AAC/C,0BAA0B,2DAAe;AACzC,0BAA0B,iDAAG;AAC7B,2BAA2B,sDAAQ;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,0DAAQ;AACf,IAAI,uDAAK;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,yDAAO,UAAU;AAC1B,MAAM,uDAAK,oDAAoD,6DAAW;AAC1E;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA,qCAAqC,aAAa,OAAO;AACzD;AACA;AACA;AACA;AACA,aAAa,uDAAK,6BAA6B,6DAAW;;AAE1D;AACA,WAAW,wDAAM;AACjB,SAAS,iDAAG,WAAW,0DAAM;AAC7B;;AAEA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;AC3JA;AAAA;AAAA;AAA2C;AACV;;AAElB;AACf;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAQ;AAC7B;;AAEA;AACA;AACA;AACA,0BAA0B,+BAA+B,EAAE;AAC3D;AACA;;AAEA,SAAS,2DAAe;AACxB;AACA;AACA,CAAC;;;;;;;;;;;;;ACtBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACR;AACC;AACS;AACyB;;AAEtE,uDAAuD;;AAExC;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,uDAAK;AACT;;AAEA;AACA,MAAM,0DAAQ;AACd,aAAa,oEAAQ,8BAA8B,2CAAK,GAAG,0CAAI;AAC/D;;AAEA;AACA,WAAW,uDAAK;AAChB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,sCAAsC,cAAc;AACpD;;AAEA;AACA,gBAAgB,uDAAK;AACrB,gCAAgC,6DAAW;AAC3C;;AAEA;AACA,UAAU,0DAAQ,WAAW,2DAAe;AAC5C,4BAA4B,2DAAe;AAC3C;AACA;AACA;AACA,kBAAkB;AAClB;AACA,MAAM,uDAAK;;AAEX;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA,oBAAoB,wDAAM;AAC1B,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,YAAY,uDAAW;AACvB;AACA;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AACF;AACF;AACJ;AAC6B;AAChB;AACJ;AACF;AACD;AAC2C;AACzC;;AAEvC,cAAc,wDAAK;;AAEJ;AACf;AACA;;AAEA;AACA;AACA,SAAS,iDAAG,wBAAwB,sDAAQ;AAC5C;AACA;AACA,6BAA6B,wDAAY;AACzC,8BAA8B,yDAAa;;AAE3C,EAAE,wDAAK;AACP,0BAA0B,uDAAW;AACrC,GAAG;;AAEH;AACA,oBAAoB,2DAAO;;AAE3B;AACA,WAAW,wEAAY;AACvB,YAAY,KAAK,SAAS,MAAM,SAAS,EAAE;AAC3C,aAAa,SAAS,gBAAgB,WAAW,iBAAiB;AAClE,GAAG;;AAEH,qBAAqB,0DAAM;AAC3B,IAAI,oEAAQ,SAAS,0DAAS,EAAE,sDAAS,sBAAsB,OAAO,iDAAG,QAAQ;AACjF;;AAEA;AACA,qBAAqB,8DAAU;AAC/B;AACA;AACA;AACA;AACA,kBAAkB,iDAAG;AACrB,GAAG;AACH;;AAEA;AACA,kBAAkB,iDAAG,UAAU,iDAAG;AAClC,EAAE,qDAAS;AACX;;AAEA;AACA,iBAAiB,yDAAK,EAAE,mBAAmB,iDAAG,SAAS;AACvD,iBAAiB,0DAAM,EAAE,OAAO,iDAAG,KAAK;AACxC,iBAAiB,yDAAK,EAAE,OAAO,iDAAG,KAAK;;AAEvC;AACA,4BAA4B,kDAAS;;AAErC;AACA;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6B;;AAE7B;AACA;AACA,WAAW,mDAAK;AAChB;AACA;;AAEO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;;AAE5B;AACP;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEA;;AAEO;AACP,aAAa;AACb;AACA;AACA;AACA;;AAEO;AACP;AACA,wBAAwB,sBAAsB;AAC9C;;AAEO;AACP,iBAAiB,2BAA2B,IAAI;AAChD;;AAEO;;AAEA;AACP,UAAU;AACV;;AAEO;AACP,aAAa;AACb;AACA;AACA;;AAEA;;AAEO;;AAEA;;AAEA;AACP,UAAU,0DAAQ;AAClB;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;;AAEO;;AAEA;;AAEA;AACP;AACA;;AAEO;AACP;AACA,MAAM,0DAAQ;AACd;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;AC1FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAI2B;;;;;;;;;;;;;ACJ3B;AAAA;AAAA;AAAA;AAAA;AAiBgB;;AAEhB,kBAAkB,sDAAO;;AAElB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa,sDAAO;;AAEpB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA,wBAAwB,gDAAS;AACjC,wBAAwB,mDAAY;AACpC,wBAAwB,4DAAqB;AAC7C,wBAAwB,8DAAuB;AAC/C,wBAAwB,wDAAiB;AACzC,wBAAwB,wDAAiB;AACzC,wBAAwB,0DAAmB;AAC3C,wBAAwB,yDAAkB;AAC1C,wBAAwB,kDAAW;AACnC,wBAAwB,kDAAW;AACnC,wBAAwB,kDAAW;AACnC,wBAAwB,uDAAgB;AACxC,wBAAwB,sDAAe;AACvC,wBAAwB,uDAAgB;AACxC,wBAAwB,4DAAqB;AAC7C;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACC;AACM;;;;;;;;;;;;;ACFvD;AAAA;AAAA;AAA2C;AACK;;AAEhD;AACA;AACA;AACA;AACA;AACe;AACf;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA,QAAQ,uDAAS;AACjB;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD;AACrD,gDAAgD,iBAAiB,EAAE;AACnE;AACA;AACA,GAAG;AACH;AACA,kDAAkD,MAAM,EAAE;AAC1D;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,qDAAqD,2DAAa;AAClE,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,YAAY,+CAAQ;AACpB,YAAY,+CAAQ;AACpB;;;;;;;;;;;;;AC9HA;AAAA;AAAA;AAAA;AAA6E;AAC1C;AACA;;AAEnC;AACA;AACA;AACe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,yDAAa;AACjB,GAAG;;AAEH;AACA;AACA,IAAI,yEAAuB;AAC3B,GAAG;;AAEH;AACA;AACA,IAAI,uDAAW;AACf,GAAG;;AAEH;AACA;AACA,IAAI,uDAAW;AACf,GAAG;;AAEH;AACA,CAAC;;;;;;;;;;;;;ACzCD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACe;AACf;AACA,gCAAgC;AAChC,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgD;AACL;AACT;AACF;;AAEhC;AACA;AACA;AACe;AACf,MAAM,wDAAU;AAChB;AACA,oBAAoB,sEAAkB;AACtC,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACO;AACP;AACA;AACA;AACA,MAAM,uDAAK;AACX;AACA,aAAa,2DAAe;AAC5B;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;AAC4B;AAC7B;AACmD;;AAEzF;AACA;AACA;AACe;AACf;AACA;;AAEA;AACA;;AAEA,kBAAkB,yDAAO;AACzB,+BAA+B,uCAAuC,EAAE;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,0DAAQ;;AAExB,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG,qCAAqC;AACxC,GAAG,gCAAgC;AACnC,GAAG,uCAAuC;AAC1C,GAAG,kCAAkC;AACrC,GAAG,mCAAmC;AACtC,GAAG,oCAAoC;AACvC,GAAG,oCAAoC;AACvC,GAAG,oCAAoC;AACvC,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,uDAAK;AACjC;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,oBAAoB,0DAAQ,CAAC,uEAAmB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAG;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uDAAK;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,uDAAK;AACf,mCAAmC,qDAAO;AAC1C,OAAO;AACP,mCAAmC,yDAAO;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA,mBAAmB,0DAAQ,CAAC,oEAAgB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,qDAAO;AAChB;;;;;;;;;;;;;AC1IA;AAAA;AAAA;AAAA;AAAiC;;AAEjC,YAAY;;AAEL;AACP;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA,GAAG;;AAEH,wBAAwB;AACxB;AACA;AACA,4BAA4B,gDAAM;AAClC;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAA6C;AACb;;AAEhC;AACA;AACA;AACe;AACf,qCAAqC,mEAAe;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI,uDAAK;AACT;;AAEA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC3CD;AAAA;AAAA;AAAA;AAAgE;AACrB;AACD;;AAE1C;AACA;AACA;AACe;AACf,cAAc,0DAAQ;AACtB;AACA;AACA;AACA;;AAEA,eAAe,uDAAK;;AAEpB;AACA,aAAa,mEAAe;AAC5B,GAAG;AACH;AACA;;AAEA;AACA;AACA,eAAe,2DAAe;AAC9B;AACA,aAAa,qEAAiB;AAC9B;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC9BD;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqD;AACP;AACiC;AACvB;AACK;AACtB;;;;;;;;;;;;;ACLvC;AAAe;AACf;AACA;AACA,CAAC;;;;;;;;;;;;;ACHD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACL;;AAE7B;AACP;AACA,aAAa,sDAAI;AACjB,sBAAsB,uCAAuC;AAC7D;;AAEO;AACP;AACA,sCAAsC,0DAAQ;AAC9C;AACA,qBAAqB,0BAA0B;AAC/C;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;;AAEO;AACP,eAAe,2CAAC;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,wCAAwC,EAAE;AAChE;AACA;;;;;;;;;;;;;AClCA;AAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACjBD;AAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC9BD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoC;AACoB;AACP;;AAE1C;AACP,cAAc,6DAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAS;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sDAAQ,qBAAqB,yBAAyB,EAAE;AACzE;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,4DAAW;AAC/B,sBAAsB,4DAAW;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;AC3LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACK;AACN;;AAE/B;AACA;;AAEA;AACA,kCAAkC,WAAW,EAAE;AAC/C;;AAEO;AACP,eAAe,4DAAW;AAC1B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,sDAAI;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AA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AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACE;AACkD;AACnD;AACE;AACA;;AAEpB;AACf,EAAE,gDAAO;AACT;AACA;AACA;AACA;;AAEA,gBAAgB,0DAAQ,gBAAgB,gDAAO;;AAE/C;AACA;AACA,oCAAoC,yDAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA,SAAS,gDAAO;AAChB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mDAAM;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,gCAAgC;AAChC,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,sDAAS;AACxB;AACA,GAAG,mBAAmB,6DAAgB,aAAa,6DAAgB;AACnE,wCAAwC,6DAAgB;AACxD;;AAEA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,2DAAK;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAK;AAClB;AACA;;;;;;;;;;;;;ACzLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACJ;AACI;;AAEE;AACE;AACI;AACP;AACA;;AAEpB;AACf,EAAE,iDAAQ;AACV;AACA,oBAAoB,+CAAM;AAC1B;;AAEA,gBAAgB,0DAAQ,iBAAiB,iDAAQ;AACjD,WAAW,iDAAQ;AACnB,qBAAqB,+CAAM;;AAE3B;AACA,iBAAiB,0DAAM,OAAO;AAC9B;AACA,IAAI,0DAAQ;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE,mEAAM;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,oDAAK;AAClB,kBAAkB,iEAAI;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpHA;AAAA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AChBD;AAAA;AAAA;AAAA;AAA0B;AACS;;AAEpB;AACf,EAAE,6CAAI;AACN;AACA;;AAEA,0DAAQ,YAAY,6CAAI;;;;;;;;;;;;;ACRxB;AAAA;AAAA;AAAA;AAAA;AAAqC;AACQ;AACV;;AAEnC;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACe;AACf;AACA;AACA,iCAAiC,0DAAM;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,cAAc;AACzB;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY,OAAO;AACnB;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,iBAAiB;AACjB;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,uBAAuB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA,cAAc,2DAAS;AACvB;AACA;AACA,KAAK;AACL,uBAAuB,mBAAmB;AAC1C;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,WAAW,iEAAW;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7MA;AAAA;AAAA;AAA8B;;AAEf;AACf;AACA,oCAAoC,+CAAM;AAC1C;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAA8C;;AAE9C;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACe;AACf;AACA;AACA,qBAAqB,uDAAc;AACnC;;AAEA;;AAEA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,OAAO;AAClB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA,WAAW,OAAO;AAClB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,kBAAkB;;AAE1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,mCAAmC,UAAU,EAAE;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;;;;;;;;;;;;ACtLA;AAAA;AAAA;AAAA;AAAkC;AACC;;AAEpB;AACf;AACA,iCAAiC,0DAAM;AACvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,cAAc,yDAAK;AACnB;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,iCAAiC;;AAEjC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc;AACd,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,EAAE;AAChD;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;AC9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;AACG;AACyC;AACzC;;AAEpB;AACf,EAAE,gDAAO;AACT;AACA;AACA;AACA,GAAG;AACH;AACA,4CAA4C,6DAAgB;AAC5D,GAAG;AACH;;AAEA,gBAAgB,0DAAQ,aAAa,gDAAO;;AAE5C;AACA;AACA;AACA,4BAA4B,sDAAS;AACrC,4BAA4B,6DAAgB;AAC5C,4BAA4B,6DAAgB;AAC5C;AACA,0BAA0B,yDAAO;AACjC;AACA,yBAAyB,sDAAS;AAClC,yBAAyB,6DAAgB;AACzC,yBAAyB,6DAAgB;AACzC;AACA,SAAS,gDAAO;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACA;AACiC;AACrB;AACc;AACzB;AACA;AACQ;AACe;AACvB;;AAEnC,SAAS,0DAAQ;;AAEF;AACf,EAAE,iDAAQ;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,0DAAQ,cAAc,iDAAQ;AAC9C,WAAW,iDAAQ;;AAEnB;AACA;AACA,gBAAgB,0DAAQ;AACxB;AACA,IAAI,0DAAQ;AACZ;AACA,iBAAiB,0DAAQ;AACzB,IAAI,0DAAQ;AACZ;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAQ;AAC1B,gBAAgB,0DAAQ;AACxB;;AAEA;AACA,OAAO,0DAAO;AACd;AACA;AACA,6CAA6C;AAC7C,OAAO,IAAI,2DAAQ;;AAEnB,SAAS,0DAAO,2CAA2C,2DAAQ;AACnE;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAQ;AACZ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,0DAAQ;AACrC;AACA;;AAEA;AACA,6BAA6B,0DAAQ;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,0DAAQ;AACd;AACA;AACA;;AAEA;AACA;;AAEA,OAAO,0DAAQ;AACf;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,KAAK;AACrC,WAAW,0DAAQ;AACnB;AACA;AACA;AACA,EAAE,0DAAQ;AACV;;AAEA;AACA;;AAEA,OAAO,0DAAQ;AACf;;AAEA;AACA,WAAW,0DAAQ;AACnB;AACA,GAAG;AACH,WAAW,0DAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,KAAK;AAChC;AACA;;AAEA;AACA;AACA;AACA,aAAa,oDAAK;AAClB;;AAEA;AACA;AACA;AACA,sCAAsC,cAAc,EAAE;AACtD;AACA,8BAA8B;;AAE9B,oBAAoB;AACpB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,2BAA2B;AACnC;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,oDAAK;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,0DAAQ;AACvC;AACA;AACA;AACA;AACA,qCAAqC,8DAAI;AACzC,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,IAAI,yDAAK;AACT;;AAEA,EAAE,0DAAQ;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA,EAAE,yDAAK;AACP;AACA;AACA,GAAG;;AAEH;AACA,EAAE,0DAAQ;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2DAAS;AACpB;;AAEA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA,iBAAiB,2DAAS;AAC1B;AACA;AACA;;AAEA,iBAAiB,2DAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,YAAY,4DAAS;AACrB;AACA;AACA;AACA;;AAEA,gCAAgC,6DAAU;AAC1C,8BAA8B,2DAAQ;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,gEAAe,QAAQ,KAAK;AAC1C,WAAW,gEAAe;AAC1B;;AAEA;AACA,cAAc,6DAAU;AACxB;;AAEA;;AAEA,WAAW,uDAAM;AACjB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACA;AACE;AACU;AACc;AACzB;AACA;AACQ;AACe;AACvB;;AAEpB;AACf,EAAE,iDAAQ;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA,gBAAgB,0DAAQ,oBAAoB,iDAAQ;AACpD,WAAW,iDAAQ;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAQ;AAC1B,gBAAgB,0DAAQ;AACxB;;AAEA,WAAW,0DAAO;;AAElB;AACA;;AAEA;AACA,WAAW,0DAAO;AAClB;AACA;AACA,gCAAgC;AAChC,KAAK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ACA,0BAA0B,iEAAI;AAC9B;AACA;AACA,4BAA4B,mEAAM;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,yDAAK;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS,6DAAS;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU,6DAAS;AACnB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;AC/JF;AAAA;AAAA;AAAA;AAAoC;AACK;AACK;;AAE9C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,mEAAS;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,EAAE,yDAAK;AACP,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAAI;AAChB;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACzGF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwB;AACE;AACE;AACA;AACF;AACA;AACA;AACA;AACE;AACE;AACJ;AACE;;AA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CA;AACA;AACA;AACA;AACA,4BAA4B,yDAAM;AAClC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,sDAAW;AACjB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,yDAAK;AACP;AACA,0DAA0D;AAC1D,gBAAgB,4DAAS,gBAAgB;;AAEzC;AACA;;AAEA,mBAAmB,uDAAI;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,0BAA0B,yDAAM;;AAEhC,qBAAqB,iEAAI;AACzB;AACA;AACA,uBAAuB,mEAAM;AAC7B;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8DAAI;AACd,CAAC,EAAC;;;;;;;;;;;;;AC1IF;AAAA;AAAA;AAAA;AAAqC;AACM;AACS;;AAErC,iIAAiB,UAAU,kDAAK,EAAE,wDAAS,CAAC,EAAC;;;;;;;;;;;;;ACJ5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACE;AACR;AACE;AACY;;AAEpD;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,YAAY,uDAAc;AAC1B,YAAY,uDAAc;AAC1B,YAAY,sDAAa;AACzB;;AAEA;AACA,YAAY,oDAAW;AACvB,YAAY,0DAAiB;AAC7B,YAAY,mDAAU;AACtB;;AAEA;;AAEO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAO;AACA;;AAEP;;AAEA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAmBkB;;AAElB;AACA;AACA,WAAW,mDAAU;AACrB,GAAG;AACH;AACA,WAAW,yDAAgB;AAC3B,GAAG;AACH;AACA,WAAW,uDAAc;AACzB,GAAG;AACH;AACA,WAAW,oDAAW;AACtB;AACA;AACA,GAAG;AACH;AACA,WAAW,sDAAa;AACxB;AACA;AACA,GAAG;AACH;AACA,WAAW,0DAAiB;AAC5B;AACA;AACA,GAAG;AACH;AACA,WAAW,4DAAmB;AAC9B;AACA;AACA,GAAG;AACH;AACA,WAAW,wDAAe;AAC1B;AACA;AACA,GAAG;AACH;AACA,WAAW,8DAAqB;AAChC;AACA;AACA,GAAG;AACH;AACA,WAAW,4DAAmB;AAC9B;AACA;AACA,GAAG;AACH;AACA,WAAW,oDAAW;AACtB,GAAG;AACH;AACA,WAAW,0DAAiB;AAC5B,GAAG;AACH;AACA,gBAAgB,uDAAc;AAC9B,gBAAgB,uDAAc;AAC9B,GAAG;AACH;AACA,WAAW,qDAAY;AACvB,GAAG;AACH;AACA,WAAW,kDAAS;AACpB,GAAG;AACH;AACA,WAAW,uDAAc;AACzB,GAAG;AACH;AACA,WAAW,wDAAe;AAC1B;AACA;;AAEe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACtGA;AAAA;AACA,cAAc,8CAA8C;AAC5D;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,KAAK;AACnC,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AChDD;AAAA;AAA6B;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,oDAAI;;AAEzC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACtHD;AAAA;AAAuC;;AAEvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mCAAmC,KAAK;AACxC;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gCAAgC,OAAO;AACvC;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,YAAY,qDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,cAAc,mDAAM;AACpB;AACA;AACA;;;;;;;;;;;;;AC3TA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;AACE;;AAEe;AACH;;AAO1B;;AAElB,qBAAqB,oBAAoB;AACzC,qBAAqB,oBAAoB;AACzC,qBAAqB,wBAAwB;AAC7C,qBAAqB,uBAAuB;AAC5C,qBAAqB,yBAAyB;AAC9C,qBAAqB,0CAA0C;AAC/D,qBAAqB,2CAA2C;AAChE,qBAAqB,6BAA6B;AAClD,qBAAqB,2BAA2B;AAChD,qBAAqB,2BAA2B;AAChD,qBAAqB,8BAA8B;AACnD,qBAAqB,8BAA8B;AACnD,qBAAqB,+BAA+B;AACpD,qBAAqB,kCAAkC;AACvD,qBAAqB,2CAA2C;AAChE,qBAAqB,QAAQ,wDAAO,yBAAyB;;AAE7D,kBAAkB,oDAAM;AACxB;AACA,kBAAkB,qDAAO;AACzB,kBAAkB,qDAAO;AACzB,kBAAkB,qDAAO;AACzB,kBAAkB,0DAAO;AACzB,kBAAkB,uDAAS;AAC3B,kBAAkB,sDAAQ;;AAEnB;AACP;AACA;;AAEO;AACP;AACA;AACA;AACA,WAAW,uDAAM;AACjB;AACA;;AAEO;AACP;AACA;AACA,yBAAyB,uDAAM;AAC/B;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAgC;AACE;;AAElC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB,sDAAS;AAC1B;AACA;AACA,QAAQ,uDAAU;AAClB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5GA;AAAA;AAA6B;;AAE7B;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,oDAAI;;AAEhD,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACpHD;AAAA;AAAqC;;AAEtB;AACf;;AAEA;AACA;;AAEA,MAAM,4DAAU;AAChB;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AChBD;AAAA;AAAkC;;AAEnB;AACf;AACA,IAAI,yDAAQ;AACZ;AACA,CAAC;;;;;;;;;;;;;ACND;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0B;AACI;AACC;;AAExB;AACP;AACA,IAAI,oDAAK;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB,qDAAI;AACvB;AACA;;AAEA,qBAAqB,uDAAM;AAC3B;AACA;AACA;;;;;;;;;;;;;ACnCA;AAAA;AAA4B;;AAEb;AACf;AACA;AACA;AACA,wBAAwB,sDAAK;AAC7B;AACA,GAAG;AACH;AACA;AACA,CAAC;;;;;;;;;;;;;ACXD;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACjBD;AAAA;AAAA;AAAA;AAAA;AAAmC;;AAEnC,2BAA2B,aAAa;;AAEjC;AACP;;AAEA;AACA;AACA;;AAEA,WAAW,wDAAS;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;AC1CA;AAAA;AACA;AACA;;AAEA;;AAEe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC9BD;AAAA;AAA4B;;AAE5B;;AAEe;AACf;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B,sDAAK;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;;;;;;;;;;;AC3BD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA,QAAQ,KAAK;AACb;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACO;;AAE7C;;AAEO;AACP;AACA;AACA;AACA,OAAO,0DAAQ,OAAO,0DAAQ;AAC9B,oBAAoB,0DAAQ,QAAQ,0DAAQ;AAC5C;AACA;AACA;;AAEO;AACP,oBAAoB,2DAAS,KAAK,2DAAS;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,yBAAyB,QAAQ;AACjC;AACA;;AAEA,yBAAyB,QAAQ;AACjC;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;AAEA;;AAEA;;;;;;;;;;;;;ACzBP;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC9CA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACND;AAAA;AAAA;AAAmC;AACP;;AAEb;AACf;AACA;;AAEA,sBAAsB,oDAAK;AAC3B,QAAQ,sDAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACnBD;AAAA;AAAA;AAAA;AAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,gEAAS;AACrB;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAqC;;AAErC;;AAEO;AACP;AACA;;AAEe;AACf;AACA;AACA;AACA,qDAAqD,OAAO;;AAE5D,MAAM,4DAAU;AAChB;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACtBD;AAAe;AACf;AACA;AACA;AACA,CAAC,E;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;;;;;;;;;;;;ACdP;AAAe;AACf;AACA,C;;;;;;;;;;;;ACFA;AAAA;AAAoC;;AAErB;AACf,SAAS,0DAAS;AAClB,C;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACO;AACP;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmC;;AAEnC;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA,8BAA8B,0DAAM;AACpC;AACA;;AAEO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEO;AACP;;AAEA;AACA;;AAEA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;;AAEA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;;AAEA,2BAA2B,KAAK;AAChC;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA,sBAAsB,UAAU;AAChC;AACA;;AAEA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACgB;AACJ;AACN;AACQ;AACR;AACQ;AACF;AACE;;;;;;;;;;;;;ACRvD;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,+BAA+B,yBAAyB;AACxD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,cAAc;;AAEvD;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACrDD;AAAA;AAAA;AAAA;AAAgC;AACA;AACa;;AAE9B;AACf;;AAEA,eAAe,wDAAO;AACtB;AACA;AACA;;AAEA,wBAAwB,KAAK;AAC7B,kBAAkB,KAAK;AACvB,qBAAqB,sDAAM;AAC3B;AACA;AACA;;AAEA;AACA,IAAI,yDAAQ,SAAS,kDAAS;AAC9B,IAAI,yDAAQ;AACZ;AACA,CAAC;;;;;;;;;;;;;ACvBD;AAAA;AAAgC;;AAEjB;AACf;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,8BAA8B,sDAAM;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACjDD;AAAA;AAAA;AAAA;AAAA;AAAgC;AACI;AACJ;AACE;;AAElC;AACe;AACf,eAAe,uDAAQ;AACvB,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,sDAAM;AAC5B;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,UAAU,0DAAS;AACnB;AACA,mCAAmC,yDAAQ;AAC3C;;;;;;;;;;;;;AC5DA;AAAA;AAAgC;;AAEjB;AACf,eAAe;;AAEf;AACA;AACA,aAAa,KAAK,OAAO,0CAA0C;AACnE,aAAa,KAAK,OAAO,aAAa;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,sDAAM;AAClB;AACA;AACA;;AAEA;AACA,UAAU,OAAO;AACjB,kBAAkB,cAAc,OAAO;AACvC;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,KAAK;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACnED;AAAA;AAAgC;;AAEjB;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sDAAM;AAChB,UAAU,sDAAM;AAChB;AACA,KAAK;AACL,4CAA4C;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AAC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AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,uDAAK,CAAC,gEAAc;AACrC;AACA,UAAU,KAAK;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAK;AACpB;AACA,gBAAgB,8DAAY;AAC5B;AACA;AACA;AACA,GAAG;AACH,iCAAiC,oEAAQ;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,IAAI,uDAAK;AACT;;AAEA,WAAW,KAAK;AAChB;AACA;;AAEA;AACA,MAAM,uDAAK;AACX;AACA,YAAY,8DAAY;AACxB,cAAc,sEAAW;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,wEAAa;AACxB;;AAEA;AACA,WAAW,0EAAe;AAC1B,GAAG;;AAEH,YAAY;AACZ;;AAEA;;AAEA,oBAAoB,oEAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;;AAEA;AACA,oBAAoB,wDAAU;AAC9B;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;;AAEZ,0BAA0B,KAAK;AAC/B;AACA;;AAEA,aAAa,6DAAO,eAAe,4DAAM;AACzC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;A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AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA,aAAa,6DAAO;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,cAAc,6DAAO;AACrB;AACA,GAAG;;AAEH;AACA;AACA,eAAe,6DAAO;AACtB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,wBAAwB,6DAAO;AAC/B,KAAK;AACL;;AAEA;AACA;AACA,eAAe,6DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;;;;;;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAuC;AACmB;;AAE1D;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACe;AACf,EAAE,sDAAQ;AACV;;AAEA,0DAAQ,QAAQ,sDAAQ;;AAExB;AACA;AACA,MAAM,yDAAO,WAAW,uDAAK,0BAA0B,QAAQ,uDAAK,IAAI,EAAE;AAC1E,MAAM,uDAAK;AACX;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAiD;AACL;;AAE5C;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,oBAAoB;AAC/B;AACA;AACe;AACf,EAAE,uDAAS,YAAY,yDAAO;AAC9B;;AAEA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,KAAK;AACL;AACA;;AAEA,gBAAgB,0DAAQ,SAAS,uDAAS;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,6DAAO;AACpB;AACA;AACA,GAAG;;AAEH;AACA;AACA,mBAAmB,6DAAO;AAC1B,GAAG;;AAEH;AACA,aAAa,6DAAO;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;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A;AACA,8BAA8B,gEAAU,CAAC,qDAAO;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAQ;AAC1B;AACA;AACA,qCAAqC,0DAAQ;AAC7C;;AAEA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AC5IA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;;AAEA,UAAU,KAAK;AACf;AACA;;AAEA;AACA;AACA;;AAEO;AACP,iDAAiD,WAAW;AAC5D;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;;AAEpC;AACP;AACA;;AAEO;AACP;AACA;AACA,6BAA6B;AAC7B;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,wBAAwB;AACxB,0BAA0B;AAC1B,yBAAyB;AACzB;AACA,GAAG;AACH;AACA;AACA,yBAAyB;AACzB,iCAAiC,6BAA6B;AAC9D,iCAAiC,sDAAsD;AACvF;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,wBAAwB;AACxB,2CAA2C;AAC3C,2CAA2C;AAC3C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mCAAmC;AACnC,6CAA6C;AAC7C,sDAAsD;AACtD;AACA;AACA,GAAG;AACH;AACA;AACA,mCAAmC;AACnC,6CAA6C;AAC7C,sDAAsD;AACtD;AACA;AACA,GAAG;AACH;AACA;AACA,gCAAgC;AAChC,oEAAoE;AACpE,6CAA6C;AAC7C;AACA;AACA,GAAG;AACH;AACA;AACA,gCAAgC;AAChC,oEAAoE;AACpE,6CAA6C;AAC7C;AACA;AACA,GAAG;AACH;;AAEO;;AAEA;AACP;AACA;;AAEA;AACA;AACA,YAAY,wDAAM,EAAE,+BAA+B;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,iDAAiD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;;AAEO;AACP,qBAAqB,kDAAQ;AAC7B;AACA,mCAAmC,gBAAgB,kBAAkB;AACrE,8BAA8B,aAAa;AAC3C,yBAAyB,eAAe,SAAS,kBAAkB,cAAc;AACjF,yBAAyB,eAAe,SAAS,kBAAkB,cAAc;AACjF,kCAAkC;;AAElC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,+CAA+C;AAC/C,GAAG;AACH,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc,EAAE;AACpD;AACA;;;;;;;;;;;;;AC3MA;AAAA;AAAA;AAAA;AAKyB;;AAEO;;AAEhC;AACA,WAAW,yDAAS;AACpB,WAAW,6DAAa;AACxB,WAAW,4DAAY;AACvB,WAAW,6DAAa;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACe;AACf;AACA;AACA,IAAI,uDAAK;AACT;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,uBAAuB,EAAE;AAClE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACzDA;AAAA;AAAgC;;AAEjB;AACf;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,sBAAsB,aAAa,EAAE;AACrC,yBAAyB,mBAAmB,EAAE;AAC9C,sBAAsB,oBAAoB,EAAE;AAC5C;AACA;AACA,wCAAwC,mBAAmB,EAAE;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACiB;AACV;;AAE9B;AACf,oBAAoB,uDAAK,QAAQ,qDAAO;AACxC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA,WAAW,KAAK;AAChB;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,6DAAW;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,iEAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,mEAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACxIA;AAAA;AAAA;AAAA;AAAA;AAAsC;;AAE/B;AACP;AACA;AACA,uBAAuB,8CAAI;AAC3B,4BAA4B,oBAAoB;AAChD;AACA;;AAEO;AACP;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,UAAU,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,WAAW,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,wBAAwB,UAAU,EAAE;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA,yBAAyB,iCAAiC;AAC1D;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA,GAAG;AACH;AACA;AACA,yBAAyB,gCAAgC;AACzD;AACA,GAAG;AACH;AACA;AACA,oBAAoB,uDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;;;;;;;;;;;;;ACrHP;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2E;AACrC;AACU;AACqB;;AAEtD;AACf;AACA,YAAY,uDAAK;AACjB,eAAe,uDAAK;AACpB,eAAe,uDAAK;AACpB,WAAW,uDAAK;AAChB;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;;AAEA;AACA,IAAI,uDAAK,CAAC,gEAAc,0BAA0B,eAAe,EAAE;AACnE;AACA;;AAEA;AACA;AACA,gBAAgB,8DAAY;AAC5B,eAAe,iEAAW;;AAE1B;AACA;;AAEA;AACA,QAAQ,oDAAS;AACjB,mBAAmB,2DAAQ;AAC3B;;AAEA;AACA;AACA;AACA,QAAQ,uDAAK;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAa;AAC1B;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oCAAoC,UAAU,EAAE;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB,gBAAgB,QAAQ;AACxB;AACA;AACA,WAAW,KAAK;AAChB;;AAEA;AACA;AACA,WAAW,qEAAe;AAC1B,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf;;AAEA;AACA,gCAAgC,mDAAU;AAC1C;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,KAAK;AACnC,yCAAyC,KAAK;AAC9C;;AAEA;AACA;AACA;AACA,iBAAiB,KAAK;AACtB;;AAEA;AACA;;;;;;;;;;;;;ACnJA;AAAA;AAAA;AAAuC;;AAEvC;AACO;AACP;AACA;AACA,oBAAoB,8DAAY;AAChC,GAAG;AACH;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIwB;;AASC;;AASH;;AASG;;AAEoB;AACI;AACE;AACA;AACN;AACE;AACU;AACR;AACJ;AACM;AACF;AACI;AACN;AACQ;AACJ;AACA;AACA;AACA;AACV;AACI;AACJ;AACE;AACI;AACkB;AACR;AACJ;AACN;AACI;AACA;AACN;AACM;AACI;;;;;;;;;;;;;AChEvD;AAAA;AAAA;AAAe;AACf;AACA;AACA;AACA,CAAC;;AAEM;AACP;AACA;;AAEO;AACP;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACN;;AAE5B;;AAEO,SAAS,sDAAK;;AAEd,eAAe,yDAAQ,cAAc,UAAU,EAAE;;AAEjD,WAAW,yDAAQ,aAAa,UAAU,EAAE;;AAE5C,UAAU,yDAAQ,aAAa,UAAU,EAAE;;AAE3C,aAAa,yDAAQ,aAAa,aAAa,EAAE;;AAEjD,YAAY,yDAAQ,aAAa,cAAc,EAAE;;;;;;;;;;;;;ACfxD;AAAA;AAAgC;;AAEjB;AACf,sBAAsB,wDAAO;AAC7B,CAAC;;;;;;;;;;;;;ACJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+D;AACnC;AACU;AACU;AACR;;AAEzB;AACf;AACA,sBAAsB,sDAAK;AAC3B;AACA;AACA,SAAS;AACT;AACA,iBAAiB,2DAAU;AAC3B,cAAc,gEAAe,QAAQ,oDAAW;AAChD;AACA,OAAO;AACP;AACA,YAAY,sDAAK;AACjB,sBAAsB;AACtB;;AAEA;;AAEA,WAAW,MAAM;AACjB;AACA;;AAEA,QAAQ,2DAAU;AAClB;AACA;AACA;AACA,kBAAkB;AAClB,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;;AAEA;AACA,QAAQ,2DAAU;AAClB,OAAO,gEAAc,oCAAoC,YAAY,EAAE;AACvE,KAAK;AACL;AACA;AACA;AACA,GAAG,IAAI;;AAEP,SAAS,yDAAQ;AACjB,CAAC;;;;;;;;;;;;;ACpED;AAAA;AAAsC;;AAEvB;AACf,SAAS,2DAAU,sBAAsB,UAAU;AACnD,CAAC;;;;;;;;;;;;;ACJD;AAAe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACbD;AAAe;AACf;AACA,CAAC;;;;;;;;;;;;;ACFD;AAAe;AACf,2CAA2C,OAAO;AAClD;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA,CAAC;;;;;;;;;;;;;ACND;AAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACpDD;AAAA;;AAEe;AACf,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;;;;;;;;;;;;ACrED;AAAA;AAAA;AAAA;AAAkC;AACc;AACR;;AAEzB;AACf,aAAa,gEAAe;AAC5B,oCAAoC,oDAAW,kBAAkB;;AAEjE,SAAS,yDAAQ;AACjB;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACbD;AAAe;AACf;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACJD;AAAe,4EAAa,EAAC;;;;;;;;;;;;;ACA7B;AAAe;AA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;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACM;AACQ;AACb;;AAEnC;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACe;AACf,EAAE,uDAAS;AACX;;AAEA,gBAAgB,0DAAQ,OAAO,uDAAS;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,gDAAK,GAAG,yDAAS,GAAG,oDAAI;AACvD,yCAAyC,uBAAuB,EAAE;;AAElE;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAwC;AACA;AACD;AACE;;AAEzC;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,sBAAsB;AACjC;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACe;AACf,EAAE,uDAAS;AACX;;AAEA,gBAAgB,0DAAQ,UAAU,uDAAS;;AAE3C;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,sDAAM;;AAEpB,iBAAiB,8CAAG,eAAe,iDAAM;AACzC;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,kBAAkB,EAAE;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL,6BAA6B,sDAAI;AACjC,4BAA4B,sDAAI;AAChC,MAAM,sDAAI;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AAAwC;AACL;;AAEnC;AACA;AACA;AACA;AACe;AACf,EAAE,uDAAS;AACX;;AAEA,gBAAgB,0DAAQ,SAAS,uDAAS;;AAE1C;AACA;;AAEA,yCAAyC,kBAAkB,EAAE;;AAE7D;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMqB;AACmB;AACA;AACY;AACjB;;AAEnC;AACA,qBAAqB,sDAAM;;AAE3B;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACe;AACf,EAAE,uDAAS;AACX;;AAEA,gBAAgB,0DAAQ,aAAa,uDAAS;;AAE9C;AACA;AACA;AACA;AACA,kBAAkB,8DAAU;AAC5B;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,sDAAM;AAC7B;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA,WAAW,mDAAQ;AACnB;AACA;AACA;AACA,WAAW,oDAAS;AACpB,qBAAqB;AACrB,WAAW,qDAAU;AACrB,2BAA2B;AAC3B,WAAW,oDAAS;AACpB,WAAW,oDAAS;AACpB,WAAW,oDAAS;AACpB,WAAW,oDAAS;AACpB,WAAW,mDAAQ;AACnB,WAAW,oDAAS;AACpB,WAAW,oDAAS;AACpB,WAAW,mDAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,KAAK;AACpC;AACA,4CAA4C,8CAAG;AAC/C;AACA;AACA;AACA;AACA,uBAAuB,+CAAI,eAAe,gDAAK;AAC/C;AACA,SAAS,qBAAqB,8CAAG,eAAe,iDAAM;AACtD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,+CAAI,eAAe,gDAAK;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,8CAAG;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,gDAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iDAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,mEAAW;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+CAAI,eAAe,gDAAK;AACrD;AACA;AACA;;AAEA,gBAAgB,gDAAK;AACrB,eAAe,+CAAI;AACnB,mBAAmB,gDAAK;AACxB;AACA,GAAG,qBAAqB,+CAAI;AAC5B;AACA;;AAEA,oBAAoB,gDAAK;AACzB,kBAAkB,8CAAG;AACrB;;AAEA;;AAEA;AACA;AACA,SAAS,8CAAG;AACZ;AACA;AACA;AACA,SAAS,+CAAI;AACb;AACA;AACA;AACA,SAAS,gDAAK;AACd;AACA;AACA;AACA,SAAS,iDAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,8BAA8B,+CAAI;AAClC;AACA,sCAAsC,mBAAmB,EAAE;AAC3D;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,8CAAG,eAAe,iDAAM;AACzC;AACA;AACA,GAAG,qBAAqB,+CAAI,eAAe,gDAAK;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,wBAAwB,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kDAAO;AAC5B;AACA;;AAEA;AACA,SAAS,+CAAI;AACb;AACA;AACA;AACA,SAAS,gDAAK;AACd;AACA;AACA;AACA,SAAS,8CAAG;AACZ;AACA;AACA;AACA,SAAS,iDAAM;AACf;AACA;AACA;AACA,SAAS,kDAAO;AAChB;AACA;AACA;AACA,SAAS,mDAAQ;AACjB;AACA;AACA;AACA,SAAS,qDAAU;AACnB;AACA;AACA;AACA,SAAS,sDAAW;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,mEAAW;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;;AAEP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,kDAAO;AAC/B;AACA;AACA;;AAEA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,8CAAG;AACvB;AACA;AACA;;AAEA,oBAAoB,+CAAI;AACxB;AACA;AACA;;AAEA,oBAAoB,+CAAI;AACxB;AACA;AACA;;AAEA,oBAAoB,8CAAG;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACreA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC5CP;AAAA;AAAA;AAAA;AAAA;AAKqB;AACc;AACI;;AAEvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,KAAK;AACb;AACA;AACA,0BAA0B,gDAAK;AAC/B;AACA,aAAa,mDAAQ;AACrB,aAAa,qDAAU;AACvB;AACA,aAAa,oDAAS,kCAAkC;AACxD,aAAa,oDAAS,kCAAkC;AACxD,aAAa,oDAAS,kCAAkC;AACxD,aAAa,oDAAS,kCAAkC;AACxD,aAAa,mDAAQ,6BAA6B;AAClD,aAAa,mDAAQ,6BAA6B;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,KAAK;AACpC;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU,0DAAQ;AAClB;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;AACA,6BAA6B,gDAAK;AAClC;AACA,mBAAmB,sDAAM;AACzB,gCAAgC,iDAAM;AACtC,gCAAgC,8CAAG;AACnC,gCAAgC,iDAAM;AACtC,gCAAgC,8CAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA;AACA;;AAEA;AACA,mBAAmB,+CAAI;AACvB,aAAa,SAAS;AACtB,yBAAyB,KAAK;AAC9B;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,GAAG,uBAAuB,8CAAG;AAC7B,uBAAuB,KAAK;AAC5B;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,GAAG;AACH,6BAA6B,SAAS;AACtC,eAAe,KAAK;AACpB;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,+CAAI;AACvB,aAAa,SAAS;AACtB,0CAA0C,KAAK;AAC/C;AACA;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA,GAAG,uBAAuB,8CAAG;AAC7B,2BAA2B,KAAK;AAChC;AACA;AACA,iBAAiB,KAAK;AACtB;AACA;AACA,GAAG;AACH,6BAA6B,SAAS;AACtC,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,kBAAkB,KAAK;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,iDAAM;AAC5B,aAAa,KAAK;AAClB;AACA,uBAAuB,8CAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,8CAAG;AACzB,aAAa,KAAK;AAClB;AACA,uBAAuB,8CAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,sBAAsB,mCAAmC;AACzD,sBAAsB,kCAAkC;;AAExD;AACA;;AAEA;AACA,6BAA6B,8CAAG;AAChC;;AAEA;AACA,6BAA6B,iDAAM;AACnC;;AAEA;AACA,6BAA6B,8CAAG;AAChC;;AAEA;AACA,6BAA6B,iDAAM;AACnC;;AAEA;AACA;AACA;AACA,8BAA8B,8CAAG;AACjC;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iDAAM;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,KAAK;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;;AAEA;AACA,sCAAsC,KAAK;AAC3C;AACA;;AAEA;AACA;AACA,aAAa,mCAAmC;;AAEhD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;AClWA;AAAA;AAAA;AAAA;AAA2C;;;;;;;;;;;;;ACA3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;AAC+B;AACN;AAC3B;AACM;AACI;AACe;AACL;AACN;AACG;AACb;AACF;AAC6C;AAChC;AACf;AACW;AACb;;AAEa;AACwB;AAItC;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACe;AACf;AACA;;AAEA,EAAE,uDAAQ;AACV;AACA;;AAEA;AACA,yCAAyC,2DAAU;AACnD,yBAAyB,2DAAU;AACnC;;AAEA;AACA;AACA,qCAAqC,iDAAc;AACnD;AACA,sBAAsB,8DAAa;AACnC;AACA;AACA;AACA;;AAEA;AACA,YAAY,yDAAO;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa,yDAAM,GAAG;AACtB;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,qEAAqB;;AAE3C;AACA;AACA;AACA,oBAAoB,wDAAS;AAC7B,qBAAqB,yDAAU;AAC/B;AACA;AACA;AACA,EAAE,+DAAgB;;AAElB;AACA,EAAE,uDAAM;AACR;;AAEA,gBAAgB,2DAAQ,OAAO,uDAAQ;;AAEvC;;AAEA;AACA;AACA,EAAE,uDAAQ;;AAEV;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,mEAAc;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,wDAAK,gCAAgC,8DAAW;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO,qEAAY,QAAQ,wDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,uDAAQ;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iDAAU;;AAElC;;AAEA;AACA;AACA;AACA;AACA,eAAe,sDAAI;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA,QAAQ,sDAAI,mBAAmB,yBAAyB,EAAE;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,qDAAO;AAChD;;AAEA;AACA,sCAAsC,qDAAO;AAC7C;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,kBAAkB,+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ACQ;AACP;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,KAAK;AAChB,YAAY,MAAM;AAClB;AACe;AACf;AACA;;AAEA;AACA,gBAAgB,2DAAM;AACtB;AACA,QAAQ,6DAAK;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,GAAG;AAC/B,iCAAiC,OAAO,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA,QAAQ,0DAAQ;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,0DAAQ;AACnB,WAAW,0DAAQ,WAAW;AAC9B;AACA;AACA,2BAA2B,oBAAoB,EAAE;AACjD,2BAA2B,oBAAoB;AAC/C;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0C;AACA;AACO;;AAEjD;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP,WAAW,wDAAM,GAAG;;AAEpB;AACA;AACA,QAAQ,yDAAO;AACf,oBAAoB,uDAAK;AACzB;AACA,QAAQ,yDAAO;AACf,kBAAkB,uDAAK;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,0BAA0B;AACrC,YAAY;AACZ;AACO;AACP;AACA,cAAc,yDAAW;AACzB;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAW;AAC/B,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,YAAY;AAC9C;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL,qCAAqC,KAAK;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;;;;;;;;;;;;AClGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;AC/BD;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACrCD;AAAA;AAAA;AAAqC;AACX;;AAEX;AACf;AACA,+CAA+C,qDAAI;AACnD;AACA,oBAAoB,2DAAM;;AAE1B;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,CAAC;;;;;;;;;;;;;ACjBD;AAAA;AAAoD;;AAErC;AACf;AACA;AACA,oBAAoB,0DAAK,QAAQ,2DAAM,QAAQ,2DAAM;AACrD;AACA,CAAC;;;;;;;;;;;;;ACPD;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0B;AACM;AACuB;AACF;AACO;;AAE7C;AACf;AACA;AACA,eAAe,oEAAY;AAC3B;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B,6DAAa;AAC3C;;AAEA;AACA;AACA,MAAM,oEAAkB;AACxB,kBAAkB,mEAAiB;AACnC;;AAEA;AACA;AACA;AACA,uBAAuB,wDAAO,SAAS,yBAAyB;;AAEhE;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,MAAM,qDAAI;AACV,KAAK;AACL;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAuD;AACV;;AAE7C;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACe;AACf,eAAe,oEAAY;AAC3B;AACA;AACA;AACA;AACA,eAAe,oEAAkB;AACjC;AACA,OAAO;AACP,CAAC;;;;;;;;;;;;;ACjBD;AAAA;AAAA;AAAA;AAAA;AAAO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAA+C;AACJ;;AAE3C;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACe;AACf,SAAS,gEAAc,OAAO,0DAAU;AACxC,8BAA8B,0BAA0B,EAAE;AAC1D,CAAC;;;;;;;;;;;;;ACXD;AAAA;AAAA;AAA+C;AACI;;AAEnD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA,+DAAe;AACf,mBAAmB,0DAAI,oBAAoB,0DAAI,iBAAiB,0DAAI;AACpE;AACA,MAAM,gEAAc;AACpB,wBAAwB,0DAAI;AAC5B;AACA;AACA,OAAO;AACP,CAAC;;AAED;AACA,+BAA+B,WAAW;AAC1C;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAA+C;AACJ;;AAE3C;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACe;AACf,SAAS,gEAAc,OAAO,0DAAU;AACxC,8BAA8B,uBAAuB,EAAE;AACvD,CAAC;;;;;;;;;;;;;ACXD;AAAA;AAAA;AAAA;AAAyC;AACG;AACA;;AAE7B;AACf,wBAAwB,2DAAe;AACvC,SAAS,0DAAK,OAAO,4DAAO,OAAO,wDAAU;AAC7C,CAAC;;;;;;;;;;;;;ACPD;AAAA;AAAA;AAAgC;;AAEzB;AACP;AACA;AACA,IAAI,uDAAK;AACT;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA,YAAY;;AAEL;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;;AAEA;AACA,iDAAiD,OAAO;;AAExD;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,eAAe,EAAE;AACzD,GAAG;AACH;;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AAAA;AAAyC;AACP;;AAElC;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,mCAAmC;AAC9C;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,OAAO;AACnB;AACO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,SAAS,yDAAO;AAChB;AACA;;AAEA;AACA,8CAA8C,wDAAU;AACxD;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA,YAAY,KAAK;AACjB;AACO;AACP;AACA;AACA;AACA;AACA,oCAAoC,sBAAsB,EAAE;AAC5D,GAAG;AACH;AACA;;;;;;;;;;;;;ACnDA;AAAA;AAAkC;;AAEnB;AACf;AACA,cAAc,wCAAwC;AACtD;AACA,oBAAoB,yDAAQ;AAC5B,CAAC;;;;;;;;;;;;;ACPD;AAAA;AAAoD;;AAErC;AACf;AACA;AACA,CAAC;;AAED;AACA;AACA,MAAM,yDAAO;AACb,MAAM,0DAAQ,YAAY,wDAAM;AAChC;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,yDAAO;AAChC,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,yDAAO;AAChB,MAAM,0DAAQ,YAAY,wDAAM,YAAY,OAAO;AACnD;AACA;;;;;;;;;;;;;AC7BA;AAAe;AACf;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACRD;AAAA;AAAA;AAAA;AAAiD;;;;;;;;;;;;;ACAjD;AAAA;AAAA;AAAA;AAAA;AAAwC;AACL;AACA;;AAEpB;AACf,EAAE,uDAAS;AACX;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,KAAK,iDAAiD;AACtD,KAAK,iDAAiD;AACtD,KAAK,+DAA+D;AACpE,KAAK;AACL;AACA,kBAAkB,6CAA6C,EAAE;AACjE,KAAK;AACL;AACA;;AAEA,gBAAgB,0DAAQ,UAAU,uDAAS;;AAE3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,0DAAO;AACnB;AACA;;AAEA;;AAEA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAqD;;;;;;;;;;;;;ACArD;AAAA;AAAmC;;AAEnC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0DAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,uBAAuB,wBAAwB,EAAE;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B,GAAG,6BAA6B;AACrF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,UAAU;AAC7D;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC9aA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkC;AACM;AACiB;AACxB;AACM;;AAEvC;;AAEA;;AAEe;AACf,EAAE,uDAAS,YAAY,4DAAK;AAC5B;;AAEA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,KAAK,+DAA+D;AACpE,KAAK,0EAA0E;AAC/E,KAAK,2EAA2E;AAChF,KAAK,4EAA4E;AACjF,KAAK,oEAAoE;AACzE,KAAK,sFAAsF;AAC3F,KAAK,iEAAiE;AACtE,KAAK,kCAAkC;AACvC,KAAK,+EAA+E;AACpF,KAAK,oDAAoD;AACzD,KAAK;AACL;AACA;;AAEA,gBAAgB,0DAAQ,YAAY,uDAAS;;AAE7C;AACA;AACA;AACA,WAAW,4DAAU;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,EAAE,4DAAU;AACZ;AACA,kBAAkB,0DAAQ;;AAE1B;AACA;AACA;AACA,oBAAoB,wDAAK;AACzB;AACA;AACA,4BAA4B,4BAA4B;AACxD;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAM;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,KAAK;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.tsx\");\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"h1 {\\n  font-size: 35; }\\n\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n","var array = Array.prototype;\n\nexport var slice = array.slice;\nexport var map = array.map;\n","export default function(a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}\n","import ascending from \"./ascending\";\nimport bisector from \"./bisector\";\n\nvar ascendingBisect = bisector(ascending);\nexport var bisectRight = ascendingBisect.right;\nexport var bisectLeft = ascendingBisect.left;\nexport default bisectRight;\n","import ascending from \"./ascending\";\n\nexport default function(compare) {\n  if (compare.length === 1) compare = ascendingComparator(compare);\n  return {\n    left: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      }\n      return lo;\n    },\n    right: function(a, x, lo, hi) {\n      if (lo == null) lo = 0;\n      if (hi == null) hi = a.length;\n      while (lo < hi) {\n        var mid = lo + hi >>> 1;\n        if (compare(a[mid], x) > 0) hi = mid;\n        else lo = mid + 1;\n      }\n      return lo;\n    }\n  };\n}\n\nfunction ascendingComparator(f) {\n  return function(d, x) {\n    return ascending(f(d), x);\n  };\n}\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","import {pair} from \"./pairs\";\n\nexport default function(values0, values1, reduce) {\n  var n0 = values0.length,\n      n1 = values1.length,\n      values = new Array(n0 * n1),\n      i0,\n      i1,\n      i,\n      value0;\n\n  if (reduce == null) reduce = pair;\n\n  for (i0 = i = 0; i0 < n0; ++i0) {\n    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {\n      values[i] = reduce(value0, values1[i1]);\n    }\n  }\n\n  return values;\n}\n","export default function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n}\n","import variance from \"./variance\";\n\nexport default function(array, f) {\n  var v = variance(array, f);\n  return v ? Math.sqrt(v) : v;\n}\n","export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null) {\n            if (min > value) min = value;\n            if (max < value) max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return [min, max];\n}\n","import {slice} from \"./array\";\nimport bisect from \"./bisect\";\nimport constant from \"./constant\";\nimport extent from \"./extent\";\nimport identity from \"./identity\";\nimport range from \"./range\";\nimport {tickStep} from \"./ticks\";\nimport sturges from \"./threshold/sturges\";\n\nexport default function() {\n  var value = identity,\n      domain = extent,\n      threshold = sturges;\n\n  function histogram(data) {\n    var i,\n        n = data.length,\n        x,\n        values = new Array(n);\n\n    for (i = 0; i < n; ++i) {\n      values[i] = value(data[i], i, data);\n    }\n\n    var xz = domain(values),\n        x0 = xz[0],\n        x1 = xz[1],\n        tz = threshold(values, x0, x1);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      tz = tickStep(x0, x1, tz);\n      tz = range(Math.ceil(x0 / tz) * tz, x1, tz); // exclusive\n    }\n\n    // Remove any thresholds outside the domain.\n    var m = tz.length;\n    while (tz[0] <= x0) tz.shift(), --m;\n    while (tz[m - 1] > x1) tz.pop(), --m;\n\n    var bins = new Array(m + 1),\n        bin;\n\n    // Initialize bins.\n    for (i = 0; i <= m; ++i) {\n      bin = bins[i] = [];\n      bin.x0 = i > 0 ? tz[i - 1] : x0;\n      bin.x1 = i < m ? tz[i] : x1;\n    }\n\n    // Assign data to bins by value, ignoring any outside the domain.\n    for (i = 0; i < n; ++i) {\n      x = values[i];\n      if (x0 <= x && x <= x1) {\n        bins[bisect(tz, x, 0, m)].push(data[i]);\n      }\n    }\n\n    return bins;\n  }\n\n  histogram.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(_), histogram) : value;\n  };\n\n  histogram.domain = function(_) {\n    return arguments.length ? (domain = typeof _ === \"function\" ? _ : constant([_[0], _[1]]), histogram) : domain;\n  };\n\n  histogram.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;\n  };\n\n  return histogram;\n}\n","export default function(x) {\n  return x;\n}\n","export {default as bisect, bisectRight, bisectLeft} from \"./bisect\";\nexport {default as ascending} from \"./ascending\";\nexport {default as bisector} from \"./bisector\";\nexport {default as cross} from \"./cross\";\nexport {default as descending} from \"./descending\";\nexport {default as deviation} from \"./deviation\";\nexport {default as extent} from \"./extent\";\nexport {default as histogram} from \"./histogram\";\nexport {default as thresholdFreedmanDiaconis} from \"./threshold/freedmanDiaconis\";\nexport {default as thresholdScott} from \"./threshold/scott\";\nexport {default as thresholdSturges} from \"./threshold/sturges\";\nexport {default as max} from \"./max\";\nexport {default as mean} from \"./mean\";\nexport {default as median} from \"./median\";\nexport {default as merge} from \"./merge\";\nexport {default as min} from \"./min\";\nexport {default as pairs} from \"./pairs\";\nexport {default as permute} from \"./permute\";\nexport {default as quantile} from \"./quantile\";\nexport {default as range} from \"./range\";\nexport {default as scan} from \"./scan\";\nexport {default as shuffle} from \"./shuffle\";\nexport {default as sum} from \"./sum\";\nexport {default as ticks, tickIncrement, tickStep} from \"./ticks\";\nexport {default as transpose} from \"./transpose\";\nexport {default as variance} from \"./variance\";\nexport {default as zip} from \"./zip\";\n","export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      max;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        max = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && value > max) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return max;\n}\n","import number from \"./number\";\n\nexport default function(values, valueof) {\n  var n = values.length,\n      m = n,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) sum += value;\n      else --m;\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;\n      else --m;\n    }\n  }\n\n  if (m) return sum / m;\n}\n","import ascending from \"./ascending\";\nimport number from \"./number\";\nimport quantile from \"./quantile\";\n\nexport default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      numbers = [];\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        numbers.push(value);\n      }\n    }\n  }\n\n  return quantile(numbers.sort(ascending), 0.5);\n}\n","export default function(arrays) {\n  var n = arrays.length,\n      m,\n      i = -1,\n      j = 0,\n      merged,\n      array;\n\n  while (++i < n) j += arrays[i].length;\n  merged = new Array(j);\n\n  while (--n >= 0) {\n    array = arrays[n];\n    m = array.length;\n    while (--m >= 0) {\n      merged[--j] = array[m];\n    }\n  }\n\n  return merged;\n}\n","export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      min;\n\n  if (valueof == null) {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = values[i]) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = values[i]) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  else {\n    while (++i < n) { // Find the first comparable value.\n      if ((value = valueof(values[i], i, values)) != null && value >= value) {\n        min = value;\n        while (++i < n) { // Compare the remaining values.\n          if ((value = valueof(values[i], i, values)) != null && min > value) {\n            min = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min;\n}\n","export default function(x) {\n  return x === null ? NaN : +x;\n}\n","export default function(array, f) {\n  if (f == null) f = pair;\n  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);\n  while (i < n) pairs[i] = f(p, p = array[++i]);\n  return pairs;\n}\n\nexport function pair(a, b) {\n  return [a, b];\n}\n","export default function(array, indexes) {\n  var i = indexes.length, permutes = new Array(i);\n  while (i--) permutes[i] = array[indexes[i]];\n  return permutes;\n}\n","import number from \"./number\";\n\nexport default function(values, p, valueof) {\n  if (valueof == null) valueof = number;\n  if (!(n = values.length)) return;\n  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);\n  if (p >= 1) return +valueof(values[n - 1], n - 1, values);\n  var n,\n      i = (n - 1) * p,\n      i0 = Math.floor(i),\n      value0 = +valueof(values[i0], i0, values),\n      value1 = +valueof(values[i0 + 1], i0 + 1, values);\n  return value0 + (value1 - value0) * (i - i0);\n}\n","export default function(start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}\n","import ascending from \"./ascending\";\n\nexport default function(values, compare) {\n  if (!(n = values.length)) return;\n  var n,\n      i = 0,\n      j = 0,\n      xi,\n      xj = values[j];\n\n  if (compare == null) compare = ascending;\n\n  while (++i < n) {\n    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {\n      xj = xi, j = i;\n    }\n  }\n\n  if (compare(xj, xj) === 0) return j;\n}\n","export default function(array, i0, i1) {\n  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m + i0];\n    array[m + i0] = array[i + i0];\n    array[i + i0] = t;\n  }\n\n  return array;\n}\n","export default function(values, valueof) {\n  var n = values.length,\n      i = -1,\n      value,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (value = +valueof(values[i], i, values)) sum += value;\n    }\n  }\n\n  return sum;\n}\n","import {map} from \"../array\";\nimport ascending from \"../ascending\";\nimport number from \"../number\";\nimport quantile from \"../quantile\";\n\nexport default function(values, min, max) {\n  values = map.call(values, number).sort(ascending);\n  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));\n}\n","import deviation from \"../deviation\";\n\nexport default function(values, min, max) {\n  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));\n}\n","export default function(values) {\n  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;\n}\n","var e10 = Math.sqrt(50),\n    e5 = Math.sqrt(10),\n    e2 = Math.sqrt(2);\n\nexport default function(start, stop, count) {\n  var reverse,\n      i = -1,\n      n,\n      ticks,\n      step;\n\n  stop = +stop, start = +start, count = +count;\n  if (start === stop && count > 0) return [start];\n  if (reverse = stop < start) n = start, start = stop, stop = n;\n  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];\n\n  if (step > 0) {\n    start = Math.ceil(start / step);\n    stop = Math.floor(stop / step);\n    ticks = new Array(n = Math.ceil(stop - start + 1));\n    while (++i < n) ticks[i] = (start + i) * step;\n  } else {\n    start = Math.floor(start * step);\n    stop = Math.ceil(stop * step);\n    ticks = new Array(n = Math.ceil(start - stop + 1));\n    while (++i < n) ticks[i] = (start - i) / step;\n  }\n\n  if (reverse) ticks.reverse();\n\n  return ticks;\n}\n\nexport function tickIncrement(start, stop, count) {\n  var step = (stop - start) / Math.max(0, count),\n      power = Math.floor(Math.log(step) / Math.LN10),\n      error = step / Math.pow(10, power);\n  return power >= 0\n      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)\n      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);\n}\n\nexport function tickStep(start, stop, count) {\n  var step0 = Math.abs(stop - start) / Math.max(0, count),\n      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),\n      error = step0 / step1;\n  if (error >= e10) step1 *= 10;\n  else if (error >= e5) step1 *= 5;\n  else if (error >= e2) step1 *= 2;\n  return stop < start ? -step1 : step1;\n}\n","import min from \"./min\";\n\nexport default function(matrix) {\n  if (!(n = matrix.length)) return [];\n  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {\n    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {\n      row[j] = matrix[j][i];\n    }\n  }\n  return transpose;\n}\n\nfunction length(d) {\n  return d.length;\n}\n","import number from \"./number\";\n\nexport default function(values, valueof) {\n  var n = values.length,\n      m = 0,\n      i = -1,\n      mean = 0,\n      value,\n      delta,\n      sum = 0;\n\n  if (valueof == null) {\n    while (++i < n) {\n      if (!isNaN(value = number(values[i]))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  else {\n    while (++i < n) {\n      if (!isNaN(value = number(valueof(values[i], i, values)))) {\n        delta = value - mean;\n        mean += delta / ++m;\n        sum += delta * (value - mean);\n      }\n    }\n  }\n\n  if (m > 1) return sum / (m - 1);\n}\n","import transpose from \"./transpose\";\n\nexport default function() {\n  return transpose(arguments);\n}\n","export default function(map) {\n  var entries = [];\n  for (var key in map) entries.push({key: key, value: map[key]});\n  return entries;\n}\n","export {default as nest} from \"./nest\";\nexport {default as set} from \"./set\";\nexport {default as map} from \"./map\";\nexport {default as keys} from \"./keys\";\nexport {default as values} from \"./values\";\nexport {default as entries} from \"./entries\";\n","export default function(map) {\n  var keys = [];\n  for (var key in map) keys.push(key);\n  return keys;\n}\n","export var prefix = \"$\";\n\nfunction Map() {}\n\nMap.prototype = map.prototype = {\n  constructor: Map,\n  has: function(key) {\n    return (prefix + key) in this;\n  },\n  get: function(key) {\n    return this[prefix + key];\n  },\n  set: function(key, value) {\n    this[prefix + key] = value;\n    return this;\n  },\n  remove: function(key) {\n    var property = prefix + key;\n    return property in this && delete this[property];\n  },\n  clear: function() {\n    for (var property in this) if (property[0] === prefix) delete this[property];\n  },\n  keys: function() {\n    var keys = [];\n    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));\n    return keys;\n  },\n  values: function() {\n    var values = [];\n    for (var property in this) if (property[0] === prefix) values.push(this[property]);\n    return values;\n  },\n  entries: function() {\n    var entries = [];\n    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});\n    return entries;\n  },\n  size: function() {\n    var size = 0;\n    for (var property in this) if (property[0] === prefix) ++size;\n    return size;\n  },\n  empty: function() {\n    for (var property in this) if (property[0] === prefix) return false;\n    return true;\n  },\n  each: function(f) {\n    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);\n  }\n};\n\nfunction map(object, f) {\n  var map = new Map;\n\n  // Copy constructor.\n  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });\n\n  // Index array by numeric index or specified key function.\n  else if (Array.isArray(object)) {\n    var i = -1,\n        n = object.length,\n        o;\n\n    if (f == null) while (++i < n) map.set(i, object[i]);\n    else while (++i < n) map.set(f(o = object[i], i, object), o);\n  }\n\n  // Convert object to map.\n  else if (object) for (var key in object) map.set(key, object[key]);\n\n  return map;\n}\n\nexport default map;\n","import map from \"./map\";\n\nexport default function() {\n  var keys = [],\n      sortKeys = [],\n      sortValues,\n      rollup,\n      nest;\n\n  function apply(array, depth, createResult, setResult) {\n    if (depth >= keys.length) {\n      if (sortValues != null) array.sort(sortValues);\n      return rollup != null ? rollup(array) : array;\n    }\n\n    var i = -1,\n        n = array.length,\n        key = keys[depth++],\n        keyValue,\n        value,\n        valuesByKey = map(),\n        values,\n        result = createResult();\n\n    while (++i < n) {\n      if (values = valuesByKey.get(keyValue = key(value = array[i]) + \"\")) {\n        values.push(value);\n      } else {\n        valuesByKey.set(keyValue, [value]);\n      }\n    }\n\n    valuesByKey.each(function(values, key) {\n      setResult(result, key, apply(values, depth, createResult, setResult));\n    });\n\n    return result;\n  }\n\n  function entries(map, depth) {\n    if (++depth > keys.length) return map;\n    var array, sortKey = sortKeys[depth - 1];\n    if (rollup != null && depth >= keys.length) array = map.entries();\n    else array = [], map.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });\n    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;\n  }\n\n  return nest = {\n    object: function(array) { return apply(array, 0, createObject, setObject); },\n    map: function(array) { return apply(array, 0, createMap, setMap); },\n    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },\n    key: function(d) { keys.push(d); return nest; },\n    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },\n    sortValues: function(order) { sortValues = order; return nest; },\n    rollup: function(f) { rollup = f; return nest; }\n  };\n}\n\nfunction createObject() {\n  return {};\n}\n\nfunction setObject(object, key, value) {\n  object[key] = value;\n}\n\nfunction createMap() {\n  return map();\n}\n\nfunction setMap(map, key, value) {\n  map.set(key, value);\n}\n","import {default as map, prefix} from \"./map\";\n\nfunction Set() {}\n\nvar proto = map.prototype;\n\nSet.prototype = set.prototype = {\n  constructor: Set,\n  has: proto.has,\n  add: function(value) {\n    value += \"\";\n    this[prefix + value] = value;\n    return this;\n  },\n  remove: proto.remove,\n  clear: proto.clear,\n  values: proto.keys,\n  size: proto.size,\n  empty: proto.empty,\n  each: proto.each\n};\n\nfunction set(object, f) {\n  var set = new Set;\n\n  // Copy constructor.\n  if (object instanceof Set) object.each(function(value) { set.add(value); });\n\n  // Otherwise, assume its an array.\n  else if (object) {\n    var i = -1, n = object.length;\n    if (f == null) while (++i < n) set.add(object[i]);\n    else while (++i < n) set.add(f(object[i], i, object));\n  }\n\n  return set;\n}\n\nexport default set;\n","export default function(map) {\n  var values = [];\n  for (var key in map) values.push(map[key]);\n  return values;\n}\n","import define, {extend} from \"./define\";\n\nexport function Color() {}\n\nexport var darker = 0.7;\nexport var brighter = 1 / darker;\n\nvar reI = \"\\\\s*([+-]?\\\\d+)\\\\s*\",\n    reN = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*\",\n    reP = \"\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*\",\n    reHex3 = /^#([0-9a-f]{3})$/,\n    reHex6 = /^#([0-9a-f]{6})$/,\n    reRgbInteger = new RegExp(\"^rgb\\\\(\" + [reI, reI, reI] + \"\\\\)$\"),\n    reRgbPercent = new RegExp(\"^rgb\\\\(\" + [reP, reP, reP] + \"\\\\)$\"),\n    reRgbaInteger = new RegExp(\"^rgba\\\\(\" + [reI, reI, reI, reN] + \"\\\\)$\"),\n    reRgbaPercent = new RegExp(\"^rgba\\\\(\" + [reP, reP, reP, reN] + \"\\\\)$\"),\n    reHslPercent = new RegExp(\"^hsl\\\\(\" + [reN, reP, reP] + \"\\\\)$\"),\n    reHslaPercent = new RegExp(\"^hsla\\\\(\" + [reN, reP, reP, reN] + \"\\\\)$\");\n\nvar named = {\n  aliceblue: 0xf0f8ff,\n  antiquewhite: 0xfaebd7,\n  aqua: 0x00ffff,\n  aquamarine: 0x7fffd4,\n  azure: 0xf0ffff,\n  beige: 0xf5f5dc,\n  bisque: 0xffe4c4,\n  black: 0x000000,\n  blanchedalmond: 0xffebcd,\n  blue: 0x0000ff,\n  blueviolet: 0x8a2be2,\n  brown: 0xa52a2a,\n  burlywood: 0xdeb887,\n  cadetblue: 0x5f9ea0,\n  chartreuse: 0x7fff00,\n  chocolate: 0xd2691e,\n  coral: 0xff7f50,\n  cornflowerblue: 0x6495ed,\n  cornsilk: 0xfff8dc,\n  crimson: 0xdc143c,\n  cyan: 0x00ffff,\n  darkblue: 0x00008b,\n  darkcyan: 0x008b8b,\n  darkgoldenrod: 0xb8860b,\n  darkgray: 0xa9a9a9,\n  darkgreen: 0x006400,\n  darkgrey: 0xa9a9a9,\n  darkkhaki: 0xbdb76b,\n  darkmagenta: 0x8b008b,\n  darkolivegreen: 0x556b2f,\n  darkorange: 0xff8c00,\n  darkorchid: 0x9932cc,\n  darkred: 0x8b0000,\n  darksalmon: 0xe9967a,\n  darkseagreen: 0x8fbc8f,\n  darkslateblue: 0x483d8b,\n  darkslategray: 0x2f4f4f,\n  darkslategrey: 0x2f4f4f,\n  darkturquoise: 0x00ced1,\n  darkviolet: 0x9400d3,\n  deeppink: 0xff1493,\n  deepskyblue: 0x00bfff,\n  dimgray: 0x696969,\n  dimgrey: 0x696969,\n  dodgerblue: 0x1e90ff,\n  firebrick: 0xb22222,\n  floralwhite: 0xfffaf0,\n  forestgreen: 0x228b22,\n  fuchsia: 0xff00ff,\n  gainsboro: 0xdcdcdc,\n  ghostwhite: 0xf8f8ff,\n  gold: 0xffd700,\n  goldenrod: 0xdaa520,\n  gray: 0x808080,\n  green: 0x008000,\n  greenyellow: 0xadff2f,\n  grey: 0x808080,\n  honeydew: 0xf0fff0,\n  hotpink: 0xff69b4,\n  indianred: 0xcd5c5c,\n  indigo: 0x4b0082,\n  ivory: 0xfffff0,\n  khaki: 0xf0e68c,\n  lavender: 0xe6e6fa,\n  lavenderblush: 0xfff0f5,\n  lawngreen: 0x7cfc00,\n  lemonchiffon: 0xfffacd,\n  lightblue: 0xadd8e6,\n  lightcoral: 0xf08080,\n  lightcyan: 0xe0ffff,\n  lightgoldenrodyellow: 0xfafad2,\n  lightgray: 0xd3d3d3,\n  lightgreen: 0x90ee90,\n  lightgrey: 0xd3d3d3,\n  lightpink: 0xffb6c1,\n  lightsalmon: 0xffa07a,\n  lightseagreen: 0x20b2aa,\n  lightskyblue: 0x87cefa,\n  lightslategray: 0x778899,\n  lightslategrey: 0x778899,\n  lightsteelblue: 0xb0c4de,\n  lightyellow: 0xffffe0,\n  lime: 0x00ff00,\n  limegreen: 0x32cd32,\n  linen: 0xfaf0e6,\n  magenta: 0xff00ff,\n  maroon: 0x800000,\n  mediumaquamarine: 0x66cdaa,\n  mediumblue: 0x0000cd,\n  mediumorchid: 0xba55d3,\n  mediumpurple: 0x9370db,\n  mediumseagreen: 0x3cb371,\n  mediumslateblue: 0x7b68ee,\n  mediumspringgreen: 0x00fa9a,\n  mediumturquoise: 0x48d1cc,\n  mediumvioletred: 0xc71585,\n  midnightblue: 0x191970,\n  mintcream: 0xf5fffa,\n  mistyrose: 0xffe4e1,\n  moccasin: 0xffe4b5,\n  navajowhite: 0xffdead,\n  navy: 0x000080,\n  oldlace: 0xfdf5e6,\n  olive: 0x808000,\n  olivedrab: 0x6b8e23,\n  orange: 0xffa500,\n  orangered: 0xff4500,\n  orchid: 0xda70d6,\n  palegoldenrod: 0xeee8aa,\n  palegreen: 0x98fb98,\n  paleturquoise: 0xafeeee,\n  palevioletred: 0xdb7093,\n  papayawhip: 0xffefd5,\n  peachpuff: 0xffdab9,\n  peru: 0xcd853f,\n  pink: 0xffc0cb,\n  plum: 0xdda0dd,\n  powderblue: 0xb0e0e6,\n  purple: 0x800080,\n  rebeccapurple: 0x663399,\n  red: 0xff0000,\n  rosybrown: 0xbc8f8f,\n  royalblue: 0x4169e1,\n  saddlebrown: 0x8b4513,\n  salmon: 0xfa8072,\n  sandybrown: 0xf4a460,\n  seagreen: 0x2e8b57,\n  seashell: 0xfff5ee,\n  sienna: 0xa0522d,\n  silver: 0xc0c0c0,\n  skyblue: 0x87ceeb,\n  slateblue: 0x6a5acd,\n  slategray: 0x708090,\n  slategrey: 0x708090,\n  snow: 0xfffafa,\n  springgreen: 0x00ff7f,\n  steelblue: 0x4682b4,\n  tan: 0xd2b48c,\n  teal: 0x008080,\n  thistle: 0xd8bfd8,\n  tomato: 0xff6347,\n  turquoise: 0x40e0d0,\n  violet: 0xee82ee,\n  wheat: 0xf5deb3,\n  white: 0xffffff,\n  whitesmoke: 0xf5f5f5,\n  yellow: 0xffff00,\n  yellowgreen: 0x9acd32\n};\n\ndefine(Color, color, {\n  displayable: function() {\n    return this.rgb().displayable();\n  },\n  hex: function() {\n    return this.rgb().hex();\n  },\n  toString: function() {\n    return this.rgb() + \"\";\n  }\n});\n\nexport default function color(format) {\n  var m;\n  format = (format + \"\").trim().toLowerCase();\n  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00\n      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000\n      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)\n      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)\n      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)\n      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)\n      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)\n      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)\n      : named.hasOwnProperty(format) ? rgbn(named[format])\n      : format === \"transparent\" ? new Rgb(NaN, NaN, NaN, 0)\n      : null;\n}\n\nfunction rgbn(n) {\n  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);\n}\n\nfunction rgba(r, g, b, a) {\n  if (a <= 0) r = g = b = NaN;\n  return new Rgb(r, g, b, a);\n}\n\nexport function rgbConvert(o) {\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Rgb;\n  o = o.rgb();\n  return new Rgb(o.r, o.g, o.b, o.opacity);\n}\n\nexport function rgb(r, g, b, opacity) {\n  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);\n}\n\nexport function Rgb(r, g, b, opacity) {\n  this.r = +r;\n  this.g = +g;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Rgb, rgb, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);\n  },\n  rgb: function() {\n    return this;\n  },\n  displayable: function() {\n    return (0 <= this.r && this.r <= 255)\n        && (0 <= this.g && this.g <= 255)\n        && (0 <= this.b && this.b <= 255)\n        && (0 <= this.opacity && this.opacity <= 1);\n  },\n  hex: function() {\n    return \"#\" + hex(this.r) + hex(this.g) + hex(this.b);\n  },\n  toString: function() {\n    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));\n    return (a === 1 ? \"rgb(\" : \"rgba(\")\n        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + \", \"\n        + Math.max(0, Math.min(255, Math.round(this.b) || 0))\n        + (a === 1 ? \")\" : \", \" + a + \")\");\n  }\n}));\n\nfunction hex(value) {\n  value = Math.max(0, Math.min(255, Math.round(value) || 0));\n  return (value < 16 ? \"0\" : \"\") + value.toString(16);\n}\n\nfunction hsla(h, s, l, a) {\n  if (a <= 0) h = s = l = NaN;\n  else if (l <= 0 || l >= 1) h = s = NaN;\n  else if (s <= 0) h = NaN;\n  return new Hsl(h, s, l, a);\n}\n\nexport function hslConvert(o) {\n  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Color)) o = color(o);\n  if (!o) return new Hsl;\n  if (o instanceof Hsl) return o;\n  o = o.rgb();\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      min = Math.min(r, g, b),\n      max = Math.max(r, g, b),\n      h = NaN,\n      s = max - min,\n      l = (max + min) / 2;\n  if (s) {\n    if (r === max) h = (g - b) / s + (g < b) * 6;\n    else if (g === max) h = (b - r) / s + 2;\n    else h = (r - g) / s + 4;\n    s /= l < 0.5 ? max + min : 2 - max - min;\n    h *= 60;\n  } else {\n    s = l > 0 && l < 1 ? 0 : h;\n  }\n  return new Hsl(h, s, l, o.opacity);\n}\n\nexport function hsl(h, s, l, opacity) {\n  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);\n}\n\nfunction Hsl(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hsl, hsl, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Hsl(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = this.h % 360 + (this.h < 0) * 360,\n        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,\n        l = this.l,\n        m2 = l + (l < 0.5 ? l : 1 - l) * s,\n        m1 = 2 * l - m2;\n    return new Rgb(\n      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),\n      hsl2rgb(h, m1, m2),\n      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),\n      this.opacity\n    );\n  },\n  displayable: function() {\n    return (0 <= this.s && this.s <= 1 || isNaN(this.s))\n        && (0 <= this.l && this.l <= 1)\n        && (0 <= this.opacity && this.opacity <= 1);\n  }\n}));\n\n/* From FvD 13.37, CSS Color Module Level 3 */\nfunction hsl2rgb(h, m1, m2) {\n  return (h < 60 ? m1 + (m2 - m1) * h / 60\n      : h < 180 ? m2\n      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60\n      : m1) * 255;\n}\n","import define, {extend} from \"./define\";\nimport {Color, rgbConvert, Rgb, darker, brighter} from \"./color\";\nimport {deg2rad, rad2deg} from \"./math\";\n\nvar A = -0.14861,\n    B = +1.78277,\n    C = -0.29227,\n    D = -0.90649,\n    E = +1.97294,\n    ED = E * D,\n    EB = E * B,\n    BC_DA = B * C - D * A;\n\nfunction cubehelixConvert(o) {\n  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var r = o.r / 255,\n      g = o.g / 255,\n      b = o.b / 255,\n      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),\n      bl = b - l,\n      k = (E * (g - l) - C * bl) / D,\n      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1\n      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;\n  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);\n}\n\nexport default function cubehelix(h, s, l, opacity) {\n  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);\n}\n\nexport function Cubehelix(h, s, l, opacity) {\n  this.h = +h;\n  this.s = +s;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Cubehelix, cubehelix, extend(Color, {\n  brighter: function(k) {\n    k = k == null ? brighter : Math.pow(brighter, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  darker: function(k) {\n    k = k == null ? darker : Math.pow(darker, k);\n    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);\n  },\n  rgb: function() {\n    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,\n        l = +this.l,\n        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),\n        cosh = Math.cos(h),\n        sinh = Math.sin(h);\n    return new Rgb(\n      255 * (l + a * (A * cosh + B * sinh)),\n      255 * (l + a * (C * cosh + D * sinh)),\n      255 * (l + a * (E * cosh)),\n      this.opacity\n    );\n  }\n}));\n","export default function(constructor, factory, prototype) {\n  constructor.prototype = factory.prototype = prototype;\n  prototype.constructor = constructor;\n}\n\nexport function extend(parent, definition) {\n  var prototype = Object.create(parent.prototype);\n  for (var key in definition) prototype[key] = definition[key];\n  return prototype;\n}\n","export {default as color, rgb, hsl} from \"./color\";\nexport {default as lab, hcl, lch, gray} from \"./lab\";\nexport {default as cubehelix} from \"./cubehelix\";\n","import define, {extend} from \"./define\";\nimport {Color, rgbConvert, Rgb} from \"./color\";\nimport {deg2rad, rad2deg} from \"./math\";\n\n// https://beta.observablehq.com/@mbostock/lab-and-rgb\nvar K = 18,\n    Xn = 0.96422,\n    Yn = 1,\n    Zn = 0.82521,\n    t0 = 4 / 29,\n    t1 = 6 / 29,\n    t2 = 3 * t1 * t1,\n    t3 = t1 * t1 * t1;\n\nfunction labConvert(o) {\n  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);\n  if (o instanceof Hcl) {\n    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);\n    var h = o.h * deg2rad;\n    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);\n  }\n  if (!(o instanceof Rgb)) o = rgbConvert(o);\n  var r = rgb2lrgb(o.r),\n      g = rgb2lrgb(o.g),\n      b = rgb2lrgb(o.b),\n      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;\n  if (r === g && g === b) x = z = y; else {\n    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);\n    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);\n  }\n  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);\n}\n\nexport function gray(l, opacity) {\n  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);\n}\n\nexport default function lab(l, a, b, opacity) {\n  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);\n}\n\nexport function Lab(l, a, b, opacity) {\n  this.l = +l;\n  this.a = +a;\n  this.b = +b;\n  this.opacity = +opacity;\n}\n\ndefine(Lab, lab, extend(Color, {\n  brighter: function(k) {\n    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  darker: function(k) {\n    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);\n  },\n  rgb: function() {\n    var y = (this.l + 16) / 116,\n        x = isNaN(this.a) ? y : y + this.a / 500,\n        z = isNaN(this.b) ? y : y - this.b / 200;\n    x = Xn * lab2xyz(x);\n    y = Yn * lab2xyz(y);\n    z = Zn * lab2xyz(z);\n    return new Rgb(\n      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),\n      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),\n      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),\n      this.opacity\n    );\n  }\n}));\n\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction lrgb2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2lrgb(x) {\n  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\nfunction hclConvert(o) {\n  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);\n  if (!(o instanceof Lab)) o = labConvert(o);\n  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);\n  var h = Math.atan2(o.b, o.a) * rad2deg;\n  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);\n}\n\nexport function lch(l, c, h, opacity) {\n  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);\n}\n\nexport function hcl(h, c, l, opacity) {\n  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);\n}\n\nexport function Hcl(h, c, l, opacity) {\n  this.h = +h;\n  this.c = +c;\n  this.l = +l;\n  this.opacity = +opacity;\n}\n\ndefine(Hcl, hcl, extend(Color, {\n  brighter: function(k) {\n    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);\n  },\n  darker: function(k) {\n    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);\n  },\n  rgb: function() {\n    return labConvert(this).rgb();\n  }\n}));\n","export var deg2rad = Math.PI / 180;\nexport var rad2deg = 180 / Math.PI;\n","export default function(ring) {\n  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];\n  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];\n  return area;\n}\n","var array = Array.prototype;\n\nexport var slice = array.slice;\n","export default function(a, b) {\n  return a - b;\n}\n","// TODO Optimize edge cases.\n// TODO Optimize index calculation.\n// TODO Optimize arguments.\nexport function blurX(source, target, r) {\n  var n = source.width,\n      m = source.height,\n      w = (r << 1) + 1;\n  for (var j = 0; j < m; ++j) {\n    for (var i = 0, sr = 0; i < n + r; ++i) {\n      if (i < n) {\n        sr += source.data[i + j * n];\n      }\n      if (i >= r) {\n        if (i >= w) {\n          sr -= source.data[i - w + j * n];\n        }\n        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);\n      }\n    }\n  }\n}\n\n// TODO Optimize edge cases.\n// TODO Optimize index calculation.\n// TODO Optimize arguments.\nexport function blurY(source, target, r) {\n  var n = source.width,\n      m = source.height,\n      w = (r << 1) + 1;\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0, sr = 0; j < m + r; ++j) {\n      if (j < m) {\n        sr += source.data[i + j * n];\n      }\n      if (j >= r) {\n        if (j >= w) {\n          sr -= source.data[i + (j - w) * n];\n        }\n        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);\n      }\n    }\n  }\n}\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","export default function(ring, hole) {\n  var i = -1, n = hole.length, c;\n  while (++i < n) if (c = ringContains(ring, hole[i])) return c;\n  return 0;\n}\n\nfunction ringContains(ring, point) {\n  var x = point[0], y = point[1], contains = -1;\n  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {\n    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];\n    if (segmentContains(pi, pj, point)) return 0;\n    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;\n  }\n  return contains;\n}\n\nfunction segmentContains(a, b, c) {\n  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);\n}\n\nfunction collinear(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);\n}\n\nfunction within(p, q, r) {\n  return p <= q && q <= r || r <= q && q <= p;\n}\n","import {extent, thresholdSturges, tickStep, range} from \"d3-array\";\nimport {slice} from \"./array\";\nimport ascending from \"./ascending\";\nimport area from \"./area\";\nimport constant from \"./constant\";\nimport contains from \"./contains\";\nimport noop from \"./noop\";\n\nvar cases = [\n  [],\n  [[[1.0, 1.5], [0.5, 1.0]]],\n  [[[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [0.5, 1.0]]],\n  [[[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],\n  [[[1.0, 0.5], [1.0, 1.5]]],\n  [[[1.0, 0.5], [0.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 0.5]]],\n  [[[1.0, 1.5], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],\n  [[[1.5, 1.0], [1.0, 0.5]]],\n  [[[0.5, 1.0], [1.5, 1.0]]],\n  [[[1.0, 1.5], [1.5, 1.0]]],\n  [[[0.5, 1.0], [1.0, 1.5]]],\n  []\n];\n\nexport default function() {\n  var dx = 1,\n      dy = 1,\n      threshold = thresholdSturges,\n      smooth = smoothLinear;\n\n  function contours(values) {\n    var tz = threshold(values);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      var domain = extent(values), start = domain[0], stop = domain[1];\n      tz = tickStep(start, stop, tz);\n      tz = range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);\n    } else {\n      tz = tz.slice().sort(ascending);\n    }\n\n    return tz.map(function(value) {\n      return contour(values, value);\n    });\n  }\n\n  // Accumulate, smooth contour rings, assign holes to exterior rings.\n  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js\n  function contour(values, value) {\n    var polygons = [],\n        holes = [];\n\n    isorings(values, value, function(ring) {\n      smooth(ring, values, value);\n      if (area(ring) > 0) polygons.push([ring]);\n      else holes.push(ring);\n    });\n\n    holes.forEach(function(hole) {\n      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {\n        if (contains((polygon = polygons[i])[0], hole) !== -1) {\n          polygon.push(hole);\n          return;\n        }\n      }\n    });\n\n    return {\n      type: \"MultiPolygon\",\n      value: value,\n      coordinates: polygons\n    };\n  }\n\n  // Marching squares with isolines stitched into rings.\n  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js\n  function isorings(values, value, callback) {\n    var fragmentByStart = new Array,\n        fragmentByEnd = new Array,\n        x, y, t0, t1, t2, t3;\n\n    // Special case for the first row (y = -1, t2 = t3 = 0).\n    x = y = -1;\n    t1 = values[0] >= value;\n    cases[t1 << 1].forEach(stitch);\n    while (++x < dx - 1) {\n      t0 = t1, t1 = values[x + 1] >= value;\n      cases[t0 | t1 << 1].forEach(stitch);\n    }\n    cases[t1 << 0].forEach(stitch);\n\n    // General case for the intermediate rows.\n    while (++y < dy - 1) {\n      x = -1;\n      t1 = values[y * dx + dx] >= value;\n      t2 = values[y * dx] >= value;\n      cases[t1 << 1 | t2 << 2].forEach(stitch);\n      while (++x < dx - 1) {\n        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;\n        t3 = t2, t2 = values[y * dx + x + 1] >= value;\n        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);\n      }\n      cases[t1 | t2 << 3].forEach(stitch);\n    }\n\n    // Special case for the last row (y = dy - 1, t0 = t1 = 0).\n    x = -1;\n    t2 = values[y * dx] >= value;\n    cases[t2 << 2].forEach(stitch);\n    while (++x < dx - 1) {\n      t3 = t2, t2 = values[y * dx + x + 1] >= value;\n      cases[t2 << 2 | t3 << 3].forEach(stitch);\n    }\n    cases[t2 << 3].forEach(stitch);\n\n    function stitch(line) {\n      var start = [line[0][0] + x, line[0][1] + y],\n          end = [line[1][0] + x, line[1][1] + y],\n          startIndex = index(start),\n          endIndex = index(end),\n          f, g;\n      if (f = fragmentByEnd[startIndex]) {\n        if (g = fragmentByStart[endIndex]) {\n          delete fragmentByEnd[f.end];\n          delete fragmentByStart[g.start];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};\n          }\n        } else {\n          delete fragmentByEnd[f.end];\n          f.ring.push(end);\n          fragmentByEnd[f.end = endIndex] = f;\n        }\n      } else if (f = fragmentByStart[endIndex]) {\n        if (g = fragmentByEnd[startIndex]) {\n          delete fragmentByStart[f.start];\n          delete fragmentByEnd[g.end];\n          if (f === g) {\n            f.ring.push(end);\n            callback(f.ring);\n          } else {\n            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};\n          }\n        } else {\n          delete fragmentByStart[f.start];\n          f.ring.unshift(start);\n          fragmentByStart[f.start = startIndex] = f;\n        }\n      } else {\n        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};\n      }\n    }\n  }\n\n  function index(point) {\n    return point[0] * 2 + point[1] * (dx + 1) * 4;\n  }\n\n  function smoothLinear(ring, values, value) {\n    ring.forEach(function(point) {\n      var x = point[0],\n          y = point[1],\n          xt = x | 0,\n          yt = y | 0,\n          v0,\n          v1 = values[yt * dx + xt];\n      if (x > 0 && x < dx && xt === x) {\n        v0 = values[yt * dx + xt - 1];\n        point[0] = x + (value - v0) / (v1 - v0) - 0.5;\n      }\n      if (y > 0 && y < dy && yt === y) {\n        v0 = values[(yt - 1) * dx + xt];\n        point[1] = y + (value - v0) / (v1 - v0) - 0.5;\n      }\n    });\n  }\n\n  contours.contour = contour;\n\n  contours.size = function(_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);\n    if (!(_0 > 0) || !(_1 > 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, contours;\n  };\n\n  contours.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;\n  };\n\n  contours.smooth = function(_) {\n    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;\n  };\n\n  return contours;\n}\n","import {max, range, tickStep} from \"d3-array\";\nimport {slice} from \"./array\";\nimport {blurX, blurY} from \"./blur\";\nimport constant from \"./constant\";\nimport contours from \"./contours\";\n\nfunction defaultX(d) {\n  return d[0];\n}\n\nfunction defaultY(d) {\n  return d[1];\n}\n\nfunction defaultWeight() {\n  return 1;\n}\n\nexport default function() {\n  var x = defaultX,\n      y = defaultY,\n      weight = defaultWeight,\n      dx = 960,\n      dy = 500,\n      r = 20, // blur radius\n      k = 2, // log2(grid cell size)\n      o = r * 3, // grid offset, to pad for blur\n      n = (dx + o * 2) >> k, // grid width\n      m = (dy + o * 2) >> k, // grid height\n      threshold = constant(20);\n\n  function density(data) {\n    var values0 = new Float32Array(n * m),\n        values1 = new Float32Array(n * m);\n\n    data.forEach(function(d, i, data) {\n      var xi = (+x(d, i, data) + o) >> k,\n          yi = (+y(d, i, data) + o) >> k,\n          wi = +weight(d, i, data);\n      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {\n        values0[xi + yi * n] += wi;\n      }\n    });\n\n    // TODO Optimize.\n    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);\n    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);\n    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);\n    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);\n    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);\n    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);\n\n    var tz = threshold(values0);\n\n    // Convert number of thresholds into uniform thresholds.\n    if (!Array.isArray(tz)) {\n      var stop = max(values0);\n      tz = tickStep(0, stop, tz);\n      tz = range(0, Math.floor(stop / tz) * tz, tz);\n      tz.shift();\n    }\n\n    return contours()\n        .thresholds(tz)\n        .size([n, m])\n      (values0)\n        .map(transform);\n  }\n\n  function transform(geometry) {\n    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.\n    geometry.coordinates.forEach(transformPolygon);\n    return geometry;\n  }\n\n  function transformPolygon(coordinates) {\n    coordinates.forEach(transformRing);\n  }\n\n  function transformRing(coordinates) {\n    coordinates.forEach(transformPoint);\n  }\n\n  // TODO Optimize.\n  function transformPoint(coordinates) {\n    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;\n    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;\n  }\n\n  function resize() {\n    o = r * 3;\n    n = (dx + o * 2) >> k;\n    m = (dy + o * 2) >> k;\n    return density;\n  }\n\n  density.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), density) : x;\n  };\n\n  density.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), density) : y;\n  };\n\n  density.weight = function(_) {\n    return arguments.length ? (weight = typeof _ === \"function\" ? _ : constant(+_), density) : weight;\n  };\n\n  density.size = function(_) {\n    if (!arguments.length) return [dx, dy];\n    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);\n    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error(\"invalid size\");\n    return dx = _0, dy = _1, resize();\n  };\n\n  density.cellSize = function(_) {\n    if (!arguments.length) return 1 << k;\n    if (!((_ = +_) >= 1)) throw new Error(\"invalid cell size\");\n    return k = Math.floor(Math.log(_) / Math.LN2), resize();\n  };\n\n  density.thresholds = function(_) {\n    return arguments.length ? (threshold = typeof _ === \"function\" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;\n  };\n\n  density.bandwidth = function(_) {\n    if (!arguments.length) return Math.sqrt(r * (r + 1));\n    if (!((_ = +_) >= 0)) throw new Error(\"invalid bandwidth\");\n    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();\n  };\n\n  return density;\n}\n","export {default as contours} from \"./contours\";\nexport {default as contourDensity} from \"./density\";\n","export default function() {}\n","var noop = {value: function() {}};\n\nfunction dispatch() {\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\n    if (!(t = arguments[i] + \"\") || (t in _)) throw new Error(\"illegal type: \" + t);\n    _[t] = [];\n  }\n  return new Dispatch(_);\n}\n\nfunction Dispatch(_) {\n  this._ = _;\n}\n\nfunction parseTypenames(typenames, types) {\n  return typenames.trim().split(/^|\\s+/).map(function(t) {\n    var name = \"\", i = t.indexOf(\".\");\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\n    if (t && !types.hasOwnProperty(t)) throw new Error(\"unknown type: \" + t);\n    return {type: t, name: name};\n  });\n}\n\nDispatch.prototype = dispatch.prototype = {\n  constructor: Dispatch,\n  on: function(typename, callback) {\n    var _ = this._,\n        T = parseTypenames(typename + \"\", _),\n        t,\n        i = -1,\n        n = T.length;\n\n    // If no callback was specified, return the callback of the given type and name.\n    if (arguments.length < 2) {\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\n      return;\n    }\n\n    // If a type was specified, set the callback for the given type and name.\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\n    if (callback != null && typeof callback !== \"function\") throw new Error(\"invalid callback: \" + callback);\n    while (++i < n) {\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\n      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\n    }\n\n    return this;\n  },\n  copy: function() {\n    var copy = {}, _ = this._;\n    for (var t in _) copy[t] = _[t].slice();\n    return new Dispatch(copy);\n  },\n  call: function(type, that) {\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  },\n  apply: function(type, that, args) {\n    if (!this._.hasOwnProperty(type)) throw new Error(\"unknown type: \" + type);\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\n  }\n};\n\nfunction get(type, name) {\n  for (var i = 0, n = type.length, c; i < n; ++i) {\n    if ((c = type[i]).name === name) {\n      return c.value;\n    }\n  }\n}\n\nfunction set(type, name, callback) {\n  for (var i = 0, n = type.length; i < n; ++i) {\n    if (type[i].name === name) {\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\n      break;\n    }\n  }\n  if (callback != null) type.push({name: name, value: callback});\n  return type;\n}\n\nexport default dispatch;\n","export {default as dispatch} from \"./dispatch\";\n","import dsv from \"./dsv\";\n\nvar csv = dsv(\",\");\n\nexport var csvParse = csv.parse;\nexport var csvParseRows = csv.parseRows;\nexport var csvFormat = csv.format;\nexport var csvFormatRows = csv.formatRows;\n","var EOL = {},\n    EOF = {},\n    QUOTE = 34,\n    NEWLINE = 10,\n    RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nexport default function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns || [];\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n}\n","export {default as dsvFormat} from \"./dsv\";\nexport {csvParse, csvParseRows, csvFormat, csvFormatRows} from \"./csv\";\nexport {tsvParse, tsvParseRows, tsvFormat, tsvFormatRows} from \"./tsv\";\n","import dsv from \"./dsv\";\n\nvar tsv = dsv(\"\\t\");\n\nexport var tsvParse = tsv.parse;\nexport var tsvParseRows = tsv.parseRows;\nexport var tsvFormat = tsv.format;\nexport var tsvFormatRows = tsv.formatRows;\n","export default function(x, y) {\n  var nodes;\n\n  if (x == null) x = 0;\n  if (y == null) y = 0;\n\n  function force() {\n    var i,\n        n = nodes.length,\n        node,\n        sx = 0,\n        sy = 0;\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], sx += node.x, sy += node.y;\n    }\n\n    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {\n      node = nodes[i], node.x -= sx, node.y -= sy;\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = +_, force) : x;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = +_, force) : y;\n  };\n\n  return force;\n}\n","import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport {quadtree} from \"d3-quadtree\";\n\nfunction x(d) {\n  return d.x + d.vx;\n}\n\nfunction y(d) {\n  return d.y + d.vy;\n}\n\nexport default function(radius) {\n  var nodes,\n      radii,\n      strength = 1,\n      iterations = 1;\n\n  if (typeof radius !== \"function\") radius = constant(radius == null ? 1 : +radius);\n\n  function force() {\n    var i, n = nodes.length,\n        tree,\n        node,\n        xi,\n        yi,\n        ri,\n        ri2;\n\n    for (var k = 0; k < iterations; ++k) {\n      tree = quadtree(nodes, x, y).visitAfter(prepare);\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        ri = radii[node.index], ri2 = ri * ri;\n        xi = node.x + node.vx;\n        yi = node.y + node.vy;\n        tree.visit(apply);\n      }\n    }\n\n    function apply(quad, x0, y0, x1, y1) {\n      var data = quad.data, rj = quad.r, r = ri + rj;\n      if (data) {\n        if (data.index > node.index) {\n          var x = xi - data.x - data.vx,\n              y = yi - data.y - data.vy,\n              l = x * x + y * y;\n          if (l < r * r) {\n            if (x === 0) x = jiggle(), l += x * x;\n            if (y === 0) y = jiggle(), l += y * y;\n            l = (r - (l = Math.sqrt(l))) / l * strength;\n            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));\n            node.vy += (y *= l) * r;\n            data.vx -= x * (r = 1 - r);\n            data.vy -= y * r;\n          }\n        }\n        return;\n      }\n      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;\n    }\n  }\n\n  function prepare(quad) {\n    if (quad.data) return quad.r = radii[quad.data.index];\n    for (var i = quad.r = 0; i < 4; ++i) {\n      if (quad[i] && quad[i].r > quad.r) {\n        quad.r = quad[i].r;\n      }\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    radii = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.iterations = function(_) {\n    return arguments.length ? (iterations = +_, force) : iterations;\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = +_, force) : strength;\n  };\n\n  force.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : radius;\n  };\n\n  return force;\n}\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","export {default as forceCenter} from \"./center\";\nexport {default as forceCollide} from \"./collide\";\nexport {default as forceLink} from \"./link\";\nexport {default as forceManyBody} from \"./manyBody\";\nexport {default as forceRadial} from \"./radial\";\nexport {default as forceSimulation} from \"./simulation\";\nexport {default as forceX} from \"./x\";\nexport {default as forceY} from \"./y\";\n","export default function() {\n  return (Math.random() - 0.5) * 1e-6;\n}\n","import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport {map} from \"d3-collection\";\n\nfunction index(d) {\n  return d.index;\n}\n\nfunction find(nodeById, nodeId) {\n  var node = nodeById.get(nodeId);\n  if (!node) throw new Error(\"missing: \" + nodeId);\n  return node;\n}\n\nexport default function(links) {\n  var id = index,\n      strength = defaultStrength,\n      strengths,\n      distance = constant(30),\n      distances,\n      nodes,\n      count,\n      bias,\n      iterations = 1;\n\n  if (links == null) links = [];\n\n  function defaultStrength(link) {\n    return 1 / Math.min(count[link.source.index], count[link.target.index]);\n  }\n\n  function force(alpha) {\n    for (var k = 0, n = links.length; k < iterations; ++k) {\n      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {\n        link = links[i], source = link.source, target = link.target;\n        x = target.x + target.vx - source.x - source.vx || jiggle();\n        y = target.y + target.vy - source.y - source.vy || jiggle();\n        l = Math.sqrt(x * x + y * y);\n        l = (l - distances[i]) / l * alpha * strengths[i];\n        x *= l, y *= l;\n        target.vx -= x * (b = bias[i]);\n        target.vy -= y * b;\n        source.vx += x * (b = 1 - b);\n        source.vy += y * b;\n      }\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n\n    var i,\n        n = nodes.length,\n        m = links.length,\n        nodeById = map(nodes, id),\n        link;\n\n    for (i = 0, count = new Array(n); i < m; ++i) {\n      link = links[i], link.index = i;\n      if (typeof link.source !== \"object\") link.source = find(nodeById, link.source);\n      if (typeof link.target !== \"object\") link.target = find(nodeById, link.target);\n      count[link.source.index] = (count[link.source.index] || 0) + 1;\n      count[link.target.index] = (count[link.target.index] || 0) + 1;\n    }\n\n    for (i = 0, bias = new Array(m); i < m; ++i) {\n      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);\n    }\n\n    strengths = new Array(m), initializeStrength();\n    distances = new Array(m), initializeDistance();\n  }\n\n  function initializeStrength() {\n    if (!nodes) return;\n\n    for (var i = 0, n = links.length; i < n; ++i) {\n      strengths[i] = +strength(links[i], i, links);\n    }\n  }\n\n  function initializeDistance() {\n    if (!nodes) return;\n\n    for (var i = 0, n = links.length; i < n; ++i) {\n      distances[i] = +distance(links[i], i, links);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.links = function(_) {\n    return arguments.length ? (links = _, initialize(), force) : links;\n  };\n\n  force.id = function(_) {\n    return arguments.length ? (id = _, force) : id;\n  };\n\n  force.iterations = function(_) {\n    return arguments.length ? (iterations = +_, force) : iterations;\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initializeStrength(), force) : strength;\n  };\n\n  force.distance = function(_) {\n    return arguments.length ? (distance = typeof _ === \"function\" ? _ : constant(+_), initializeDistance(), force) : distance;\n  };\n\n  return force;\n}\n","import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport {quadtree} from \"d3-quadtree\";\nimport {x, y} from \"./simulation\";\n\nexport default function() {\n  var nodes,\n      node,\n      alpha,\n      strength = constant(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i, n = nodes.length, tree = quadtree(nodes, x, y).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n  }\n\n  function accumulate(quad) {\n    var strength = 0, q, c, weight = 0, x, y, i;\n\n    // For internal nodes, accumulate forces from child quadrants.\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = Math.abs(q.value))) {\n          strength += q.value, weight += c, x += c * q.x, y += c * q.y;\n        }\n      }\n      quad.x = x / weight;\n      quad.y = y / weight;\n    }\n\n    // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do strength += strengths[q.data.index];\n      while (q = q.next);\n    }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n\n    var x = quad.x - node.x,\n        y = quad.y - node.y,\n        w = x2 - x1,\n        l = x * x + y * y;\n\n    // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n      return true;\n    }\n\n    // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return;\n\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x * w;\n      node.vy += y * w;\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n}\n","import constant from \"./constant\";\n\nexport default function(radius, x, y) {\n  var nodes,\n      strength = constant(0.1),\n      strengths,\n      radiuses;\n\n  if (typeof radius !== \"function\") radius = constant(+radius);\n  if (x == null) x = 0;\n  if (y == null) y = 0;\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length; i < n; ++i) {\n      var node = nodes[i],\n          dx = node.x - x || 1e-6,\n          dy = node.y - y || 1e-6,\n          r = Math.sqrt(dx * dx + dy * dy),\n          k = (radiuses[i] - r) * strengths[i] * alpha / r;\n      node.vx += dx * k;\n      node.vy += dy * k;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    radiuses = new Array(n);\n    for (i = 0; i < n; ++i) {\n      radiuses[i] = +radius(nodes[i], i, nodes);\n      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _, initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : radius;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = +_, force) : x;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = +_, force) : y;\n  };\n\n  return force;\n}\n","import {dispatch} from \"d3-dispatch\";\nimport {map} from \"d3-collection\";\nimport {timer} from \"d3-timer\";\n\nexport function x(d) {\n  return d.x;\n}\n\nexport function y(d) {\n  return d.y;\n}\n\nvar initialRadius = 10,\n    initialAngle = Math.PI * (3 - Math.sqrt(5));\n\nexport default function(nodes) {\n  var simulation,\n      alpha = 1,\n      alphaMin = 0.001,\n      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),\n      alphaTarget = 0,\n      velocityDecay = 0.6,\n      forces = map(),\n      stepper = timer(step),\n      event = dispatch(\"tick\", \"end\");\n\n  if (nodes == null) nodes = [];\n\n  function step() {\n    tick();\n    event.call(\"tick\", simulation);\n    if (alpha < alphaMin) {\n      stepper.stop();\n      event.call(\"end\", simulation);\n    }\n  }\n\n  function tick() {\n    var i, n = nodes.length, node;\n\n    alpha += (alphaTarget - alpha) * alphaDecay;\n\n    forces.each(function(force) {\n      force(alpha);\n    });\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i];\n      if (node.fx == null) node.x += node.vx *= velocityDecay;\n      else node.x = node.fx, node.vx = 0;\n      if (node.fy == null) node.y += node.vy *= velocityDecay;\n      else node.y = node.fy, node.vy = 0;\n    }\n  }\n\n  function initializeNodes() {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.index = i;\n      if (isNaN(node.x) || isNaN(node.y)) {\n        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;\n        node.x = radius * Math.cos(angle);\n        node.y = radius * Math.sin(angle);\n      }\n      if (isNaN(node.vx) || isNaN(node.vy)) {\n        node.vx = node.vy = 0;\n      }\n    }\n  }\n\n  function initializeForce(force) {\n    if (force.initialize) force.initialize(nodes);\n    return force;\n  }\n\n  initializeNodes();\n\n  return simulation = {\n    tick: tick,\n\n    restart: function() {\n      return stepper.restart(step), simulation;\n    },\n\n    stop: function() {\n      return stepper.stop(), simulation;\n    },\n\n    nodes: function(_) {\n      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;\n    },\n\n    alpha: function(_) {\n      return arguments.length ? (alpha = +_, simulation) : alpha;\n    },\n\n    alphaMin: function(_) {\n      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;\n    },\n\n    alphaDecay: function(_) {\n      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;\n    },\n\n    alphaTarget: function(_) {\n      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;\n    },\n\n    velocityDecay: function(_) {\n      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;\n    },\n\n    force: function(name, _) {\n      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);\n    },\n\n    find: function(x, y, radius) {\n      var i = 0,\n          n = nodes.length,\n          dx,\n          dy,\n          d2,\n          node,\n          closest;\n\n      if (radius == null) radius = Infinity;\n      else radius *= radius;\n\n      for (i = 0; i < n; ++i) {\n        node = nodes[i];\n        dx = x - node.x;\n        dy = y - node.y;\n        d2 = dx * dx + dy * dy;\n        if (d2 < radius) closest = node, radius = d2;\n      }\n\n      return closest;\n    },\n\n    on: function(name, _) {\n      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);\n    }\n  };\n}\n","import constant from \"./constant\";\n\nexport default function(x) {\n  var strength = constant(0.1),\n      nodes,\n      strengths,\n      xz;\n\n  if (typeof x !== \"function\") x = constant(x == null ? 0 : +x);\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    xz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : x;\n  };\n\n  return force;\n}\n","import constant from \"./constant\";\n\nexport default function(y) {\n  var strength = constant(0.1),\n      nodes,\n      strengths,\n      yz;\n\n  if (typeof y !== \"function\") y = constant(y == null ? 0 : +y);\n\n  function force(alpha) {\n    for (var i = 0, n = nodes.length, node; i < n; ++i) {\n      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;\n    }\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length;\n    strengths = new Array(n);\n    yz = new Array(n);\n    for (i = 0; i < n; ++i) {\n      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);\n    }\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : y;\n  };\n\n  return force;\n}\n","import formatLocale from \"./locale\";\n\nvar locale;\nexport var format;\nexport var formatPrefix;\n\ndefaultLocale({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"]\n});\n\nexport default function defaultLocale(definition) {\n  locale = formatLocale(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n","import formatDecimal from \"./formatDecimal\";\n\nexport default function(x) {\n  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;\n}\n","// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimal(1.23) returns [\"123\", 0].\nexport default function(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n}\n","export default function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n}\n","export default function(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n","import formatDecimal from \"./formatDecimal\";\n\nexport var prefixExponent;\n\nexport default function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n}\n","import formatDecimal from \"./formatDecimal\";\n\nexport default function(x, p) {\n  var d = formatDecimal(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n}\n","// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\n\nexport default function formatSpecifier(specifier) {\n  return new FormatSpecifier(specifier);\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nfunction FormatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n  var match;\n  this.fill = match[1] || \" \";\n  this.align = match[2] || \">\";\n  this.sign = match[3] || \"-\";\n  this.symbol = match[4] || \"\";\n  this.zero = !!match[5];\n  this.width = match[6] && +match[6];\n  this.comma = !!match[7];\n  this.precision = match[8] && +match[8].slice(1);\n  this.trim = !!match[9];\n  this.type = match[10] || \"\";\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width == null ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision == null ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + (this.trim ? \"~\" : \"\")\n      + this.type;\n};\n","// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nexport default function(s) {\n  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (s[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;\n    }\n  }\n  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\n","import formatPrefixAuto from \"./formatPrefixAuto\";\nimport formatRounded from \"./formatRounded\";\n\nexport default {\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": function(x) { return Math.round(x).toString(10); },\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n","export default function(x) {\n  return x;\n}\n","export {default as formatDefaultLocale, format, formatPrefix} from \"./defaultLocale\";\nexport {default as formatLocale} from \"./locale\";\nexport {default as formatSpecifier} from \"./formatSpecifier\";\nexport {default as precisionFixed} from \"./precisionFixed\";\nexport {default as precisionPrefix} from \"./precisionPrefix\";\nexport {default as precisionRound} from \"./precisionRound\";\n","import exponent from \"./exponent\";\nimport formatGroup from \"./formatGroup\";\nimport formatNumerals from \"./formatNumerals\";\nimport formatSpecifier from \"./formatSpecifier\";\nimport formatTrim from \"./formatTrim\";\nimport formatTypes from \"./formatTypes\";\nimport {prefixExponent} from \"./formatPrefixAuto\";\nimport identity from \"./identity\";\n\nvar prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nexport default function(locale) {\n  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,\n      currency = locale.currency,\n      decimal = locale.decimal,\n      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,\n      percent = locale.percent || \"%\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        trim = specifier.trim,\n        type = specifier.type;\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // The \"\" type, and any invalid type, is an alias for \".12~g\".\n    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = \"g\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currency[0] : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currency[1] : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision == null ? 6\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Perform the initial formatting.\n        var valueNegative = value < 0;\n        value = formatType(Math.abs(value), precision);\n\n        // Trim insignificant zeros.\n        if (trim) value = formatTrim(value);\n\n        // If a negative value rounds to zero during formatting, treat as positive.\n        if (valueNegative && +value === 0) valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : \"-\") : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer value part that can be\n        // grouped, and fractional or exponential suffix part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}\n","import exponent from \"./exponent\";\n\nexport default function(step) {\n  return Math.max(0, -exponent(Math.abs(step)));\n}\n","import exponent from \"./exponent\";\n\nexport default function(step, value) {\n  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));\n}\n","import exponent from \"./exponent\";\n\nexport default function(step, max) {\n  step = Math.abs(step), max = Math.abs(max) - step;\n  return Math.max(0, exponent(max) - exponent(step)) + 1;\n}\n","// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\n\nexport default function() {\n  return new Adder;\n}\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function(y) {\n    add(temp, y, this.t);\n    add(this, temp.s, this.s);\n    if (this.s) this.t += temp.t;\n    else this.s = temp.t;\n  },\n  valueOf: function() {\n    return this.s;\n  }\n};\n\nvar temp = new Adder;\n\nfunction add(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = (a - av) + (b - bv);\n}\n","import adder from \"./adder\";\nimport {atan2, cos, quarterPi, radians, sin, tau} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nexport var areaRingSum = adder();\n\nvar areaSum = adder(),\n    lambda00,\n    phi00,\n    lambda0,\n    cosPhi0,\n    sinPhi0;\n\nexport var areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaRingSum.reset();\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    var areaRing = +areaRingSum;\n    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);\n    this.lineStart = this.lineEnd = this.point = noop;\n  },\n  sphere: function() {\n    areaSum.add(tau);\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaRingEnd() {\n  areaPoint(lambda00, phi00);\n}\n\nfunction areaPointFirst(lambda, phi) {\n  areaStream.point = areaPoint;\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);\n}\n\nfunction areaPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  phi = phi / 2 + quarterPi; // half the angular distance from south pole\n\n  // Spherical excess E for a spherical triangle with vertices: south pole,\n  // previous point, current point.  Uses a formula derived from Cagnolis\n  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).\n  var dLambda = lambda - lambda0,\n      sdLambda = dLambda >= 0 ? 1 : -1,\n      adLambda = sdLambda * dLambda,\n      cosPhi = cos(phi),\n      sinPhi = sin(phi),\n      k = sinPhi0 * sinPhi,\n      u = cosPhi0 * cosPhi + k * cos(adLambda),\n      v = k * sdLambda * sin(adLambda);\n  areaRingSum.add(atan2(v, u));\n\n  // Advance the previous points.\n  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;\n}\n\nexport default function(object) {\n  areaSum.reset();\n  stream(object, areaStream);\n  return areaSum * 2;\n}\n","import adder from \"./adder\";\nimport {areaStream, areaRingSum} from \"./area\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport {abs, degrees, epsilon, radians} from \"./math\";\nimport stream from \"./stream\";\n\nvar lambda0, phi0, lambda1, phi1, // bounds\n    lambda2, // previous lambda-coordinate\n    lambda00, phi00, // first point\n    p0, // previous 3D point\n    deltaSum = adder(),\n    ranges,\n    range;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: boundsLineStart,\n  lineEnd: boundsLineEnd,\n  polygonStart: function() {\n    boundsStream.point = boundsRingPoint;\n    boundsStream.lineStart = boundsRingStart;\n    boundsStream.lineEnd = boundsRingEnd;\n    deltaSum.reset();\n    areaStream.polygonStart();\n  },\n  polygonEnd: function() {\n    areaStream.polygonEnd();\n    boundsStream.point = boundsPoint;\n    boundsStream.lineStart = boundsLineStart;\n    boundsStream.lineEnd = boundsLineEnd;\n    if (areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);\n    else if (deltaSum > epsilon) phi1 = 90;\n    else if (deltaSum < -epsilon) phi0 = -90;\n    range[0] = lambda0, range[1] = lambda1;\n  }\n};\n\nfunction boundsPoint(lambda, phi) {\n  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n}\n\nfunction linePoint(lambda, phi) {\n  var p = cartesian([lambda * radians, phi * radians]);\n  if (p0) {\n    var normal = cartesianCross(p0, p),\n        equatorial = [normal[1], -normal[0], 0],\n        inflection = cartesianCross(equatorial, normal);\n    cartesianNormalizeInPlace(inflection);\n    inflection = spherical(inflection);\n    var delta = lambda - lambda2,\n        sign = delta > 0 ? 1 : -1,\n        lambdai = inflection[0] * degrees * sign,\n        phii,\n        antimeridian = abs(delta) > 180;\n    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = inflection[1] * degrees;\n      if (phii > phi1) phi1 = phii;\n    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {\n      phii = -inflection[1] * degrees;\n      if (phii < phi0) phi0 = phii;\n    } else {\n      if (phi < phi0) phi0 = phi;\n      if (phi > phi1) phi1 = phi;\n    }\n    if (antimeridian) {\n      if (lambda < lambda2) {\n        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n      } else {\n        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n      }\n    } else {\n      if (lambda1 >= lambda0) {\n        if (lambda < lambda0) lambda0 = lambda;\n        if (lambda > lambda1) lambda1 = lambda;\n      } else {\n        if (lambda > lambda2) {\n          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;\n        } else {\n          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;\n        }\n      }\n    }\n  } else {\n    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);\n  }\n  if (phi < phi0) phi0 = phi;\n  if (phi > phi1) phi1 = phi;\n  p0 = p, lambda2 = lambda;\n}\n\nfunction boundsLineStart() {\n  boundsStream.point = linePoint;\n}\n\nfunction boundsLineEnd() {\n  range[0] = lambda0, range[1] = lambda1;\n  boundsStream.point = boundsPoint;\n  p0 = null;\n}\n\nfunction boundsRingPoint(lambda, phi) {\n  if (p0) {\n    var delta = lambda - lambda2;\n    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);\n  } else {\n    lambda00 = lambda, phi00 = phi;\n  }\n  areaStream.point(lambda, phi);\n  linePoint(lambda, phi);\n}\n\nfunction boundsRingStart() {\n  areaStream.lineStart();\n}\n\nfunction boundsRingEnd() {\n  boundsRingPoint(lambda00, phi00);\n  areaStream.lineEnd();\n  if (abs(deltaSum) > epsilon) lambda0 = -(lambda1 = 180);\n  range[0] = lambda0, range[1] = lambda1;\n  p0 = null;\n}\n\n// Finds the left-right distance between two longitudes.\n// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want\n// the distance between 180 to be 360.\nfunction angle(lambda0, lambda1) {\n  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;\n}\n\nfunction rangeCompare(a, b) {\n  return a[0] - b[0];\n}\n\nfunction rangeContains(range, x) {\n  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\n}\n\nexport default function(feature) {\n  var i, n, a, b, merged, deltaMax, delta;\n\n  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);\n  ranges = [];\n  stream(feature, boundsStream);\n\n  // First, sort ranges by their minimum longitudes.\n  if (n = ranges.length) {\n    ranges.sort(rangeCompare);\n\n    // Then, merge any ranges that overlap.\n    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {\n      b = ranges[i];\n      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {\n        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\n        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\n      } else {\n        merged.push(a = b);\n      }\n    }\n\n    // Finally, find the largest gap between the merged ranges.\n    // The final bounding box will be the inverse of this gap.\n    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {\n      b = merged[i];\n      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];\n    }\n  }\n\n  ranges = range = null;\n\n  return lambda0 === Infinity || phi0 === Infinity\n      ? [[NaN, NaN], [NaN, NaN]]\n      : [[lambda0, phi0], [lambda1, phi1]];\n}\n","import {asin, atan2, cos, sin, sqrt} from \"./math\";\n\nexport function spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\n\nexport function cartesian(spherical) {\n  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\n\nexport function cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\nexport function cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// TODO return a\nexport function cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\n\nexport function cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n}\n\n// TODO return d\nexport function cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\n","import {asin, atan2, cos, degrees, epsilon, epsilon2, radians, sin, sqrt} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nvar W0, W1,\n    X0, Y0, Z0,\n    X1, Y1, Z1,\n    X2, Y2, Z2,\n    lambda00, phi00, // first point\n    x0, y0, z0; // previous point\n\nvar centroidStream = {\n  sphere: noop,\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  }\n};\n\n// Arithmetic mean of Cartesian vectors.\nfunction centroidPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));\n}\n\nfunction centroidPointCartesian(x, y, z) {\n  ++W0;\n  X0 += (x - X0) / W0;\n  Y0 += (y - Y0) / W0;\n  Z0 += (z - Z0) / W0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidLinePointFirst;\n}\n\nfunction centroidLinePointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidStream.point = centroidLinePoint;\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLinePoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\n// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,\n// J. Applied Mechanics 42, 239 (1975).\nfunction centroidRingStart() {\n  centroidStream.point = centroidRingPointFirst;\n}\n\nfunction centroidRingEnd() {\n  centroidRingPoint(lambda00, phi00);\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingPointFirst(lambda, phi) {\n  lambda00 = lambda, phi00 = phi;\n  lambda *= radians, phi *= radians;\n  centroidStream.point = centroidRingPoint;\n  var cosPhi = cos(phi);\n  x0 = cosPhi * cos(lambda);\n  y0 = cosPhi * sin(lambda);\n  z0 = sin(phi);\n  centroidPointCartesian(x0, y0, z0);\n}\n\nfunction centroidRingPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var cosPhi = cos(phi),\n      x = cosPhi * cos(lambda),\n      y = cosPhi * sin(lambda),\n      z = sin(phi),\n      cx = y0 * z - z0 * y,\n      cy = z0 * x - x0 * z,\n      cz = x0 * y - y0 * x,\n      m = sqrt(cx * cx + cy * cy + cz * cz),\n      w = asin(m), // line weight = angle\n      v = m && -w / m; // area weight multiplier\n  X2 += v * cx;\n  Y2 += v * cy;\n  Z2 += v * cz;\n  W1 += w;\n  X1 += w * (x0 + (x0 = x));\n  Y1 += w * (y0 + (y0 = y));\n  Z1 += w * (z0 + (z0 = z));\n  centroidPointCartesian(x0, y0, z0);\n}\n\nexport default function(object) {\n  W0 = W1 =\n  X0 = Y0 = Z0 =\n  X1 = Y1 = Z1 =\n  X2 = Y2 = Z2 = 0;\n  stream(object, centroidStream);\n\n  var x = X2,\n      y = Y2,\n      z = Z2,\n      m = x * x + y * y + z * z;\n\n  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.\n  if (m < epsilon2) {\n    x = X1, y = Y1, z = Z1;\n    // If the feature has zero length, fall back to arithmetic mean of point vectors.\n    if (W1 < epsilon) x = X0, y = Y0, z = Z0;\n    m = x * x + y * y + z * z;\n    // If the feature still has an undefined ccentroid, then return.\n    if (m < epsilon2) return [NaN, NaN];\n  }\n\n  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];\n}\n","import {cartesian, cartesianNormalizeInPlace, spherical} from \"./cartesian\";\nimport constant from \"./constant\";\nimport {acos, cos, degrees, epsilon, radians, sin, tau} from \"./math\";\nimport {rotateRadians} from \"./rotation\";\n\n// Generates a circle centered at [0, 0], with a given radius and precision.\nexport function circleStream(stream, radius, delta, direction, t0, t1) {\n  if (!delta) return;\n  var cosRadius = cos(radius),\n      sinRadius = sin(radius),\n      step = direction * delta;\n  if (t0 == null) {\n    t0 = radius + direction * tau;\n    t1 = radius - step / 2;\n  } else {\n    t0 = circleRadius(cosRadius, t0);\n    t1 = circleRadius(cosRadius, t1);\n    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;\n  }\n  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {\n    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);\n    stream.point(point[0], point[1]);\n  }\n}\n\n// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].\nfunction circleRadius(cosRadius, point) {\n  point = cartesian(point), point[0] -= cosRadius;\n  cartesianNormalizeInPlace(point);\n  var radius = acos(-point[1]);\n  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;\n}\n\nexport default function() {\n  var center = constant([0, 0]),\n      radius = constant(90),\n      precision = constant(6),\n      ring,\n      rotate,\n      stream = {point: point};\n\n  function point(x, y) {\n    ring.push(x = rotate(x, y));\n    x[0] *= degrees, x[1] *= degrees;\n  }\n\n  function circle() {\n    var c = center.apply(this, arguments),\n        r = radius.apply(this, arguments) * radians,\n        p = precision.apply(this, arguments) * radians;\n    ring = [];\n    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;\n    circleStream(stream, r, p, 1);\n    c = {type: \"Polygon\", coordinates: [ring]};\n    ring = rotate = null;\n    return c;\n  }\n\n  circle.center = function(_) {\n    return arguments.length ? (center = typeof _ === \"function\" ? _ : constant([+_[0], +_[1]]), circle) : center;\n  };\n\n  circle.radius = function(_) {\n    return arguments.length ? (radius = typeof _ === \"function\" ? _ : constant(+_), circle) : radius;\n  };\n\n  circle.precision = function(_) {\n    return arguments.length ? (precision = typeof _ === \"function\" ? _ : constant(+_), circle) : precision;\n  };\n\n  return circle;\n}\n","import clip from \"./index\";\nimport {abs, atan, cos, epsilon, halfPi, pi, sin} from \"../math\";\n\nexport default clip(\n  function() { return true; },\n  clipAntimeridianLine,\n  clipAntimeridianInterpolate,\n  [-pi, -halfPi]\n);\n\n// Takes a line and cuts into visible segments. Return values: 0 - there were\n// intersections or the line was empty; 1 - no intersections; 2 - there were\n// intersections, and the first and last segments should be rejoined.\nfunction clipAntimeridianLine(stream) {\n  var lambda0 = NaN,\n      phi0 = NaN,\n      sign0 = NaN,\n      clean; // no intersections\n\n  return {\n    lineStart: function() {\n      stream.lineStart();\n      clean = 1;\n    },\n    point: function(lambda1, phi1) {\n      var sign1 = lambda1 > 0 ? pi : -pi,\n          delta = abs(lambda1 - lambda0);\n      if (abs(delta - pi) < epsilon) { // line crosses a pole\n        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        stream.point(lambda1, phi0);\n        clean = 0;\n      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian\n        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies\n        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;\n        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);\n        stream.point(sign0, phi0);\n        stream.lineEnd();\n        stream.lineStart();\n        stream.point(sign1, phi0);\n        clean = 0;\n      }\n      stream.point(lambda0 = lambda1, phi0 = phi1);\n      sign0 = sign1;\n    },\n    lineEnd: function() {\n      stream.lineEnd();\n      lambda0 = phi0 = NaN;\n    },\n    clean: function() {\n      return 2 - clean; // if intersections, rejoin first and last segments\n    }\n  };\n}\n\nfunction clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {\n  var cosPhi0,\n      cosPhi1,\n      sinLambda0Lambda1 = sin(lambda0 - lambda1);\n  return abs(sinLambda0Lambda1) > epsilon\n      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)\n          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))\n          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))\n      : (phi0 + phi1) / 2;\n}\n\nfunction clipAntimeridianInterpolate(from, to, direction, stream) {\n  var phi;\n  if (from == null) {\n    phi = direction * halfPi;\n    stream.point(-pi, phi);\n    stream.point(0, phi);\n    stream.point(pi, phi);\n    stream.point(pi, 0);\n    stream.point(pi, -phi);\n    stream.point(0, -phi);\n    stream.point(-pi, -phi);\n    stream.point(-pi, 0);\n    stream.point(-pi, phi);\n  } else if (abs(from[0] - to[0]) > epsilon) {\n    var lambda = from[0] < to[0] ? pi : -pi;\n    phi = direction * lambda / 2;\n    stream.point(-lambda, phi);\n    stream.point(0, phi);\n    stream.point(lambda, phi);\n  } else {\n    stream.point(to[0], to[1]);\n  }\n}\n","import noop from \"../noop\";\n\nexport default function() {\n  var lines = [],\n      line;\n  return {\n    point: function(x, y) {\n      line.push([x, y]);\n    },\n    lineStart: function() {\n      lines.push(line = []);\n    },\n    lineEnd: noop,\n    rejoin: function() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n}\n","import {cartesian, cartesianAddInPlace, cartesianCross, cartesianDot, cartesianScale, spherical} from \"../cartesian\";\nimport {circleStream} from \"../circle\";\nimport {abs, cos, epsilon, pi, radians, sqrt} from \"../math\";\nimport pointEqual from \"../pointEqual\";\nimport clip from \"./index\";\n\nexport default function(radius) {\n  var cr = cos(radius),\n      delta = 6 * radians,\n      smallRadius = cr > 0,\n      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case\n\n  function interpolate(from, to, direction, stream) {\n    circleStream(stream, radius, delta, direction, from, to);\n  }\n\n  function visible(lambda, phi) {\n    return cos(lambda) * cos(phi) > cr;\n  }\n\n  // Takes a line and cuts into visible segments. Return values used for polygon\n  // clipping: 0 - there were intersections or the line was empty; 1 - no\n  // intersections 2 - there were intersections, and the first and last segments\n  // should be rejoined.\n  function clipLine(stream) {\n    var point0, // previous point\n        c0, // code for previous point\n        v0, // visibility of previous point\n        v00, // visibility of first point\n        clean; // no intersections\n    return {\n      lineStart: function() {\n        v00 = v0 = false;\n        clean = 1;\n      },\n      point: function(lambda, phi) {\n        var point1 = [lambda, phi],\n            point2,\n            v = visible(lambda, phi),\n            c = smallRadius\n              ? v ? 0 : code(lambda, phi)\n              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;\n        if (!point0 && (v00 = v0 = v)) stream.lineStart();\n        // Handle degeneracies.\n        // TODO ignore if not clipping polygons.\n        if (v !== v0) {\n          point2 = intersect(point0, point1);\n          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {\n            point1[0] += epsilon;\n            point1[1] += epsilon;\n            v = visible(point1[0], point1[1]);\n          }\n        }\n        if (v !== v0) {\n          clean = 0;\n          if (v) {\n            // outside going in\n            stream.lineStart();\n            point2 = intersect(point1, point0);\n            stream.point(point2[0], point2[1]);\n          } else {\n            // inside going out\n            point2 = intersect(point0, point1);\n            stream.point(point2[0], point2[1]);\n            stream.lineEnd();\n          }\n          point0 = point2;\n        } else if (notHemisphere && point0 && smallRadius ^ v) {\n          var t;\n          // If the codes for two points are different, or are both zero,\n          // and there this segment intersects with the small circle.\n          if (!(c & c0) && (t = intersect(point1, point0, true))) {\n            clean = 0;\n            if (smallRadius) {\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n            } else {\n              stream.point(t[1][0], t[1][1]);\n              stream.lineEnd();\n              stream.lineStart();\n              stream.point(t[0][0], t[0][1]);\n            }\n          }\n        }\n        if (v && (!point0 || !pointEqual(point0, point1))) {\n          stream.point(point1[0], point1[1]);\n        }\n        point0 = point1, v0 = v, c0 = c;\n      },\n      lineEnd: function() {\n        if (v0) stream.lineEnd();\n        point0 = null;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function() {\n        return clean | ((v00 && v0) << 1);\n      }\n    };\n  }\n\n  // Intersects the great circle between a and b with the clip circle.\n  function intersect(a, b, two) {\n    var pa = cartesian(a),\n        pb = cartesian(b);\n\n    // We have two planes, n1.p = d1 and n2.p = d2.\n    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).\n    var n1 = [1, 0, 0], // normal\n        n2 = cartesianCross(pa, pb),\n        n2n2 = cartesianDot(n2, n2),\n        n1n2 = n2[0], // cartesianDot(n1, n2),\n        determinant = n2n2 - n1n2 * n1n2;\n\n    // Two polar points.\n    if (!determinant) return !two && a;\n\n    var c1 =  cr * n2n2 / determinant,\n        c2 = -cr * n1n2 / determinant,\n        n1xn2 = cartesianCross(n1, n2),\n        A = cartesianScale(n1, c1),\n        B = cartesianScale(n2, c2);\n    cartesianAddInPlace(A, B);\n\n    // Solve |p(t)|^2 = 1.\n    var u = n1xn2,\n        w = cartesianDot(A, u),\n        uu = cartesianDot(u, u),\n        t2 = w * w - uu * (cartesianDot(A, A) - 1);\n\n    if (t2 < 0) return;\n\n    var t = sqrt(t2),\n        q = cartesianScale(u, (-w - t) / uu);\n    cartesianAddInPlace(q, A);\n    q = spherical(q);\n\n    if (!two) return q;\n\n    // Two intersection points.\n    var lambda0 = a[0],\n        lambda1 = b[0],\n        phi0 = a[1],\n        phi1 = b[1],\n        z;\n\n    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;\n\n    var delta = lambda1 - lambda0,\n        polar = abs(delta - pi) < epsilon,\n        meridian = polar || delta < epsilon;\n\n    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;\n\n    // Check that the first point is between a and b.\n    if (meridian\n        ? polar\n          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)\n          : phi0 <= q[1] && q[1] <= phi1\n        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {\n      var q1 = cartesianScale(u, (-w + t) / uu);\n      cartesianAddInPlace(q1, A);\n      return [q, spherical(q1)];\n    }\n  }\n\n  // Generates a 4-bit vector representing the location of a point relative to\n  // the small circle's bounding box.\n  function code(lambda, phi) {\n    var r = smallRadius ? radius : pi - radius,\n        code = 0;\n    if (lambda < -r) code |= 1; // left\n    else if (lambda > r) code |= 2; // right\n    if (phi < -r) code |= 4; // below\n    else if (phi > r) code |= 8; // above\n    return code;\n  }\n\n  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);\n}\n","import clipRectangle from \"./rectangle\";\n\nexport default function() {\n  var x0 = 0,\n      y0 = 0,\n      x1 = 960,\n      y1 = 500,\n      cache,\n      cacheStream,\n      clip;\n\n  return clip = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);\n    },\n    extent: function(_) {\n      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];\n    }\n  };\n}\n","import clipBuffer from \"./buffer\";\nimport clipRejoin from \"./rejoin\";\nimport {epsilon, halfPi} from \"../math\";\nimport polygonContains from \"../polygonContains\";\nimport {merge} from \"d3-array\";\n\nexport default function(pointVisible, clipLine, interpolate, start) {\n  return function(sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          interpolate(null, null, 1, sink);\n          sink.lineEnd();\n        }\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function() {\n        sink.polygonStart();\n        sink.lineStart();\n        interpolate(null, null, 1, sink);\n        sink.lineEnd();\n        sink.polygonEnd();\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1]);\n      ringSink.lineEnd();\n\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i, n = ringSegments.length, m,\n          segment,\n          point;\n\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n\n      if (!n) return;\n\n      // No intersections.\n      if (clean & 1) {\n        segment = ringSegments[0];\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);\n          sink.lineEnd();\n        }\n        return;\n      }\n\n      // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n}\n\n// Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])\n       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}\n","export default function(a, b, x0, y0, x1, y1) {\n  var ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;\n  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;\n  return true;\n}\n","import {abs, epsilon} from \"../math\";\nimport clipBuffer from \"./buffer\";\nimport clipLine from \"./line\";\nimport clipRejoin from \"./rejoin\";\nimport {merge} from \"d3-array\";\n\nvar clipMax = 1e9, clipMin = -clipMax;\n\n// TODO Use d3-polygons polygonContains here for the ring check?\n// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?\n\nexport default function clipRectangle(x0, y0, x1, y1) {\n\n  function visible(x, y) {\n    return x0 <= x && x <= x1 && y0 <= y && y <= y1;\n  }\n\n  function interpolate(from, to, direction, stream) {\n    var a = 0, a1 = 0;\n    if (from == null\n        || (a = corner(from, direction)) !== (a1 = corner(to, direction))\n        || comparePoint(from, to) < 0 ^ direction > 0) {\n      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\n      while ((a = (a + direction + 4) % 4) !== a1);\n    } else {\n      stream.point(to[0], to[1]);\n    }\n  }\n\n  function corner(p, direction) {\n    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3\n        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1\n        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0\n        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon\n  }\n\n  function compareIntersection(a, b) {\n    return comparePoint(a.x, b.x);\n  }\n\n  function comparePoint(a, b) {\n    var ca = corner(a, 1),\n        cb = corner(b, 1);\n    return ca !== cb ? ca - cb\n        : ca === 0 ? b[1] - a[1]\n        : ca === 1 ? a[0] - b[0]\n        : ca === 2 ? a[1] - b[1]\n        : b[0] - a[0];\n  }\n\n  return function(stream) {\n    var activeStream = stream,\n        bufferStream = clipBuffer(),\n        segments,\n        polygon,\n        ring,\n        x__, y__, v__, // first point\n        x_, y_, v_, // previous point\n        first,\n        clean;\n\n    var clipStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: polygonStart,\n      polygonEnd: polygonEnd\n    };\n\n    function point(x, y) {\n      if (visible(x, y)) activeStream.point(x, y);\n    }\n\n    function polygonInside() {\n      var winding = 0;\n\n      for (var i = 0, n = polygon.length; i < n; ++i) {\n        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {\n          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];\n          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }\n          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }\n        }\n      }\n\n      return winding;\n    }\n\n    // Buffer geometry within a polygon and then clip it en masse.\n    function polygonStart() {\n      activeStream = bufferStream, segments = [], polygon = [], clean = true;\n    }\n\n    function polygonEnd() {\n      var startInside = polygonInside(),\n          cleanInside = clean && startInside,\n          visible = (segments = merge(segments)).length;\n      if (cleanInside || visible) {\n        stream.polygonStart();\n        if (cleanInside) {\n          stream.lineStart();\n          interpolate(null, null, 1, stream);\n          stream.lineEnd();\n        }\n        if (visible) {\n          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);\n        }\n        stream.polygonEnd();\n      }\n      activeStream = stream, segments = polygon = ring = null;\n    }\n\n    function lineStart() {\n      clipStream.point = linePoint;\n      if (polygon) polygon.push(ring = []);\n      first = true;\n      v_ = false;\n      x_ = y_ = NaN;\n    }\n\n    // TODO rather than special-case polygons, simply handle them separately.\n    // Ideally, coincident intersection points should be jittered to avoid\n    // clipping issues.\n    function lineEnd() {\n      if (segments) {\n        linePoint(x__, y__);\n        if (v__ && v_) bufferStream.rejoin();\n        segments.push(bufferStream.result());\n      }\n      clipStream.point = point;\n      if (v_) activeStream.lineEnd();\n    }\n\n    function linePoint(x, y) {\n      var v = visible(x, y);\n      if (polygon) ring.push([x, y]);\n      if (first) {\n        x__ = x, y__ = y, v__ = v;\n        first = false;\n        if (v) {\n          activeStream.lineStart();\n          activeStream.point(x, y);\n        }\n      } else {\n        if (v && v_) activeStream.point(x, y);\n        else {\n          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],\n              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];\n          if (clipLine(a, b, x0, y0, x1, y1)) {\n            if (!v_) {\n              activeStream.lineStart();\n              activeStream.point(a[0], a[1]);\n            }\n            activeStream.point(b[0], b[1]);\n            if (!v) activeStream.lineEnd();\n            clean = false;\n          } else if (v) {\n            activeStream.lineStart();\n            activeStream.point(x, y);\n            clean = false;\n          }\n        }\n      }\n      x_ = x, y_ = y, v_ = v;\n    }\n\n    return clipStream;\n  };\n}\n","import pointEqual from \"../pointEqual\";\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n  this.e = entry; // is an entry?\n  this.v = false; // visited\n  this.n = this.p = null; // next & previous\n}\n\n// A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\nexport default function(segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n\n  segments.forEach(function(segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n, p0 = segment[0], p1 = segment[n], x;\n\n    // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n\n  if (!subject.length) return;\n\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n    while (current.v) if ((current = current.n) === start) return;\n    points = current.z;\n    stream.lineStart();\n    do {\n      current.v = current.o.v = true;\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n        current = current.p;\n      }\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n  a.n = b = array[0];\n  b.p = a;\n}\n","export default function(a, b) {\n\n  function compose(x, y) {\n    return x = a(x, y), b(x[0], x[1]);\n  }\n\n  if (a.invert && b.invert) compose.invert = function(x, y) {\n    return x = b.invert(x, y), x && a.invert(x[0], x[1]);\n  };\n\n  return compose;\n}\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","import {default as polygonContains} from \"./polygonContains\";\nimport {default as distance} from \"./distance\";\nimport {epsilon, radians} from \"./math\";\n\nvar containsObjectType = {\n  Feature: function(object, point) {\n    return containsGeometry(object.geometry, point);\n  },\n  FeatureCollection: function(object, point) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;\n    return false;\n  }\n};\n\nvar containsGeometryType = {\n  Sphere: function() {\n    return true;\n  },\n  Point: function(object, point) {\n    return containsPoint(object.coordinates, point);\n  },\n  MultiPoint: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPoint(coordinates[i], point)) return true;\n    return false;\n  },\n  LineString: function(object, point) {\n    return containsLine(object.coordinates, point);\n  },\n  MultiLineString: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsLine(coordinates[i], point)) return true;\n    return false;\n  },\n  Polygon: function(object, point) {\n    return containsPolygon(object.coordinates, point);\n  },\n  MultiPolygon: function(object, point) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;\n    return false;\n  },\n  GeometryCollection: function(object, point) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) if (containsGeometry(geometries[i], point)) return true;\n    return false;\n  }\n};\n\nfunction containsGeometry(geometry, point) {\n  return geometry && containsGeometryType.hasOwnProperty(geometry.type)\n      ? containsGeometryType[geometry.type](geometry, point)\n      : false;\n}\n\nfunction containsPoint(coordinates, point) {\n  return distance(coordinates, point) === 0;\n}\n\nfunction containsLine(coordinates, point) {\n  var ab = distance(coordinates[0], coordinates[1]),\n      ao = distance(coordinates[0], point),\n      ob = distance(point, coordinates[1]);\n  return ao + ob <= ab + epsilon;\n}\n\nfunction containsPolygon(coordinates, point) {\n  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));\n}\n\nfunction ringRadians(ring) {\n  return ring = ring.map(pointRadians), ring.pop(), ring;\n}\n\nfunction pointRadians(point) {\n  return [point[0] * radians, point[1] * radians];\n}\n\nexport default function(object, point) {\n  return (object && containsObjectType.hasOwnProperty(object.type)\n      ? containsObjectType[object.type]\n      : containsGeometry)(object, point);\n}\n","import length from \"./length\";\n\nvar coordinates = [null, null],\n    object = {type: \"LineString\", coordinates: coordinates};\n\nexport default function(a, b) {\n  coordinates[0] = a;\n  coordinates[1] = b;\n  return length(object);\n}\n","import {range} from \"d3-array\";\nimport {abs, ceil, epsilon} from \"./math\";\n\nfunction graticuleX(y0, y1, dy) {\n  var y = range(y0, y1 - epsilon, dy).concat(y1);\n  return function(x) { return y.map(function(y) { return [x, y]; }); };\n}\n\nfunction graticuleY(x0, x1, dx) {\n  var x = range(x0, x1 - epsilon, dx).concat(x1);\n  return function(y) { return x.map(function(x) { return [x, y]; }); };\n}\n\nexport default function graticule() {\n  var x1, x0, X1, X0,\n      y1, y0, Y1, Y0,\n      dx = 10, dy = dx, DX = 90, DY = 360,\n      x, y, X, Y,\n      precision = 2.5;\n\n  function graticule() {\n    return {type: \"MultiLineString\", coordinates: lines()};\n  }\n\n  function lines() {\n    return range(ceil(X0 / DX) * DX, X1, DX).map(X)\n        .concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))\n        .concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))\n        .concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));\n  }\n\n  graticule.lines = function() {\n    return lines().map(function(coordinates) { return {type: \"LineString\", coordinates: coordinates}; });\n  };\n\n  graticule.outline = function() {\n    return {\n      type: \"Polygon\",\n      coordinates: [\n        X(X0).concat(\n        Y(Y1).slice(1),\n        X(X1).reverse().slice(1),\n        Y(Y0).reverse().slice(1))\n      ]\n    };\n  };\n\n  graticule.extent = function(_) {\n    if (!arguments.length) return graticule.extentMinor();\n    return graticule.extentMajor(_).extentMinor(_);\n  };\n\n  graticule.extentMajor = function(_) {\n    if (!arguments.length) return [[X0, Y0], [X1, Y1]];\n    X0 = +_[0][0], X1 = +_[1][0];\n    Y0 = +_[0][1], Y1 = +_[1][1];\n    if (X0 > X1) _ = X0, X0 = X1, X1 = _;\n    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.extentMinor = function(_) {\n    if (!arguments.length) return [[x0, y0], [x1, y1]];\n    x0 = +_[0][0], x1 = +_[1][0];\n    y0 = +_[0][1], y1 = +_[1][1];\n    if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n    if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n    return graticule.precision(precision);\n  };\n\n  graticule.step = function(_) {\n    if (!arguments.length) return graticule.stepMinor();\n    return graticule.stepMajor(_).stepMinor(_);\n  };\n\n  graticule.stepMajor = function(_) {\n    if (!arguments.length) return [DX, DY];\n    DX = +_[0], DY = +_[1];\n    return graticule;\n  };\n\n  graticule.stepMinor = function(_) {\n    if (!arguments.length) return [dx, dy];\n    dx = +_[0], dy = +_[1];\n    return graticule;\n  };\n\n  graticule.precision = function(_) {\n    if (!arguments.length) return precision;\n    precision = +_;\n    x = graticuleX(y0, y1, 90);\n    y = graticuleY(x0, x1, precision);\n    X = graticuleX(Y0, Y1, 90);\n    Y = graticuleY(X0, X1, precision);\n    return graticule;\n  };\n\n  return graticule\n      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])\n      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);\n}\n\nexport function graticule10() {\n  return graticule()();\n}\n","export default function(x) {\n  return x;\n}\n","export {default as geoArea} from \"./area\";\nexport {default as geoBounds} from \"./bounds\";\nexport {default as geoCentroid} from \"./centroid\";\nexport {default as geoCircle} from \"./circle\";\nexport {default as geoClipAntimeridian} from \"./clip/antimeridian\";\nexport {default as geoClipCircle} from \"./clip/circle\";\nexport {default as geoClipExtent} from \"./clip/extent\"; // DEPRECATED! Use d3.geoIdentity().clipExtent().\nexport {default as geoClipRectangle} from \"./clip/rectangle\";\nexport {default as geoContains} from \"./contains\";\nexport {default as geoDistance} from \"./distance\";\nexport {default as geoGraticule, graticule10 as geoGraticule10} from \"./graticule\";\nexport {default as geoInterpolate} from \"./interpolate\";\nexport {default as geoLength} from \"./length\";\nexport {default as geoPath} from \"./path/index\";\nexport {default as geoAlbers} from \"./projection/albers\";\nexport {default as geoAlbersUsa} from \"./projection/albersUsa\";\nexport {default as geoAzimuthalEqualArea, azimuthalEqualAreaRaw as geoAzimuthalEqualAreaRaw} from \"./projection/azimuthalEqualArea\";\nexport {default as geoAzimuthalEquidistant, azimuthalEquidistantRaw as geoAzimuthalEquidistantRaw} from \"./projection/azimuthalEquidistant\";\nexport {default as geoConicConformal, conicConformalRaw as geoConicConformalRaw} from \"./projection/conicConformal\";\nexport {default as geoConicEqualArea, conicEqualAreaRaw as geoConicEqualAreaRaw} from \"./projection/conicEqualArea\";\nexport {default as geoConicEquidistant, conicEquidistantRaw as geoConicEquidistantRaw} from \"./projection/conicEquidistant\";\nexport {default as geoEqualEarth, equalEarthRaw as geoEqualEarthRaw} from \"./projection/equalEarth\";\nexport {default as geoEquirectangular, equirectangularRaw as geoEquirectangularRaw} from \"./projection/equirectangular\";\nexport {default as geoGnomonic, gnomonicRaw as geoGnomonicRaw} from \"./projection/gnomonic\";\nexport {default as geoIdentity} from \"./projection/identity\";\nexport {default as geoProjection, projectionMutator as geoProjectionMutator} from \"./projection/index\";\nexport {default as geoMercator, mercatorRaw as geoMercatorRaw} from \"./projection/mercator\";\nexport {default as geoNaturalEarth1, naturalEarth1Raw as geoNaturalEarth1Raw} from \"./projection/naturalEarth1\";\nexport {default as geoOrthographic, orthographicRaw as geoOrthographicRaw} from \"./projection/orthographic\";\nexport {default as geoStereographic, stereographicRaw as geoStereographicRaw} from \"./projection/stereographic\";\nexport {default as geoTransverseMercator, transverseMercatorRaw as geoTransverseMercatorRaw} from \"./projection/transverseMercator\";\nexport {default as geoRotation} from \"./rotation\";\nexport {default as geoStream} from \"./stream\";\nexport {default as geoTransform} from \"./transform\";\n","import {asin, atan2, cos, degrees, haversin, radians, sin, sqrt} from \"./math\";\n\nexport default function(a, b) {\n  var x0 = a[0] * radians,\n      y0 = a[1] * radians,\n      x1 = b[0] * radians,\n      y1 = b[1] * radians,\n      cy0 = cos(y0),\n      sy0 = sin(y0),\n      cy1 = cos(y1),\n      sy1 = sin(y1),\n      kx0 = cy0 * cos(x0),\n      ky0 = cy0 * sin(x0),\n      kx1 = cy1 * cos(x1),\n      ky1 = cy1 * sin(x1),\n      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),\n      k = sin(d);\n\n  var interpolate = d ? function(t) {\n    var B = sin(t *= d) / k,\n        A = sin(d - t) / k,\n        x = A * kx0 + B * kx1,\n        y = A * ky0 + B * ky1,\n        z = A * sy0 + B * sy1;\n    return [\n      atan2(y, x) * degrees,\n      atan2(z, sqrt(x * x + y * y)) * degrees\n    ];\n  } : function() {\n    return [x0 * degrees, y0 * degrees];\n  };\n\n  interpolate.distance = d;\n\n  return interpolate;\n}\n","import adder from \"./adder\";\nimport {abs, atan2, cos, radians, sin, sqrt} from \"./math\";\nimport noop from \"./noop\";\nimport stream from \"./stream\";\n\nvar lengthSum = adder(),\n    lambda0,\n    sinPhi0,\n    cosPhi0;\n\nvar lengthStream = {\n  sphere: noop,\n  point: noop,\n  lineStart: lengthLineStart,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop\n};\n\nfunction lengthLineStart() {\n  lengthStream.point = lengthPointFirst;\n  lengthStream.lineEnd = lengthLineEnd;\n}\n\nfunction lengthLineEnd() {\n  lengthStream.point = lengthStream.lineEnd = noop;\n}\n\nfunction lengthPointFirst(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  lambda0 = lambda, sinPhi0 = sin(phi), cosPhi0 = cos(phi);\n  lengthStream.point = lengthPoint;\n}\n\nfunction lengthPoint(lambda, phi) {\n  lambda *= radians, phi *= radians;\n  var sinPhi = sin(phi),\n      cosPhi = cos(phi),\n      delta = abs(lambda - lambda0),\n      cosDelta = cos(delta),\n      sinDelta = sin(delta),\n      x = cosPhi * sinDelta,\n      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,\n      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;\n  lengthSum.add(atan2(sqrt(x * x + y * y), z));\n  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;\n}\n\nexport default function(object) {\n  lengthSum.reset();\n  stream(object, lengthStream);\n  return +lengthSum;\n}\n","export var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var quarterPi = pi / 4;\nexport var tau = pi * 2;\n\nexport var degrees = 180 / pi;\nexport var radians = pi / 180;\n\nexport var abs = Math.abs;\nexport var atan = Math.atan;\nexport var atan2 = Math.atan2;\nexport var cos = Math.cos;\nexport var ceil = Math.ceil;\nexport var exp = Math.exp;\nexport var floor = Math.floor;\nexport var log = Math.log;\nexport var pow = Math.pow;\nexport var sin = Math.sin;\nexport var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };\nexport var sqrt = Math.sqrt;\nexport var tan = Math.tan;\n\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nexport function asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\n\nexport function haversin(x) {\n  return (x = sin(x / 2)) * x;\n}\n","export default function noop() {}\n","import adder from \"../adder\";\nimport {abs} from \"../math\";\nimport noop from \"../noop\";\n\nvar areaSum = adder(),\n    areaRingSum = adder(),\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar areaStream = {\n  point: noop,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: function() {\n    areaStream.lineStart = areaRingStart;\n    areaStream.lineEnd = areaRingEnd;\n  },\n  polygonEnd: function() {\n    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;\n    areaSum.add(abs(areaRingSum));\n    areaRingSum.reset();\n  },\n  result: function() {\n    var area = areaSum / 2;\n    areaSum.reset();\n    return area;\n  }\n};\n\nfunction areaRingStart() {\n  areaStream.point = areaPointFirst;\n}\n\nfunction areaPointFirst(x, y) {\n  areaStream.point = areaPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction areaPoint(x, y) {\n  areaRingSum.add(y0 * x - x0 * y);\n  x0 = x, y0 = y;\n}\n\nfunction areaRingEnd() {\n  areaPoint(x00, y00);\n}\n\nexport default areaStream;\n","import noop from \"../noop\";\n\nvar x0 = Infinity,\n    y0 = x0,\n    x1 = -x0,\n    y1 = x1;\n\nvar boundsStream = {\n  point: boundsPoint,\n  lineStart: noop,\n  lineEnd: noop,\n  polygonStart: noop,\n  polygonEnd: noop,\n  result: function() {\n    var bounds = [[x0, y0], [x1, y1]];\n    x1 = y1 = -(y0 = x0 = Infinity);\n    return bounds;\n  }\n};\n\nfunction boundsPoint(x, y) {\n  if (x < x0) x0 = x;\n  if (x > x1) x1 = x;\n  if (y < y0) y0 = y;\n  if (y > y1) y1 = y;\n}\n\nexport default boundsStream;\n","import {sqrt} from \"../math\";\n\n// TODO Enforce positive area for exterior, negative area for interior?\n\nvar X0 = 0,\n    Y0 = 0,\n    Z0 = 0,\n    X1 = 0,\n    Y1 = 0,\n    Z1 = 0,\n    X2 = 0,\n    Y2 = 0,\n    Z2 = 0,\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar centroidStream = {\n  point: centroidPoint,\n  lineStart: centroidLineStart,\n  lineEnd: centroidLineEnd,\n  polygonStart: function() {\n    centroidStream.lineStart = centroidRingStart;\n    centroidStream.lineEnd = centroidRingEnd;\n  },\n  polygonEnd: function() {\n    centroidStream.point = centroidPoint;\n    centroidStream.lineStart = centroidLineStart;\n    centroidStream.lineEnd = centroidLineEnd;\n  },\n  result: function() {\n    var centroid = Z2 ? [X2 / Z2, Y2 / Z2]\n        : Z1 ? [X1 / Z1, Y1 / Z1]\n        : Z0 ? [X0 / Z0, Y0 / Z0]\n        : [NaN, NaN];\n    X0 = Y0 = Z0 =\n    X1 = Y1 = Z1 =\n    X2 = Y2 = Z2 = 0;\n    return centroid;\n  }\n};\n\nfunction centroidPoint(x, y) {\n  X0 += x;\n  Y0 += y;\n  ++Z0;\n}\n\nfunction centroidLineStart() {\n  centroidStream.point = centroidPointFirstLine;\n}\n\nfunction centroidPointFirstLine(x, y) {\n  centroidStream.point = centroidPointLine;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nfunction centroidPointLine(x, y) {\n  var dx = x - x0, dy = y - y0, z = sqrt(dx * dx + dy * dy);\n  X1 += z * (x0 + x) / 2;\n  Y1 += z * (y0 + y) / 2;\n  Z1 += z;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nfunction centroidLineEnd() {\n  centroidStream.point = centroidPoint;\n}\n\nfunction centroidRingStart() {\n  centroidStream.point = centroidPointFirstRing;\n}\n\nfunction centroidRingEnd() {\n  centroidPointRing(x00, y00);\n}\n\nfunction centroidPointFirstRing(x, y) {\n  centroidStream.point = centroidPointRing;\n  centroidPoint(x00 = x0 = x, y00 = y0 = y);\n}\n\nfunction centroidPointRing(x, y) {\n  var dx = x - x0,\n      dy = y - y0,\n      z = sqrt(dx * dx + dy * dy);\n\n  X1 += z * (x0 + x) / 2;\n  Y1 += z * (y0 + y) / 2;\n  Z1 += z;\n\n  z = y0 * x - x0 * y;\n  X2 += z * (x0 + x);\n  Y2 += z * (y0 + y);\n  Z2 += z * 3;\n  centroidPoint(x0 = x, y0 = y);\n}\n\nexport default centroidStream;\n","import {tau} from \"../math\";\nimport noop from \"../noop\";\n\nexport default function PathContext(context) {\n  this._context = context;\n}\n\nPathContext.prototype = {\n  _radius: 4.5,\n  pointRadius: function(_) {\n    return this._radius = _, this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._context.closePath();\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._context.moveTo(x, y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._context.lineTo(x, y);\n        break;\n      }\n      default: {\n        this._context.moveTo(x + this._radius, y);\n        this._context.arc(x, y, this._radius, 0, tau);\n        break;\n      }\n    }\n  },\n  result: noop\n};\n","import identity from \"../identity\";\nimport stream from \"../stream\";\nimport pathArea from \"./area\";\nimport pathBounds from \"./bounds\";\nimport pathCentroid from \"./centroid\";\nimport PathContext from \"./context\";\nimport pathMeasure from \"./measure\";\nimport PathString from \"./string\";\n\nexport default function(projection, context) {\n  var pointRadius = 4.5,\n      projectionStream,\n      contextStream;\n\n  function path(object) {\n    if (object) {\n      if (typeof pointRadius === \"function\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\n      stream(object, projectionStream(contextStream));\n    }\n    return contextStream.result();\n  }\n\n  path.area = function(object) {\n    stream(object, projectionStream(pathArea));\n    return pathArea.result();\n  };\n\n  path.measure = function(object) {\n    stream(object, projectionStream(pathMeasure));\n    return pathMeasure.result();\n  };\n\n  path.bounds = function(object) {\n    stream(object, projectionStream(pathBounds));\n    return pathBounds.result();\n  };\n\n  path.centroid = function(object) {\n    stream(object, projectionStream(pathCentroid));\n    return pathCentroid.result();\n  };\n\n  path.projection = function(_) {\n    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;\n  };\n\n  path.context = function(_) {\n    if (!arguments.length) return context;\n    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);\n    if (typeof pointRadius !== \"function\") contextStream.pointRadius(pointRadius);\n    return path;\n  };\n\n  path.pointRadius = function(_) {\n    if (!arguments.length) return pointRadius;\n    pointRadius = typeof _ === \"function\" ? _ : (contextStream.pointRadius(+_), +_);\n    return path;\n  };\n\n  return path.projection(projection).context(context);\n}\n","import adder from \"../adder\";\nimport {sqrt} from \"../math\";\nimport noop from \"../noop\";\n\nvar lengthSum = adder(),\n    lengthRing,\n    x00,\n    y00,\n    x0,\n    y0;\n\nvar lengthStream = {\n  point: noop,\n  lineStart: function() {\n    lengthStream.point = lengthPointFirst;\n  },\n  lineEnd: function() {\n    if (lengthRing) lengthPoint(x00, y00);\n    lengthStream.point = noop;\n  },\n  polygonStart: function() {\n    lengthRing = true;\n  },\n  polygonEnd: function() {\n    lengthRing = null;\n  },\n  result: function() {\n    var length = +lengthSum;\n    lengthSum.reset();\n    return length;\n  }\n};\n\nfunction lengthPointFirst(x, y) {\n  lengthStream.point = lengthPoint;\n  x00 = x0 = x, y00 = y0 = y;\n}\n\nfunction lengthPoint(x, y) {\n  x0 -= x, y0 -= y;\n  lengthSum.add(sqrt(x0 * x0 + y0 * y0));\n  x0 = x, y0 = y;\n}\n\nexport default lengthStream;\n","export default function PathString() {\n  this._string = [];\n}\n\nPathString.prototype = {\n  _radius: 4.5,\n  _circle: circle(4.5),\n  pointRadius: function(_) {\n    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;\n    return this;\n  },\n  polygonStart: function() {\n    this._line = 0;\n  },\n  polygonEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line === 0) this._string.push(\"Z\");\n    this._point = NaN;\n  },\n  point: function(x, y) {\n    switch (this._point) {\n      case 0: {\n        this._string.push(\"M\", x, \",\", y);\n        this._point = 1;\n        break;\n      }\n      case 1: {\n        this._string.push(\"L\", x, \",\", y);\n        break;\n      }\n      default: {\n        if (this._circle == null) this._circle = circle(this._radius);\n        this._string.push(\"M\", x, \",\", y, this._circle);\n        break;\n      }\n    }\n  },\n  result: function() {\n    if (this._string.length) {\n      var result = this._string.join(\"\");\n      this._string = [];\n      return result;\n    } else {\n      return null;\n    }\n  }\n};\n\nfunction circle(radius) {\n  return \"m0,\" + radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius\n      + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + 2 * radius\n      + \"z\";\n}\n","import {abs, epsilon} from \"./math\";\n\nexport default function(a, b) {\n  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;\n}\n","import adder from \"./adder\";\nimport {cartesian, cartesianCross, cartesianNormalizeInPlace} from \"./cartesian\";\nimport {asin, atan2, cos, epsilon, halfPi, pi, quarterPi, sin, tau} from \"./math\";\n\nvar sum = adder();\n\nexport default function(polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      sinPhi = sin(phi),\n      normal = [sin(lambda), -cos(lambda), 0],\n      angle = 0,\n      winding = 0;\n\n  sum.reset();\n\n  if (sinPhi === 1) phi = halfPi + epsilon;\n  else if (sinPhi === -1) phi = -halfPi - epsilon;\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin(phi0),\n        cosPhi0 = cos(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin(phi1),\n          cosPhi1 = cos(phi1),\n          delta = lambda1 - lambda0,\n          sign = delta >= 0 ? 1 : -1,\n          absDelta = sign * delta,\n          antimeridian = absDelta > pi,\n          k = sinPhi0 * sinPhi1;\n\n      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n      angle += antimeridian ? delta + sign * tau : delta;\n\n      // Are the longitudes either side of the points meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  }\n\n  // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);\n}\n","import conicEqualArea from \"./conicEqualArea\";\n\nexport default function() {\n  return conicEqualArea()\n      .parallels([29.5, 45.5])\n      .scale(1070)\n      .translate([480, 250])\n      .rotate([96, 0])\n      .center([-0.6, 38.7]);\n}\n","import {epsilon} from \"../math\";\nimport albers from \"./albers\";\nimport conicEqualArea from \"./conicEqualArea\";\nimport {fitExtent, fitSize, fitWidth, fitHeight} from \"./fit\";\n\n// The projections must have mutually exclusive clip regions on the sphere,\n// as this will avoid emitting interleaving lines and polygons.\nfunction multiplex(streams) {\n  var n = streams.length;\n  return {\n    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },\n    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },\n    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },\n    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },\n    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },\n    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }\n  };\n}\n\n// A composite projection for the United States, configured by default for\n// 960500. The projection also works quite well at 960600 if you change the\n// scale to 1285 and adjust the translate accordingly. The set of standard\n// parallels for each region comes from USGS, which is published here:\n// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers\nexport default function() {\n  var cache,\n      cacheStream,\n      lower48 = albers(), lower48Point,\n      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338\n      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007\n      point, pointStream = {point: function(x, y) { point = [x, y]; }};\n\n  function albersUsa(coordinates) {\n    var x = coordinates[0], y = coordinates[1];\n    return point = null,\n        (lower48Point.point(x, y), point)\n        || (alaskaPoint.point(x, y), point)\n        || (hawaiiPoint.point(x, y), point);\n  }\n\n  albersUsa.invert = function(coordinates) {\n    var k = lower48.scale(),\n        t = lower48.translate(),\n        x = (coordinates[0] - t[0]) / k,\n        y = (coordinates[1] - t[1]) / k;\n    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska\n        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii\n        : lower48).invert(coordinates);\n  };\n\n  albersUsa.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);\n  };\n\n  albersUsa.precision = function(_) {\n    if (!arguments.length) return lower48.precision();\n    lower48.precision(_), alaska.precision(_), hawaii.precision(_);\n    return reset();\n  };\n\n  albersUsa.scale = function(_) {\n    if (!arguments.length) return lower48.scale();\n    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);\n    return albersUsa.translate(lower48.translate());\n  };\n\n  albersUsa.translate = function(_) {\n    if (!arguments.length) return lower48.translate();\n    var k = lower48.scale(), x = +_[0], y = +_[1];\n\n    lower48Point = lower48\n        .translate(_)\n        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])\n        .stream(pointStream);\n\n    alaskaPoint = alaska\n        .translate([x - 0.307 * k, y + 0.201 * k])\n        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])\n        .stream(pointStream);\n\n    hawaiiPoint = hawaii\n        .translate([x - 0.205 * k, y + 0.212 * k])\n        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])\n        .stream(pointStream);\n\n    return reset();\n  };\n\n  albersUsa.fitExtent = function(extent, object) {\n    return fitExtent(albersUsa, extent, object);\n  };\n\n  albersUsa.fitSize = function(size, object) {\n    return fitSize(albersUsa, size, object);\n  };\n\n  albersUsa.fitWidth = function(width, object) {\n    return fitWidth(albersUsa, width, object);\n  };\n\n  albersUsa.fitHeight = function(height, object) {\n    return fitHeight(albersUsa, height, object);\n  };\n\n  function reset() {\n    cache = cacheStream = null;\n    return albersUsa;\n  }\n\n  return albersUsa.scale(1070);\n}\n","import {asin, atan2, cos, sin, sqrt} from \"../math\";\n\nexport function azimuthalRaw(scale) {\n  return function(x, y) {\n    var cx = cos(x),\n        cy = cos(y),\n        k = scale(cx * cy);\n    return [\n      k * cy * sin(x),\n      k * sin(y)\n    ];\n  }\n}\n\nexport function azimuthalInvert(angle) {\n  return function(x, y) {\n    var z = sqrt(x * x + y * y),\n        c = angle(z),\n        sc = sin(c),\n        cc = cos(c);\n    return [\n      atan2(x * sc, z * cc),\n      asin(z && y * sc / z)\n    ];\n  }\n}\n","import {asin, sqrt} from \"../math\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {\n  return sqrt(2 / (1 + cxcy));\n});\n\nazimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {\n  return 2 * asin(z / 2);\n});\n\nexport default function() {\n  return projection(azimuthalEqualAreaRaw)\n      .scale(124.75)\n      .clipAngle(180 - 1e-3);\n}\n","import {acos, sin} from \"../math\";\nimport {azimuthalRaw, azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport var azimuthalEquidistantRaw = azimuthalRaw(function(c) {\n  return (c = acos(c)) && c / sin(c);\n});\n\nazimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {\n  return z;\n});\n\nexport default function() {\n  return projection(azimuthalEquidistantRaw)\n      .scale(79.4188)\n      .clipAngle(180 - 1e-3);\n}\n","import {degrees, pi, radians} from \"../math\";\nimport {projectionMutator} from \"./index\";\n\nexport function conicProjection(projectAt) {\n  var phi0 = 0,\n      phi1 = pi / 3,\n      m = projectionMutator(projectAt),\n      p = m(phi0, phi1);\n\n  p.parallels = function(_) {\n    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];\n  };\n\n  return p;\n}\n","import {abs, atan, atan2, cos, epsilon, halfPi, log, pow, sign, sin, sqrt, tan} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {mercatorRaw} from \"./mercator\";\n\nfunction tany(y) {\n  return tan((halfPi + y) / 2);\n}\n\nexport function conicConformalRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),\n      f = cy0 * pow(tany(y0), n) / n;\n\n  if (!n) return mercatorRaw;\n\n  function project(x, y) {\n    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }\n    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }\n    var r = f / pow(tany(y), n);\n    return [r * sin(n * x), f - r * cos(n * x)];\n  }\n\n  project.invert = function(x, y) {\n    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);\n    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicConformalRaw)\n      .scale(109.5)\n      .parallels([30, 30]);\n}\n","import {abs, asin, atan2, cos, epsilon, sign, sin, sqrt} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {cylindricalEqualAreaRaw} from \"./cylindricalEqualArea\";\n\nexport function conicEqualAreaRaw(y0, y1) {\n  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;\n\n  // Are the parallels symmetrical around the Equator?\n  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);\n\n  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;\n\n  function project(x, y) {\n    var r = sqrt(c - 2 * n * sin(y)) / n;\n    return [r * sin(x *= n), r0 - r * cos(x)];\n  }\n\n  project.invert = function(x, y) {\n    var r0y = r0 - y;\n    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicEqualAreaRaw)\n      .scale(155.424)\n      .center([0, 33.6442]);\n}\n","import {abs, atan2, cos, epsilon, sign, sin, sqrt} from \"../math\";\nimport {conicProjection} from \"./conic\";\nimport {equirectangularRaw} from \"./equirectangular\";\n\nexport function conicEquidistantRaw(y0, y1) {\n  var cy0 = cos(y0),\n      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),\n      g = cy0 / n + y0;\n\n  if (abs(n) < epsilon) return equirectangularRaw;\n\n  function project(x, y) {\n    var gy = g - y, nx = n * x;\n    return [gy * sin(nx), g - gy * cos(nx)];\n  }\n\n  project.invert = function(x, y) {\n    var gy = g - y;\n    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];\n  };\n\n  return project;\n}\n\nexport default function() {\n  return conicProjection(conicEquidistantRaw)\n      .scale(131.154)\n      .center([0, 13.9389]);\n}\n","import {asin, cos, sin} from \"../math\";\n\nexport function cylindricalEqualAreaRaw(phi0) {\n  var cosPhi0 = cos(phi0);\n\n  function forward(lambda, phi) {\n    return [lambda * cosPhi0, sin(phi) / cosPhi0];\n  }\n\n  forward.invert = function(x, y) {\n    return [x / cosPhi0, asin(y * cosPhi0)];\n  };\n\n  return forward;\n}\n","import projection from \"./index.js\";\nimport {abs, asin, cos, epsilon2, sin, sqrt} from \"../math.js\";\n\nvar A1 = 1.340264,\n    A2 = -0.081106,\n    A3 = 0.000893,\n    A4 = 0.003796,\n    M = sqrt(3) / 2,\n    iterations = 12;\n\nexport function equalEarthRaw(lambda, phi) {\n  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;\n  return [\n    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),\n    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))\n  ];\n}\n\nequalEarthRaw.invert = function(x, y) {\n  var l = y, l2 = l * l, l6 = l2 * l2 * l2;\n  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {\n    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;\n    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);\n    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;\n    if (abs(delta) < epsilon2) break;\n  }\n  return [\n    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),\n    asin(sin(l) / M)\n  ];\n};\n\nexport default function() {\n  return projection(equalEarthRaw)\n      .scale(177.158);\n}\n","import projection from \"./index\";\n\nexport function equirectangularRaw(lambda, phi) {\n  return [lambda, phi];\n}\n\nequirectangularRaw.invert = equirectangularRaw;\n\nexport default function() {\n  return projection(equirectangularRaw)\n      .scale(152.63);\n}\n","import {default as geoStream} from \"../stream\";\nimport boundsStream from \"../path/bounds\";\n\nfunction fit(projection, fitBounds, object) {\n  var clip = projection.clipExtent && projection.clipExtent();\n  projection.scale(150).translate([0, 0]);\n  if (clip != null) projection.clipExtent(null);\n  geoStream(object, projection.stream(boundsStream));\n  fitBounds(boundsStream.result());\n  if (clip != null) projection.clipExtent(clip);\n  return projection;\n}\n\nexport function fitExtent(projection, extent, object) {\n  return fit(projection, function(b) {\n    var w = extent[1][0] - extent[0][0],\n        h = extent[1][1] - extent[0][1],\n        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),\n        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,\n        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n\nexport function fitSize(projection, size, object) {\n  return fitExtent(projection, [[0, 0], size], object);\n}\n\nexport function fitWidth(projection, width, object) {\n  return fit(projection, function(b) {\n    var w = +width,\n        k = w / (b[1][0] - b[0][0]),\n        x = (w - k * (b[1][0] + b[0][0])) / 2,\n        y = -k * b[0][1];\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n\nexport function fitHeight(projection, height, object) {\n  return fit(projection, function(b) {\n    var h = +height,\n        k = h / (b[1][1] - b[0][1]),\n        x = -k * b[0][0],\n        y = (h - k * (b[1][1] + b[0][1])) / 2;\n    projection.scale(150 * k).translate([x, y]);\n  }, object);\n}\n","import {atan, cos, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function gnomonicRaw(x, y) {\n  var cy = cos(y), k = cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\ngnomonicRaw.invert = azimuthalInvert(atan);\n\nexport default function() {\n  return projection(gnomonicRaw)\n      .scale(144.049)\n      .clipAngle(60);\n}\n","import clipRectangle from \"../clip/rectangle\";\nimport identity from \"../identity\";\nimport {transformer} from \"../transform\";\nimport {fitExtent, fitSize, fitWidth, fitHeight} from \"./fit\";\n\nfunction scaleTranslate(kx, ky, tx, ty) {\n  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({\n    point: function(x, y) {\n      this.stream.point(x * kx + tx, y * ky + ty);\n    }\n  });\n}\n\nexport default function() {\n  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity, // scale, translate and reflect\n      x0 = null, y0, x1, y1, // clip extent\n      postclip = identity,\n      cache,\n      cacheStream,\n      projection;\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return projection = {\n    stream: function(stream) {\n      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));\n    },\n    postclip: function(_) {\n      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n    },\n    clipExtent: function(_) {\n      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n    },\n    scale: function(_) {\n      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;\n    },\n    translate: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];\n    },\n    reflectX: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;\n    },\n    reflectY: function(_) {\n      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;\n    },\n    fitExtent: function(extent, object) {\n      return fitExtent(projection, extent, object);\n    },\n    fitSize: function(size, object) {\n      return fitSize(projection, size, object);\n    },\n    fitWidth: function(width, object) {\n      return fitWidth(projection, width, object);\n    },\n    fitHeight: function(height, object) {\n      return fitHeight(projection, height, object);\n    }\n  };\n}\n","import clipAntimeridian from \"../clip/antimeridian\";\nimport clipCircle from \"../clip/circle\";\nimport clipRectangle from \"../clip/rectangle\";\nimport compose from \"../compose\";\nimport identity from \"../identity\";\nimport {cos, degrees, radians, sin, sqrt} from \"../math\";\nimport {rotateRadians} from \"../rotation\";\nimport {transformer} from \"../transform\";\nimport {fitExtent, fitSize, fitWidth, fitHeight} from \"./fit\";\nimport resample from \"./resample\";\n\nvar transformRadians = transformer({\n  point: function(x, y) {\n    this.stream.point(x * radians, y * radians);\n  }\n});\n\nfunction transformRotate(rotate) {\n  return transformer({\n    point: function(x, y) {\n      var r = rotate(x, y);\n      return this.stream.point(r[0], r[1]);\n    }\n  });\n}\n\nfunction scaleTranslate(k, dx, dy) {\n  function transform(x, y) {\n    return [dx + k * x, dy - k * y];\n  }\n  transform.invert = function(x, y) {\n    return [(x - dx) / k, (dy - y) / k];\n  };\n  return transform;\n}\n\nfunction scaleTranslateRotate(k, dx, dy, alpha) {\n  var cosAlpha = cos(alpha),\n      sinAlpha = sin(alpha),\n      a = cosAlpha * k,\n      b = sinAlpha * k,\n      ai = cosAlpha / k,\n      bi = sinAlpha / k,\n      ci = (sinAlpha * dy - cosAlpha * dx) / k,\n      fi = (sinAlpha * dx + cosAlpha * dy) / k;\n  function transform(x, y) {\n    return [a * x - b * y + dx, dy - b * x - a * y];\n  }\n  transform.invert = function(x, y) {\n    return [ai * x - bi * y + ci, fi - bi * x - ai * y];\n  };\n  return transform;\n}\n\nexport default function projection(project) {\n  return projectionMutator(function() { return project; })();\n}\n\nexport function projectionMutator(projectAt) {\n  var project,\n      k = 150, // scale\n      x = 480, y = 250, // translate\n      lambda = 0, phi = 0, // center\n      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate\n      alpha = 0, // post-rotate\n      theta = null, preclip = clipAntimeridian, // pre-clip angle\n      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent\n      delta2 = 0.5, // precision\n      projectResample,\n      projectTransform,\n      projectRotateTransform,\n      cache,\n      cacheStream;\n\n  function projection(point) {\n    return projectRotateTransform(point[0] * radians, point[1] * radians);\n  }\n\n  function invert(point) {\n    point = projectRotateTransform.invert(point[0], point[1]);\n    return point && [point[0] * degrees, point[1] * degrees];\n  }\n\n  projection.stream = function(stream) {\n    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));\n  };\n\n  projection.preclip = function(_) {\n    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;\n  };\n\n  projection.postclip = function(_) {\n    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;\n  };\n\n  projection.clipAngle = function(_) {\n    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;\n  };\n\n  projection.clipExtent = function(_) {\n    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  projection.scale = function(_) {\n    return arguments.length ? (k = +_, recenter()) : k;\n  };\n\n  projection.translate = function(_) {\n    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];\n  };\n\n  projection.center = function(_) {\n    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];\n  };\n\n  projection.rotate = function(_) {\n    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];\n  };\n\n  projection.angle = function(_) {\n    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;\n  };\n\n  projection.precision = function(_) {\n    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);\n  };\n\n  projection.fitExtent = function(extent, object) {\n    return fitExtent(projection, extent, object);\n  };\n\n  projection.fitSize = function(size, object) {\n    return fitSize(projection, size, object);\n  };\n\n  projection.fitWidth = function(width, object) {\n    return fitWidth(projection, width, object);\n  };\n\n  projection.fitHeight = function(height, object) {\n    return fitHeight(projection, height, object);\n  };\n\n  function recenter() {\n    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),\n        transform = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);\n    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);\n    projectTransform = compose(project, transform);\n    projectRotateTransform = compose(rotate, projectTransform);\n    projectResample = resample(projectTransform, delta2);\n    return reset();\n  }\n\n  function reset() {\n    cache = cacheStream = null;\n    return projection;\n  }\n\n  return function() {\n    project = projectAt.apply(this, arguments);\n    projection.invert = project.invert && invert;\n    return recenter();\n  };\n}\n","import {atan, exp, halfPi, log, pi, tan, tau} from \"../math\";\nimport rotation from \"../rotation\";\nimport projection from \"./index\";\n\nexport function mercatorRaw(lambda, phi) {\n  return [lambda, log(tan((halfPi + phi) / 2))];\n}\n\nmercatorRaw.invert = function(x, y) {\n  return [x, 2 * atan(exp(y)) - halfPi];\n};\n\nexport default function() {\n  return mercatorProjection(mercatorRaw)\n      .scale(961 / tau);\n}\n\nexport function mercatorProjection(project) {\n  var m = projection(project),\n      center = m.center,\n      scale = m.scale,\n      translate = m.translate,\n      clipExtent = m.clipExtent,\n      x0 = null, y0, x1, y1; // clip extent\n\n  m.scale = function(_) {\n    return arguments.length ? (scale(_), reclip()) : scale();\n  };\n\n  m.translate = function(_) {\n    return arguments.length ? (translate(_), reclip()) : translate();\n  };\n\n  m.center = function(_) {\n    return arguments.length ? (center(_), reclip()) : center();\n  };\n\n  m.clipExtent = function(_) {\n    return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];\n  };\n\n  function reclip() {\n    var k = pi * scale(),\n        t = m(rotation(m.rotate()).invert([0, 0]));\n    return clipExtent(x0 == null\n        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw\n        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]\n        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);\n  }\n\n  return reclip();\n}\n","import projection from \"./index\";\nimport {abs, epsilon} from \"../math\";\n\nexport function naturalEarth1Raw(lambda, phi) {\n  var phi2 = phi * phi, phi4 = phi2 * phi2;\n  return [\n    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),\n    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))\n  ];\n}\n\nnaturalEarth1Raw.invert = function(x, y) {\n  var phi = y, i = 25, delta;\n  do {\n    var phi2 = phi * phi, phi4 = phi2 * phi2;\n    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /\n        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));\n  } while (abs(delta) > epsilon && --i > 0);\n  return [\n    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),\n    phi\n  ];\n};\n\nexport default function() {\n  return projection(naturalEarth1Raw)\n      .scale(175.295);\n}\n","import {asin, cos, epsilon, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function orthographicRaw(x, y) {\n  return [cos(y) * sin(x), sin(y)];\n}\n\northographicRaw.invert = azimuthalInvert(asin);\n\nexport default function() {\n  return projection(orthographicRaw)\n      .scale(249.5)\n      .clipAngle(90 + epsilon);\n}\n","import {cartesian} from \"../cartesian\";\nimport {abs, asin, atan2, cos, epsilon, radians, sqrt} from \"../math\";\nimport {transformer} from \"../transform\";\n\nvar maxDepth = 16, // maximum depth of subdivision\n    cosMinDistance = cos(30 * radians); // cos(minimum angular distance)\n\nexport default function(project, delta2) {\n  return +delta2 ? resample(project, delta2) : resampleNone(project);\n}\n\nfunction resampleNone(project) {\n  return transformer({\n    point: function(x, y) {\n      x = project(x, y);\n      this.stream.point(x[0], x[1]);\n    }\n  });\n}\n\nfunction resample(project, delta2) {\n\n  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {\n    var dx = x1 - x0,\n        dy = y1 - y0,\n        d2 = dx * dx + dy * dy;\n    if (d2 > 4 * delta2 && depth--) {\n      var a = a0 + a1,\n          b = b0 + b1,\n          c = c0 + c1,\n          m = sqrt(a * a + b * b + c * c),\n          phi2 = asin(c /= m),\n          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),\n          p = project(lambda2, phi2),\n          x2 = p[0],\n          y2 = p[1],\n          dx2 = x2 - x0,\n          dy2 = y2 - y0,\n          dz = dy * dx2 - dx * dy2;\n      if (dz * dz / d2 > delta2 // perpendicular projected distance\n          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end\n          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance\n        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);\n        stream.point(x2, y2);\n        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);\n      }\n    }\n  }\n  return function(stream) {\n    var lambda00, x00, y00, a00, b00, c00, // first point\n        lambda0, x0, y0, a0, b0, c0; // previous point\n\n    var resampleStream = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },\n      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }\n    };\n\n    function point(x, y) {\n      x = project(x, y);\n      stream.point(x[0], x[1]);\n    }\n\n    function lineStart() {\n      x0 = NaN;\n      resampleStream.point = linePoint;\n      stream.lineStart();\n    }\n\n    function linePoint(lambda, phi) {\n      var c = cartesian([lambda, phi]), p = project(lambda, phi);\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n      stream.point(x0, y0);\n    }\n\n    function lineEnd() {\n      resampleStream.point = point;\n      stream.lineEnd();\n    }\n\n    function ringStart() {\n      lineStart();\n      resampleStream.point = ringPoint;\n      resampleStream.lineEnd = ringEnd;\n    }\n\n    function ringPoint(lambda, phi) {\n      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n      resampleStream.point = linePoint;\n    }\n\n    function ringEnd() {\n      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);\n      resampleStream.lineEnd = lineEnd;\n      lineEnd();\n    }\n\n    return resampleStream;\n  };\n}\n","import {atan, cos, sin} from \"../math\";\nimport {azimuthalInvert} from \"./azimuthal\";\nimport projection from \"./index\";\n\nexport function stereographicRaw(x, y) {\n  var cy = cos(y), k = 1 + cos(x) * cy;\n  return [cy * sin(x) / k, sin(y) / k];\n}\n\nstereographicRaw.invert = azimuthalInvert(function(z) {\n  return 2 * atan(z);\n});\n\nexport default function() {\n  return projection(stereographicRaw)\n      .scale(250)\n      .clipAngle(142);\n}\n","import {atan, exp, halfPi, log, tan} from \"../math\";\nimport {mercatorProjection} from \"./mercator\";\n\nexport function transverseMercatorRaw(lambda, phi) {\n  return [log(tan((halfPi + phi) / 2)), -lambda];\n}\n\ntransverseMercatorRaw.invert = function(x, y) {\n  return [-y, 2 * atan(exp(x)) - halfPi];\n};\n\nexport default function() {\n  var m = mercatorProjection(transverseMercatorRaw),\n      center = m.center,\n      rotate = m.rotate;\n\n  m.center = function(_) {\n    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);\n  };\n\n  m.rotate = function(_) {\n    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);\n  };\n\n  return rotate([0, 0, 90])\n      .scale(159.155);\n}\n","import compose from \"./compose\";\nimport {asin, atan2, cos, degrees, pi, radians, sin, tau} from \"./math\";\n\nfunction rotationIdentity(lambda, phi) {\n  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n}\n\nrotationIdentity.invert = rotationIdentity;\n\nexport function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {\n  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))\n    : rotationLambda(deltaLambda))\n    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)\n    : rotationIdentity);\n}\n\nfunction forwardRotationLambda(deltaLambda) {\n  return function(lambda, phi) {\n    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];\n  };\n}\n\nfunction rotationLambda(deltaLambda) {\n  var rotation = forwardRotationLambda(deltaLambda);\n  rotation.invert = forwardRotationLambda(-deltaLambda);\n  return rotation;\n}\n\nfunction rotationPhiGamma(deltaPhi, deltaGamma) {\n  var cosDeltaPhi = cos(deltaPhi),\n      sinDeltaPhi = sin(deltaPhi),\n      cosDeltaGamma = cos(deltaGamma),\n      sinDeltaGamma = sin(deltaGamma);\n\n  function rotation(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return [\n      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    ];\n  }\n\n  rotation.invert = function(lambda, phi) {\n    var cosPhi = cos(phi),\n        x = cos(lambda) * cosPhi,\n        y = sin(lambda) * cosPhi,\n        z = sin(phi),\n        k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return [\n      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    ];\n  };\n\n  return rotation;\n}\n\nexport default function(rotate) {\n  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);\n\n  function forward(coordinates) {\n    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  }\n\n  forward.invert = function(coordinates) {\n    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);\n    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;\n  };\n\n  return forward;\n}\n","function streamGeometry(geometry, stream) {\n  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {\n    streamGeometryType[geometry.type](geometry, stream);\n  }\n}\n\nvar streamObjectType = {\n  Feature: function(object, stream) {\n    streamGeometry(object.geometry, stream);\n  },\n  FeatureCollection: function(object, stream) {\n    var features = object.features, i = -1, n = features.length;\n    while (++i < n) streamGeometry(features[i].geometry, stream);\n  }\n};\n\nvar streamGeometryType = {\n  Sphere: function(object, stream) {\n    stream.sphere();\n  },\n  Point: function(object, stream) {\n    object = object.coordinates;\n    stream.point(object[0], object[1], object[2]);\n  },\n  MultiPoint: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);\n  },\n  LineString: function(object, stream) {\n    streamLine(object.coordinates, stream, 0);\n  },\n  MultiLineString: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamLine(coordinates[i], stream, 0);\n  },\n  Polygon: function(object, stream) {\n    streamPolygon(object.coordinates, stream);\n  },\n  MultiPolygon: function(object, stream) {\n    var coordinates = object.coordinates, i = -1, n = coordinates.length;\n    while (++i < n) streamPolygon(coordinates[i], stream);\n  },\n  GeometryCollection: function(object, stream) {\n    var geometries = object.geometries, i = -1, n = geometries.length;\n    while (++i < n) streamGeometry(geometries[i], stream);\n  }\n};\n\nfunction streamLine(coordinates, stream, closed) {\n  var i = -1, n = coordinates.length - closed, coordinate;\n  stream.lineStart();\n  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);\n  stream.lineEnd();\n}\n\nfunction streamPolygon(coordinates, stream) {\n  var i = -1, n = coordinates.length;\n  stream.polygonStart();\n  while (++i < n) streamLine(coordinates[i], stream, 1);\n  stream.polygonEnd();\n}\n\nexport default function(object, stream) {\n  if (object && streamObjectType.hasOwnProperty(object.type)) {\n    streamObjectType[object.type](object, stream);\n  } else {\n    streamGeometry(object, stream);\n  }\n}\n","export default function(methods) {\n  return {\n    stream: transformer(methods)\n  };\n}\n\nexport function transformer(methods) {\n  return function(stream) {\n    var s = new TransformStream;\n    for (var key in methods) s[key] = methods[key];\n    s.stream = stream;\n    return s;\n  };\n}\n\nfunction TransformStream() {}\n\nTransformStream.prototype = {\n  constructor: TransformStream,\n  point: function(x, y) { this.stream.point(x, y); },\n  sphere: function() { this.stream.sphere(); },\n  lineStart: function() { this.stream.lineStart(); },\n  lineEnd: function() { this.stream.lineEnd(); },\n  polygonStart: function() { this.stream.polygonStart(); },\n  polygonEnd: function() { this.stream.polygonEnd(); }\n};\n","export function optional(f) {\n  return f == null ? null : required(f);\n}\n\nexport function required(f) {\n  if (typeof f !== \"function\") throw new Error;\n  return f;\n}\n","export var slice = Array.prototype.slice;\n\nexport function shuffle(array) {\n  var m = array.length,\n      t,\n      i;\n\n  while (m) {\n    i = Math.random() * m-- | 0;\n    t = array[m];\n    array[m] = array[i];\n    array[i] = t;\n  }\n\n  return array;\n}\n","function defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\nfunction meanX(children) {\n  return children.reduce(meanXReduce, 0) / children.length;\n}\n\nfunction meanXReduce(x, c) {\n  return x + c.x;\n}\n\nfunction maxY(children) {\n  return 1 + children.reduce(maxYReduce, 0);\n}\n\nfunction maxYReduce(y, c) {\n  return Math.max(y, c.y);\n}\n\nfunction leafLeft(node) {\n  var children;\n  while (children = node.children) node = children[0];\n  return node;\n}\n\nfunction leafRight(node) {\n  var children;\n  while (children = node.children) node = children[children.length - 1];\n  return node;\n}\n\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = false;\n\n  function cluster(root) {\n    var previousNode,\n        x = 0;\n\n    // First walk, computing the initial x & y values.\n    root.eachAfter(function(node) {\n      var children = node.children;\n      if (children) {\n        node.x = meanX(children);\n        node.y = maxY(children);\n      } else {\n        node.x = previousNode ? x += separation(node, previousNode) : 0;\n        node.y = 0;\n        previousNode = node;\n      }\n    });\n\n    var left = leafLeft(root),\n        right = leafRight(root),\n        x0 = left.x - separation(left, right) / 2,\n        x1 = right.x + separation(right, left) / 2;\n\n    // Second walk, normalizing x & y to the desired size.\n    return root.eachAfter(nodeSize ? function(node) {\n      node.x = (node.x - root.x) * dx;\n      node.y = (root.y - node.y) * dy;\n    } : function(node) {\n      node.x = (node.x - x0) / (x1 - x0) * dx;\n      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;\n    });\n  }\n\n  cluster.separation = function(x) {\n    return arguments.length ? (separation = x, cluster) : separation;\n  };\n\n  cluster.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);\n  };\n\n  cluster.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return cluster;\n}\n","export function constantZero() {\n  return 0;\n}\n\nexport default function(x) {\n  return function() {\n    return x;\n  };\n}\n","export default function() {\n  var node = this, nodes = [node];\n  while (node = node.parent) {\n    nodes.push(node);\n  }\n  return nodes;\n}\n","function count(node) {\n  var sum = 0,\n      children = node.children,\n      i = children && children.length;\n  if (!i) sum = 1;\n  else while (--i >= 0) sum += children[i].value;\n  node.value = sum;\n}\n\nexport default function() {\n  return this.eachAfter(count);\n}\n","export default function() {\n  var nodes = [];\n  this.each(function(node) {\n    nodes.push(node);\n  });\n  return nodes;\n}\n","export default function(callback) {\n  var node = this, current, next = [node], children, i, n;\n  do {\n    current = next.reverse(), next = [];\n    while (node = current.pop()) {\n      callback(node), children = node.children;\n      if (children) for (i = 0, n = children.length; i < n; ++i) {\n        next.push(children[i]);\n      }\n    }\n  } while (next.length);\n  return this;\n}\n","export default function(callback) {\n  var node = this, nodes = [node], next = [], children, i, n;\n  while (node = nodes.pop()) {\n    next.push(node), children = node.children;\n    if (children) for (i = 0, n = children.length; i < n; ++i) {\n      nodes.push(children[i]);\n    }\n  }\n  while (node = next.pop()) {\n    callback(node);\n  }\n  return this;\n}\n","export default function(callback) {\n  var node = this, nodes = [node], children, i;\n  while (node = nodes.pop()) {\n    callback(node), children = node.children;\n    if (children) for (i = children.length - 1; i >= 0; --i) {\n      nodes.push(children[i]);\n    }\n  }\n  return this;\n}\n","import node_count from \"./count\";\nimport node_each from \"./each\";\nimport node_eachBefore from \"./eachBefore\";\nimport node_eachAfter from \"./eachAfter\";\nimport node_sum from \"./sum\";\nimport node_sort from \"./sort\";\nimport node_path from \"./path\";\nimport node_ancestors from \"./ancestors\";\nimport node_descendants from \"./descendants\";\nimport node_leaves from \"./leaves\";\nimport node_links from \"./links\";\n\nexport default function hierarchy(data, children) {\n  var root = new Node(data),\n      valued = +data.value && (root.value = data.value),\n      node,\n      nodes = [root],\n      child,\n      childs,\n      i,\n      n;\n\n  if (children == null) children = defaultChildren;\n\n  while (node = nodes.pop()) {\n    if (valued) node.value = +node.data.value;\n    if ((childs = children(node.data)) && (n = childs.length)) {\n      node.children = new Array(n);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new Node(childs[i]));\n        child.parent = node;\n        child.depth = node.depth + 1;\n      }\n    }\n  }\n\n  return root.eachBefore(computeHeight);\n}\n\nfunction node_copy() {\n  return hierarchy(this).eachBefore(copyData);\n}\n\nfunction defaultChildren(d) {\n  return d.children;\n}\n\nfunction copyData(node) {\n  node.data = node.data.data;\n}\n\nexport function computeHeight(node) {\n  var height = 0;\n  do node.height = height;\n  while ((node = node.parent) && (node.height < ++height));\n}\n\nexport function Node(data) {\n  this.data = data;\n  this.depth =\n  this.height = 0;\n  this.parent = null;\n}\n\nNode.prototype = hierarchy.prototype = {\n  constructor: Node,\n  count: node_count,\n  each: node_each,\n  eachAfter: node_eachAfter,\n  eachBefore: node_eachBefore,\n  sum: node_sum,\n  sort: node_sort,\n  path: node_path,\n  ancestors: node_ancestors,\n  descendants: node_descendants,\n  leaves: node_leaves,\n  links: node_links,\n  copy: node_copy\n};\n","export default function() {\n  var leaves = [];\n  this.eachBefore(function(node) {\n    if (!node.children) {\n      leaves.push(node);\n    }\n  });\n  return leaves;\n}\n","export default function() {\n  var root = this, links = [];\n  root.each(function(node) {\n    if (node !== root) { // Dont include the roots parent, if any.\n      links.push({source: node.parent, target: node});\n    }\n  });\n  return links;\n}\n","export default function(end) {\n  var start = this,\n      ancestor = leastCommonAncestor(start, end),\n      nodes = [start];\n  while (start !== ancestor) {\n    start = start.parent;\n    nodes.push(start);\n  }\n  var k = nodes.length;\n  while (end !== ancestor) {\n    nodes.splice(k, 0, end);\n    end = end.parent;\n  }\n  return nodes;\n}\n\nfunction leastCommonAncestor(a, b) {\n  if (a === b) return a;\n  var aNodes = a.ancestors(),\n      bNodes = b.ancestors(),\n      c = null;\n  a = aNodes.pop();\n  b = bNodes.pop();\n  while (a === b) {\n    c = a;\n    a = aNodes.pop();\n    b = bNodes.pop();\n  }\n  return c;\n}\n","export default function(compare) {\n  return this.eachBefore(function(node) {\n    if (node.children) {\n      node.children.sort(compare);\n    }\n  });\n}\n","export default function(value) {\n  return this.eachAfter(function(node) {\n    var sum = +value(node.data) || 0,\n        children = node.children,\n        i = children && children.length;\n    while (--i >= 0) sum += children[i].value;\n    node.value = sum;\n  });\n}\n","export {default as cluster} from \"./cluster\";\nexport {default as hierarchy} from \"./hierarchy/index\";\nexport {default as pack} from \"./pack/index\";\nexport {default as packSiblings} from \"./pack/siblings\";\nexport {default as packEnclose} from \"./pack/enclose\";\nexport {default as partition} from \"./partition\";\nexport {default as stratify} from \"./stratify\";\nexport {default as tree} from \"./tree\";\nexport {default as treemap} from \"./treemap/index\";\nexport {default as treemapBinary} from \"./treemap/binary\";\nexport {default as treemapDice} from \"./treemap/dice\";\nexport {default as treemapSlice} from \"./treemap/slice\";\nexport {default as treemapSliceDice} from \"./treemap/sliceDice\";\nexport {default as treemapSquarify} from \"./treemap/squarify\";\nexport {default as treemapResquarify} from \"./treemap/resquarify\";\n","import {shuffle, slice} from \"../array\";\n\nexport default function(circles) {\n  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;\n\n  while (i < n) {\n    p = circles[i];\n    if (e && enclosesWeak(e, p)) ++i;\n    else e = encloseBasis(B = extendBasis(B, p)), i = 0;\n  }\n\n  return e;\n}\n\nfunction extendBasis(B, p) {\n  var i, j;\n\n  if (enclosesWeakAll(p, B)) return [p];\n\n  // If we get here then B must have at least one element.\n  for (i = 0; i < B.length; ++i) {\n    if (enclosesNot(p, B[i])\n        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n      return [B[i], p];\n    }\n  }\n\n  // If we get here then B must have at least two elements.\n  for (i = 0; i < B.length - 1; ++i) {\n    for (j = i + 1; j < B.length; ++j) {\n      if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n          && enclosesNot(encloseBasis2(B[i], p), B[j])\n          && enclosesNot(encloseBasis2(B[j], p), B[i])\n          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {\n        return [B[i], B[j], p];\n      }\n    }\n  }\n\n  // If we get here then something is very wrong.\n  throw new Error;\n}\n\nfunction enclosesNot(a, b) {\n  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\n\nfunction enclosesWeak(a, b) {\n  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction enclosesWeakAll(a, B) {\n  for (var i = 0; i < B.length; ++i) {\n    if (!enclosesWeak(a, B[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction encloseBasis(B) {\n  switch (B.length) {\n    case 1: return encloseBasis1(B[0]);\n    case 2: return encloseBasis2(B[0], B[1]);\n    case 3: return encloseBasis3(B[0], B[1], B[2]);\n  }\n}\n\nfunction encloseBasis1(a) {\n  return {\n    x: a.x,\n    y: a.y,\n    r: a.r\n  };\n}\n\nfunction encloseBasis2(a, b) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,\n      l = Math.sqrt(x21 * x21 + y21 * y21);\n  return {\n    x: (x1 + x2 + x21 / l * r21) / 2,\n    y: (y1 + y2 + y21 / l * r21) / 2,\n    r: (l + r1 + r2) / 2\n  };\n}\n\nfunction encloseBasis3(a, b, c) {\n  var x1 = a.x, y1 = a.y, r1 = a.r,\n      x2 = b.x, y2 = b.y, r2 = b.r,\n      x3 = c.x, y3 = c.y, r3 = c.r,\n      a2 = x1 - x2,\n      a3 = x1 - x3,\n      b2 = y1 - y2,\n      b3 = y1 - y3,\n      c2 = r2 - r1,\n      c3 = r3 - r1,\n      d1 = x1 * x1 + y1 * y1 - r1 * r1,\n      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,\n      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,\n      ab = a3 * b2 - a2 * b3,\n      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,\n      xb = (b3 * c2 - b2 * c3) / ab,\n      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,\n      yb = (a2 * c3 - a3 * c2) / ab,\n      A = xb * xb + yb * yb - 1,\n      B = 2 * (r1 + xa * xb + ya * yb),\n      C = xa * xa + ya * ya - r1 * r1,\n      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n  return {\n    x: x1 + xa + xb * r,\n    y: y1 + ya + yb * r,\n    r: r\n  };\n}\n","import {packEnclose} from \"./siblings\";\nimport {optional} from \"../accessors\";\nimport constant, {constantZero} from \"../constant\";\n\nfunction defaultRadius(d) {\n  return Math.sqrt(d.value);\n}\n\nexport default function() {\n  var radius = null,\n      dx = 1,\n      dy = 1,\n      padding = constantZero;\n\n  function pack(root) {\n    root.x = dx / 2, root.y = dy / 2;\n    if (radius) {\n      root.eachBefore(radiusLeaf(radius))\n          .eachAfter(packChildren(padding, 0.5))\n          .eachBefore(translateChild(1));\n    } else {\n      root.eachBefore(radiusLeaf(defaultRadius))\n          .eachAfter(packChildren(constantZero, 1))\n          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))\n          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));\n    }\n    return root;\n  }\n\n  pack.radius = function(x) {\n    return arguments.length ? (radius = optional(x), pack) : radius;\n  };\n\n  pack.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];\n  };\n\n  pack.padding = function(x) {\n    return arguments.length ? (padding = typeof x === \"function\" ? x : constant(+x), pack) : padding;\n  };\n\n  return pack;\n}\n\nfunction radiusLeaf(radius) {\n  return function(node) {\n    if (!node.children) {\n      node.r = Math.max(0, +radius(node) || 0);\n    }\n  };\n}\n\nfunction packChildren(padding, k) {\n  return function(node) {\n    if (children = node.children) {\n      var children,\n          i,\n          n = children.length,\n          r = padding(node) * k || 0,\n          e;\n\n      if (r) for (i = 0; i < n; ++i) children[i].r += r;\n      e = packEnclose(children);\n      if (r) for (i = 0; i < n; ++i) children[i].r -= r;\n      node.r = e + r;\n    }\n  };\n}\n\nfunction translateChild(k) {\n  return function(node) {\n    var parent = node.parent;\n    node.r *= k;\n    if (parent) {\n      node.x = parent.x + k * node.x;\n      node.y = parent.y + k * node.y;\n    }\n  };\n}\n","import enclose from \"./enclose\";\n\nfunction place(b, a, c) {\n  var dx = b.x - a.x, x, a2,\n      dy = b.y - a.y, y, b2,\n      d2 = dx * dx + dy * dy;\n  if (d2) {\n    a2 = a.r + c.r, a2 *= a2;\n    b2 = b.r + c.r, b2 *= b2;\n    if (a2 > b2) {\n      x = (d2 + b2 - a2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));\n      c.x = b.x - x * dx - y * dy;\n      c.y = b.y - x * dy + y * dx;\n    } else {\n      x = (d2 + a2 - b2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));\n      c.x = a.x + x * dx - y * dy;\n      c.y = a.y + x * dy + y * dx;\n    }\n  } else {\n    c.x = a.x + c.r;\n    c.y = a.y;\n  }\n}\n\nfunction intersects(a, b) {\n  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction score(node) {\n  var a = node._,\n      b = node.next._,\n      ab = a.r + b.r,\n      dx = (a.x * b.r + b.x * a.r) / ab,\n      dy = (a.y * b.r + b.y * a.r) / ab;\n  return dx * dx + dy * dy;\n}\n\nfunction Node(circle) {\n  this._ = circle;\n  this.next = null;\n  this.previous = null;\n}\n\nexport function packEnclose(circles) {\n  if (!(n = circles.length)) return 0;\n\n  var a, b, c, n, aa, ca, i, j, k, sj, sk;\n\n  // Place the first circle.\n  a = circles[0], a.x = 0, a.y = 0;\n  if (!(n > 1)) return a.r;\n\n  // Place the second circle.\n  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;\n  if (!(n > 2)) return a.r + b.r;\n\n  // Place the third circle.\n  place(b, a, c = circles[2]);\n\n  // Initialize the front-chain using the first three circles a, b and c.\n  a = new Node(a), b = new Node(b), c = new Node(c);\n  a.next = c.previous = b;\n  b.next = a.previous = c;\n  c.next = b.previous = a;\n\n  // Attempt to place each remaining circle\n  pack: for (i = 3; i < n; ++i) {\n    place(a._, b._, c = circles[i]), c = new Node(c);\n\n    // Find the closest intersecting circle on the front-chain, if any.\n    // Closeness is determined by linear distance along the front-chain.\n    // Ahead or behind is likewise determined by linear distance.\n    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;\n    do {\n      if (sj <= sk) {\n        if (intersects(j._, c._)) {\n          b = j, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sj += j._.r, j = j.next;\n      } else {\n        if (intersects(k._, c._)) {\n          a = k, a.next = b, b.previous = a, --i;\n          continue pack;\n        }\n        sk += k._.r, k = k.previous;\n      }\n    } while (j !== k.next);\n\n    // Success! Insert the new circle c between a and b.\n    c.previous = a, c.next = b, a.next = b.previous = b = c;\n\n    // Compute the new closest circle pair to the centroid.\n    aa = score(a);\n    while ((c = c.next) !== b) {\n      if ((ca = score(c)) < aa) {\n        a = c, aa = ca;\n      }\n    }\n    b = a.next;\n  }\n\n  // Compute the enclosing circle of the front chain.\n  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);\n\n  // Translate the circles to put the enclosing circle around the origin.\n  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;\n\n  return c.r;\n}\n\nexport default function(circles) {\n  packEnclose(circles);\n  return circles;\n}\n","import roundNode from \"./treemap/round\";\nimport treemapDice from \"./treemap/dice\";\n\nexport default function() {\n  var dx = 1,\n      dy = 1,\n      padding = 0,\n      round = false;\n\n  function partition(root) {\n    var n = root.height + 1;\n    root.x0 =\n    root.y0 = padding;\n    root.x1 = dx;\n    root.y1 = dy / n;\n    root.eachBefore(positionNode(dy, n));\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(dy, n) {\n    return function(node) {\n      if (node.children) {\n        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n      }\n      var x0 = node.x0,\n          y0 = node.y0,\n          x1 = node.x1 - padding,\n          y1 = node.y1 - padding;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      node.x0 = x0;\n      node.y0 = y0;\n      node.x1 = x1;\n      node.y1 = y1;\n    };\n  }\n\n  partition.round = function(x) {\n    return arguments.length ? (round = !!x, partition) : round;\n  };\n\n  partition.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];\n  };\n\n  partition.padding = function(x) {\n    return arguments.length ? (padding = +x, partition) : padding;\n  };\n\n  return partition;\n}\n","import {required} from \"./accessors\";\nimport {Node, computeHeight} from \"./hierarchy/index\";\n\nvar keyPrefix = \"$\", // Protect against keys like __proto__.\n    preroot = {depth: -1},\n    ambiguous = {};\n\nfunction defaultId(d) {\n  return d.id;\n}\n\nfunction defaultParentId(d) {\n  return d.parentId;\n}\n\nexport default function() {\n  var id = defaultId,\n      parentId = defaultParentId;\n\n  function stratify(data) {\n    var d,\n        i,\n        n = data.length,\n        root,\n        parent,\n        node,\n        nodes = new Array(n),\n        nodeId,\n        nodeKey,\n        nodeByKey = {};\n\n    for (i = 0; i < n; ++i) {\n      d = data[i], node = nodes[i] = new Node(d);\n      if ((nodeId = id(d, i, data)) != null && (nodeId += \"\")) {\n        nodeKey = keyPrefix + (node.id = nodeId);\n        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;\n      }\n    }\n\n    for (i = 0; i < n; ++i) {\n      node = nodes[i], nodeId = parentId(data[i], i, data);\n      if (nodeId == null || !(nodeId += \"\")) {\n        if (root) throw new Error(\"multiple roots\");\n        root = node;\n      } else {\n        parent = nodeByKey[keyPrefix + nodeId];\n        if (!parent) throw new Error(\"missing: \" + nodeId);\n        if (parent === ambiguous) throw new Error(\"ambiguous: \" + nodeId);\n        if (parent.children) parent.children.push(node);\n        else parent.children = [node];\n        node.parent = parent;\n      }\n    }\n\n    if (!root) throw new Error(\"no root\");\n    root.parent = preroot;\n    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);\n    root.parent = null;\n    if (n > 0) throw new Error(\"cycle\");\n\n    return root;\n  }\n\n  stratify.id = function(x) {\n    return arguments.length ? (id = required(x), stratify) : id;\n  };\n\n  stratify.parentId = function(x) {\n    return arguments.length ? (parentId = required(x), stratify) : parentId;\n  };\n\n  return stratify;\n}\n","import {Node} from \"./hierarchy/index\";\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n\n// function radialSeparation(a, b) {\n//   return (a.parent === b.parent ? 1 : 2) / a.depth;\n// }\n\n// This function is used to traverse the left contour of a subtree (or\n// subforest). It returns the successor of v on this contour. This successor is\n// either given by the leftmost child of v or by the thread of v. The function\n// returns null if and only if v is on the highest level of its subtree.\nfunction nextLeft(v) {\n  var children = v.children;\n  return children ? children[0] : v.t;\n}\n\n// This function works analogously to nextLeft.\nfunction nextRight(v) {\n  var children = v.children;\n  return children ? children[children.length - 1] : v.t;\n}\n\n// Shifts the current subtree rooted at w+. This is done by increasing\n// prelim(w+) and mod(w+) by shift.\nfunction moveSubtree(wm, wp, shift) {\n  var change = shift / (wp.i - wm.i);\n  wp.c -= change;\n  wp.s += shift;\n  wm.c += change;\n  wp.z += shift;\n  wp.m += shift;\n}\n\n// All other shifts, applied to the smaller subtrees between w- and w+, are\n// performed by this function. To prepare the shifts, we have to adjust\n// change(w+), shift(w+), and change(w-).\nfunction executeShifts(v) {\n  var shift = 0,\n      change = 0,\n      children = v.children,\n      i = children.length,\n      w;\n  while (--i >= 0) {\n    w = children[i];\n    w.z += shift;\n    w.m += shift;\n    shift += w.s + (change += w.c);\n  }\n}\n\n// If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,\n// returns the specified (default) ancestor.\nfunction nextAncestor(vim, v, ancestor) {\n  return vim.a.parent === v.parent ? vim.a : ancestor;\n}\n\nfunction TreeNode(node, i) {\n  this._ = node;\n  this.parent = null;\n  this.children = null;\n  this.A = null; // default ancestor\n  this.a = this; // ancestor\n  this.z = 0; // prelim\n  this.m = 0; // mod\n  this.c = 0; // change\n  this.s = 0; // shift\n  this.t = null; // thread\n  this.i = i; // number\n}\n\nTreeNode.prototype = Object.create(Node.prototype);\n\nfunction treeRoot(root) {\n  var tree = new TreeNode(root, 0),\n      node,\n      nodes = [tree],\n      child,\n      children,\n      i,\n      n;\n\n  while (node = nodes.pop()) {\n    if (children = node._.children) {\n      node.children = new Array(n = children.length);\n      for (i = n - 1; i >= 0; --i) {\n        nodes.push(child = node.children[i] = new TreeNode(children[i], i));\n        child.parent = node;\n      }\n    }\n  }\n\n  (tree.parent = new TreeNode(null, 0)).children = [tree];\n  return tree;\n}\n\n// Node-link tree diagram using the Reingold-Tilford \"tidy\" algorithm\nexport default function() {\n  var separation = defaultSeparation,\n      dx = 1,\n      dy = 1,\n      nodeSize = null;\n\n  function tree(root) {\n    var t = treeRoot(root);\n\n    // Compute the layout using Buchheim et al.s algorithm.\n    t.eachAfter(firstWalk), t.parent.m = -t.z;\n    t.eachBefore(secondWalk);\n\n    // If a fixed node size is specified, scale x and y.\n    if (nodeSize) root.eachBefore(sizeNode);\n\n    // If a fixed tree size is specified, scale x and y based on the extent.\n    // Compute the left-most, right-most, and depth-most nodes for extents.\n    else {\n      var left = root,\n          right = root,\n          bottom = root;\n      root.eachBefore(function(node) {\n        if (node.x < left.x) left = node;\n        if (node.x > right.x) right = node;\n        if (node.depth > bottom.depth) bottom = node;\n      });\n      var s = left === right ? 1 : separation(left, right) / 2,\n          tx = s - left.x,\n          kx = dx / (right.x + s + tx),\n          ky = dy / (bottom.depth || 1);\n      root.eachBefore(function(node) {\n        node.x = (node.x + tx) * kx;\n        node.y = node.depth * ky;\n      });\n    }\n\n    return root;\n  }\n\n  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is\n  // applied recursively to the children of v, as well as the function\n  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the\n  // node v is placed to the midpoint of its outermost children.\n  function firstWalk(v) {\n    var children = v.children,\n        siblings = v.parent.children,\n        w = v.i ? siblings[v.i - 1] : null;\n    if (children) {\n      executeShifts(v);\n      var midpoint = (children[0].z + children[children.length - 1].z) / 2;\n      if (w) {\n        v.z = w.z + separation(v._, w._);\n        v.m = v.z - midpoint;\n      } else {\n        v.z = midpoint;\n      }\n    } else if (w) {\n      v.z = w.z + separation(v._, w._);\n    }\n    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\n  }\n\n  // Computes all real x-coordinates by summing up the modifiers recursively.\n  function secondWalk(v) {\n    v._.x = v.z + v.parent.m;\n    v.m += v.parent.m;\n  }\n\n  // The core of the algorithm. Here, a new subtree is combined with the\n  // previous subtrees. Threads are used to traverse the inside and outside\n  // contours of the left and right subtree up to the highest common level. The\n  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the\n  // superscript o means outside and i means inside, the subscript - means left\n  // subtree and + means right subtree. For summing up the modifiers along the\n  // contour, we use respective variables si+, si-, so-, and so+. Whenever two\n  // nodes of the inside contours conflict, we compute the left one of the\n  // greatest uncommon ancestors using the function ANCESTOR and call MOVE\n  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n  // Finally, we add a new thread (if necessary).\n  function apportion(v, w, ancestor) {\n    if (w) {\n      var vip = v,\n          vop = v,\n          vim = w,\n          vom = vip.parent.children[0],\n          sip = vip.m,\n          sop = vop.m,\n          sim = vim.m,\n          som = vom.m,\n          shift;\n      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {\n        vom = nextLeft(vom);\n        vop = nextRight(vop);\n        vop.a = v;\n        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\n        if (shift > 0) {\n          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);\n          sip += shift;\n          sop += shift;\n        }\n        sim += vim.m;\n        sip += vip.m;\n        som += vom.m;\n        sop += vop.m;\n      }\n      if (vim && !nextRight(vop)) {\n        vop.t = vim;\n        vop.m += sim - sop;\n      }\n      if (vip && !nextLeft(vom)) {\n        vom.t = vip;\n        vom.m += sip - som;\n        ancestor = v;\n      }\n    }\n    return ancestor;\n  }\n\n  function sizeNode(node) {\n    node.x *= dx;\n    node.y = node.depth * dy;\n  }\n\n  tree.separation = function(x) {\n    return arguments.length ? (separation = x, tree) : separation;\n  };\n\n  tree.size = function(x) {\n    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);\n  };\n\n  tree.nodeSize = function(x) {\n    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);\n  };\n\n  return tree;\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      i, n = nodes.length,\n      sum, sums = new Array(n + 1);\n\n  for (sums[0] = sum = i = 0; i < n; ++i) {\n    sums[i + 1] = sum += nodes[i].value;\n  }\n\n  partition(0, n, parent.value, x0, y0, x1, y1);\n\n  function partition(i, j, value, x0, y0, x1, y1) {\n    if (i >= j - 1) {\n      var node = nodes[i];\n      node.x0 = x0, node.y0 = y0;\n      node.x1 = x1, node.y1 = y1;\n      return;\n    }\n\n    var valueOffset = sums[i],\n        valueTarget = (value / 2) + valueOffset,\n        k = i + 1,\n        hi = j - 1;\n\n    while (k < hi) {\n      var mid = k + hi >>> 1;\n      if (sums[mid] < valueTarget) k = mid + 1;\n      else hi = mid;\n    }\n\n    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;\n\n    var valueLeft = sums[k] - valueOffset,\n        valueRight = value - valueLeft;\n\n    if ((x1 - x0) > (y1 - y0)) {\n      var xk = (x0 * valueRight + x1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, xk, y1);\n      partition(k, j, valueRight, xk, y0, x1, y1);\n    } else {\n      var yk = (y0 * valueRight + y1 * valueLeft) / value;\n      partition(i, k, valueLeft, x0, y0, x1, yk);\n      partition(k, j, valueRight, x0, yk, x1, y1);\n    }\n  }\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (x1 - x0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.y0 = y0, node.y1 = y1;\n    node.x0 = x0, node.x1 = x0 += node.value * k;\n  }\n}\n","import roundNode from \"./round\";\nimport squarify from \"./squarify\";\nimport {required} from \"../accessors\";\nimport constant, {constantZero} from \"../constant\";\n\nexport default function() {\n  var tile = squarify,\n      round = false,\n      dx = 1,\n      dy = 1,\n      paddingStack = [0],\n      paddingInner = constantZero,\n      paddingTop = constantZero,\n      paddingRight = constantZero,\n      paddingBottom = constantZero,\n      paddingLeft = constantZero;\n\n  function treemap(root) {\n    root.x0 =\n    root.y0 = 0;\n    root.x1 = dx;\n    root.y1 = dy;\n    root.eachBefore(positionNode);\n    paddingStack = [0];\n    if (round) root.eachBefore(roundNode);\n    return root;\n  }\n\n  function positionNode(node) {\n    var p = paddingStack[node.depth],\n        x0 = node.x0 + p,\n        y0 = node.y0 + p,\n        x1 = node.x1 - p,\n        y1 = node.y1 - p;\n    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n    node.x0 = x0;\n    node.y0 = y0;\n    node.x1 = x1;\n    node.y1 = y1;\n    if (node.children) {\n      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;\n      x0 += paddingLeft(node) - p;\n      y0 += paddingTop(node) - p;\n      x1 -= paddingRight(node) - p;\n      y1 -= paddingBottom(node) - p;\n      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;\n      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;\n      tile(node, x0, y0, x1, y1);\n    }\n  }\n\n  treemap.round = function(x) {\n    return arguments.length ? (round = !!x, treemap) : round;\n  };\n\n  treemap.size = function(x) {\n    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];\n  };\n\n  treemap.tile = function(x) {\n    return arguments.length ? (tile = required(x), treemap) : tile;\n  };\n\n  treemap.padding = function(x) {\n    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();\n  };\n\n  treemap.paddingInner = function(x) {\n    return arguments.length ? (paddingInner = typeof x === \"function\" ? x : constant(+x), treemap) : paddingInner;\n  };\n\n  treemap.paddingOuter = function(x) {\n    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();\n  };\n\n  treemap.paddingTop = function(x) {\n    return arguments.length ? (paddingTop = typeof x === \"function\" ? x : constant(+x), treemap) : paddingTop;\n  };\n\n  treemap.paddingRight = function(x) {\n    return arguments.length ? (paddingRight = typeof x === \"function\" ? x : constant(+x), treemap) : paddingRight;\n  };\n\n  treemap.paddingBottom = function(x) {\n    return arguments.length ? (paddingBottom = typeof x === \"function\" ? x : constant(+x), treemap) : paddingBottom;\n  };\n\n  treemap.paddingLeft = function(x) {\n    return arguments.length ? (paddingLeft = typeof x === \"function\" ? x : constant(+x), treemap) : paddingLeft;\n  };\n\n  return treemap;\n}\n","import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\nimport {phi, squarifyRatio} from \"./squarify\";\n\nexport default (function custom(ratio) {\n\n  function resquarify(parent, x0, y0, x1, y1) {\n    if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n      var rows,\n          row,\n          nodes,\n          i,\n          j = -1,\n          n,\n          m = rows.length,\n          value = parent.value;\n\n      while (++j < m) {\n        row = rows[j], nodes = row.children;\n        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n        value -= row.value;\n      }\n    } else {\n      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n      rows.ratio = ratio;\n    }\n  }\n\n  resquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return resquarify;\n})(phi);\n","export default function(node) {\n  node.x0 = Math.round(node.x0);\n  node.y0 = Math.round(node.y0);\n  node.x1 = Math.round(node.x1);\n  node.y1 = Math.round(node.y1);\n}\n","export default function(parent, x0, y0, x1, y1) {\n  var nodes = parent.children,\n      node,\n      i = -1,\n      n = nodes.length,\n      k = parent.value && (y1 - y0) / parent.value;\n\n  while (++i < n) {\n    node = nodes[i], node.x0 = x0, node.x1 = x1;\n    node.y0 = y0, node.y1 = y0 += node.value * k;\n  }\n}\n","import dice from \"./dice\";\nimport slice from \"./slice\";\n\nexport default function(parent, x0, y0, x1, y1) {\n  (parent.depth & 1 ? slice : dice)(parent, x0, y0, x1, y1);\n}\n","import treemapDice from \"./dice\";\nimport treemapSlice from \"./slice\";\n\nexport var phi = (1 + Math.sqrt(5)) / 2;\n\nexport function squarifyRatio(ratio, parent, x0, y0, x1, y1) {\n  var rows = [],\n      nodes = parent.children,\n      row,\n      nodeValue,\n      i0 = 0,\n      i1 = 0,\n      n = nodes.length,\n      dx, dy,\n      value = parent.value,\n      sumValue,\n      minValue,\n      maxValue,\n      newRatio,\n      minRatio,\n      alpha,\n      beta;\n\n  while (i0 < n) {\n    dx = x1 - x0, dy = y1 - y0;\n\n    // Find the next non-empty node.\n    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);\n    minValue = maxValue = sumValue;\n    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);\n    beta = sumValue * sumValue * alpha;\n    minRatio = Math.max(maxValue / beta, beta / minValue);\n\n    // Keep adding nodes while the aspect ratio maintains or improves.\n    for (; i1 < n; ++i1) {\n      sumValue += nodeValue = nodes[i1].value;\n      if (nodeValue < minValue) minValue = nodeValue;\n      if (nodeValue > maxValue) maxValue = nodeValue;\n      beta = sumValue * sumValue * alpha;\n      newRatio = Math.max(maxValue / beta, beta / minValue);\n      if (newRatio > minRatio) { sumValue -= nodeValue; break; }\n      minRatio = newRatio;\n    }\n\n    // Position and record the row orientation.\n    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});\n    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);\n    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);\n    value -= sumValue, i0 = i1;\n  }\n\n  return rows;\n}\n\nexport default (function custom(ratio) {\n\n  function squarify(parent, x0, y0, x1, y1) {\n    squarifyRatio(ratio, parent, x0, y0, x1, y1);\n  }\n\n  squarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n  };\n\n  return squarify;\n})(phi);\n","import value from \"./value\";\n\nexport default function(a, b) {\n  var nb = b ? b.length : 0,\n      na = a ? Math.min(nb, a.length) : 0,\n      x = new Array(na),\n      c = new Array(nb),\n      i;\n\n  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);\n  for (; i < nb; ++i) c[i] = b[i];\n\n  return function(t) {\n    for (i = 0; i < na; ++i) c[i] = x[i](t);\n    return c;\n  };\n}\n","export function basis(t1, v0, v1, v2, v3) {\n  var t2 = t1 * t1, t3 = t2 * t1;\n  return ((1 - 3 * t1 + 3 * t2 - t3) * v0\n      + (4 - 6 * t2 + 3 * t3) * v1\n      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2\n      + t3 * v3) / 6;\n}\n\nexport default function(values) {\n  var n = values.length - 1;\n  return function(t) {\n    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),\n        v1 = values[i],\n        v2 = values[i + 1],\n        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,\n        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n","import {basis} from \"./basis\";\n\nexport default function(values) {\n  var n = values.length;\n  return function(t) {\n    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),\n        v0 = values[(i + n - 1) % n],\n        v1 = values[i % n],\n        v2 = values[(i + 1) % n],\n        v3 = values[(i + 2) % n];\n    return basis((t - i / n) * n, v0, v1, v2, v3);\n  };\n}\n","import constant from \"./constant\";\n\nfunction linear(a, d) {\n  return function(t) {\n    return a + t * d;\n  };\n}\n\nfunction exponential(a, b, y) {\n  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {\n    return Math.pow(a + t * b, y);\n  };\n}\n\nexport function hue(a, b) {\n  var d = b - a;\n  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);\n}\n\nexport function gamma(y) {\n  return (y = +y) === 1 ? nogamma : function(a, b) {\n    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);\n  };\n}\n\nexport default function nogamma(a, b) {\n  var d = b - a;\n  return d ? linear(a, d) : constant(isNaN(a) ? b : a);\n}\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","import {cubehelix as colorCubehelix} from \"d3-color\";\nimport color, {hue} from \"./color\";\n\nfunction cubehelix(hue) {\n  return (function cubehelixGamma(y) {\n    y = +y;\n\n    function cubehelix(start, end) {\n      var h = hue((start = colorCubehelix(start)).h, (end = colorCubehelix(end)).h),\n          s = color(start.s, end.s),\n          l = color(start.l, end.l),\n          opacity = color(start.opacity, end.opacity);\n      return function(t) {\n        start.h = h(t);\n        start.s = s(t);\n        start.l = l(Math.pow(t, y));\n        start.opacity = opacity(t);\n        return start + \"\";\n      };\n    }\n\n    cubehelix.gamma = cubehelixGamma;\n\n    return cubehelix;\n  })(1);\n}\n\nexport default cubehelix(hue);\nexport var cubehelixLong = cubehelix(color);\n","export default function(a, b) {\n  var d = new Date;\n  return a = +a, b -= a, function(t) {\n    return d.setTime(a + b * t), d;\n  };\n}\n","export default function(range) {\n  var n = range.length;\n  return function(t) {\n    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n","import {hcl as colorHcl} from \"d3-color\";\nimport color, {hue} from \"./color\";\n\nfunction hcl(hue) {\n  return function(start, end) {\n    var h = hue((start = colorHcl(start)).h, (end = colorHcl(end)).h),\n        c = color(start.c, end.c),\n        l = color(start.l, end.l),\n        opacity = color(start.opacity, end.opacity);\n    return function(t) {\n      start.h = h(t);\n      start.c = c(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n}\n\nexport default hcl(hue);\nexport var hclLong = hcl(color);\n","import {hsl as colorHsl} from \"d3-color\";\nimport color, {hue} from \"./color\";\n\nfunction hsl(hue) {\n  return function(start, end) {\n    var h = hue((start = colorHsl(start)).h, (end = colorHsl(end)).h),\n        s = color(start.s, end.s),\n        l = color(start.l, end.l),\n        opacity = color(start.opacity, end.opacity);\n    return function(t) {\n      start.h = h(t);\n      start.s = s(t);\n      start.l = l(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n}\n\nexport default hsl(hue);\nexport var hslLong = hsl(color);\n","import {hue} from \"./color\";\n\nexport default function(a, b) {\n  var i = hue(+a, +b);\n  return function(t) {\n    var x = i(t);\n    return x - 360 * Math.floor(x / 360);\n  };\n}\n","export {default as interpolate} from \"./value\";\nexport {default as interpolateArray} from \"./array\";\nexport {default as interpolateBasis} from \"./basis\";\nexport {default as interpolateBasisClosed} from \"./basisClosed\";\nexport {default as interpolateDate} from \"./date\";\nexport {default as interpolateDiscrete} from \"./discrete\";\nexport {default as interpolateHue} from \"./hue\";\nexport {default as interpolateNumber} from \"./number\";\nexport {default as interpolateObject} from \"./object\";\nexport {default as interpolateRound} from \"./round\";\nexport {default as interpolateString} from \"./string\";\nexport {interpolateTransformCss, interpolateTransformSvg} from \"./transform/index\";\nexport {default as interpolateZoom} from \"./zoom\";\nexport {default as interpolateRgb, rgbBasis as interpolateRgbBasis, rgbBasisClosed as interpolateRgbBasisClosed} from \"./rgb\";\nexport {default as interpolateHsl, hslLong as interpolateHslLong} from \"./hsl\";\nexport {default as interpolateLab} from \"./lab\";\nexport {default as interpolateHcl, hclLong as interpolateHclLong} from \"./hcl\";\nexport {default as interpolateCubehelix, cubehelixLong as interpolateCubehelixLong} from \"./cubehelix\";\nexport {default as piecewise} from \"./piecewise\";\nexport {default as quantize} from \"./quantize\";\n","import {lab as colorLab} from \"d3-color\";\nimport color from \"./color\";\n\nexport default function lab(start, end) {\n  var l = color((start = colorLab(start)).l, (end = colorLab(end)).l),\n      a = color(start.a, end.a),\n      b = color(start.b, end.b),\n      opacity = color(start.opacity, end.opacity);\n  return function(t) {\n    start.l = l(t);\n    start.a = a(t);\n    start.b = b(t);\n    start.opacity = opacity(t);\n    return start + \"\";\n  };\n}\n","export default function(a, b) {\n  return a = +a, b -= a, function(t) {\n    return a + b * t;\n  };\n}\n","import value from \"./value\";\n\nexport default function(a, b) {\n  var i = {},\n      c = {},\n      k;\n\n  if (a === null || typeof a !== \"object\") a = {};\n  if (b === null || typeof b !== \"object\") b = {};\n\n  for (k in b) {\n    if (k in a) {\n      i[k] = value(a[k], b[k]);\n    } else {\n      c[k] = b[k];\n    }\n  }\n\n  return function(t) {\n    for (k in i) c[k] = i[k](t);\n    return c;\n  };\n}\n","export default function piecewise(interpolate, values) {\n  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);\n  while (i < n) I[i] = interpolate(v, v = values[++i]);\n  return function(t) {\n    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));\n    return I[i](t - i);\n  };\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n","import {rgb as colorRgb} from \"d3-color\";\nimport basis from \"./basis\";\nimport basisClosed from \"./basisClosed\";\nimport nogamma, {gamma} from \"./color\";\n\nexport default (function rgbGamma(y) {\n  var color = gamma(y);\n\n  function rgb(start, end) {\n    var r = color((start = colorRgb(start)).r, (end = colorRgb(end)).r),\n        g = color(start.g, end.g),\n        b = color(start.b, end.b),\n        opacity = nogamma(start.opacity, end.opacity);\n    return function(t) {\n      start.r = r(t);\n      start.g = g(t);\n      start.b = b(t);\n      start.opacity = opacity(t);\n      return start + \"\";\n    };\n  }\n\n  rgb.gamma = rgbGamma;\n\n  return rgb;\n})(1);\n\nfunction rgbSpline(spline) {\n  return function(colors) {\n    var n = colors.length,\n        r = new Array(n),\n        g = new Array(n),\n        b = new Array(n),\n        i, color;\n    for (i = 0; i < n; ++i) {\n      color = colorRgb(colors[i]);\n      r[i] = color.r || 0;\n      g[i] = color.g || 0;\n      b[i] = color.b || 0;\n    }\n    r = spline(r);\n    g = spline(g);\n    b = spline(b);\n    color.opacity = 1;\n    return function(t) {\n      color.r = r(t);\n      color.g = g(t);\n      color.b = b(t);\n      return color + \"\";\n    };\n  };\n}\n\nexport var rgbBasis = rgbSpline(basis);\nexport var rgbBasisClosed = rgbSpline(basisClosed);\n","export default function(a, b) {\n  return a = +a, b -= a, function(t) {\n    return Math.round(a + b * t);\n  };\n}\n","import number from \"./number\";\n\nvar reA = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,\n    reB = new RegExp(reA.source, \"g\");\n\nfunction zero(b) {\n  return function() {\n    return b;\n  };\n}\n\nfunction one(b) {\n  return function(t) {\n    return b(t) + \"\";\n  };\n}\n\nexport default function(a, b) {\n  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b\n      am, // current match in a\n      bm, // current match in b\n      bs, // string preceding current number in b, if any\n      i = -1, // index in s\n      s = [], // string constants and placeholders\n      q = []; // number interpolators\n\n  // Coerce inputs to strings.\n  a = a + \"\", b = b + \"\";\n\n  // Interpolate pairs of numbers in a & b.\n  while ((am = reA.exec(a))\n      && (bm = reB.exec(b))) {\n    if ((bs = bm.index) > bi) { // a string precedes the next number in b\n      bs = b.slice(bi, bs);\n      if (s[i]) s[i] += bs; // coalesce with previous string\n      else s[++i] = bs;\n    }\n    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match\n      if (s[i]) s[i] += bm; // coalesce with previous string\n      else s[++i] = bm;\n    } else { // interpolate non-matching numbers\n      s[++i] = null;\n      q.push({i: i, x: number(am, bm)});\n    }\n    bi = reB.lastIndex;\n  }\n\n  // Add remains of b.\n  if (bi < b.length) {\n    bs = b.slice(bi);\n    if (s[i]) s[i] += bs; // coalesce with previous string\n    else s[++i] = bs;\n  }\n\n  // Special optimization for only a single match.\n  // Otherwise, interpolate each of the numbers and rejoin the string.\n  return s.length < 2 ? (q[0]\n      ? one(q[0].x)\n      : zero(b))\n      : (b = q.length, function(t) {\n          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\n          return s.join(\"\");\n        });\n}\n","var degrees = 180 / Math.PI;\n\nexport var identity = {\n  translateX: 0,\n  translateY: 0,\n  rotate: 0,\n  skewX: 0,\n  scaleX: 1,\n  scaleY: 1\n};\n\nexport default function(a, b, c, d, e, f) {\n  var scaleX, scaleY, skewX;\n  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;\n  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;\n  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;\n  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;\n  return {\n    translateX: e,\n    translateY: f,\n    rotate: Math.atan2(b, a) * degrees,\n    skewX: Math.atan(skewX) * degrees,\n    scaleX: scaleX,\n    scaleY: scaleY\n  };\n}\n","import number from \"../number\";\nimport {parseCss, parseSvg} from \"./parse\";\n\nfunction interpolateTransform(parse, pxComma, pxParen, degParen) {\n\n  function pop(s) {\n    return s.length ? s.pop() + \" \" : \"\";\n  }\n\n  function translate(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(\"translate(\", null, pxComma, null, pxParen);\n      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});\n    } else if (xb || yb) {\n      s.push(\"translate(\" + xb + pxComma + yb + pxParen);\n    }\n  }\n\n  function rotate(a, b, s, q) {\n    if (a !== b) {\n      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path\n      q.push({i: s.push(pop(s) + \"rotate(\", null, degParen) - 2, x: number(a, b)});\n    } else if (b) {\n      s.push(pop(s) + \"rotate(\" + b + degParen);\n    }\n  }\n\n  function skewX(a, b, s, q) {\n    if (a !== b) {\n      q.push({i: s.push(pop(s) + \"skewX(\", null, degParen) - 2, x: number(a, b)});\n    } else if (b) {\n      s.push(pop(s) + \"skewX(\" + b + degParen);\n    }\n  }\n\n  function scale(xa, ya, xb, yb, s, q) {\n    if (xa !== xb || ya !== yb) {\n      var i = s.push(pop(s) + \"scale(\", null, \",\", null, \")\");\n      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});\n    } else if (xb !== 1 || yb !== 1) {\n      s.push(pop(s) + \"scale(\" + xb + \",\" + yb + \")\");\n    }\n  }\n\n  return function(a, b) {\n    var s = [], // string constants and placeholders\n        q = []; // number interpolators\n    a = parse(a), b = parse(b);\n    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);\n    rotate(a.rotate, b.rotate, s, q);\n    skewX(a.skewX, b.skewX, s, q);\n    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);\n    a = b = null; // gc\n    return function(t) {\n      var i = -1, n = q.length, o;\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n      return s.join(\"\");\n    };\n  };\n}\n\nexport var interpolateTransformCss = interpolateTransform(parseCss, \"px, \", \"px)\", \"deg)\");\nexport var interpolateTransformSvg = interpolateTransform(parseSvg, \", \", \")\", \")\");\n","import decompose, {identity} from \"./decompose\";\n\nvar cssNode,\n    cssRoot,\n    cssView,\n    svgNode;\n\nexport function parseCss(value) {\n  if (value === \"none\") return identity;\n  if (!cssNode) cssNode = document.createElement(\"DIV\"), cssRoot = document.documentElement, cssView = document.defaultView;\n  cssNode.style.transform = value;\n  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue(\"transform\");\n  cssRoot.removeChild(cssNode);\n  value = value.slice(7, -1).split(\",\");\n  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);\n}\n\nexport function parseSvg(value) {\n  if (value == null) return identity;\n  if (!svgNode) svgNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n  svgNode.setAttribute(\"transform\", value);\n  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;\n  value = value.matrix;\n  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);\n}\n","import {color} from \"d3-color\";\nimport rgb from \"./rgb\";\nimport array from \"./array\";\nimport date from \"./date\";\nimport number from \"./number\";\nimport object from \"./object\";\nimport string from \"./string\";\nimport constant from \"./constant\";\n\nexport default function(a, b) {\n  var t = typeof b, c;\n  return b == null || t === \"boolean\" ? constant(b)\n      : (t === \"number\" ? number\n      : t === \"string\" ? ((c = color(b)) ? (b = c, rgb) : string)\n      : b instanceof color ? rgb\n      : b instanceof Date ? date\n      : Array.isArray(b) ? array\n      : typeof b.valueOf !== \"function\" && typeof b.toString !== \"function\" || isNaN(b) ? object\n      : number)(a, b);\n}\n","var rho = Math.SQRT2,\n    rho2 = 2,\n    rho4 = 4,\n    epsilon2 = 1e-12;\n\nfunction cosh(x) {\n  return ((x = Math.exp(x)) + 1 / x) / 2;\n}\n\nfunction sinh(x) {\n  return ((x = Math.exp(x)) - 1 / x) / 2;\n}\n\nfunction tanh(x) {\n  return ((x = Math.exp(2 * x)) - 1) / (x + 1);\n}\n\n// p0 = [ux0, uy0, w0]\n// p1 = [ux1, uy1, w1]\nexport default function(p0, p1) {\n  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],\n      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],\n      dx = ux1 - ux0,\n      dy = uy1 - uy0,\n      d2 = dx * dx + dy * dy,\n      i,\n      S;\n\n  // Special case for u0  u1.\n  if (d2 < epsilon2) {\n    S = Math.log(w1 / w0) / rho;\n    i = function(t) {\n      return [\n        ux0 + t * dx,\n        uy0 + t * dy,\n        w0 * Math.exp(rho * t * S)\n      ];\n    }\n  }\n\n  // General case.\n  else {\n    var d1 = Math.sqrt(d2),\n        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),\n        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),\n        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),\n        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n    S = (r1 - r0) / rho;\n    i = function(t) {\n      var s = t * S,\n          coshr0 = cosh(r0),\n          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));\n      return [\n        ux0 + u * dx,\n        uy0 + u * dy,\n        w0 * coshr0 / cosh(rho * s + r0)\n      ];\n    }\n  }\n\n  i.duration = S * 1000;\n\n  return i;\n}\n","export {default as path} from \"./path\";\n","var pi = Math.PI,\n    tau = 2 * pi,\n    epsilon = 1e-6,\n    tauEpsilon = tau - epsilon;\n\nfunction Path() {\n  this._x0 = this._y0 = // start of current subpath\n  this._x1 = this._y1 = null; // end of current subpath\n  this._ = \"\";\n}\n\nfunction path() {\n  return new Path;\n}\n\nPath.prototype = path.prototype = {\n  constructor: Path,\n  moveTo: function(x, y) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y);\n  },\n  closePath: function() {\n    if (this._x1 !== null) {\n      this._x1 = this._x0, this._y1 = this._y0;\n      this._ += \"Z\";\n    }\n  },\n  lineTo: function(x, y) {\n    this._ += \"L\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  quadraticCurveTo: function(x1, y1, x, y) {\n    this._ += \"Q\" + (+x1) + \",\" + (+y1) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) {\n    this._ += \"C\" + (+x1) + \",\" + (+y1) + \",\" + (+x2) + \",\" + (+y2) + \",\" + (this._x1 = +x) + \",\" + (this._y1 = +y);\n  },\n  arcTo: function(x1, y1, x2, y2, r) {\n    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;\n    var x0 = this._x1,\n        y0 = this._y1,\n        x21 = x2 - x1,\n        y21 = y2 - y1,\n        x01 = x0 - x1,\n        y01 = y0 - y1,\n        l01_2 = x01 * x01 + y01 * y01;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x1,y1).\n    if (this._x1 === null) {\n      this._ += \"M\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n    else if (!(l01_2 > epsilon));\n\n    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n    // Equivalently, is (x1,y1) coincident with (x2,y2)?\n    // Or, is the radius zero? Line to (x1,y1).\n    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {\n      this._ += \"L\" + (this._x1 = x1) + \",\" + (this._y1 = y1);\n    }\n\n    // Otherwise, draw an arc!\n    else {\n      var x20 = x2 - x0,\n          y20 = y2 - y0,\n          l21_2 = x21 * x21 + y21 * y21,\n          l20_2 = x20 * x20 + y20 * y20,\n          l21 = Math.sqrt(l21_2),\n          l01 = Math.sqrt(l01_2),\n          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),\n          t01 = l / l01,\n          t21 = l / l21;\n\n      // If the start tangent is not coincident with (x0,y0), line to.\n      if (Math.abs(t01 - 1) > epsilon) {\n        this._ += \"L\" + (x1 + t01 * x01) + \",\" + (y1 + t01 * y01);\n      }\n\n      this._ += \"A\" + r + \",\" + r + \",0,0,\" + (+(y01 * x20 > x01 * y20)) + \",\" + (this._x1 = x1 + t21 * x21) + \",\" + (this._y1 = y1 + t21 * y21);\n    }\n  },\n  arc: function(x, y, r, a0, a1, ccw) {\n    x = +x, y = +y, r = +r;\n    var dx = r * Math.cos(a0),\n        dy = r * Math.sin(a0),\n        x0 = x + dx,\n        y0 = y + dy,\n        cw = 1 ^ ccw,\n        da = ccw ? a0 - a1 : a1 - a0;\n\n    // Is the radius negative? Error.\n    if (r < 0) throw new Error(\"negative radius: \" + r);\n\n    // Is this path empty? Move to (x0,y0).\n    if (this._x1 === null) {\n      this._ += \"M\" + x0 + \",\" + y0;\n    }\n\n    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).\n    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {\n      this._ += \"L\" + x0 + \",\" + y0;\n    }\n\n    // Is this arc empty? Were done.\n    if (!r) return;\n\n    // Does the angle go the wrong way? Flip the direction.\n    if (da < 0) da = da % tau + tau;\n\n    // Is this a complete circle? Draw two arcs to complete the circle.\n    if (da > tauEpsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (x - dx) + \",\" + (y - dy) + \"A\" + r + \",\" + r + \",0,1,\" + cw + \",\" + (this._x1 = x0) + \",\" + (this._y1 = y0);\n    }\n\n    // Is this arc non-empty? Draw an arc!\n    else if (da > epsilon) {\n      this._ += \"A\" + r + \",\" + r + \",0,\" + (+(da >= pi)) + \",\" + cw + \",\" + (this._x1 = x + r * Math.cos(a1)) + \",\" + (this._y1 = y + r * Math.sin(a1));\n    }\n  },\n  rect: function(x, y, w, h) {\n    this._ += \"M\" + (this._x0 = this._x1 = +x) + \",\" + (this._y0 = this._y1 = +y) + \"h\" + (+w) + \"v\" + (+h) + \"h\" + (-w) + \"Z\";\n  },\n  toString: function() {\n    return this._;\n  }\n};\n\nexport default path;\n","export default function(d) {\n  var x = +this._x.call(null, d),\n      y = +this._y.call(null, d);\n  return add(this.cover(x, y), x, y, d);\n}\n\nfunction add(tree, x, y, d) {\n  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points\n\n  var parent,\n      node = tree._root,\n      leaf = {data: d},\n      x0 = tree._x0,\n      y0 = tree._y0,\n      x1 = tree._x1,\n      y1 = tree._y1,\n      xm,\n      ym,\n      xp,\n      yp,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return tree._root = leaf, tree;\n\n  // Find the existing leaf for the new point, or add it.\n  while (node.length) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;\n  }\n\n  // Is the new point is exactly coincident with the existing point?\n  xp = +tree._x.call(null, node.data);\n  yp = +tree._y.call(null, node.data);\n  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;\n\n  // Otherwise, split the leaf node until the old and new point are separated.\n  do {\n    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));\n  return parent[j] = node, parent[i] = leaf, tree;\n}\n\nexport function addAll(data) {\n  var d, i, n = data.length,\n      x,\n      y,\n      xz = new Array(n),\n      yz = new Array(n),\n      x0 = Infinity,\n      y0 = Infinity,\n      x1 = -Infinity,\n      y1 = -Infinity;\n\n  // Compute the points and their extent.\n  for (i = 0; i < n; ++i) {\n    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;\n    xz[i] = x;\n    yz[i] = y;\n    if (x < x0) x0 = x;\n    if (x > x1) x1 = x;\n    if (y < y0) y0 = y;\n    if (y > y1) y1 = y;\n  }\n\n  // If there were no (valid) points, inherit the existing extent.\n  if (x1 < x0) x0 = this._x0, x1 = this._x1;\n  if (y1 < y0) y0 = this._y0, y1 = this._y1;\n\n  // Expand the tree to cover the new points.\n  this.cover(x0, y0).cover(x1, y1);\n\n  // Add the new points.\n  for (i = 0; i < n; ++i) {\n    add(this, xz[i], yz[i], data[i]);\n  }\n\n  return this;\n}\n","export default function(x, y) {\n  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points\n\n  var x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1;\n\n  // If the quadtree has no extent, initialize them.\n  // Integer extent are necessary so that if we later double the extent,\n  // the existing quadrant boundaries dont change due to floating point error!\n  if (isNaN(x0)) {\n    x1 = (x0 = Math.floor(x)) + 1;\n    y1 = (y0 = Math.floor(y)) + 1;\n  }\n\n  // Otherwise, double repeatedly to cover.\n  else if (x0 > x || x > x1 || y0 > y || y > y1) {\n    var z = x1 - x0,\n        node = this._root,\n        parent,\n        i;\n\n    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {\n      case 0: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);\n        break;\n      }\n      case 1: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);\n        break;\n      }\n      case 2: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);\n        break;\n      }\n      case 3: {\n        do parent = new Array(4), parent[i] = node, node = parent;\n        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);\n        break;\n      }\n    }\n\n    if (this._root && this._root.length) this._root = node;\n  }\n\n  // If the quadtree covers the point already, just return.\n  else return this;\n\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  return this;\n}\n","export default function() {\n  var data = [];\n  this.visit(function(node) {\n    if (!node.length) do data.push(node.data); while (node = node.next)\n  });\n  return data;\n}\n","export default function(_) {\n  return arguments.length\n      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])\n      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];\n}\n","import Quad from \"./quad\";\n\nexport default function(x, y, radius) {\n  var data,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1,\n      y1,\n      x2,\n      y2,\n      x3 = this._x1,\n      y3 = this._y1,\n      quads = [],\n      node = this._root,\n      q,\n      i;\n\n  if (node) quads.push(new Quad(node, x0, y0, x3, y3));\n  if (radius == null) radius = Infinity;\n  else {\n    x0 = x - radius, y0 = y - radius;\n    x3 = x + radius, y3 = y + radius;\n    radius *= radius;\n  }\n\n  while (q = quads.pop()) {\n\n    // Stop searching if this quadrant cant contain a closer node.\n    if (!(node = q.node)\n        || (x1 = q.x0) > x3\n        || (y1 = q.y0) > y3\n        || (x2 = q.x1) < x0\n        || (y2 = q.y1) < y0) continue;\n\n    // Bisect the current quadrant.\n    if (node.length) {\n      var xm = (x1 + x2) / 2,\n          ym = (y1 + y2) / 2;\n\n      quads.push(\n        new Quad(node[3], xm, ym, x2, y2),\n        new Quad(node[2], x1, ym, xm, y2),\n        new Quad(node[1], xm, y1, x2, ym),\n        new Quad(node[0], x1, y1, xm, ym)\n      );\n\n      // Visit the closest quadrant first.\n      if (i = (y >= ym) << 1 | (x >= xm)) {\n        q = quads[quads.length - 1];\n        quads[quads.length - 1] = quads[quads.length - 1 - i];\n        quads[quads.length - 1 - i] = q;\n      }\n    }\n\n    // Visit this point. (Visiting coincident points isnt necessary!)\n    else {\n      var dx = x - +this._x.call(null, node.data),\n          dy = y - +this._y.call(null, node.data),\n          d2 = dx * dx + dy * dy;\n      if (d2 < radius) {\n        var d = Math.sqrt(radius = d2);\n        x0 = x - d, y0 = y - d;\n        x3 = x + d, y3 = y + d;\n        data = node.data;\n      }\n    }\n  }\n\n  return data;\n}\n","export {default as quadtree} from \"./quadtree\";\n","export default function(node, x0, y0, x1, y1) {\n  this.node = node;\n  this.x0 = x0;\n  this.y0 = y0;\n  this.x1 = x1;\n  this.y1 = y1;\n}\n","import tree_add, {addAll as tree_addAll} from \"./add\";\nimport tree_cover from \"./cover\";\nimport tree_data from \"./data\";\nimport tree_extent from \"./extent\";\nimport tree_find from \"./find\";\nimport tree_remove, {removeAll as tree_removeAll} from \"./remove\";\nimport tree_root from \"./root\";\nimport tree_size from \"./size\";\nimport tree_visit from \"./visit\";\nimport tree_visitAfter from \"./visitAfter\";\nimport tree_x, {defaultX} from \"./x\";\nimport tree_y, {defaultY} from \"./y\";\n\nexport default function quadtree(nodes, x, y) {\n  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);\n  return nodes == null ? tree : tree.addAll(nodes);\n}\n\nfunction Quadtree(x, y, x0, y0, x1, y1) {\n  this._x = x;\n  this._y = y;\n  this._x0 = x0;\n  this._y0 = y0;\n  this._x1 = x1;\n  this._y1 = y1;\n  this._root = undefined;\n}\n\nfunction leaf_copy(leaf) {\n  var copy = {data: leaf.data}, next = copy;\n  while (leaf = leaf.next) next = next.next = {data: leaf.data};\n  return copy;\n}\n\nvar treeProto = quadtree.prototype = Quadtree.prototype;\n\ntreeProto.copy = function() {\n  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n      node = this._root,\n      nodes,\n      child;\n\n  if (!node) return copy;\n\n  if (!node.length) return copy._root = leaf_copy(node), copy;\n\n  nodes = [{source: node, target: copy._root = new Array(4)}];\n  while (node = nodes.pop()) {\n    for (var i = 0; i < 4; ++i) {\n      if (child = node.source[i]) {\n        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});\n        else node.target[i] = leaf_copy(child);\n      }\n    }\n  }\n\n  return copy;\n};\n\ntreeProto.add = tree_add;\ntreeProto.addAll = tree_addAll;\ntreeProto.cover = tree_cover;\ntreeProto.data = tree_data;\ntreeProto.extent = tree_extent;\ntreeProto.find = tree_find;\ntreeProto.remove = tree_remove;\ntreeProto.removeAll = tree_removeAll;\ntreeProto.root = tree_root;\ntreeProto.size = tree_size;\ntreeProto.visit = tree_visit;\ntreeProto.visitAfter = tree_visitAfter;\ntreeProto.x = tree_x;\ntreeProto.y = tree_y;\n","export default function(d) {\n  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points\n\n  var parent,\n      node = this._root,\n      retainer,\n      previous,\n      next,\n      x0 = this._x0,\n      y0 = this._y0,\n      x1 = this._x1,\n      y1 = this._y1,\n      x,\n      y,\n      xm,\n      ym,\n      right,\n      bottom,\n      i,\n      j;\n\n  // If the tree is empty, initialize the root as a leaf.\n  if (!node) return this;\n\n  // Find the leaf node for the point.\n  // While descending, also retain the deepest parent with a non-removed sibling.\n  if (node.length) while (true) {\n    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;\n    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;\n    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;\n    if (!node.length) break;\n    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;\n  }\n\n  // Find the point to remove.\n  while (node.data !== d) if (!(previous = node, node = node.next)) return this;\n  if (next = node.next) delete node.next;\n\n  // If there are multiple coincident points, remove just the point.\n  if (previous) return (next ? previous.next = next : delete previous.next), this;\n\n  // If this is the root point, remove it.\n  if (!parent) return this._root = next, this;\n\n  // Remove this leaf.\n  next ? parent[i] = next : delete parent[i];\n\n  // If the parent now contains exactly one leaf, collapse superfluous parents.\n  if ((node = parent[0] || parent[1] || parent[2] || parent[3])\n      && node === (parent[3] || parent[2] || parent[1] || parent[0])\n      && !node.length) {\n    if (retainer) retainer[j] = node;\n    else this._root = node;\n  }\n\n  return this;\n}\n\nexport function removeAll(data) {\n  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);\n  return this;\n}\n","export default function() {\n  return this._root;\n}\n","export default function() {\n  var size = 0;\n  this.visit(function(node) {\n    if (!node.length) do ++size; while (node = node.next)\n  });\n  return size;\n}\n","import Quad from \"./quad\";\n\nexport default function(callback) {\n  var quads = [], q, node = this._root, child, x0, y0, x1, y1;\n  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {\n      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n    }\n  }\n  return this;\n}\n","import Quad from \"./quad\";\n\nexport default function(callback) {\n  var quads = [], next = [], q;\n  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));\n  while (q = quads.pop()) {\n    var node = q.node;\n    if (node.length) {\n      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;\n      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));\n      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));\n      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));\n      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));\n    }\n    next.push(q);\n  }\n  while (q = next.pop()) {\n    callback(q.node, q.x0, q.y0, q.x1, q.y1);\n  }\n  return this;\n}\n","export function defaultX(d) {\n  return d[0];\n}\n\nexport default function(_) {\n  return arguments.length ? (this._x = _, this) : this._x;\n}\n","export function defaultY(d) {\n  return d[1];\n}\n\nexport default function(_) {\n  return arguments.length ? (this._y = _, this) : this._y;\n}\n","import colors from \"../colors\";\n\nexport default colors(\"7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666\");\n","import colors from \"../colors\";\n\nexport default colors(\"1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666\");\n","import colors from \"../colors\";\n\nexport default colors(\"a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928\");\n","import colors from \"../colors\";\n\nexport default colors(\"fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2\");\n","import colors from \"../colors\";\n\nexport default colors(\"b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc\");\n","import colors from \"../colors\";\n\nexport default colors(\"e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999\");\n","import colors from \"../colors\";\n\nexport default colors(\"66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3\");\n","import colors from \"../colors\";\n\nexport default colors(\"8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f\");\n","import colors from \"../colors\";\n\nexport default colors(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\");\n","export default function(specifier) {\n  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;\n  while (i < n) colors[i] = \"#\" + specifier.slice(i * 6, ++i * 6);\n  return colors;\n}\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"d8b365f5f5f55ab4ac\",\n  \"a6611adfc27d80cdc1018571\",\n  \"a6611adfc27df5f5f580cdc1018571\",\n  \"8c510ad8b365f6e8c3c7eae55ab4ac01665e\",\n  \"8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e\",\n  \"8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e\",\n  \"8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e\",\n  \"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30\",\n  \"5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"af8dc3f7f7f77fbf7b\",\n  \"7b3294c2a5cfa6dba0008837\",\n  \"7b3294c2a5cff7f7f7a6dba0008837\",\n  \"762a83af8dc3e7d4e8d9f0d37fbf7b1b7837\",\n  \"762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837\",\n  \"762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837\",\n  \"762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837\",\n  \"40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b\",\n  \"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"e9a3c9f7f7f7a1d76a\",\n  \"d01c8bf1b6dab8e1864dac26\",\n  \"d01c8bf1b6daf7f7f7b8e1864dac26\",\n  \"c51b7de9a3c9fde0efe6f5d0a1d76a4d9221\",\n  \"c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221\",\n  \"c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221\",\n  \"c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221\",\n  \"8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419\",\n  \"8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"998ec3f7f7f7f1a340\",\n  \"5e3c99b2abd2fdb863e66101\",\n  \"5e3c99b2abd2f7f7f7fdb863e66101\",\n  \"542788998ec3d8daebfee0b6f1a340b35806\",\n  \"542788998ec3d8daebf7f7f7fee0b6f1a340b35806\",\n  \"5427888073acb2abd2d8daebfee0b6fdb863e08214b35806\",\n  \"5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806\",\n  \"2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08\",\n  \"2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"ef8a62f7f7f767a9cf\",\n  \"ca0020f4a58292c5de0571b0\",\n  \"ca0020f4a582f7f7f792c5de0571b0\",\n  \"b2182bef8a62fddbc7d1e5f067a9cf2166ac\",\n  \"b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac\",\n  \"b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac\",\n  \"b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac\",\n  \"67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061\",\n  \"67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"ef8a62ffffff999999\",\n  \"ca0020f4a582bababa404040\",\n  \"ca0020f4a582ffffffbababa404040\",\n  \"b2182bef8a62fddbc7e0e0e09999994d4d4d\",\n  \"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d\",\n  \"b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d\",\n  \"b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d\",\n  \"67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a\",\n  \"67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"fc8d59ffffbf91bfdb\",\n  \"d7191cfdae61abd9e92c7bb6\",\n  \"d7191cfdae61ffffbfabd9e92c7bb6\",\n  \"d73027fc8d59fee090e0f3f891bfdb4575b4\",\n  \"d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4\",\n  \"d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4\",\n  \"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4\",\n  \"a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695\",\n  \"a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"fc8d59ffffbf91cf60\",\n  \"d7191cfdae61a6d96a1a9641\",\n  \"d7191cfdae61ffffbfa6d96a1a9641\",\n  \"d73027fc8d59fee08bd9ef8b91cf601a9850\",\n  \"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850\",\n  \"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850\",\n  \"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850\",\n  \"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837\",\n  \"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"fc8d59ffffbf99d594\",\n  \"d7191cfdae61abdda42b83ba\",\n  \"d7191cfdae61ffffbfabdda42b83ba\",\n  \"d53e4ffc8d59fee08be6f59899d5943288bd\",\n  \"d53e4ffc8d59fee08bffffbfe6f59899d5943288bd\",\n  \"d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd\",\n  \"d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd\",\n  \"9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2\",\n  \"9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2\"\n).map(colors);\n\nexport default ramp(scheme);\n","export {default as schemeCategory10} from \"./categorical/category10\";\nexport {default as schemeAccent} from \"./categorical/Accent\";\nexport {default as schemeDark2} from \"./categorical/Dark2\";\nexport {default as schemePaired} from \"./categorical/Paired\";\nexport {default as schemePastel1} from \"./categorical/Pastel1\";\nexport {default as schemePastel2} from \"./categorical/Pastel2\";\nexport {default as schemeSet1} from \"./categorical/Set1\";\nexport {default as schemeSet2} from \"./categorical/Set2\";\nexport {default as schemeSet3} from \"./categorical/Set3\";\nexport {default as interpolateBrBG, scheme as schemeBrBG} from \"./diverging/BrBG\";\nexport {default as interpolatePRGn, scheme as schemePRGn} from \"./diverging/PRGn\";\nexport {default as interpolatePiYG, scheme as schemePiYG} from \"./diverging/PiYG\";\nexport {default as interpolatePuOr, scheme as schemePuOr} from \"./diverging/PuOr\";\nexport {default as interpolateRdBu, scheme as schemeRdBu} from \"./diverging/RdBu\";\nexport {default as interpolateRdGy, scheme as schemeRdGy} from \"./diverging/RdGy\";\nexport {default as interpolateRdYlBu, scheme as schemeRdYlBu} from \"./diverging/RdYlBu\";\nexport {default as interpolateRdYlGn, scheme as schemeRdYlGn} from \"./diverging/RdYlGn\";\nexport {default as interpolateSpectral, scheme as schemeSpectral} from \"./diverging/Spectral\";\nexport {default as interpolateBuGn, scheme as schemeBuGn} from \"./sequential-multi/BuGn\";\nexport {default as interpolateBuPu, scheme as schemeBuPu} from \"./sequential-multi/BuPu\";\nexport {default as interpolateGnBu, scheme as schemeGnBu} from \"./sequential-multi/GnBu\";\nexport {default as interpolateOrRd, scheme as schemeOrRd} from \"./sequential-multi/OrRd\";\nexport {default as interpolatePuBuGn, scheme as schemePuBuGn} from \"./sequential-multi/PuBuGn\";\nexport {default as interpolatePuBu, scheme as schemePuBu} from \"./sequential-multi/PuBu\";\nexport {default as interpolatePuRd, scheme as schemePuRd} from \"./sequential-multi/PuRd\";\nexport {default as interpolateRdPu, scheme as schemeRdPu} from \"./sequential-multi/RdPu\";\nexport {default as interpolateYlGnBu, scheme as schemeYlGnBu} from \"./sequential-multi/YlGnBu\";\nexport {default as interpolateYlGn, scheme as schemeYlGn} from \"./sequential-multi/YlGn\";\nexport {default as interpolateYlOrBr, scheme as schemeYlOrBr} from \"./sequential-multi/YlOrBr\";\nexport {default as interpolateYlOrRd, scheme as schemeYlOrRd} from \"./sequential-multi/YlOrRd\";\nexport {default as interpolateBlues, scheme as schemeBlues} from \"./sequential-single/Blues\";\nexport {default as interpolateGreens, scheme as schemeGreens} from \"./sequential-single/Greens\";\nexport {default as interpolateGreys, scheme as schemeGreys} from \"./sequential-single/Greys\";\nexport {default as interpolatePurples, scheme as schemePurples} from \"./sequential-single/Purples\";\nexport {default as interpolateReds, scheme as schemeReds} from \"./sequential-single/Reds\";\nexport {default as interpolateOranges, scheme as schemeOranges} from \"./sequential-single/Oranges\";\nexport {default as interpolateCubehelixDefault} from \"./sequential-multi/cubehelix\";\nexport {default as interpolateRainbow, warm as interpolateWarm, cool as interpolateCool} from \"./sequential-multi/rainbow\";\nexport {default as interpolateSinebow} from \"./sequential-multi/sinebow\";\nexport {default as interpolateViridis, magma as interpolateMagma, inferno as interpolateInferno, plasma as interpolatePlasma} from \"./sequential-multi/viridis\";\n","import {interpolateRgbBasis} from \"d3-interpolate\";\n\nexport default function(scheme) {\n  return interpolateRgbBasis(scheme[scheme.length - 1]);\n}\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"e5f5f999d8c92ca25f\",\n  \"edf8fbb2e2e266c2a4238b45\",\n  \"edf8fbb2e2e266c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a42ca25f006d2c\",\n  \"edf8fbccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824\",\n  \"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"e0ecf49ebcda8856a7\",\n  \"edf8fbb3cde38c96c688419d\",\n  \"edf8fbb3cde38c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68856a7810f7c\",\n  \"edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b\",\n  \"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"e0f3dba8ddb543a2ca\",\n  \"f0f9e8bae4bc7bccc42b8cbe\",\n  \"f0f9e8bae4bc7bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc443a2ca0868ac\",\n  \"f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e\",\n  \"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"fee8c8fdbb84e34a33\",\n  \"fef0d9fdcc8afc8d59d7301f\",\n  \"fef0d9fdcc8afc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59e34a33b30000\",\n  \"fef0d9fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000\",\n  \"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"ece7f2a6bddb2b8cbe\",\n  \"f1eef6bdc9e174a9cf0570b0\",\n  \"f1eef6bdc9e174a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d\",\n  \"f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b\",\n  \"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"ece2f0a6bddb1c9099\",\n  \"f6eff7bdc9e167a9cf02818a\",\n  \"f6eff7bdc9e167a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf1c9099016c59\",\n  \"f6eff7d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450\",\n  \"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"e7e1efc994c7dd1c77\",\n  \"f1eef6d7b5d8df65b0ce1256\",\n  \"f1eef6d7b5d8df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0dd1c77980043\",\n  \"f1eef6d4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f\",\n  \"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"fde0ddfa9fb5c51b8a\",\n  \"feebe2fbb4b9f768a1ae017e\",\n  \"feebe2fbb4b9f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1c51b8a7a0177\",\n  \"feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177\",\n  \"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"f7fcb9addd8e31a354\",\n  \"ffffccc2e69978c679238443\",\n  \"ffffccc2e69978c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67931a354006837\",\n  \"ffffccd9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32\",\n  \"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"edf8b17fcdbb2c7fb8\",\n  \"ffffcca1dab441b6c4225ea8\",\n  \"ffffcca1dab441b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c42c7fb8253494\",\n  \"ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84\",\n  \"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"fff7bcfec44fd95f0e\",\n  \"ffffd4fed98efe9929cc4c02\",\n  \"ffffd4fed98efe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929d95f0e993404\",\n  \"ffffd4fee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04\",\n  \"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"ffeda0feb24cf03b20\",\n  \"ffffb2fecc5cfd8d3ce31a1c\",\n  \"ffffb2fecc5cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cf03b20bd0026\",\n  \"ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026\",\n  \"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026\"\n).map(colors);\n\nexport default ramp(scheme);\n","import {cubehelix} from \"d3-color\";\nimport {interpolateCubehelixLong} from \"d3-interpolate\";\n\nexport default interpolateCubehelixLong(cubehelix(300, 0.5, 0.0), cubehelix(-240, 0.5, 1.0));\n","import {cubehelix} from \"d3-color\";\nimport {interpolateCubehelixLong} from \"d3-interpolate\";\n\nexport var warm = interpolateCubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nexport var cool = interpolateCubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.50, 0.8));\n\nvar c = cubehelix();\n\nexport default function(t) {\n  if (t < 0 || t > 1) t -= Math.floor(t);\n  var ts = Math.abs(t - 0.5);\n  c.h = 360 * t - 100;\n  c.s = 1.5 - 1.5 * ts;\n  c.l = 0.8 - 0.9 * ts;\n  return c + \"\";\n}\n","import {rgb} from \"d3-color\";\n\nvar c = rgb(),\n    pi_1_3 = Math.PI / 3,\n    pi_2_3 = Math.PI * 2 / 3;\n\nexport default function(t) {\n  var x;\n  t = (0.5 - t) * Math.PI;\n  c.r = 255 * (x = Math.sin(t)) * x;\n  c.g = 255 * (x = Math.sin(t + pi_1_3)) * x;\n  c.b = 255 * (x = Math.sin(t + pi_2_3)) * x;\n  return c + \"\";\n}\n","import colors from \"../colors\";\n\nfunction ramp(range) {\n  var n = range.length;\n  return function(t) {\n    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];\n  };\n}\n\nexport default ramp(colors(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\"));\n\nexport var magma = ramp(colors(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\"));\n\nexport var inferno = ramp(colors(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\"));\n\nexport var plasma = ramp(colors(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\"));\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"deebf79ecae13182bd\",\n  \"eff3ffbdd7e76baed62171b5\",\n  \"eff3ffbdd7e76baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed63182bd08519c\",\n  \"eff3ffc6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594\",\n  \"f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"e5f5e0a1d99b31a354\",\n  \"edf8e9bae4b374c476238b45\",\n  \"edf8e9bae4b374c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47631a354006d2c\",\n  \"edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32\",\n  \"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"f0f0f0bdbdbd636363\",\n  \"f7f7f7cccccc969696525252\",\n  \"f7f7f7cccccc969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696636363252525\",\n  \"f7f7f7d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525\",\n  \"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"fee6cefdae6be6550d\",\n  \"feeddefdbe85fd8d3cd94701\",\n  \"feeddefdbe85fd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3ce6550da63603\",\n  \"feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04\",\n  \"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"efedf5bcbddc756bb1\",\n  \"f2f0f7cbc9e29e9ac86a51a3\",\n  \"f2f0f7cbc9e29e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8756bb154278f\",\n  \"f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486\",\n  \"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d\"\n).map(colors);\n\nexport default ramp(scheme);\n","import colors from \"../colors\";\nimport ramp from \"../ramp\";\n\nexport var scheme = new Array(3).concat(\n  \"fee0d2fc9272de2d26\",\n  \"fee5d9fcae91fb6a4acb181d\",\n  \"fee5d9fcae91fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4ade2d26a50f15\",\n  \"fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d\",\n  \"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d\"\n).map(colors);\n\nexport default ramp(scheme);\n","var array = Array.prototype;\n\nexport var map = array.map;\nexport var slice = array.slice;\n","import {range as sequence} from \"d3-array\";\nimport ordinal from \"./ordinal\";\n\nexport default function band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse];\n    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);\n    if (round) step = Math.floor(step);\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);\n    var values = sequence(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = [+_[0], +_[1]], round = true, rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    return arguments.length ? (round = !!_, rescale()) : round;\n  };\n\n  scale.padding = function(_) {\n    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingInner = function(_) {\n    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;\n  };\n\n  scale.paddingOuter = function(_) {\n    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;\n  };\n\n  scale.align = function(_) {\n    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;\n  };\n\n  scale.copy = function() {\n    return band()\n        .domain(domain())\n        .range(range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return rescale();\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n  delete scale.paddingOuter;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nexport function point() {\n  return pointish(band().paddingInner(1));\n}\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","import {bisect} from \"d3-array\";\nimport {interpolate as interpolateValue, interpolateRound} from \"d3-interpolate\";\nimport {map, slice} from \"./array\";\nimport constant from \"./constant\";\nimport number from \"./number\";\n\nvar unit = [0, 1];\n\nexport function deinterpolateLinear(a, b) {\n  return (b -= (a = +a))\n      ? function(x) { return (x - a) / b; }\n      : constant(b);\n}\n\nfunction deinterpolateClamp(deinterpolate) {\n  return function(a, b) {\n    var d = deinterpolate(a = +a, b = +b);\n    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };\n  };\n}\n\nfunction reinterpolateClamp(reinterpolate) {\n  return function(a, b) {\n    var r = reinterpolate(a = +a, b = +b);\n    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };\n  };\n}\n\nfunction bimap(domain, range, deinterpolate, reinterpolate) {\n  var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];\n  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);\n  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);\n  return function(x) { return r0(d0(x)); };\n}\n\nfunction polymap(domain, range, deinterpolate, reinterpolate) {\n  var j = Math.min(domain.length, range.length) - 1,\n      d = new Array(j),\n      r = new Array(j),\n      i = -1;\n\n  // Reverse descending domains.\n  if (domain[j] < domain[0]) {\n    domain = domain.slice().reverse();\n    range = range.slice().reverse();\n  }\n\n  while (++i < j) {\n    d[i] = deinterpolate(domain[i], domain[i + 1]);\n    r[i] = reinterpolate(range[i], range[i + 1]);\n  }\n\n  return function(x) {\n    var i = bisect(domain, x, 1, j) - 1;\n    return r[i](d[i](x));\n  };\n}\n\nexport function copy(source, target) {\n  return target\n      .domain(source.domain())\n      .range(source.range())\n      .interpolate(source.interpolate())\n      .clamp(source.clamp());\n}\n\n// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].\n// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].\nexport default function continuous(deinterpolate, reinterpolate) {\n  var domain = unit,\n      range = unit,\n      interpolate = interpolateValue,\n      clamp = false,\n      piecewise,\n      output,\n      input;\n\n  function rescale() {\n    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;\n    output = input = null;\n    return scale;\n  }\n\n  function scale(x) {\n    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);\n  }\n\n  scale.invert = function(y) {\n    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = map.call(_, number), rescale()) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.rangeRound = function(_) {\n    return range = slice.call(_), interpolate = interpolateRound, rescale();\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, rescale()) : clamp;\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (interpolate = _, rescale()) : interpolate;\n  };\n\n  return rescale();\n}\n","import {linearish} from \"./linear\";\n\nexport default function diverging(interpolator) {\n  var x0 = 0,\n      x1 = 0.5,\n      x2 = 1,\n      k10 = 1,\n      k21 = 1,\n      clamp = false;\n\n  function scale(x) {\n    var t = 0.5 + ((x = +x) - x1) * (x < x1 ? k10 : k21);\n    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], x2 = +_[2], k10 = x0 === x1 ? 0 : 0.5 / (x1 - x0), k21 = x1 === x2 ? 0 : 0.5 / (x2 - x1), scale) : [x0, x1, x2];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return diverging(interpolator).domain([x0, x1, x2]).clamp(clamp);\n  };\n\n  return linearish(scale);\n}\n","import {map} from \"./array\";\nimport {linearish} from \"./linear\";\nimport number from \"./number\";\n\nexport default function identity() {\n  var domain = [0, 1];\n\n  function scale(x) {\n    return +x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = function(_) {\n    return arguments.length ? (domain = map.call(_, number), scale) : domain.slice();\n  };\n\n  scale.copy = function() {\n    return identity().domain(domain);\n  };\n\n  return linearish(scale);\n}\n","export {\n  default as scaleBand,\n  point as scalePoint\n} from \"./band\";\n\nexport {\n  default as scaleIdentity\n} from \"./identity\";\n\nexport {\n  default as scaleLinear\n} from \"./linear\";\n\nexport {\n  default as scaleLog\n} from \"./log\";\n\nexport {\n  default as scaleOrdinal,\n  implicit as scaleImplicit\n} from \"./ordinal\";\n\nexport {\n  default as scalePow,\n  sqrt as scaleSqrt\n} from \"./pow\";\n\nexport {\n  default as scaleQuantile\n} from \"./quantile\";\n\nexport {\n  default as scaleQuantize\n} from \"./quantize\";\n\nexport {\n  default as scaleThreshold\n} from \"./threshold\";\n\nexport {\n  default as scaleTime\n} from \"./time\";\n\nexport {\n  default as scaleUtc\n} from \"./utcTime\";\n\nexport {\n  default as scaleSequential\n} from \"./sequential\";\n\nexport {\n  default as scaleDiverging\n} from \"./diverging\";\n","import {ticks, tickIncrement} from \"d3-array\";\nimport {interpolateNumber as reinterpolate} from \"d3-interpolate\";\nimport {default as continuous, copy, deinterpolateLinear as deinterpolate} from \"./continuous\";\nimport tickFormat from \"./tickFormat\";\n\nexport function linearish(scale) {\n  var domain = scale.domain;\n\n  scale.ticks = function(count) {\n    var d = domain();\n    return ticks(d[0], d[d.length - 1], count == null ? 10 : count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return tickFormat(domain(), count, specifier);\n  };\n\n  scale.nice = function(count) {\n    if (count == null) count = 10;\n\n    var d = domain(),\n        i0 = 0,\n        i1 = d.length - 1,\n        start = d[i0],\n        stop = d[i1],\n        step;\n\n    if (stop < start) {\n      step = start, start = stop, stop = step;\n      step = i0, i0 = i1, i1 = step;\n    }\n\n    step = tickIncrement(start, stop, count);\n\n    if (step > 0) {\n      start = Math.floor(start / step) * step;\n      stop = Math.ceil(stop / step) * step;\n      step = tickIncrement(start, stop, count);\n    } else if (step < 0) {\n      start = Math.ceil(start * step) / step;\n      stop = Math.floor(stop * step) / step;\n      step = tickIncrement(start, stop, count);\n    }\n\n    if (step > 0) {\n      d[i0] = Math.floor(start / step) * step;\n      d[i1] = Math.ceil(stop / step) * step;\n      domain(d);\n    } else if (step < 0) {\n      d[i0] = Math.ceil(start * step) / step;\n      d[i1] = Math.floor(stop * step) / step;\n      domain(d);\n    }\n\n    return scale;\n  };\n\n  return scale;\n}\n\nexport default function linear() {\n  var scale = continuous(deinterpolate, reinterpolate);\n\n  scale.copy = function() {\n    return copy(scale, linear());\n  };\n\n  return linearish(scale);\n}\n","import {ticks} from \"d3-array\";\nimport {format} from \"d3-format\";\nimport constant from \"./constant\";\nimport nice from \"./nice\";\nimport {default as continuous, copy} from \"./continuous\";\n\nfunction deinterpolate(a, b) {\n  return (b = Math.log(b / a))\n      ? function(x) { return Math.log(x / a) / b; }\n      : constant(b);\n}\n\nfunction reinterpolate(a, b) {\n  return a < 0\n      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }\n      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };\n}\n\nfunction pow10(x) {\n  return isFinite(x) ? +(\"1e\" + x) : x < 0 ? 0 : x;\n}\n\nfunction powp(base) {\n  return base === 10 ? pow10\n      : base === Math.E ? Math.exp\n      : function(x) { return Math.pow(base, x); };\n}\n\nfunction logp(base) {\n  return base === Math.E ? Math.log\n      : base === 10 && Math.log10\n      || base === 2 && Math.log2\n      || (base = Math.log(base), function(x) { return Math.log(x) / base; });\n}\n\nfunction reflect(f) {\n  return function(x) {\n    return -f(-x);\n  };\n}\n\nexport default function log() {\n  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),\n      domain = scale.domain,\n      base = 10,\n      logs = logp(10),\n      pows = powp(10);\n\n  function rescale() {\n    logs = logp(base), pows = powp(base);\n    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);\n    return scale;\n  }\n\n  scale.base = function(_) {\n    return arguments.length ? (base = +_, rescale()) : base;\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain(_), rescale()) : domain();\n  };\n\n  scale.ticks = function(count) {\n    var d = domain(),\n        u = d[0],\n        v = d[d.length - 1],\n        r;\n\n    if (r = v < u) i = u, u = v, v = i;\n\n    var i = logs(u),\n        j = logs(v),\n        p,\n        k,\n        t,\n        n = count == null ? 10 : +count,\n        z = [];\n\n    if (!(base % 1) && j - i < n) {\n      i = Math.round(i) - 1, j = Math.round(j) + 1;\n      if (u > 0) for (; i < j; ++i) {\n        for (k = 1, p = pows(i); k < base; ++k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      } else for (; i < j; ++i) {\n        for (k = base - 1, p = pows(i); k >= 1; --k) {\n          t = p * k;\n          if (t < u) continue;\n          if (t > v) break;\n          z.push(t);\n        }\n      }\n    } else {\n      z = ticks(i, j, Math.min(j - i, n)).map(pows);\n    }\n\n    return r ? z.reverse() : z;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    if (specifier == null) specifier = base === 10 ? \".0e\" : \",\";\n    if (typeof specifier !== \"function\") specifier = format(specifier);\n    if (count === Infinity) return specifier;\n    if (count == null) count = 10;\n    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?\n    return function(d) {\n      var i = d / pows(Math.round(logs(d)));\n      if (i * base < base - 0.5) i *= base;\n      return i <= k ? specifier(d) : \"\";\n    };\n  };\n\n  scale.nice = function() {\n    return domain(nice(domain(), {\n      floor: function(x) { return pows(Math.floor(logs(x))); },\n      ceil: function(x) { return pows(Math.ceil(logs(x))); }\n    }));\n  };\n\n  scale.copy = function() {\n    return copy(scale, log().base(base));\n  };\n\n  return scale;\n}\n","export default function(domain, interval) {\n  domain = domain.slice();\n\n  var i0 = 0,\n      i1 = domain.length - 1,\n      x0 = domain[i0],\n      x1 = domain[i1],\n      t;\n\n  if (x1 < x0) {\n    t = i0, i0 = i1, i1 = t;\n    t = x0, x0 = x1, x1 = t;\n  }\n\n  domain[i0] = interval.floor(x0);\n  domain[i1] = interval.ceil(x1);\n  return domain;\n}\n","export default function(x) {\n  return +x;\n}\n","import {map} from \"d3-collection\";\nimport {slice} from \"./array\";\n\nexport var implicit = {name: \"implicit\"};\n\nexport default function ordinal(range) {\n  var index = map(),\n      domain = [],\n      unknown = implicit;\n\n  range = range == null ? [] : slice.call(range);\n\n  function scale(d) {\n    var key = d + \"\", i = index.get(key);\n    if (!i) {\n      if (unknown !== implicit) return unknown;\n      index.set(key, i = domain.push(d));\n    }\n    return range[(i - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [], index = map();\n    var i = -1, n = _.length, d, key;\n    while (++i < n) if (!index.has(key = (d = _[i]) + \"\")) index.set(key, domain.push(d));\n    return scale;\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), scale) : range.slice();\n  };\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  scale.copy = function() {\n    return ordinal()\n        .domain(domain)\n        .range(range)\n        .unknown(unknown);\n  };\n\n  return scale;\n}\n","import constant from \"./constant\";\nimport {linearish} from \"./linear\";\nimport {default as continuous, copy} from \"./continuous\";\n\nfunction raise(x, exponent) {\n  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n}\n\nexport default function pow() {\n  var exponent = 1,\n      scale = continuous(deinterpolate, reinterpolate),\n      domain = scale.domain;\n\n  function deinterpolate(a, b) {\n    return (b = raise(b, exponent) - (a = raise(a, exponent)))\n        ? function(x) { return (raise(x, exponent) - a) / b; }\n        : constant(b);\n  }\n\n  function reinterpolate(a, b) {\n    b = raise(b, exponent) - (a = raise(a, exponent));\n    return function(t) { return raise(a + b * t, 1 / exponent); };\n  }\n\n  scale.exponent = function(_) {\n    return arguments.length ? (exponent = +_, domain(domain())) : exponent;\n  };\n\n  scale.copy = function() {\n    return copy(scale, pow().exponent(exponent));\n  };\n\n  return linearish(scale);\n}\n\nexport function sqrt() {\n  return pow().exponent(0.5);\n}\n","import {ascending, bisect, quantile as threshold} from \"d3-array\";\nimport {slice} from \"./array\";\n\nexport default function quantile() {\n  var domain = [],\n      range = [],\n      thresholds = [];\n\n  function rescale() {\n    var i = 0, n = Math.max(1, range.length);\n    thresholds = new Array(n - 1);\n    while (++i < n) thresholds[i - 1] = threshold(domain, i / n);\n    return scale;\n  }\n\n  function scale(x) {\n    if (!isNaN(x = +x)) return range[bisect(thresholds, x)];\n  }\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN] : [\n      i > 0 ? thresholds[i - 1] : domain[0],\n      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]\n    ];\n  };\n\n  scale.domain = function(_) {\n    if (!arguments.length) return domain.slice();\n    domain = [];\n    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);\n    domain.sort(ascending);\n    return rescale();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), rescale()) : range.slice();\n  };\n\n  scale.quantiles = function() {\n    return thresholds.slice();\n  };\n\n  scale.copy = function() {\n    return quantile()\n        .domain(domain)\n        .range(range);\n  };\n\n  return scale;\n}\n","import {bisect} from \"d3-array\";\nimport {slice} from \"./array\";\nimport {linearish} from \"./linear\";\n\nexport default function quantize() {\n  var x0 = 0,\n      x1 = 1,\n      n = 1,\n      domain = [0.5],\n      range = [0, 1];\n\n  function scale(x) {\n    if (x <= x) return range[bisect(domain, x, 0, n)];\n  }\n\n  function rescale() {\n    var i = -1;\n    domain = new Array(n);\n    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);\n    return scale;\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return i < 0 ? [NaN, NaN]\n        : i < 1 ? [x0, domain[0]]\n        : i >= n ? [domain[n - 1], x1]\n        : [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return quantize()\n        .domain([x0, x1])\n        .range(range);\n  };\n\n  return linearish(scale);\n}\n","import {linearish} from \"./linear\";\n\nexport default function sequential(interpolator) {\n  var x0 = 0,\n      x1 = 1,\n      k10 = 1,\n      clamp = false;\n\n  function scale(x) {\n    var t = (x - x0) * k10;\n    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (x0 = +_[0], x1 = +_[1], k10 = x0 === x1 ? 0 : 1 / (x1 - x0), scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  scale.copy = function() {\n    return sequential(interpolator).domain([x0, x1]).clamp(clamp);\n  };\n\n  return linearish(scale);\n}\n","import {bisect} from \"d3-array\";\nimport {slice} from \"./array\";\n\nexport default function threshold() {\n  var domain = [0.5],\n      range = [0, 1],\n      n = 1;\n\n  function scale(x) {\n    if (x <= x) return range[bisect(domain, x, 0, n)];\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (range = slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();\n  };\n\n  scale.invertExtent = function(y) {\n    var i = range.indexOf(y);\n    return [domain[i - 1], domain[i]];\n  };\n\n  scale.copy = function() {\n    return threshold()\n        .domain(domain)\n        .range(range);\n  };\n\n  return scale;\n}\n","import {tickStep} from \"d3-array\";\nimport {format, formatPrefix, formatSpecifier, precisionFixed, precisionPrefix, precisionRound} from \"d3-format\";\n\nexport default function(domain, count, specifier) {\n  var start = domain[0],\n      stop = domain[domain.length - 1],\n      step = tickStep(start, stop, count == null ? 10 : count),\n      precision;\n  specifier = formatSpecifier(specifier == null ? \",f\" : specifier);\n  switch (specifier.type) {\n    case \"s\": {\n      var value = Math.max(Math.abs(start), Math.abs(stop));\n      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;\n      return formatPrefix(specifier, value);\n    }\n    case \"\":\n    case \"e\":\n    case \"g\":\n    case \"p\":\n    case \"r\": {\n      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === \"e\");\n      break;\n    }\n    case \"f\":\n    case \"%\": {\n      if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === \"%\") * 2;\n      break;\n    }\n  }\n  return format(specifier);\n}\n","import {bisector, tickStep} from \"d3-array\";\nimport {interpolateNumber as reinterpolate} from \"d3-interpolate\";\nimport {timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeMillisecond} from \"d3-time\";\nimport {timeFormat} from \"d3-time-format\";\nimport {map} from \"./array\";\nimport {default as continuous, copy, deinterpolateLinear as deinterpolate} from \"./continuous\";\nimport nice from \"./nice\";\n\nvar durationSecond = 1000,\n    durationMinute = durationSecond * 60,\n    durationHour = durationMinute * 60,\n    durationDay = durationHour * 24,\n    durationWeek = durationDay * 7,\n    durationMonth = durationDay * 30,\n    durationYear = durationDay * 365;\n\nfunction date(t) {\n  return new Date(t);\n}\n\nfunction number(t) {\n  return t instanceof Date ? +t : +new Date(+t);\n}\n\nexport function calendar(year, month, week, day, hour, minute, second, millisecond, format) {\n  var scale = continuous(deinterpolate, reinterpolate),\n      invert = scale.invert,\n      domain = scale.domain;\n\n  var formatMillisecond = format(\".%L\"),\n      formatSecond = format(\":%S\"),\n      formatMinute = format(\"%I:%M\"),\n      formatHour = format(\"%I %p\"),\n      formatDay = format(\"%a %d\"),\n      formatWeek = format(\"%b %d\"),\n      formatMonth = format(\"%B\"),\n      formatYear = format(\"%Y\");\n\n  var tickIntervals = [\n    [second,  1,      durationSecond],\n    [second,  5,  5 * durationSecond],\n    [second, 15, 15 * durationSecond],\n    [second, 30, 30 * durationSecond],\n    [minute,  1,      durationMinute],\n    [minute,  5,  5 * durationMinute],\n    [minute, 15, 15 * durationMinute],\n    [minute, 30, 30 * durationMinute],\n    [  hour,  1,      durationHour  ],\n    [  hour,  3,  3 * durationHour  ],\n    [  hour,  6,  6 * durationHour  ],\n    [  hour, 12, 12 * durationHour  ],\n    [   day,  1,      durationDay   ],\n    [   day,  2,  2 * durationDay   ],\n    [  week,  1,      durationWeek  ],\n    [ month,  1,      durationMonth ],\n    [ month,  3,  3 * durationMonth ],\n    [  year,  1,      durationYear  ]\n  ];\n\n  function tickFormat(date) {\n    return (second(date) < date ? formatMillisecond\n        : minute(date) < date ? formatSecond\n        : hour(date) < date ? formatMinute\n        : day(date) < date ? formatHour\n        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)\n        : year(date) < date ? formatMonth\n        : formatYear)(date);\n  }\n\n  function tickInterval(interval, start, stop, step) {\n    if (interval == null) interval = 10;\n\n    // If a desired tick count is specified, pick a reasonable tick interval\n    // based on the extent of the domain and a rough estimate of tick size.\n    // Otherwise, assume interval is already a time interval and use it.\n    if (typeof interval === \"number\") {\n      var target = Math.abs(stop - start) / interval,\n          i = bisector(function(i) { return i[2]; }).right(tickIntervals, target);\n      if (i === tickIntervals.length) {\n        step = tickStep(start / durationYear, stop / durationYear, interval);\n        interval = year;\n      } else if (i) {\n        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];\n        step = i[1];\n        interval = i[0];\n      } else {\n        step = Math.max(tickStep(start, stop, interval), 1);\n        interval = millisecond;\n      }\n    }\n\n    return step == null ? interval : interval.every(step);\n  }\n\n  scale.invert = function(y) {\n    return new Date(invert(y));\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? domain(map.call(_, number)) : domain().map(date);\n  };\n\n  scale.ticks = function(interval, step) {\n    var d = domain(),\n        t0 = d[0],\n        t1 = d[d.length - 1],\n        r = t1 < t0,\n        t;\n    if (r) t = t0, t0 = t1, t1 = t;\n    t = tickInterval(interval, t0, t1, step);\n    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop\n    return r ? t.reverse() : t;\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return specifier == null ? tickFormat : format(specifier);\n  };\n\n  scale.nice = function(interval, step) {\n    var d = domain();\n    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))\n        ? domain(nice(d, interval))\n        : scale;\n  };\n\n  scale.copy = function() {\n    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));\n  };\n\n  return scale;\n}\n\nexport default function() {\n  return calendar(timeYear, timeMonth, timeWeek, timeDay, timeHour, timeMinute, timeSecond, timeMillisecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);\n}\n","import {calendar} from \"./time\";\nimport {utcFormat} from \"d3-time-format\";\nimport {utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcMillisecond} from \"d3-time\";\n\nexport default function() {\n  return calendar(utcYear, utcMonth, utcWeek, utcDay, utcHour, utcMinute, utcSecond, utcMillisecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);\n}\n","import {path} from \"d3-path\";\nimport constant from \"./constant\";\nimport {abs, acos, asin, atan2, cos, epsilon, halfPi, max, min, pi, sin, sqrt, tau} from \"./math\";\n\nfunction arcInnerRadius(d) {\n  return d.innerRadius;\n}\n\nfunction arcOuterRadius(d) {\n  return d.outerRadius;\n}\n\nfunction arcStartAngle(d) {\n  return d.startAngle;\n}\n\nfunction arcEndAngle(d) {\n  return d.endAngle;\n}\n\nfunction arcPadAngle(d) {\n  return d && d.padAngle; // Note: optional!\n}\n\nfunction intersect(x0, y0, x1, y1, x2, y2, x3, y3) {\n  var x10 = x1 - x0, y10 = y1 - y0,\n      x32 = x3 - x2, y32 = y3 - y2,\n      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);\n  return [x0 + t * x10, y0 + t * y10];\n}\n\n// Compute perpendicular offset line of length rc.\n// http://mathworld.wolfram.com/Circle-LineIntersection.html\nfunction cornerTangents(x0, y0, x1, y1, r1, rc, cw) {\n  var x01 = x0 - x1,\n      y01 = y0 - y1,\n      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),\n      ox = lo * y01,\n      oy = -lo * x01,\n      x11 = x0 + ox,\n      y11 = y0 + oy,\n      x10 = x1 + ox,\n      y10 = y1 + oy,\n      x00 = (x11 + x10) / 2,\n      y00 = (y11 + y10) / 2,\n      dx = x10 - x11,\n      dy = y10 - y11,\n      d2 = dx * dx + dy * dy,\n      r = r1 - rc,\n      D = x11 * y10 - x10 * y11,\n      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),\n      cx0 = (D * dy - dx * d) / d2,\n      cy0 = (-D * dx - dy * d) / d2,\n      cx1 = (D * dy + dx * d) / d2,\n      cy1 = (-D * dx + dy * d) / d2,\n      dx0 = cx0 - x00,\n      dy0 = cy0 - y00,\n      dx1 = cx1 - x00,\n      dy1 = cy1 - y00;\n\n  // Pick the closer of the two intersection points.\n  // TODO Is there a faster way to determine which intersection to use?\n  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\n\n  return {\n    cx: cx0,\n    cy: cy0,\n    x01: -ox,\n    y01: -oy,\n    x11: cx0 * (r1 / r - 1),\n    y11: cy0 * (r1 / r - 1)\n  };\n}\n\nexport default function() {\n  var innerRadius = arcInnerRadius,\n      outerRadius = arcOuterRadius,\n      cornerRadius = constant(0),\n      padRadius = null,\n      startAngle = arcStartAngle,\n      endAngle = arcEndAngle,\n      padAngle = arcPadAngle,\n      context = null;\n\n  function arc() {\n    var buffer,\n        r,\n        r0 = +innerRadius.apply(this, arguments),\n        r1 = +outerRadius.apply(this, arguments),\n        a0 = startAngle.apply(this, arguments) - halfPi,\n        a1 = endAngle.apply(this, arguments) - halfPi,\n        da = abs(a1 - a0),\n        cw = a1 > a0;\n\n    if (!context) context = buffer = path();\n\n    // Ensure that the outer radius is always larger than the inner radius.\n    if (r1 < r0) r = r1, r1 = r0, r0 = r;\n\n    // Is it a point?\n    if (!(r1 > epsilon)) context.moveTo(0, 0);\n\n    // Or is it a circle or annulus?\n    else if (da > tau - epsilon) {\n      context.moveTo(r1 * cos(a0), r1 * sin(a0));\n      context.arc(0, 0, r1, a0, a1, !cw);\n      if (r0 > epsilon) {\n        context.moveTo(r0 * cos(a1), r0 * sin(a1));\n        context.arc(0, 0, r0, a1, a0, cw);\n      }\n    }\n\n    // Or is it a circular or annular sector?\n    else {\n      var a01 = a0,\n          a11 = a1,\n          a00 = a0,\n          a10 = a1,\n          da0 = da,\n          da1 = da,\n          ap = padAngle.apply(this, arguments) / 2,\n          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),\n          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),\n          rc0 = rc,\n          rc1 = rc,\n          t0,\n          t1;\n\n      // Apply padding? Note that since r1  r0, da1  da0.\n      if (rp > epsilon) {\n        var p0 = asin(rp / r0 * sin(ap)),\n            p1 = asin(rp / r1 * sin(ap));\n        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;\n        else da0 = 0, a00 = a10 = (a0 + a1) / 2;\n        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;\n        else da1 = 0, a01 = a11 = (a0 + a1) / 2;\n      }\n\n      var x01 = r1 * cos(a01),\n          y01 = r1 * sin(a01),\n          x10 = r0 * cos(a10),\n          y10 = r0 * sin(a10);\n\n      // Apply rounded corners?\n      if (rc > epsilon) {\n        var x11 = r1 * cos(a11),\n            y11 = r1 * sin(a11),\n            x00 = r0 * cos(a00),\n            y00 = r0 * sin(a00);\n\n        // Restrict the corner radius according to the sector angle.\n        if (da < pi) {\n          var oc = da0 > epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],\n              ax = x01 - oc[0],\n              ay = y01 - oc[1],\n              bx = x11 - oc[0],\n              by = y11 - oc[1],\n              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),\n              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\n          rc0 = min(rc, (r0 - lc) / (kc - 1));\n          rc1 = min(rc, (r1 - lc) / (kc + 1));\n        }\n      }\n\n      // Is the sector collapsed to a line?\n      if (!(da1 > epsilon)) context.moveTo(x01, y01);\n\n      // Does the sectors outer ring have rounded corners?\n      else if (rc1 > epsilon) {\n        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);\n        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);\n\n        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);\n          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the outer ring just a circular arc?\n      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);\n\n      // Is there no inner ring, and its a circular sector?\n      // Or perhaps its an annular sector collapsed due to padding?\n      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);\n\n      // Does the sectors inner ring (or point) have rounded corners?\n      else if (rc0 > epsilon) {\n        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);\n        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);\n\n        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);\n\n        // Have the corners merged?\n        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);\n\n        // Otherwise, draw the two corners and the ring.\n        else {\n          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);\n          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);\n          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);\n        }\n      }\n\n      // Or is the inner ring just a circular arc?\n      else context.arc(0, 0, r0, a10, a00, cw);\n    }\n\n    context.closePath();\n\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  arc.centroid = function() {\n    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,\n        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;\n    return [cos(a) * r, sin(a) * r];\n  };\n\n  arc.innerRadius = function(_) {\n    return arguments.length ? (innerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : innerRadius;\n  };\n\n  arc.outerRadius = function(_) {\n    return arguments.length ? (outerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : outerRadius;\n  };\n\n  arc.cornerRadius = function(_) {\n    return arguments.length ? (cornerRadius = typeof _ === \"function\" ? _ : constant(+_), arc) : cornerRadius;\n  };\n\n  arc.padRadius = function(_) {\n    return arguments.length ? (padRadius = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), arc) : padRadius;\n  };\n\n  arc.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : startAngle;\n  };\n\n  arc.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : endAngle;\n  };\n\n  arc.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), arc) : padAngle;\n  };\n\n  arc.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), arc) : context;\n  };\n\n  return arc;\n}\n","import {path} from \"d3-path\";\nimport constant from \"./constant\";\nimport curveLinear from \"./curve/linear\";\nimport line from \"./line\";\nimport {x as pointX, y as pointY} from \"./point\";\n\nexport default function() {\n  var x0 = pointX,\n      x1 = null,\n      y0 = constant(0),\n      y1 = pointY,\n      defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function area(data) {\n    var i,\n        j,\n        k,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer,\n        x0z = new Array(n),\n        y0z = new Array(n);\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) {\n          j = i;\n          output.areaStart();\n          output.lineStart();\n        } else {\n          output.lineEnd();\n          output.lineStart();\n          for (k = i - 1; k >= j; --k) {\n            output.point(x0z[k], y0z[k]);\n          }\n          output.lineEnd();\n          output.areaEnd();\n        }\n      }\n      if (defined0) {\n        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);\n        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);\n      }\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  function arealine() {\n    return line().defined(defined).curve(curve).context(context);\n  }\n\n  area.x = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), x1 = null, area) : x0;\n  };\n\n  area.x0 = function(_) {\n    return arguments.length ? (x0 = typeof _ === \"function\" ? _ : constant(+_), area) : x0;\n  };\n\n  area.x1 = function(_) {\n    return arguments.length ? (x1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : x1;\n  };\n\n  area.y = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), y1 = null, area) : y0;\n  };\n\n  area.y0 = function(_) {\n    return arguments.length ? (y0 = typeof _ === \"function\" ? _ : constant(+_), area) : y0;\n  };\n\n  area.y1 = function(_) {\n    return arguments.length ? (y1 = _ == null ? null : typeof _ === \"function\" ? _ : constant(+_), area) : y1;\n  };\n\n  area.lineX0 =\n  area.lineY0 = function() {\n    return arealine().x(x0).y(y0);\n  };\n\n  area.lineY1 = function() {\n    return arealine().x(x0).y(y1);\n  };\n\n  area.lineX1 = function() {\n    return arealine().x(x1).y(y0);\n  };\n\n  area.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), area) : defined;\n  };\n\n  area.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;\n  };\n\n  area.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;\n  };\n\n  return area;\n}\n","import curveRadial, {curveRadialLinear} from \"./curve/radial\";\nimport area from \"./area\";\nimport {lineRadial} from \"./lineRadial\"\n\nexport default function() {\n  var a = area().curve(curveRadialLinear),\n      c = a.curve,\n      x0 = a.lineX0,\n      x1 = a.lineX1,\n      y0 = a.lineY0,\n      y1 = a.lineY1;\n\n  a.angle = a.x, delete a.x;\n  a.startAngle = a.x0, delete a.x0;\n  a.endAngle = a.x1, delete a.x1;\n  a.radius = a.y, delete a.y;\n  a.innerRadius = a.y0, delete a.y0;\n  a.outerRadius = a.y1, delete a.y1;\n  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;\n  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;\n  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;\n  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;\n\n  a.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return a;\n}\n","export var slice = Array.prototype.slice;\n","export default function(x) {\n  return function constant() {\n    return x;\n  };\n}\n","export function point(that, x, y) {\n  that._context.bezierCurveTo(\n    (2 * that._x0 + that._x1) / 3,\n    (2 * that._y0 + that._y1) / 3,\n    (that._x0 + 2 * that._x1) / 3,\n    (that._y0 + 2 * that._y1) / 3,\n    (that._x0 + 4 * that._x1 + x) / 6,\n    (that._y0 + 4 * that._y1 + y) / 6\n  );\n}\n\nexport function Basis(context) {\n  this._context = context;\n}\n\nBasis.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 3: point(this, this._x1, this._y1); // proceed\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new Basis(context);\n}\n","import noop from \"../noop\";\nimport {point} from \"./basis\";\n\nfunction BasisClosed(context) {\n  this._context = context;\n}\n\nBasisClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x2, this._y2);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);\n        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x2, this._y2);\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;\n      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;\n      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new BasisClosed(context);\n}\n","import {point} from \"./basis\";\n\nfunction BasisOpen(context) {\n  this._context = context;\n}\n\nBasisOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;\n      case 3: this._point = 4; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n  }\n};\n\nexport default function(context) {\n  return new BasisOpen(context);\n}\n","import {Basis} from \"./basis\";\n\nfunction Bundle(context, beta) {\n  this._basis = new Basis(context);\n  this._beta = beta;\n}\n\nBundle.prototype = {\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n    this._basis.lineStart();\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        j = x.length - 1;\n\n    if (j > 0) {\n      var x0 = x[0],\n          y0 = y[0],\n          dx = x[j] - x0,\n          dy = y[j] - y0,\n          i = -1,\n          t;\n\n      while (++i <= j) {\n        t = i / j;\n        this._basis.point(\n          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),\n          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)\n        );\n      }\n    }\n\n    this._x = this._y = null;\n    this._basis.lineEnd();\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\nexport default (function custom(beta) {\n\n  function bundle(context) {\n    return beta === 1 ? new Basis(context) : new Bundle(context, beta);\n  }\n\n  bundle.beta = function(beta) {\n    return custom(+beta);\n  };\n\n  return bundle;\n})(0.85);\n","export function point(that, x, y) {\n  that._context.bezierCurveTo(\n    that._x1 + that._k * (that._x2 - that._x0),\n    that._y1 + that._k * (that._y2 - that._y0),\n    that._x2 + that._k * (that._x1 - x),\n    that._y2 + that._k * (that._y1 - y),\n    that._x2,\n    that._y2\n  );\n}\n\nexport function Cardinal(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinal.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: point(this, this._x1, this._y1); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;\n      case 2: this._point = 3; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new Cardinal(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n","import noop from \"../noop\";\nimport {point} from \"./cardinal\";\n\nexport function CardinalClosed(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalClosed(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n","import {point} from \"./cardinal\";\n\nexport function CardinalOpen(context, tension) {\n  this._context = context;\n  this._k = (1 - tension) / 6;\n}\n\nCardinalOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point(this, x, y); break;\n    }\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(tension) {\n\n  function cardinal(context) {\n    return new CardinalOpen(context, tension);\n  }\n\n  cardinal.tension = function(tension) {\n    return custom(+tension);\n  };\n\n  return cardinal;\n})(0);\n","import {epsilon} from \"../math\";\nimport {Cardinal} from \"./cardinal\";\n\nexport function point(that, x, y) {\n  var x1 = that._x1,\n      y1 = that._y1,\n      x2 = that._x2,\n      y2 = that._y2;\n\n  if (that._l01_a > epsilon) {\n    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,\n        n = 3 * that._l01_a * (that._l01_a + that._l12_a);\n    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;\n    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;\n  }\n\n  if (that._l23_a > epsilon) {\n    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,\n        m = 3 * that._l23_a * (that._l23_a + that._l12_a);\n    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;\n    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;\n  }\n\n  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);\n}\n\nfunction CatmullRom(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRom.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x2, this._y2); break;\n      case 3: this.point(this._x2, this._y2); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; // proceed\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n","import {CardinalClosed} from \"./cardinalClosed\";\nimport noop from \"../noop\";\nimport {point} from \"./catmullRom\";\n\nfunction CatmullRomClosed(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =\n    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 1: {\n        this._context.moveTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 2: {\n        this._context.lineTo(this._x3, this._y3);\n        this._context.closePath();\n        break;\n      }\n      case 3: {\n        this.point(this._x3, this._y3);\n        this.point(this._x4, this._y4);\n        this.point(this._x5, this._y5);\n        break;\n      }\n    }\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;\n      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;\n      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n","import {CardinalOpen} from \"./cardinalOpen\";\nimport {point} from \"./catmullRom\";\n\nfunction CatmullRomOpen(context, alpha) {\n  this._context = context;\n  this._alpha = alpha;\n}\n\nCatmullRomOpen.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 = this._x2 =\n    this._y0 = this._y1 = this._y2 = NaN;\n    this._l01_a = this._l12_a = this._l23_a =\n    this._l01_2a = this._l12_2a = this._l23_2a =\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n\n    if (this._point) {\n      var x23 = this._x2 - x,\n          y23 = this._y2 - y;\n      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));\n    }\n\n    switch (this._point) {\n      case 0: this._point = 1; break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;\n      case 3: this._point = 4; // proceed\n      default: point(this, x, y); break;\n    }\n\n    this._l01_a = this._l12_a, this._l12_a = this._l23_a;\n    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;\n    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;\n    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;\n  }\n};\n\nexport default (function custom(alpha) {\n\n  function catmullRom(context) {\n    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);\n  }\n\n  catmullRom.alpha = function(alpha) {\n    return custom(+alpha);\n  };\n\n  return catmullRom;\n})(0.5);\n","function Linear(context) {\n  this._context = context;\n}\n\nLinear.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: this._context.lineTo(x, y); break;\n    }\n  }\n};\n\nexport default function(context) {\n  return new Linear(context);\n}\n","import noop from \"../noop\";\n\nfunction LinearClosed(context) {\n  this._context = context;\n}\n\nLinearClosed.prototype = {\n  areaStart: noop,\n  areaEnd: noop,\n  lineStart: function() {\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (this._point) this._context.closePath();\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    if (this._point) this._context.lineTo(x, y);\n    else this._point = 1, this._context.moveTo(x, y);\n  }\n};\n\nexport default function(context) {\n  return new LinearClosed(context);\n}\n","function sign(x) {\n  return x < 0 ? -1 : 1;\n}\n\n// Calculate the slopes of the tangents (Hermite-type interpolation) based on\n// the following paper: Steffen, M. 1990. A Simple Method for Monotonic\n// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.\n// NOV(II), P. 443, 1990.\nfunction slope3(that, x2, y2) {\n  var h0 = that._x1 - that._x0,\n      h1 = x2 - that._x1,\n      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),\n      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),\n      p = (s0 * h1 + s1 * h0) / (h0 + h1);\n  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;\n}\n\n// Calculate a one-sided slope.\nfunction slope2(that, t) {\n  var h = that._x1 - that._x0;\n  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;\n}\n\n// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations\n// \"you can express cubic Hermite interpolation in terms of cubic Bzier curves\n// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1\".\nfunction point(that, t0, t1) {\n  var x0 = that._x0,\n      y0 = that._y0,\n      x1 = that._x1,\n      y1 = that._y1,\n      dx = (x1 - x0) / 3;\n  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);\n}\n\nfunction MonotoneX(context) {\n  this._context = context;\n}\n\nMonotoneX.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x0 = this._x1 =\n    this._y0 = this._y1 =\n    this._t0 = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    switch (this._point) {\n      case 2: this._context.lineTo(this._x1, this._y1); break;\n      case 3: point(this, this._t0, slope2(this, this._t0)); break;\n    }\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    var t1 = NaN;\n\n    x = +x, y = +y;\n    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; break;\n      case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;\n      default: point(this, this._t0, t1 = slope3(this, x, y)); break;\n    }\n\n    this._x0 = this._x1, this._x1 = x;\n    this._y0 = this._y1, this._y1 = y;\n    this._t0 = t1;\n  }\n}\n\nfunction MonotoneY(context) {\n  this._context = new ReflectContext(context);\n}\n\n(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {\n  MonotoneX.prototype.point.call(this, y, x);\n};\n\nfunction ReflectContext(context) {\n  this._context = context;\n}\n\nReflectContext.prototype = {\n  moveTo: function(x, y) { this._context.moveTo(y, x); },\n  closePath: function() { this._context.closePath(); },\n  lineTo: function(x, y) { this._context.lineTo(y, x); },\n  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }\n};\n\nexport function monotoneX(context) {\n  return new MonotoneX(context);\n}\n\nexport function monotoneY(context) {\n  return new MonotoneY(context);\n}\n","function Natural(context) {\n  this._context = context;\n}\n\nNatural.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = [];\n    this._y = [];\n  },\n  lineEnd: function() {\n    var x = this._x,\n        y = this._y,\n        n = x.length;\n\n    if (n) {\n      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);\n      if (n === 2) {\n        this._context.lineTo(x[1], y[1]);\n      } else {\n        var px = controlPoints(x),\n            py = controlPoints(y);\n        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {\n          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);\n        }\n      }\n    }\n\n    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();\n    this._line = 1 - this._line;\n    this._x = this._y = null;\n  },\n  point: function(x, y) {\n    this._x.push(+x);\n    this._y.push(+y);\n  }\n};\n\n// See https://www.particleincell.com/2012/bezier-splines/ for derivation.\nfunction controlPoints(x) {\n  var i,\n      n = x.length - 1,\n      m,\n      a = new Array(n),\n      b = new Array(n),\n      r = new Array(n);\n  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];\n  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];\n  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];\n  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];\n  a[n - 1] = r[n - 1] / b[n - 1];\n  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];\n  b[n - 1] = (x[n] + a[n - 1]) / 2;\n  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];\n  return [a, b];\n}\n\nexport default function(context) {\n  return new Natural(context);\n}\n","import curveLinear from \"./linear\";\n\nexport var curveRadialLinear = curveRadial(curveLinear);\n\nfunction Radial(curve) {\n  this._curve = curve;\n}\n\nRadial.prototype = {\n  areaStart: function() {\n    this._curve.areaStart();\n  },\n  areaEnd: function() {\n    this._curve.areaEnd();\n  },\n  lineStart: function() {\n    this._curve.lineStart();\n  },\n  lineEnd: function() {\n    this._curve.lineEnd();\n  },\n  point: function(a, r) {\n    this._curve.point(r * Math.sin(a), r * -Math.cos(a));\n  }\n};\n\nexport default function curveRadial(curve) {\n\n  function radial(context) {\n    return new Radial(curve(context));\n  }\n\n  radial._curve = curve;\n\n  return radial;\n}\n","function Step(context, t) {\n  this._context = context;\n  this._t = t;\n}\n\nStep.prototype = {\n  areaStart: function() {\n    this._line = 0;\n  },\n  areaEnd: function() {\n    this._line = NaN;\n  },\n  lineStart: function() {\n    this._x = this._y = NaN;\n    this._point = 0;\n  },\n  lineEnd: function() {\n    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);\n    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();\n    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;\n  },\n  point: function(x, y) {\n    x = +x, y = +y;\n    switch (this._point) {\n      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;\n      case 1: this._point = 2; // proceed\n      default: {\n        if (this._t <= 0) {\n          this._context.lineTo(this._x, y);\n          this._context.lineTo(x, y);\n        } else {\n          var x1 = this._x * (1 - this._t) + x * this._t;\n          this._context.lineTo(x1, this._y);\n          this._context.lineTo(x1, y);\n        }\n        break;\n      }\n    }\n    this._x = x, this._y = y;\n  }\n};\n\nexport default function(context) {\n  return new Step(context, 0.5);\n}\n\nexport function stepBefore(context) {\n  return new Step(context, 0);\n}\n\nexport function stepAfter(context) {\n  return new Step(context, 1);\n}\n","export default function(a, b) {\n  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n}\n","export default function(d) {\n  return d;\n}\n","export {default as arc} from \"./arc\";\nexport {default as area} from \"./area\";\nexport {default as line} from \"./line\";\nexport {default as pie} from \"./pie\";\nexport {default as areaRadial, default as radialArea} from \"./areaRadial\"; // Note: radialArea is deprecated!\nexport {default as lineRadial, default as radialLine} from \"./lineRadial\"; // Note: radialLine is deprecated!\nexport {default as pointRadial} from \"./pointRadial\";\nexport {linkHorizontal, linkVertical, linkRadial} from \"./link/index\";\n\nexport {default as symbol, symbols} from \"./symbol\";\nexport {default as symbolCircle} from \"./symbol/circle\";\nexport {default as symbolCross} from \"./symbol/cross\";\nexport {default as symbolDiamond} from \"./symbol/diamond\";\nexport {default as symbolSquare} from \"./symbol/square\";\nexport {default as symbolStar} from \"./symbol/star\";\nexport {default as symbolTriangle} from \"./symbol/triangle\";\nexport {default as symbolWye} from \"./symbol/wye\";\n\nexport {default as curveBasisClosed} from \"./curve/basisClosed\";\nexport {default as curveBasisOpen} from \"./curve/basisOpen\";\nexport {default as curveBasis} from \"./curve/basis\";\nexport {default as curveBundle} from \"./curve/bundle\";\nexport {default as curveCardinalClosed} from \"./curve/cardinalClosed\";\nexport {default as curveCardinalOpen} from \"./curve/cardinalOpen\";\nexport {default as curveCardinal} from \"./curve/cardinal\";\nexport {default as curveCatmullRomClosed} from \"./curve/catmullRomClosed\";\nexport {default as curveCatmullRomOpen} from \"./curve/catmullRomOpen\";\nexport {default as curveCatmullRom} from \"./curve/catmullRom\";\nexport {default as curveLinearClosed} from \"./curve/linearClosed\";\nexport {default as curveLinear} from \"./curve/linear\";\nexport {monotoneX as curveMonotoneX, monotoneY as curveMonotoneY} from \"./curve/monotone\";\nexport {default as curveNatural} from \"./curve/natural\";\nexport {default as curveStep, stepAfter as curveStepAfter, stepBefore as curveStepBefore} from \"./curve/step\";\n\nexport {default as stack} from \"./stack\";\nexport {default as stackOffsetExpand} from \"./offset/expand\";\nexport {default as stackOffsetDiverging} from \"./offset/diverging\";\nexport {default as stackOffsetNone} from \"./offset/none\";\nexport {default as stackOffsetSilhouette} from \"./offset/silhouette\";\nexport {default as stackOffsetWiggle} from \"./offset/wiggle\";\nexport {default as stackOrderAscending} from \"./order/ascending\";\nexport {default as stackOrderDescending} from \"./order/descending\";\nexport {default as stackOrderInsideOut} from \"./order/insideOut\";\nexport {default as stackOrderNone} from \"./order/none\";\nexport {default as stackOrderReverse} from \"./order/reverse\";\n","import {path} from \"d3-path\";\nimport constant from \"./constant\";\nimport curveLinear from \"./curve/linear\";\nimport {x as pointX, y as pointY} from \"./point\";\n\nexport default function() {\n  var x = pointX,\n      y = pointY,\n      defined = constant(true),\n      context = null,\n      curve = curveLinear,\n      output = null;\n\n  function line(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) output = curve(buffer = path());\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) output.lineStart();\n        else output.lineEnd();\n      }\n      if (defined0) output.point(+x(d, i, data), +y(d, i, data));\n    }\n\n    if (buffer) return output = null, buffer + \"\" || null;\n  }\n\n  line.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), line) : x;\n  };\n\n  line.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), line) : y;\n  };\n\n  line.defined = function(_) {\n    return arguments.length ? (defined = typeof _ === \"function\" ? _ : constant(!!_), line) : defined;\n  };\n\n  line.curve = function(_) {\n    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;\n  };\n\n  line.context = function(_) {\n    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;\n  };\n\n  return line;\n}\n","import curveRadial, {curveRadialLinear} from \"./curve/radial\";\nimport line from \"./line\";\n\nexport function lineRadial(l) {\n  var c = l.curve;\n\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n\n  l.curve = function(_) {\n    return arguments.length ? c(curveRadial(_)) : c()._curve;\n  };\n\n  return l;\n}\n\nexport default function() {\n  return lineRadial(line().curve(curveRadialLinear));\n}\n","import {path} from \"d3-path\";\nimport {slice} from \"../array\";\nimport constant from \"../constant\";\nimport {x as pointX, y as pointY} from \"../point\";\nimport pointRadial from \"../pointRadial\";\n\nfunction linkSource(d) {\n  return d.source;\n}\n\nfunction linkTarget(d) {\n  return d.target;\n}\n\nfunction link(curve) {\n  var source = linkSource,\n      target = linkTarget,\n      x = pointX,\n      y = pointY,\n      context = null;\n\n  function link() {\n    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);\n    if (!context) context = buffer = path();\n    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  link.source = function(_) {\n    return arguments.length ? (source = _, link) : source;\n  };\n\n  link.target = function(_) {\n    return arguments.length ? (target = _, link) : target;\n  };\n\n  link.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), link) : x;\n  };\n\n  link.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), link) : y;\n  };\n\n  link.context = function(_) {\n    return arguments.length ? ((context = _ == null ? null : _), link) : context;\n  };\n\n  return link;\n}\n\nfunction curveHorizontal(context, x0, y0, x1, y1) {\n  context.moveTo(x0, y0);\n  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);\n}\n\nfunction curveVertical(context, x0, y0, x1, y1) {\n  context.moveTo(x0, y0);\n  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);\n}\n\nfunction curveRadial(context, x0, y0, x1, y1) {\n  var p0 = pointRadial(x0, y0),\n      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),\n      p2 = pointRadial(x1, y0),\n      p3 = pointRadial(x1, y1);\n  context.moveTo(p0[0], p0[1]);\n  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\nexport function linkHorizontal() {\n  return link(curveHorizontal);\n}\n\nexport function linkVertical() {\n  return link(curveVertical);\n}\n\nexport function linkRadial() {\n  var l = link(curveRadial);\n  l.angle = l.x, delete l.x;\n  l.radius = l.y, delete l.y;\n  return l;\n}\n","export var abs = Math.abs;\nexport var atan2 = Math.atan2;\nexport var cos = Math.cos;\nexport var max = Math.max;\nexport var min = Math.min;\nexport var sin = Math.sin;\nexport var sqrt = Math.sqrt;\n\nexport var epsilon = 1e-12;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var tau = 2 * pi;\n\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\n\nexport function asin(x) {\n  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);\n}\n","export default function() {}\n","export default function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {\n    for (yp = yn = 0, i = 0; i < n; ++i) {\n      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {\n        d[0] = yp, d[1] = yp += dy;\n      } else if (dy < 0) {\n        d[1] = yn, d[0] = yn += dy;\n      } else {\n        d[0] = yp;\n      }\n    }\n  }\n}\n","import none from \"./none\";\n\nexport default function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {\n    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;\n    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;\n  }\n  none(series, order);\n}\n","export default function(series, order) {\n  if (!((n = series.length) > 1)) return;\n  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {\n    s0 = s1, s1 = series[order[i]];\n    for (j = 0; j < m; ++j) {\n      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];\n    }\n  }\n}\n","import none from \"./none\";\n\nexport default function(series, order) {\n  if (!((n = series.length) > 0)) return;\n  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {\n    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;\n    s0[j][1] += s0[j][0] = -y / 2;\n  }\n  none(series, order);\n}\n","import none from \"./none\";\n\nexport default function(series, order) {\n  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;\n  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {\n    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {\n      var si = series[order[i]],\n          sij0 = si[j][1] || 0,\n          sij1 = si[j - 1][1] || 0,\n          s3 = (sij0 - sij1) / 2;\n      for (var k = 0; k < i; ++k) {\n        var sk = series[order[k]],\n            skj0 = sk[j][1] || 0,\n            skj1 = sk[j - 1][1] || 0;\n        s3 += skj0 - skj1;\n      }\n      s1 += sij0, s2 += s3 * sij0;\n    }\n    s0[j - 1][1] += s0[j - 1][0] = y;\n    if (s1) y -= s2 / s1;\n  }\n  s0[j - 1][1] += s0[j - 1][0] = y;\n  none(series, order);\n}\n","import none from \"./none\";\n\nexport default function(series) {\n  var sums = series.map(sum);\n  return none(series).sort(function(a, b) { return sums[a] - sums[b]; });\n}\n\nexport function sum(series) {\n  var s = 0, i = -1, n = series.length, v;\n  while (++i < n) if (v = +series[i][1]) s += v;\n  return s;\n}\n","import ascending from \"./ascending\";\n\nexport default function(series) {\n  return ascending(series).reverse();\n}\n","import none from \"./none\";\nimport {sum} from \"./ascending\";\n\nexport default function(series) {\n  var n = series.length,\n      i,\n      j,\n      sums = series.map(sum),\n      order = none(series).sort(function(a, b) { return sums[b] - sums[a]; }),\n      top = 0,\n      bottom = 0,\n      tops = [],\n      bottoms = [];\n\n  for (i = 0; i < n; ++i) {\n    j = order[i];\n    if (top < bottom) {\n      top += sums[j];\n      tops.push(j);\n    } else {\n      bottom += sums[j];\n      bottoms.push(j);\n    }\n  }\n\n  return bottoms.reverse().concat(tops);\n}\n","export default function(series) {\n  var n = series.length, o = new Array(n);\n  while (--n >= 0) o[n] = n;\n  return o;\n}\n","import none from \"./none\";\n\nexport default function(series) {\n  return none(series).reverse();\n}\n","import constant from \"./constant\";\nimport descending from \"./descending\";\nimport identity from \"./identity\";\nimport {tau} from \"./math\";\n\nexport default function() {\n  var value = identity,\n      sortValues = descending,\n      sort = null,\n      startAngle = constant(0),\n      endAngle = constant(tau),\n      padAngle = constant(0);\n\n  function pie(data) {\n    var i,\n        n = data.length,\n        j,\n        k,\n        sum = 0,\n        index = new Array(n),\n        arcs = new Array(n),\n        a0 = +startAngle.apply(this, arguments),\n        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),\n        a1,\n        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),\n        pa = p * (da < 0 ? -1 : 1),\n        v;\n\n    for (i = 0; i < n; ++i) {\n      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {\n        sum += v;\n      }\n    }\n\n    // Optionally sort the arcs by previously-computed values or by data.\n    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });\n    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });\n\n    // Compute the arcs! They are stored in the original data's order.\n    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {\n      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {\n        data: data[j],\n        index: i,\n        value: v,\n        startAngle: a0,\n        endAngle: a1,\n        padAngle: p\n      };\n    }\n\n    return arcs;\n  }\n\n  pie.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), pie) : value;\n  };\n\n  pie.sortValues = function(_) {\n    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;\n  };\n\n  pie.sort = function(_) {\n    return arguments.length ? (sort = _, sortValues = null, pie) : sort;\n  };\n\n  pie.startAngle = function(_) {\n    return arguments.length ? (startAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : startAngle;\n  };\n\n  pie.endAngle = function(_) {\n    return arguments.length ? (endAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : endAngle;\n  };\n\n  pie.padAngle = function(_) {\n    return arguments.length ? (padAngle = typeof _ === \"function\" ? _ : constant(+_), pie) : padAngle;\n  };\n\n  return pie;\n}\n","export function x(p) {\n  return p[0];\n}\n\nexport function y(p) {\n  return p[1];\n}\n","export default function(x, y) {\n  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];\n}\n","import {slice} from \"./array\";\nimport constant from \"./constant\";\nimport offsetNone from \"./offset/none\";\nimport orderNone from \"./order/none\";\n\nfunction stackValue(d, key) {\n  return d[key];\n}\n\nexport default function() {\n  var keys = constant([]),\n      order = orderNone,\n      offset = offsetNone,\n      value = stackValue;\n\n  function stack(data) {\n    var kz = keys.apply(this, arguments),\n        i,\n        m = data.length,\n        n = kz.length,\n        sz = new Array(n),\n        oz;\n\n    for (i = 0; i < n; ++i) {\n      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {\n        si[j] = sij = [0, +value(data[j], ki, j, data)];\n        sij.data = data[j];\n      }\n      si.key = ki;\n    }\n\n    for (i = 0, oz = order(sz); i < n; ++i) {\n      sz[oz[i]].index = i;\n    }\n\n    offset(sz, oz);\n    return sz;\n  }\n\n  stack.keys = function(_) {\n    return arguments.length ? (keys = typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : keys;\n  };\n\n  stack.value = function(_) {\n    return arguments.length ? (value = typeof _ === \"function\" ? _ : constant(+_), stack) : value;\n  };\n\n  stack.order = function(_) {\n    return arguments.length ? (order = _ == null ? orderNone : typeof _ === \"function\" ? _ : constant(slice.call(_)), stack) : order;\n  };\n\n  stack.offset = function(_) {\n    return arguments.length ? (offset = _ == null ? offsetNone : _, stack) : offset;\n  };\n\n  return stack;\n}\n","import {path} from \"d3-path\";\nimport circle from \"./symbol/circle\";\nimport cross from \"./symbol/cross\";\nimport diamond from \"./symbol/diamond\";\nimport star from \"./symbol/star\";\nimport square from \"./symbol/square\";\nimport triangle from \"./symbol/triangle\";\nimport wye from \"./symbol/wye\";\nimport constant from \"./constant\";\n\nexport var symbols = [\n  circle,\n  cross,\n  diamond,\n  square,\n  star,\n  triangle,\n  wye\n];\n\nexport default function() {\n  var type = constant(circle),\n      size = constant(64),\n      context = null;\n\n  function symbol() {\n    var buffer;\n    if (!context) context = buffer = path();\n    type.apply(this, arguments).draw(context, +size.apply(this, arguments));\n    if (buffer) return context = null, buffer + \"\" || null;\n  }\n\n  symbol.type = function(_) {\n    return arguments.length ? (type = typeof _ === \"function\" ? _ : constant(_), symbol) : type;\n  };\n\n  symbol.size = function(_) {\n    return arguments.length ? (size = typeof _ === \"function\" ? _ : constant(+_), symbol) : size;\n  };\n\n  symbol.context = function(_) {\n    return arguments.length ? (context = _ == null ? null : _, symbol) : context;\n  };\n\n  return symbol;\n}\n","import {pi, tau} from \"../math\";\n\nexport default {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / pi);\n    context.moveTo(r, 0);\n    context.arc(0, 0, r, 0, tau);\n  }\n};\n","export default {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / 5) / 2;\n    context.moveTo(-3 * r, -r);\n    context.lineTo(-r, -r);\n    context.lineTo(-r, -3 * r);\n    context.lineTo(r, -3 * r);\n    context.lineTo(r, -r);\n    context.lineTo(3 * r, -r);\n    context.lineTo(3 * r, r);\n    context.lineTo(r, r);\n    context.lineTo(r, 3 * r);\n    context.lineTo(-r, 3 * r);\n    context.lineTo(-r, r);\n    context.lineTo(-3 * r, r);\n    context.closePath();\n  }\n};\n","var tan30 = Math.sqrt(1 / 3),\n    tan30_2 = tan30 * 2;\n\nexport default {\n  draw: function(context, size) {\n    var y = Math.sqrt(size / tan30_2),\n        x = y * tan30;\n    context.moveTo(0, -y);\n    context.lineTo(x, 0);\n    context.lineTo(0, y);\n    context.lineTo(-x, 0);\n    context.closePath();\n  }\n};\n","export default {\n  draw: function(context, size) {\n    var w = Math.sqrt(size),\n        x = -w / 2;\n    context.rect(x, x, w, w);\n  }\n};\n","import {pi, tau} from \"../math\";\n\nvar ka = 0.89081309152928522810,\n    kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10),\n    kx = Math.sin(tau / 10) * kr,\n    ky = -Math.cos(tau / 10) * kr;\n\nexport default {\n  draw: function(context, size) {\n    var r = Math.sqrt(size * ka),\n        x = kx * r,\n        y = ky * r;\n    context.moveTo(0, -r);\n    context.lineTo(x, y);\n    for (var i = 1; i < 5; ++i) {\n      var a = tau * i / 5,\n          c = Math.cos(a),\n          s = Math.sin(a);\n      context.lineTo(s * r, -c * r);\n      context.lineTo(c * x - s * y, s * x + c * y);\n    }\n    context.closePath();\n  }\n};\n","var sqrt3 = Math.sqrt(3);\n\nexport default {\n  draw: function(context, size) {\n    var y = -Math.sqrt(size / (sqrt3 * 3));\n    context.moveTo(0, y * 2);\n    context.lineTo(-sqrt3 * y, -y);\n    context.lineTo(sqrt3 * y, -y);\n    context.closePath();\n  }\n};\n","var c = -0.5,\n    s = Math.sqrt(3) / 2,\n    k = 1 / Math.sqrt(12),\n    a = (k / 2 + 1) * 3;\n\nexport default {\n  draw: function(context, size) {\n    var r = Math.sqrt(size / a),\n        x0 = r / 2,\n        y0 = r * k,\n        x1 = x0,\n        y1 = r * k + r,\n        x2 = -x1,\n        y2 = y1;\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);\n    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);\n    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);\n    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);\n    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);\n    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);\n    context.closePath();\n  }\n};\n","import formatLocale from \"./locale\";\n\nvar locale;\nexport var timeFormat;\nexport var timeParse;\nexport var utcFormat;\nexport var utcParse;\n\ndefaultLocale({\n  dateTime: \"%x, %X\",\n  date: \"%-m/%-d/%Y\",\n  time: \"%-I:%M:%S %p\",\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n});\n\nexport default function defaultLocale(definition) {\n  locale = formatLocale(definition);\n  timeFormat = locale.format;\n  timeParse = locale.parse;\n  utcFormat = locale.utcFormat;\n  utcParse = locale.utcParse;\n  return locale;\n}\n","export {default as timeFormatDefaultLocale, timeFormat, timeParse, utcFormat, utcParse} from \"./defaultLocale\";\nexport {default as timeFormatLocale} from \"./locale\";\nexport {default as isoFormat} from \"./isoFormat\";\nexport {default as isoParse} from \"./isoParse\";\n","import {utcFormat} from \"./defaultLocale\";\n\nexport var isoSpecifier = \"%Y-%m-%dT%H:%M:%S.%LZ\";\n\nfunction formatIsoNative(date) {\n  return date.toISOString();\n}\n\nvar formatIso = Date.prototype.toISOString\n    ? formatIsoNative\n    : utcFormat(isoSpecifier);\n\nexport default formatIso;\n","import {isoSpecifier} from \"./isoFormat\";\nimport {utcParse} from \"./defaultLocale\";\n\nfunction parseIsoNative(string) {\n  var date = new Date(string);\n  return isNaN(date) ? null : date;\n}\n\nvar parseIso = +new Date(\"2000-01-01T00:00:00.000Z\")\n    ? parseIsoNative\n    : utcParse(isoSpecifier);\n\nexport default parseIso;\n","import {\n  timeDay,\n  timeSunday,\n  timeMonday,\n  timeThursday,\n  timeYear,\n  utcDay,\n  utcSunday,\n  utcMonday,\n  utcThursday,\n  utcYear\n} from \"d3-time\";\n\nfunction localDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);\n    date.setFullYear(d.y);\n    return date;\n  }\n  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);\n}\n\nfunction utcDate(d) {\n  if (0 <= d.y && d.y < 100) {\n    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));\n    date.setUTCFullYear(d.y);\n    return date;\n  }\n  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));\n}\n\nfunction newYear(y) {\n  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\n}\n\nexport default function formatLocale(locale) {\n  var locale_dateTime = locale.dateTime,\n      locale_date = locale.date,\n      locale_time = locale.time,\n      locale_periods = locale.periods,\n      locale_weekdays = locale.days,\n      locale_shortWeekdays = locale.shortDays,\n      locale_months = locale.months,\n      locale_shortMonths = locale.shortMonths;\n\n  var periodRe = formatRe(locale_periods),\n      periodLookup = formatLookup(locale_periods),\n      weekdayRe = formatRe(locale_weekdays),\n      weekdayLookup = formatLookup(locale_weekdays),\n      shortWeekdayRe = formatRe(locale_shortWeekdays),\n      shortWeekdayLookup = formatLookup(locale_shortWeekdays),\n      monthRe = formatRe(locale_months),\n      monthLookup = formatLookup(locale_months),\n      shortMonthRe = formatRe(locale_shortMonths),\n      shortMonthLookup = formatLookup(locale_shortMonths);\n\n  var formats = {\n    \"a\": formatShortWeekday,\n    \"A\": formatWeekday,\n    \"b\": formatShortMonth,\n    \"B\": formatMonth,\n    \"c\": null,\n    \"d\": formatDayOfMonth,\n    \"e\": formatDayOfMonth,\n    \"f\": formatMicroseconds,\n    \"H\": formatHour24,\n    \"I\": formatHour12,\n    \"j\": formatDayOfYear,\n    \"L\": formatMilliseconds,\n    \"m\": formatMonthNumber,\n    \"M\": formatMinutes,\n    \"p\": formatPeriod,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatSeconds,\n    \"u\": formatWeekdayNumberMonday,\n    \"U\": formatWeekNumberSunday,\n    \"V\": formatWeekNumberISO,\n    \"w\": formatWeekdayNumberSunday,\n    \"W\": formatWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatYear,\n    \"Y\": formatFullYear,\n    \"Z\": formatZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"f\": formatUTCMicroseconds,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"Q\": formatUnixTimestamp,\n    \"s\": formatUnixTimestampSeconds,\n    \"S\": formatUTCSeconds,\n    \"u\": formatUTCWeekdayNumberMonday,\n    \"U\": formatUTCWeekNumberSunday,\n    \"V\": formatUTCWeekNumberISO,\n    \"w\": formatUTCWeekdayNumberSunday,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n  };\n\n  var parses = {\n    \"a\": parseShortWeekday,\n    \"A\": parseWeekday,\n    \"b\": parseShortMonth,\n    \"B\": parseMonth,\n    \"c\": parseLocaleDateTime,\n    \"d\": parseDayOfMonth,\n    \"e\": parseDayOfMonth,\n    \"f\": parseMicroseconds,\n    \"H\": parseHour24,\n    \"I\": parseHour24,\n    \"j\": parseDayOfYear,\n    \"L\": parseMilliseconds,\n    \"m\": parseMonthNumber,\n    \"M\": parseMinutes,\n    \"p\": parsePeriod,\n    \"Q\": parseUnixTimestamp,\n    \"s\": parseUnixTimestampSeconds,\n    \"S\": parseSeconds,\n    \"u\": parseWeekdayNumberMonday,\n    \"U\": parseWeekNumberSunday,\n    \"V\": parseWeekNumberISO,\n    \"w\": parseWeekdayNumberSunday,\n    \"W\": parseWeekNumberMonday,\n    \"x\": parseLocaleDate,\n    \"X\": parseLocaleTime,\n    \"y\": parseYear,\n    \"Y\": parseFullYear,\n    \"Z\": parseZone,\n    \"%\": parseLiteralPercent\n  };\n\n  // These recursive directive definitions must be deferred.\n  formats.x = newFormat(locale_date, formats);\n  formats.X = newFormat(locale_time, formats);\n  formats.c = newFormat(locale_dateTime, formats);\n  utcFormats.x = newFormat(locale_date, utcFormats);\n  utcFormats.X = newFormat(locale_time, utcFormats);\n  utcFormats.c = newFormat(locale_dateTime, utcFormats);\n\n  function newFormat(specifier, formats) {\n    return function(date) {\n      var string = [],\n          i = -1,\n          j = 0,\n          n = specifier.length,\n          c,\n          pad,\n          format;\n\n      if (!(date instanceof Date)) date = new Date(+date);\n\n      while (++i < n) {\n        if (specifier.charCodeAt(i) === 37) {\n          string.push(specifier.slice(j, i));\n          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);\n          else pad = c === \"e\" ? \" \" : \"0\";\n          if (format = formats[c]) c = format(date, pad);\n          string.push(c);\n          j = i + 1;\n        }\n      }\n\n      string.push(specifier.slice(j, i));\n      return string.join(\"\");\n    };\n  }\n\n  function newParse(specifier, newDate) {\n    return function(string) {\n      var d = newYear(1900),\n          i = parseSpecifier(d, specifier, string += \"\", 0),\n          week, day;\n      if (i != string.length) return null;\n\n      // If a UNIX timestamp is specified, return it.\n      if (\"Q\" in d) return new Date(d.Q);\n\n      // The am-pm flag is 0 for AM, and 1 for PM.\n      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n\n      // Convert day-of-week and week-of-year to day-of-year.\n      if (\"V\" in d) {\n        if (d.V < 1 || d.V > 53) return null;\n        if (!(\"w\" in d)) d.w = 1;\n        if (\"Z\" in d) {\n          week = utcDate(newYear(d.y)), day = week.getUTCDay();\n          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);\n          week = utcDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getUTCFullYear();\n          d.m = week.getUTCMonth();\n          d.d = week.getUTCDate() + (d.w + 6) % 7;\n        } else {\n          week = newDate(newYear(d.y)), day = week.getDay();\n          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);\n          week = timeDay.offset(week, (d.V - 1) * 7);\n          d.y = week.getFullYear();\n          d.m = week.getMonth();\n          d.d = week.getDate() + (d.w + 6) % 7;\n        }\n      } else if (\"W\" in d || \"U\" in d) {\n        if (!(\"w\" in d)) d.w = \"u\" in d ? d.u % 7 : \"W\" in d ? 1 : 0;\n        day = \"Z\" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();\n        d.m = 0;\n        d.d = \"W\" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;\n      }\n\n      // If a time zone is specified, all fields are interpreted as UTC and then\n      // offset according to the specified time zone.\n      if (\"Z\" in d) {\n        d.H += d.Z / 100 | 0;\n        d.M += d.Z % 100;\n        return utcDate(d);\n      }\n\n      // Otherwise, all fields are in local time.\n      return newDate(d);\n    };\n  }\n\n  function parseSpecifier(d, specifier, string, j) {\n    var i = 0,\n        n = specifier.length,\n        m = string.length,\n        c,\n        parse;\n\n    while (i < n) {\n      if (j >= m) return -1;\n      c = specifier.charCodeAt(i++);\n      if (c === 37) {\n        c = specifier.charAt(i++);\n        parse = parses[c in pads ? specifier.charAt(i++) : c];\n        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n      } else if (c != string.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n\n    return j;\n  }\n\n  function parsePeriod(d, string, i) {\n    var n = periodRe.exec(string.slice(i));\n    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortWeekday(d, string, i) {\n    var n = shortWeekdayRe.exec(string.slice(i));\n    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseWeekday(d, string, i) {\n    var n = weekdayRe.exec(string.slice(i));\n    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseShortMonth(d, string, i) {\n    var n = shortMonthRe.exec(string.slice(i));\n    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseMonth(d, string, i) {\n    var n = monthRe.exec(string.slice(i));\n    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;\n  }\n\n  function parseLocaleDateTime(d, string, i) {\n    return parseSpecifier(d, locale_dateTime, string, i);\n  }\n\n  function parseLocaleDate(d, string, i) {\n    return parseSpecifier(d, locale_date, string, i);\n  }\n\n  function parseLocaleTime(d, string, i) {\n    return parseSpecifier(d, locale_time, string, i);\n  }\n\n  function formatShortWeekday(d) {\n    return locale_shortWeekdays[d.getDay()];\n  }\n\n  function formatWeekday(d) {\n    return locale_weekdays[d.getDay()];\n  }\n\n  function formatShortMonth(d) {\n    return locale_shortMonths[d.getMonth()];\n  }\n\n  function formatMonth(d) {\n    return locale_months[d.getMonth()];\n  }\n\n  function formatPeriod(d) {\n    return locale_periods[+(d.getHours() >= 12)];\n  }\n\n  function formatUTCShortWeekday(d) {\n    return locale_shortWeekdays[d.getUTCDay()];\n  }\n\n  function formatUTCWeekday(d) {\n    return locale_weekdays[d.getUTCDay()];\n  }\n\n  function formatUTCShortMonth(d) {\n    return locale_shortMonths[d.getUTCMonth()];\n  }\n\n  function formatUTCMonth(d) {\n    return locale_months[d.getUTCMonth()];\n  }\n\n  function formatUTCPeriod(d) {\n    return locale_periods[+(d.getUTCHours() >= 12)];\n  }\n\n  return {\n    format: function(specifier) {\n      var f = newFormat(specifier += \"\", formats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    parse: function(specifier) {\n      var p = newParse(specifier += \"\", localDate);\n      p.toString = function() { return specifier; };\n      return p;\n    },\n    utcFormat: function(specifier) {\n      var f = newFormat(specifier += \"\", utcFormats);\n      f.toString = function() { return specifier; };\n      return f;\n    },\n    utcParse: function(specifier) {\n      var p = newParse(specifier, utcDate);\n      p.toString = function() { return specifier; };\n      return p;\n    }\n  };\n}\n\nvar pads = {\"-\": \"\", \"_\": \" \", \"0\": \"0\"},\n    numberRe = /^\\s*\\d+/, // note: ignores next directive\n    percentRe = /^%/,\n    requoteRe = /[\\\\^$*+?|[\\]().{}]/g;\n\nfunction pad(value, fill, width) {\n  var sign = value < 0 ? \"-\" : \"\",\n      string = (sign ? -value : value) + \"\",\n      length = string.length;\n  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\n}\n\nfunction requote(s) {\n  return s.replace(requoteRe, \"\\\\$&\");\n}\n\nfunction formatRe(names) {\n  return new RegExp(\"^(?:\" + names.map(requote).join(\"|\") + \")\", \"i\");\n}\n\nfunction formatLookup(names) {\n  var map = {}, i = -1, n = names.length;\n  while (++i < n) map[names[i].toLowerCase()] = i;\n  return map;\n}\n\nfunction parseWeekdayNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.w = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekdayNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 1));\n  return n ? (d.u = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberSunday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.U = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberISO(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.V = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseWeekNumberMonday(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.W = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseFullYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 4));\n  return n ? (d.y = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;\n}\n\nfunction parseZone(d, string, i) {\n  var n = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(string.slice(i, i + 6));\n  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || \"00\")), i + n[0].length) : -1;\n}\n\nfunction parseMonthNumber(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;\n}\n\nfunction parseDayOfMonth(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseDayOfYear(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseHour24(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.H = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMinutes(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.M = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 2));\n  return n ? (d.S = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMilliseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 3));\n  return n ? (d.L = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseMicroseconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i, i + 6));\n  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;\n}\n\nfunction parseLiteralPercent(d, string, i) {\n  var n = percentRe.exec(string.slice(i, i + 1));\n  return n ? i + n[0].length : -1;\n}\n\nfunction parseUnixTimestamp(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.Q = +n[0], i + n[0].length) : -1;\n}\n\nfunction parseUnixTimestampSeconds(d, string, i) {\n  var n = numberRe.exec(string.slice(i));\n  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;\n}\n\nfunction formatDayOfMonth(d, p) {\n  return pad(d.getDate(), p, 2);\n}\n\nfunction formatHour24(d, p) {\n  return pad(d.getHours(), p, 2);\n}\n\nfunction formatHour12(d, p) {\n  return pad(d.getHours() % 12 || 12, p, 2);\n}\n\nfunction formatDayOfYear(d, p) {\n  return pad(1 + timeDay.count(timeYear(d), d), p, 3);\n}\n\nfunction formatMilliseconds(d, p) {\n  return pad(d.getMilliseconds(), p, 3);\n}\n\nfunction formatMicroseconds(d, p) {\n  return formatMilliseconds(d, p) + \"000\";\n}\n\nfunction formatMonthNumber(d, p) {\n  return pad(d.getMonth() + 1, p, 2);\n}\n\nfunction formatMinutes(d, p) {\n  return pad(d.getMinutes(), p, 2);\n}\n\nfunction formatSeconds(d, p) {\n  return pad(d.getSeconds(), p, 2);\n}\n\nfunction formatWeekdayNumberMonday(d) {\n  var day = d.getDay();\n  return day === 0 ? 7 : day;\n}\n\nfunction formatWeekNumberSunday(d, p) {\n  return pad(timeSunday.count(timeYear(d), d), p, 2);\n}\n\nfunction formatWeekNumberISO(d, p) {\n  var day = d.getDay();\n  d = (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);\n  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);\n}\n\nfunction formatWeekdayNumberSunday(d) {\n  return d.getDay();\n}\n\nfunction formatWeekNumberMonday(d, p) {\n  return pad(timeMonday.count(timeYear(d), d), p, 2);\n}\n\nfunction formatYear(d, p) {\n  return pad(d.getFullYear() % 100, p, 2);\n}\n\nfunction formatFullYear(d, p) {\n  return pad(d.getFullYear() % 10000, p, 4);\n}\n\nfunction formatZone(d) {\n  var z = d.getTimezoneOffset();\n  return (z > 0 ? \"-\" : (z *= -1, \"+\"))\n      + pad(z / 60 | 0, \"0\", 2)\n      + pad(z % 60, \"0\", 2);\n}\n\nfunction formatUTCDayOfMonth(d, p) {\n  return pad(d.getUTCDate(), p, 2);\n}\n\nfunction formatUTCHour24(d, p) {\n  return pad(d.getUTCHours(), p, 2);\n}\n\nfunction formatUTCHour12(d, p) {\n  return pad(d.getUTCHours() % 12 || 12, p, 2);\n}\n\nfunction formatUTCDayOfYear(d, p) {\n  return pad(1 + utcDay.count(utcYear(d), d), p, 3);\n}\n\nfunction formatUTCMilliseconds(d, p) {\n  return pad(d.getUTCMilliseconds(), p, 3);\n}\n\nfunction formatUTCMicroseconds(d, p) {\n  return formatUTCMilliseconds(d, p) + \"000\";\n}\n\nfunction formatUTCMonthNumber(d, p) {\n  return pad(d.getUTCMonth() + 1, p, 2);\n}\n\nfunction formatUTCMinutes(d, p) {\n  return pad(d.getUTCMinutes(), p, 2);\n}\n\nfunction formatUTCSeconds(d, p) {\n  return pad(d.getUTCSeconds(), p, 2);\n}\n\nfunction formatUTCWeekdayNumberMonday(d) {\n  var dow = d.getUTCDay();\n  return dow === 0 ? 7 : dow;\n}\n\nfunction formatUTCWeekNumberSunday(d, p) {\n  return pad(utcSunday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCWeekNumberISO(d, p) {\n  var day = d.getUTCDay();\n  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);\n  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);\n}\n\nfunction formatUTCWeekdayNumberSunday(d) {\n  return d.getUTCDay();\n}\n\nfunction formatUTCWeekNumberMonday(d, p) {\n  return pad(utcMonday.count(utcYear(d), d), p, 2);\n}\n\nfunction formatUTCYear(d, p) {\n  return pad(d.getUTCFullYear() % 100, p, 2);\n}\n\nfunction formatUTCFullYear(d, p) {\n  return pad(d.getUTCFullYear() % 10000, p, 4);\n}\n\nfunction formatUTCZone() {\n  return \"+0000\";\n}\n\nfunction formatLiteralPercent() {\n  return \"%\";\n}\n\nfunction formatUnixTimestamp(d) {\n  return +d;\n}\n\nfunction formatUnixTimestampSeconds(d) {\n  return Math.floor(+d / 1000);\n}\n","import interval from \"./interval\";\nimport {durationDay, durationMinute} from \"./duration\";\n\nvar day = interval(function(date) {\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setDate(date.getDate() + step);\n}, function(start, end) {\n  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;\n}, function(date) {\n  return date.getDate() - 1;\n});\n\nexport default day;\nexport var days = day.range;\n","export var durationSecond = 1e3;\nexport var durationMinute = 6e4;\nexport var durationHour = 36e5;\nexport var durationDay = 864e5;\nexport var durationWeek = 6048e5;\n","import interval from \"./interval\";\nimport {durationHour, durationMinute} from \"./duration\";\n\nvar hour = interval(function(date) {\n  var offset = date.getTimezoneOffset() * durationMinute % durationHour;\n  if (offset < 0) offset += durationHour;\n  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour);\n}, function(start, end) {\n  return (end - start) / durationHour;\n}, function(date) {\n  return date.getHours();\n});\n\nexport default hour;\nexport var hours = hour.range;\n","export {\n  default as timeInterval\n} from \"./interval\";\n\nexport {\n  default as timeMillisecond,\n  milliseconds as timeMilliseconds,\n  default as utcMillisecond,\n  milliseconds as utcMilliseconds\n} from \"./millisecond\";\n\nexport {\n  default as timeSecond,\n  seconds as timeSeconds,\n  default as utcSecond,\n  seconds as utcSeconds\n} from \"./second\";\n\nexport {\n  default as timeMinute,\n  minutes as timeMinutes\n} from \"./minute\";\n\nexport {\n  default as timeHour,\n  hours as timeHours\n} from \"./hour\";\n\nexport {\n  default as timeDay,\n  days as timeDays\n} from \"./day\";\n\nexport {\n  sunday as timeWeek,\n  sundays as timeWeeks,\n  sunday as timeSunday,\n  sundays as timeSundays,\n  monday as timeMonday,\n  mondays as timeMondays,\n  tuesday as timeTuesday,\n  tuesdays as timeTuesdays,\n  wednesday as timeWednesday,\n  wednesdays as timeWednesdays,\n  thursday as timeThursday,\n  thursdays as timeThursdays,\n  friday as timeFriday,\n  fridays as timeFridays,\n  saturday as timeSaturday,\n  saturdays as timeSaturdays\n} from \"./week\";\n\nexport {\n  default as timeMonth,\n  months as timeMonths\n} from \"./month\";\n\nexport {\n  default as timeYear,\n  years as timeYears\n} from \"./year\";\n\nexport {\n  default as utcMinute,\n  utcMinutes as utcMinutes\n} from \"./utcMinute\";\n\nexport {\n  default as utcHour,\n  utcHours as utcHours\n} from \"./utcHour\";\n\nexport {\n  default as utcDay,\n  utcDays as utcDays\n} from \"./utcDay\";\n\nexport {\n  utcSunday as utcWeek,\n  utcSundays as utcWeeks,\n  utcSunday as utcSunday,\n  utcSundays as utcSundays,\n  utcMonday as utcMonday,\n  utcMondays as utcMondays,\n  utcTuesday as utcTuesday,\n  utcTuesdays as utcTuesdays,\n  utcWednesday as utcWednesday,\n  utcWednesdays as utcWednesdays,\n  utcThursday as utcThursday,\n  utcThursdays as utcThursdays,\n  utcFriday as utcFriday,\n  utcFridays as utcFridays,\n  utcSaturday as utcSaturday,\n  utcSaturdays as utcSaturdays\n} from \"./utcWeek\";\n\nexport {\n  default as utcMonth,\n  utcMonths as utcMonths\n} from \"./utcMonth\";\n\nexport {\n  default as utcYear,\n  utcYears as utcYears\n} from \"./utcYear\";\n","var t0 = new Date,\n    t1 = new Date;\n\nexport default function newInterval(floori, offseti, count, field) {\n\n  function interval(date) {\n    return floori(date = new Date(+date)), date;\n  }\n\n  interval.floor = interval;\n\n  interval.ceil = function(date) {\n    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;\n  };\n\n  interval.round = function(date) {\n    var d0 = interval(date),\n        d1 = interval.ceil(date);\n    return date - d0 < d1 - date ? d0 : d1;\n  };\n\n  interval.offset = function(date, step) {\n    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n  };\n\n  interval.range = function(start, stop, step) {\n    var range = [], previous;\n    start = interval.ceil(start);\n    step = step == null ? 1 : Math.floor(step);\n    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);\n    while (previous < start && start < stop);\n    return range;\n  };\n\n  interval.filter = function(test) {\n    return newInterval(function(date) {\n      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);\n    }, function(date, step) {\n      if (date >= date) {\n        if (step < 0) while (++step <= 0) {\n          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty\n        } else while (--step >= 0) {\n          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty\n        }\n      }\n    });\n  };\n\n  if (count) {\n    interval.count = function(start, end) {\n      t0.setTime(+start), t1.setTime(+end);\n      floori(t0), floori(t1);\n      return Math.floor(count(t0, t1));\n    };\n\n    interval.every = function(step) {\n      step = Math.floor(step);\n      return !isFinite(step) || !(step > 0) ? null\n          : !(step > 1) ? interval\n          : interval.filter(field\n              ? function(d) { return field(d) % step === 0; }\n              : function(d) { return interval.count(0, d) % step === 0; });\n    };\n  }\n\n  return interval;\n}\n","import interval from \"./interval\";\n\nvar millisecond = interval(function() {\n  // noop\n}, function(date, step) {\n  date.setTime(+date + step);\n}, function(start, end) {\n  return end - start;\n});\n\n// An optimized implementation for this simple case.\nmillisecond.every = function(k) {\n  k = Math.floor(k);\n  if (!isFinite(k) || !(k > 0)) return null;\n  if (!(k > 1)) return millisecond;\n  return interval(function(date) {\n    date.setTime(Math.floor(date / k) * k);\n  }, function(date, step) {\n    date.setTime(+date + step * k);\n  }, function(start, end) {\n    return (end - start) / k;\n  });\n};\n\nexport default millisecond;\nexport var milliseconds = millisecond.range;\n","import interval from \"./interval\";\nimport {durationMinute} from \"./duration\";\n\nvar minute = interval(function(date) {\n  date.setTime(Math.floor(date / durationMinute) * durationMinute);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function(start, end) {\n  return (end - start) / durationMinute;\n}, function(date) {\n  return date.getMinutes();\n});\n\nexport default minute;\nexport var minutes = minute.range;\n","import interval from \"./interval\";\n\nvar month = interval(function(date) {\n  date.setDate(1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setMonth(date.getMonth() + step);\n}, function(start, end) {\n  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n}, function(date) {\n  return date.getMonth();\n});\n\nexport default month;\nexport var months = month.range;\n","import interval from \"./interval\";\nimport {durationSecond} from \"./duration\";\n\nvar second = interval(function(date) {\n  date.setTime(Math.floor(date / durationSecond) * durationSecond);\n}, function(date, step) {\n  date.setTime(+date + step * durationSecond);\n}, function(start, end) {\n  return (end - start) / durationSecond;\n}, function(date) {\n  return date.getUTCSeconds();\n});\n\nexport default second;\nexport var seconds = second.range;\n","import interval from \"./interval\";\nimport {durationDay} from \"./duration\";\n\nvar utcDay = interval(function(date) {\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCDate(date.getUTCDate() + step);\n}, function(start, end) {\n  return (end - start) / durationDay;\n}, function(date) {\n  return date.getUTCDate() - 1;\n});\n\nexport default utcDay;\nexport var utcDays = utcDay.range;\n","import interval from \"./interval\";\nimport {durationHour} from \"./duration\";\n\nvar utcHour = interval(function(date) {\n  date.setUTCMinutes(0, 0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationHour);\n}, function(start, end) {\n  return (end - start) / durationHour;\n}, function(date) {\n  return date.getUTCHours();\n});\n\nexport default utcHour;\nexport var utcHours = utcHour.range;\n","import interval from \"./interval\";\nimport {durationMinute} from \"./duration\";\n\nvar utcMinute = interval(function(date) {\n  date.setUTCSeconds(0, 0);\n}, function(date, step) {\n  date.setTime(+date + step * durationMinute);\n}, function(start, end) {\n  return (end - start) / durationMinute;\n}, function(date) {\n  return date.getUTCMinutes();\n});\n\nexport default utcMinute;\nexport var utcMinutes = utcMinute.range;\n","import interval from \"./interval\";\n\nvar utcMonth = interval(function(date) {\n  date.setUTCDate(1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCMonth(date.getUTCMonth() + step);\n}, function(start, end) {\n  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n}, function(date) {\n  return date.getUTCMonth();\n});\n\nexport default utcMonth;\nexport var utcMonths = utcMonth.range;\n","import interval from \"./interval\";\nimport {durationWeek} from \"./duration\";\n\nfunction utcWeekday(i) {\n  return interval(function(date) {\n    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step * 7);\n  }, function(start, end) {\n    return (end - start) / durationWeek;\n  });\n}\n\nexport var utcSunday = utcWeekday(0);\nexport var utcMonday = utcWeekday(1);\nexport var utcTuesday = utcWeekday(2);\nexport var utcWednesday = utcWeekday(3);\nexport var utcThursday = utcWeekday(4);\nexport var utcFriday = utcWeekday(5);\nexport var utcSaturday = utcWeekday(6);\n\nexport var utcSundays = utcSunday.range;\nexport var utcMondays = utcMonday.range;\nexport var utcTuesdays = utcTuesday.range;\nexport var utcWednesdays = utcWednesday.range;\nexport var utcThursdays = utcThursday.range;\nexport var utcFridays = utcFriday.range;\nexport var utcSaturdays = utcSaturday.range;\n","import interval from \"./interval\";\n\nvar utcYear = interval(function(date) {\n  date.setUTCMonth(0, 1);\n  date.setUTCHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setUTCFullYear(date.getUTCFullYear() + step);\n}, function(start, end) {\n  return end.getUTCFullYear() - start.getUTCFullYear();\n}, function(date) {\n  return date.getUTCFullYear();\n});\n\n// An optimized implementation for this simple case.\nutcYear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : interval(function(date) {\n    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);\n    date.setUTCMonth(0, 1);\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step * k);\n  });\n};\n\nexport default utcYear;\nexport var utcYears = utcYear.range;\n","import interval from \"./interval\";\nimport {durationMinute, durationWeek} from \"./duration\";\n\nfunction weekday(i) {\n  return interval(function(date) {\n    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step * 7);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;\n  });\n}\n\nexport var sunday = weekday(0);\nexport var monday = weekday(1);\nexport var tuesday = weekday(2);\nexport var wednesday = weekday(3);\nexport var thursday = weekday(4);\nexport var friday = weekday(5);\nexport var saturday = weekday(6);\n\nexport var sundays = sunday.range;\nexport var mondays = monday.range;\nexport var tuesdays = tuesday.range;\nexport var wednesdays = wednesday.range;\nexport var thursdays = thursday.range;\nexport var fridays = friday.range;\nexport var saturdays = saturday.range;\n","import interval from \"./interval\";\n\nvar year = interval(function(date) {\n  date.setMonth(0, 1);\n  date.setHours(0, 0, 0, 0);\n}, function(date, step) {\n  date.setFullYear(date.getFullYear() + step);\n}, function(start, end) {\n  return end.getFullYear() - start.getFullYear();\n}, function(date) {\n  return date.getFullYear();\n});\n\n// An optimized implementation for this simple case.\nyear.every = function(k) {\n  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : interval(function(date) {\n    date.setFullYear(Math.floor(date.getFullYear() / k) * k);\n    date.setMonth(0, 1);\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step * k);\n  });\n};\n\nexport default year;\nexport var years = year.range;\n","export {\n  now,\n  timer,\n  timerFlush\n} from \"./timer\";\n\nexport {\n  default as timeout\n} from \"./timeout\";\n\nexport {\n  default as interval\n} from \"./interval\";\n","import {Timer, now} from \"./timer\";\n\nexport default function(callback, delay, time) {\n  var t = new Timer, total = delay;\n  if (delay == null) return t.restart(callback, delay, time), t;\n  delay = +delay, time = time == null ? now() : +time;\n  t.restart(function tick(elapsed) {\n    elapsed += total;\n    t.restart(tick, total += delay, time);\n    callback(elapsed);\n  }, delay, time);\n  return t;\n}\n","import {Timer} from \"./timer\";\n\nexport default function(callback, delay, time) {\n  var t = new Timer;\n  delay = delay == null ? 0 : +delay;\n  t.restart(function(elapsed) {\n    t.stop();\n    callback(elapsed + delay);\n  }, delay, time);\n  return t;\n}\n","var frame = 0, // is an animation frame pending?\n    timeout = 0, // is a timeout pending?\n    interval = 0, // are any timers active?\n    pokeDelay = 1000, // how frequently we check for clock skew\n    taskHead,\n    taskTail,\n    clockLast = 0,\n    clockNow = 0,\n    clockSkew = 0,\n    clock = typeof performance === \"object\" && performance.now ? performance : Date,\n    setFrame = typeof window === \"object\" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };\n\nexport function now() {\n  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);\n}\n\nfunction clearNow() {\n  clockNow = 0;\n}\n\nexport function Timer() {\n  this._call =\n  this._time =\n  this._next = null;\n}\n\nTimer.prototype = timer.prototype = {\n  constructor: Timer,\n  restart: function(callback, delay, time) {\n    if (typeof callback !== \"function\") throw new TypeError(\"callback is not a function\");\n    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);\n    if (!this._next && taskTail !== this) {\n      if (taskTail) taskTail._next = this;\n      else taskHead = this;\n      taskTail = this;\n    }\n    this._call = callback;\n    this._time = time;\n    sleep();\n  },\n  stop: function() {\n    if (this._call) {\n      this._call = null;\n      this._time = Infinity;\n      sleep();\n    }\n  }\n};\n\nexport function timer(callback, delay, time) {\n  var t = new Timer;\n  t.restart(callback, delay, time);\n  return t;\n}\n\nexport function timerFlush() {\n  now(); // Get the current time, if not already set.\n  ++frame; // Pretend weve set an alarm, if we havent already.\n  var t = taskHead, e;\n  while (t) {\n    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);\n    t = t._next;\n  }\n  --frame;\n}\n\nfunction wake() {\n  clockNow = (clockLast = clock.now()) + clockSkew;\n  frame = timeout = 0;\n  try {\n    timerFlush();\n  } finally {\n    frame = 0;\n    nap();\n    clockNow = 0;\n  }\n}\n\nfunction poke() {\n  var now = clock.now(), delay = now - clockLast;\n  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;\n}\n\nfunction nap() {\n  var t0, t1 = taskHead, t2, time = Infinity;\n  while (t1) {\n    if (t1._call) {\n      if (time > t1._time) time = t1._time;\n      t0 = t1, t1 = t1._next;\n    } else {\n      t2 = t1._next, t1._next = null;\n      t1 = t0 ? t0._next = t2 : taskHead = t2;\n    }\n  }\n  taskTail = t0;\n  sleep(time);\n}\n\nfunction sleep(time) {\n  if (frame) return; // Soonest alarm already set, or will be.\n  if (timeout) timeout = clearTimeout(timeout);\n  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.\n  if (delay > 24) {\n    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);\n    if (interval) interval = clearInterval(interval);\n  } else {\n    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);\n    frame = 1, setFrame(wake);\n  }\n}\n","import {RedBlackNode} from \"./RedBlackTree\";\nimport {createCell} from \"./Cell\";\nimport {attachCircle, detachCircle} from \"./Circle\";\nimport {createEdge, setEdgeEnd} from \"./Edge\";\nimport {beaches, epsilon} from \"./Diagram\";\n\nvar beachPool = [];\n\nfunction Beach() {\n  RedBlackNode(this);\n  this.edge =\n  this.site =\n  this.circle = null;\n}\n\nfunction createBeach(site) {\n  var beach = beachPool.pop() || new Beach;\n  beach.site = site;\n  return beach;\n}\n\nfunction detachBeach(beach) {\n  detachCircle(beach);\n  beaches.remove(beach);\n  beachPool.push(beach);\n  RedBlackNode(beach);\n}\n\nexport function removeBeach(beach) {\n  var circle = beach.circle,\n      x = circle.x,\n      y = circle.cy,\n      vertex = [x, y],\n      previous = beach.P,\n      next = beach.N,\n      disappearing = [beach];\n\n  detachBeach(beach);\n\n  var lArc = previous;\n  while (lArc.circle\n      && Math.abs(x - lArc.circle.x) < epsilon\n      && Math.abs(y - lArc.circle.cy) < epsilon) {\n    previous = lArc.P;\n    disappearing.unshift(lArc);\n    detachBeach(lArc);\n    lArc = previous;\n  }\n\n  disappearing.unshift(lArc);\n  detachCircle(lArc);\n\n  var rArc = next;\n  while (rArc.circle\n      && Math.abs(x - rArc.circle.x) < epsilon\n      && Math.abs(y - rArc.circle.cy) < epsilon) {\n    next = rArc.N;\n    disappearing.push(rArc);\n    detachBeach(rArc);\n    rArc = next;\n  }\n\n  disappearing.push(rArc);\n  detachCircle(rArc);\n\n  var nArcs = disappearing.length,\n      iArc;\n  for (iArc = 1; iArc < nArcs; ++iArc) {\n    rArc = disappearing[iArc];\n    lArc = disappearing[iArc - 1];\n    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\n  }\n\n  lArc = disappearing[0];\n  rArc = disappearing[nArcs - 1];\n  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);\n\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nexport function addBeach(site) {\n  var x = site[0],\n      directrix = site[1],\n      lArc,\n      rArc,\n      dxl,\n      dxr,\n      node = beaches._;\n\n  while (node) {\n    dxl = leftBreakPoint(node, directrix) - x;\n    if (dxl > epsilon) node = node.L; else {\n      dxr = x - rightBreakPoint(node, directrix);\n      if (dxr > epsilon) {\n        if (!node.R) {\n          lArc = node;\n          break;\n        }\n        node = node.R;\n      } else {\n        if (dxl > -epsilon) {\n          lArc = node.P;\n          rArc = node;\n        } else if (dxr > -epsilon) {\n          lArc = node;\n          rArc = node.N;\n        } else {\n          lArc = rArc = node;\n        }\n        break;\n      }\n    }\n  }\n\n  createCell(site);\n  var newArc = createBeach(site);\n  beaches.insert(lArc, newArc);\n\n  if (!lArc && !rArc) return;\n\n  if (lArc === rArc) {\n    detachCircle(lArc);\n    rArc = createBeach(lArc.site);\n    beaches.insert(newArc, rArc);\n    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);\n    attachCircle(lArc);\n    attachCircle(rArc);\n    return;\n  }\n\n  if (!rArc) { // && lArc\n    newArc.edge = createEdge(lArc.site, newArc.site);\n    return;\n  }\n\n  // else lArc !== rArc\n  detachCircle(lArc);\n  detachCircle(rArc);\n\n  var lSite = lArc.site,\n      ax = lSite[0],\n      ay = lSite[1],\n      bx = site[0] - ax,\n      by = site[1] - ay,\n      rSite = rArc.site,\n      cx = rSite[0] - ax,\n      cy = rSite[1] - ay,\n      d = 2 * (bx * cy - by * cx),\n      hb = bx * bx + by * by,\n      hc = cx * cx + cy * cy,\n      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];\n\n  setEdgeEnd(rArc.edge, lSite, rSite, vertex);\n  newArc.edge = createEdge(lSite, site, null, vertex);\n  rArc.edge = createEdge(site, rSite, null, vertex);\n  attachCircle(lArc);\n  attachCircle(rArc);\n}\n\nfunction leftBreakPoint(arc, directrix) {\n  var site = arc.site,\n      rfocx = site[0],\n      rfocy = site[1],\n      pby2 = rfocy - directrix;\n\n  if (!pby2) return rfocx;\n\n  var lArc = arc.P;\n  if (!lArc) return -Infinity;\n\n  site = lArc.site;\n  var lfocx = site[0],\n      lfocy = site[1],\n      plby2 = lfocy - directrix;\n\n  if (!plby2) return lfocx;\n\n  var hl = lfocx - rfocx,\n      aby2 = 1 / pby2 - 1 / plby2,\n      b = hl / plby2;\n\n  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\n\n  return (rfocx + lfocx) / 2;\n}\n\nfunction rightBreakPoint(arc, directrix) {\n  var rArc = arc.N;\n  if (rArc) return leftBreakPoint(rArc, directrix);\n  var site = arc.site;\n  return site[1] === directrix ? site[0] : Infinity;\n}\n","import {createBorderEdge} from \"./Edge\";\nimport {cells, edges, epsilon} from \"./Diagram\";\n\nexport function createCell(site) {\n  return cells[site.index] = {\n    site: site,\n    halfedges: []\n  };\n}\n\nfunction cellHalfedgeAngle(cell, edge) {\n  var site = cell.site,\n      va = edge.left,\n      vb = edge.right;\n  if (site === vb) vb = va, va = site;\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\n  if (site === va) va = edge[1], vb = edge[0];\n  else va = edge[0], vb = edge[1];\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\n}\n\nexport function cellHalfedgeStart(cell, edge) {\n  return edge[+(edge.left !== cell.site)];\n}\n\nexport function cellHalfedgeEnd(cell, edge) {\n  return edge[+(edge.left === cell.site)];\n}\n\nexport function sortCellHalfedges() {\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\n      var index = new Array(m),\n          array = new Array(m);\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\n      index.sort(function(i, j) { return array[j] - array[i]; });\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\n    }\n  }\n}\n\nexport function clipCells(x0, y0, x1, y1) {\n  var nCells = cells.length,\n      iCell,\n      cell,\n      site,\n      iHalfedge,\n      halfedges,\n      nHalfedges,\n      start,\n      startX,\n      startY,\n      end,\n      endX,\n      endY,\n      cover = true;\n\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      site = cell.site;\n      halfedges = cell.halfedges;\n      iHalfedge = halfedges.length;\n\n      // Remove any dangling clipped edges.\n      while (iHalfedge--) {\n        if (!edges[halfedges[iHalfedge]]) {\n          halfedges.splice(iHalfedge, 1);\n        }\n      }\n\n      // Insert any border edges as necessary.\n      iHalfedge = 0, nHalfedges = halfedges.length;\n      while (iHalfedge < nHalfedges) {\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\n        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\n              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\n              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\n              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\n              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\n              : null)) - 1);\n          ++nHalfedges;\n        }\n      }\n\n      if (nHalfedges) cover = false;\n    }\n  }\n\n  // If there werent any edges, have the closest site cover the extent.\n  // It doesnt matter which corner of the extent we measure!\n  if (cover) {\n    var dx, dy, d2, dc = Infinity;\n\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\n      if (cell = cells[iCell]) {\n        site = cell.site;\n        dx = site[0] - x0;\n        dy = site[1] - y0;\n        d2 = dx * dx + dy * dy;\n        if (d2 < dc) dc = d2, cover = cell;\n      }\n    }\n\n    if (cover) {\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\n      cover.halfedges.push(\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\n        edges.push(createBorderEdge(site, v10, v00)) - 1\n      );\n    }\n  }\n\n  // Lastly delete any cells with no edges; these were entirely clipped.\n  for (iCell = 0; iCell < nCells; ++iCell) {\n    if (cell = cells[iCell]) {\n      if (!cell.halfedges.length) {\n        delete cells[iCell];\n      }\n    }\n  }\n}\n","import {RedBlackNode} from \"./RedBlackTree\";\nimport {circles, epsilon2} from \"./Diagram\";\n\nvar circlePool = [];\n\nexport var firstCircle;\n\nfunction Circle() {\n  RedBlackNode(this);\n  this.x =\n  this.y =\n  this.arc =\n  this.site =\n  this.cy = null;\n}\n\nexport function attachCircle(arc) {\n  var lArc = arc.P,\n      rArc = arc.N;\n\n  if (!lArc || !rArc) return;\n\n  var lSite = lArc.site,\n      cSite = arc.site,\n      rSite = rArc.site;\n\n  if (lSite === rSite) return;\n\n  var bx = cSite[0],\n      by = cSite[1],\n      ax = lSite[0] - bx,\n      ay = lSite[1] - by,\n      cx = rSite[0] - bx,\n      cy = rSite[1] - by;\n\n  var d = 2 * (ax * cy - ay * cx);\n  if (d >= -epsilon2) return;\n\n  var ha = ax * ax + ay * ay,\n      hc = cx * cx + cy * cy,\n      x = (cy * ha - ay * hc) / d,\n      y = (ax * hc - cx * ha) / d;\n\n  var circle = circlePool.pop() || new Circle;\n  circle.arc = arc;\n  circle.site = cSite;\n  circle.x = x + bx;\n  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom\n\n  arc.circle = circle;\n\n  var before = null,\n      node = circles._;\n\n  while (node) {\n    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {\n      if (node.L) node = node.L;\n      else { before = node.P; break; }\n    } else {\n      if (node.R) node = node.R;\n      else { before = node; break; }\n    }\n  }\n\n  circles.insert(before, circle);\n  if (!before) firstCircle = circle;\n}\n\nexport function detachCircle(arc) {\n  var circle = arc.circle;\n  if (circle) {\n    if (!circle.P) firstCircle = circle.N;\n    circles.remove(circle);\n    circlePool.push(circle);\n    RedBlackNode(circle);\n    arc.circle = null;\n  }\n}\n","import {addBeach, removeBeach} from \"./Beach\";\nimport {sortCellHalfedges, cellHalfedgeStart, clipCells} from \"./Cell\";\nimport {firstCircle} from \"./Circle\";\nimport {clipEdges} from \"./Edge\";\nimport RedBlackTree from \"./RedBlackTree\";\n\nexport var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var beaches;\nexport var cells;\nexport var circles;\nexport var edges;\n\nfunction triangleArea(a, b, c) {\n  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);\n}\n\nfunction lexicographic(a, b) {\n  return b[1] - a[1]\n      || b[0] - a[0];\n}\n\nexport default function Diagram(sites, extent) {\n  var site = sites.sort(lexicographic).pop(),\n      x,\n      y,\n      circle;\n\n  edges = [];\n  cells = new Array(sites.length);\n  beaches = new RedBlackTree;\n  circles = new RedBlackTree;\n\n  while (true) {\n    circle = firstCircle;\n    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {\n      if (site[0] !== x || site[1] !== y) {\n        addBeach(site);\n        x = site[0], y = site[1];\n      }\n      site = sites.pop();\n    } else if (circle) {\n      removeBeach(circle.arc);\n    } else {\n      break;\n    }\n  }\n\n  sortCellHalfedges();\n\n  if (extent) {\n    var x0 = +extent[0][0],\n        y0 = +extent[0][1],\n        x1 = +extent[1][0],\n        y1 = +extent[1][1];\n    clipEdges(x0, y0, x1, y1);\n    clipCells(x0, y0, x1, y1);\n  }\n\n  this.edges = edges;\n  this.cells = cells;\n\n  beaches =\n  circles =\n  edges =\n  cells = null;\n}\n\nDiagram.prototype = {\n  constructor: Diagram,\n\n  polygons: function() {\n    var edges = this.edges;\n\n    return this.cells.map(function(cell) {\n      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });\n      polygon.data = cell.site.data;\n      return polygon;\n    });\n  },\n\n  triangles: function() {\n    var triangles = [],\n        edges = this.edges;\n\n    this.cells.forEach(function(cell, i) {\n      if (!(m = (halfedges = cell.halfedges).length)) return;\n      var site = cell.site,\n          halfedges,\n          j = -1,\n          m,\n          s0,\n          e1 = edges[halfedges[m - 1]],\n          s1 = e1.left === site ? e1.right : e1.left;\n\n      while (++j < m) {\n        s0 = s1;\n        e1 = edges[halfedges[j]];\n        s1 = e1.left === site ? e1.right : e1.left;\n        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {\n          triangles.push([site.data, s0.data, s1.data]);\n        }\n      }\n    });\n\n    return triangles;\n  },\n\n  links: function() {\n    return this.edges.filter(function(edge) {\n      return edge.right;\n    }).map(function(edge) {\n      return {\n        source: edge.left.data,\n        target: edge.right.data\n      };\n    });\n  },\n\n  find: function(x, y, radius) {\n    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;\n\n    // Use the previously-found cell, or start with an arbitrary one.\n    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;\n    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;\n\n    // Traverse the half-edges to find a closer cell, if any.\n    do {\n      cell = that.cells[i0 = i1], i1 = null;\n      cell.halfedges.forEach(function(e) {\n        var edge = that.edges[e], v = edge.left;\n        if ((v === cell.site || !v) && !(v = edge.right)) return;\n        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;\n        if (v2 < d2) d2 = v2, i1 = v.index;\n      });\n    } while (i1 !== null);\n\n    that._found = i0;\n\n    return radius == null || d2 <= radius * radius ? cell.site : null;\n  }\n}\n","import {cells, edges, epsilon} from \"./Diagram\";\n\nexport function createEdge(left, right, v0, v1) {\n  var edge = [null, null],\n      index = edges.push(edge) - 1;\n  edge.left = left;\n  edge.right = right;\n  if (v0) setEdgeEnd(edge, left, right, v0);\n  if (v1) setEdgeEnd(edge, right, left, v1);\n  cells[left.index].halfedges.push(index);\n  cells[right.index].halfedges.push(index);\n  return edge;\n}\n\nexport function createBorderEdge(left, v0, v1) {\n  var edge = [v0, v1];\n  edge.left = left;\n  return edge;\n}\n\nexport function setEdgeEnd(edge, left, right, vertex) {\n  if (!edge[0] && !edge[1]) {\n    edge[0] = vertex;\n    edge.left = left;\n    edge.right = right;\n  } else if (edge.left === right) {\n    edge[1] = vertex;\n  } else {\n    edge[0] = vertex;\n  }\n}\n\n// LiangBarsky line clipping.\nfunction clipEdge(edge, x0, y0, x1, y1) {\n  var a = edge[0],\n      b = edge[1],\n      ax = a[0],\n      ay = a[1],\n      bx = b[0],\n      by = b[1],\n      t0 = 0,\n      t1 = 1,\n      dx = bx - ax,\n      dy = by - ay,\n      r;\n\n  r = x0 - ax;\n  if (!dx && r > 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dx > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = x1 - ax;\n  if (!dx && r < 0) return;\n  r /= dx;\n  if (dx < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dx > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  r = y0 - ay;\n  if (!dy && r > 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  } else if (dy > 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  }\n\n  r = y1 - ay;\n  if (!dy && r < 0) return;\n  r /= dy;\n  if (dy < 0) {\n    if (r > t1) return;\n    if (r > t0) t0 = r;\n  } else if (dy > 0) {\n    if (r < t0) return;\n    if (r < t1) t1 = r;\n  }\n\n  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?\n\n  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];\n  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];\n  return true;\n}\n\nfunction connectEdge(edge, x0, y0, x1, y1) {\n  var v1 = edge[1];\n  if (v1) return true;\n\n  var v0 = edge[0],\n      left = edge.left,\n      right = edge.right,\n      lx = left[0],\n      ly = left[1],\n      rx = right[0],\n      ry = right[1],\n      fx = (lx + rx) / 2,\n      fy = (ly + ry) / 2,\n      fm,\n      fb;\n\n  if (ry === ly) {\n    if (fx < x0 || fx >= x1) return;\n    if (lx > rx) {\n      if (!v0) v0 = [fx, y0];\n      else if (v0[1] >= y1) return;\n      v1 = [fx, y1];\n    } else {\n      if (!v0) v0 = [fx, y1];\n      else if (v0[1] < y0) return;\n      v1 = [fx, y0];\n    }\n  } else {\n    fm = (lx - rx) / (ry - ly);\n    fb = fy - fm * fx;\n    if (fm < -1 || fm > 1) {\n      if (lx > rx) {\n        if (!v0) v0 = [(y0 - fb) / fm, y0];\n        else if (v0[1] >= y1) return;\n        v1 = [(y1 - fb) / fm, y1];\n      } else {\n        if (!v0) v0 = [(y1 - fb) / fm, y1];\n        else if (v0[1] < y0) return;\n        v1 = [(y0 - fb) / fm, y0];\n      }\n    } else {\n      if (ly < ry) {\n        if (!v0) v0 = [x0, fm * x0 + fb];\n        else if (v0[0] >= x1) return;\n        v1 = [x1, fm * x1 + fb];\n      } else {\n        if (!v0) v0 = [x1, fm * x1 + fb];\n        else if (v0[0] < x0) return;\n        v1 = [x0, fm * x0 + fb];\n      }\n    }\n  }\n\n  edge[0] = v0;\n  edge[1] = v1;\n  return true;\n}\n\nexport function clipEdges(x0, y0, x1, y1) {\n  var i = edges.length,\n      edge;\n\n  while (i--) {\n    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)\n        || !clipEdge(edge, x0, y0, x1, y1)\n        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon\n            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {\n      delete edges[i];\n    }\n  }\n}\n","function RedBlackTree() {\n  this._ = null; // root node\n}\n\nexport function RedBlackNode(node) {\n  node.U = // parent node\n  node.C = // color - true for red, false for black\n  node.L = // left node\n  node.R = // right node\n  node.P = // previous node\n  node.N = null; // next node\n}\n\nRedBlackTree.prototype = {\n  constructor: RedBlackTree,\n\n  insert: function(after, node) {\n    var parent, grandpa, uncle;\n\n    if (after) {\n      node.P = after;\n      node.N = after.N;\n      if (after.N) after.N.P = node;\n      after.N = node;\n      if (after.R) {\n        after = after.R;\n        while (after.L) after = after.L;\n        after.L = node;\n      } else {\n        after.R = node;\n      }\n      parent = after;\n    } else if (this._) {\n      after = RedBlackFirst(this._);\n      node.P = null;\n      node.N = after;\n      after.P = after.L = node;\n      parent = after;\n    } else {\n      node.P = node.N = null;\n      this._ = node;\n      parent = null;\n    }\n    node.L = node.R = null;\n    node.U = parent;\n    node.C = true;\n\n    after = node;\n    while (parent && parent.C) {\n      grandpa = parent.U;\n      if (parent === grandpa.L) {\n        uncle = grandpa.R;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.R) {\n            RedBlackRotateLeft(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateRight(this, grandpa);\n        }\n      } else {\n        uncle = grandpa.L;\n        if (uncle && uncle.C) {\n          parent.C = uncle.C = false;\n          grandpa.C = true;\n          after = grandpa;\n        } else {\n          if (after === parent.L) {\n            RedBlackRotateRight(this, parent);\n            after = parent;\n            parent = after.U;\n          }\n          parent.C = false;\n          grandpa.C = true;\n          RedBlackRotateLeft(this, grandpa);\n        }\n      }\n      parent = after.U;\n    }\n    this._.C = false;\n  },\n\n  remove: function(node) {\n    if (node.N) node.N.P = node.P;\n    if (node.P) node.P.N = node.N;\n    node.N = node.P = null;\n\n    var parent = node.U,\n        sibling,\n        left = node.L,\n        right = node.R,\n        next,\n        red;\n\n    if (!left) next = right;\n    else if (!right) next = left;\n    else next = RedBlackFirst(right);\n\n    if (parent) {\n      if (parent.L === node) parent.L = next;\n      else parent.R = next;\n    } else {\n      this._ = next;\n    }\n\n    if (left && right) {\n      red = next.C;\n      next.C = node.C;\n      next.L = left;\n      left.U = next;\n      if (next !== right) {\n        parent = next.U;\n        next.U = node.U;\n        node = next.R;\n        parent.L = node;\n        next.R = right;\n        right.U = next;\n      } else {\n        next.U = parent;\n        parent = next;\n        node = next.R;\n      }\n    } else {\n      red = node.C;\n      node = next;\n    }\n\n    if (node) node.U = parent;\n    if (red) return;\n    if (node && node.C) { node.C = false; return; }\n\n    do {\n      if (node === this._) break;\n      if (node === parent.L) {\n        sibling = parent.R;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateLeft(this, parent);\n          sibling = parent.R;\n        }\n        if ((sibling.L && sibling.L.C)\n            || (sibling.R && sibling.R.C)) {\n          if (!sibling.R || !sibling.R.C) {\n            sibling.L.C = false;\n            sibling.C = true;\n            RedBlackRotateRight(this, sibling);\n            sibling = parent.R;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.R.C = false;\n          RedBlackRotateLeft(this, parent);\n          node = this._;\n          break;\n        }\n      } else {\n        sibling = parent.L;\n        if (sibling.C) {\n          sibling.C = false;\n          parent.C = true;\n          RedBlackRotateRight(this, parent);\n          sibling = parent.L;\n        }\n        if ((sibling.L && sibling.L.C)\n          || (sibling.R && sibling.R.C)) {\n          if (!sibling.L || !sibling.L.C) {\n            sibling.R.C = false;\n            sibling.C = true;\n            RedBlackRotateLeft(this, sibling);\n            sibling = parent.L;\n          }\n          sibling.C = parent.C;\n          parent.C = sibling.L.C = false;\n          RedBlackRotateRight(this, parent);\n          node = this._;\n          break;\n        }\n      }\n      sibling.C = true;\n      node = parent;\n      parent = parent.U;\n    } while (!node.C);\n\n    if (node) node.C = false;\n  }\n};\n\nfunction RedBlackRotateLeft(tree, node) {\n  var p = node,\n      q = node.R,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.R = q.L;\n  if (p.R) p.R.U = p;\n  q.L = p;\n}\n\nfunction RedBlackRotateRight(tree, node) {\n  var p = node,\n      q = node.L,\n      parent = p.U;\n\n  if (parent) {\n    if (parent.L === p) parent.L = q;\n    else parent.R = q;\n  } else {\n    tree._ = q;\n  }\n\n  q.U = parent;\n  p.U = q;\n  p.L = q.R;\n  if (p.L) p.L.U = p;\n  q.R = p;\n}\n\nfunction RedBlackFirst(node) {\n  while (node.L) node = node.L;\n  return node;\n}\n\nexport default RedBlackTree;\n","export default function(x) {\n  return function() {\n    return x;\n  };\n}\n","export {default as voronoi} from \"./voronoi\";\n","export function x(d) {\n  return d[0];\n}\n\nexport function y(d) {\n  return d[1];\n}\n","import constant from \"./constant\";\nimport {x as pointX, y as pointY} from \"./point\";\nimport Diagram, {epsilon} from \"./Diagram\";\n\nexport default function() {\n  var x = pointX,\n      y = pointY,\n      extent = null;\n\n  function voronoi(data) {\n    return new Diagram(data.map(function(d, i) {\n      var s = [Math.round(x(d, i, data) / epsilon) * epsilon, Math.round(y(d, i, data) / epsilon) * epsilon];\n      s.index = i;\n      s.data = d;\n      return s;\n    }), extent);\n  }\n\n  voronoi.polygons = function(data) {\n    return voronoi(data).polygons();\n  };\n\n  voronoi.links = function(data) {\n    return voronoi(data).links();\n  };\n\n  voronoi.triangles = function(data) {\n    return voronoi(data).triangles();\n  };\n\n  voronoi.x = function(_) {\n    return arguments.length ? (x = typeof _ === \"function\" ? _ : constant(+_), voronoi) : x;\n  };\n\n  voronoi.y = function(_) {\n    return arguments.length ? (y = typeof _ === \"function\" ? _ : constant(+_), voronoi) : y;\n  };\n\n  voronoi.extent = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];\n  };\n\n  voronoi.size = function(_) {\n    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];\n  };\n\n  return voronoi;\n}\n","export var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\nexport var addEventListener = function addEventListener(node, event, listener) {\n  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);\n};\n\nexport var removeEventListener = function removeEventListener(node, event, listener) {\n  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);\n};\n\nexport var getConfirmation = function getConfirmation(message, callback) {\n  return callback(window.confirm(message));\n}; // eslint-disable-line no-alert\n\n/**\n * Returns true if the HTML5 history API is supported. Taken from Modernizr.\n *\n * https://github.com/Modernizr/Modernizr/blob/master/LICENSE\n * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js\n * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586\n */\nexport var supportsHistory = function supportsHistory() {\n  var ua = window.navigator.userAgent;\n\n  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;\n\n  return window.history && 'pushState' in window.history;\n};\n\n/**\n * Returns true if browser fires popstate on hash change.\n * IE10 and IE11 do not.\n */\nexport var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {\n  return window.navigator.userAgent.indexOf('Trident') === -1;\n};\n\n/**\n * Returns false if using go(n) with hash history causes a full page reload.\n */\nexport var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {\n  return window.navigator.userAgent.indexOf('Firefox') === -1;\n};\n\n/**\n * Returns true if a given popstate event is an extraneous WebKit event.\n * Accounts for the fact that Chrome on iOS fires real popstate events\n * containing undefined state when pressing the back button.\n */\nexport var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {\n  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;\n};","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport resolvePathname from 'resolve-pathname';\nimport valueEqual from 'value-equal';\nimport { parsePath } from './PathUtils';\n\nexport var createLocation = function createLocation(path, state, key, currentLocation) {\n  var location = void 0;\n  if (typeof path === 'string') {\n    // Two-arg form: push(path, state)\n    location = parsePath(path);\n    location.state = state;\n  } else {\n    // One-arg form: push(location)\n    location = _extends({}, path);\n\n    if (location.pathname === undefined) location.pathname = '';\n\n    if (location.search) {\n      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;\n    } else {\n      location.search = '';\n    }\n\n    if (location.hash) {\n      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;\n    } else {\n      location.hash = '';\n    }\n\n    if (state !== undefined && location.state === undefined) location.state = state;\n  }\n\n  try {\n    location.pathname = decodeURI(location.pathname);\n  } catch (e) {\n    if (e instanceof URIError) {\n      throw new URIError('Pathname \"' + location.pathname + '\" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');\n    } else {\n      throw e;\n    }\n  }\n\n  if (key) location.key = key;\n\n  if (currentLocation) {\n    // Resolve incomplete/relative pathname relative to current location.\n    if (!location.pathname) {\n      location.pathname = currentLocation.pathname;\n    } else if (location.pathname.charAt(0) !== '/') {\n      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);\n    }\n  } else {\n    // When there is no prior location and pathname is empty, set it to /\n    if (!location.pathname) {\n      location.pathname = '/';\n    }\n  }\n\n  return location;\n};\n\nexport var locationsAreEqual = function locationsAreEqual(a, b) {\n  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && valueEqual(a.state, b.state);\n};","export var addLeadingSlash = function addLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path : '/' + path;\n};\n\nexport var stripLeadingSlash = function stripLeadingSlash(path) {\n  return path.charAt(0) === '/' ? path.substr(1) : path;\n};\n\nexport var hasBasename = function hasBasename(path, prefix) {\n  return new RegExp('^' + prefix + '(\\\\/|\\\\?|#|$)', 'i').test(path);\n};\n\nexport var stripBasename = function stripBasename(path, prefix) {\n  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;\n};\n\nexport var stripTrailingSlash = function stripTrailingSlash(path) {\n  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;\n};\n\nexport var parsePath = function parsePath(path) {\n  var pathname = path || '/';\n  var search = '';\n  var hash = '';\n\n  var hashIndex = pathname.indexOf('#');\n  if (hashIndex !== -1) {\n    hash = pathname.substr(hashIndex);\n    pathname = pathname.substr(0, hashIndex);\n  }\n\n  var searchIndex = pathname.indexOf('?');\n  if (searchIndex !== -1) {\n    search = pathname.substr(searchIndex);\n    pathname = pathname.substr(0, searchIndex);\n  }\n\n  return {\n    pathname: pathname,\n    search: search === '?' ? '' : search,\n    hash: hash === '#' ? '' : hash\n  };\n};\n\nexport var createPath = function createPath(location) {\n  var pathname = location.pathname,\n      search = location.search,\n      hash = location.hash;\n\n\n  var path = pathname || '/';\n\n  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;\n\n  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;\n\n  return path;\n};","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation } from './LocationUtils';\nimport { addLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, isExtraneousPopstateEvent } from './DOMUtils';\n\nvar PopStateEvent = 'popstate';\nvar HashChangeEvent = 'hashchange';\n\nvar getHistoryState = function getHistoryState() {\n  try {\n    return window.history.state || {};\n  } catch (e) {\n    // IE 11 sometimes throws when accessing window.history.state\n    // See https://github.com/ReactTraining/history/pull/289\n    return {};\n  }\n};\n\n/**\n * Creates a history object that uses the HTML5 history API including\n * pushState, replaceState, and the popstate event.\n */\nvar createBrowserHistory = function createBrowserHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant(canUseDOM, 'Browser history needs a DOM');\n\n  var globalHistory = window.history;\n  var canUseHistory = supportsHistory();\n  var needsHashChangeListener = !supportsPopStateOnHashChange();\n\n  var _props$forceRefresh = props.forceRefresh,\n      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,\n      _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  var getDOMLocation = function getDOMLocation(historyState) {\n    var _ref = historyState || {},\n        key = _ref.key,\n        state = _ref.state;\n\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n\n\n    var path = pathname + search + hash;\n\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = stripBasename(path, basename);\n\n    return createLocation(path, state, key);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var handlePopState = function handlePopState(event) {\n    // Ignore extraneous popstate events in WebKit.\n    if (isExtraneousPopstateEvent(event)) return;\n\n    handlePop(getDOMLocation(event.state));\n  };\n\n  var handleHashChange = function handleHashChange() {\n    handlePop(getDOMLocation(getHistoryState()));\n  };\n\n  var forceNextPop = false;\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of keys we've seen in sessionStorage.\n    // Instead, we just default to 0 for keys we don't know.\n\n    var toIndex = allKeys.indexOf(toLocation.key);\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allKeys.indexOf(fromLocation.key);\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  var initialLocation = getDOMLocation(getHistoryState());\n  var allKeys = [initialLocation.key];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return basename + createPath(location);\n  };\n\n  var push = function push(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.pushState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.href = href;\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n          nextKeys.push(location.key);\n          allKeys = nextKeys;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');\n\n        window.location.href = href;\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var href = createHref(location);\n      var key = location.key,\n          state = location.state;\n\n\n      if (canUseHistory) {\n        globalHistory.replaceState({ key: key, state: state }, null, href);\n\n        if (forceRefresh) {\n          window.location.replace(href);\n        } else {\n          var prevIndex = allKeys.indexOf(history.location.key);\n\n          if (prevIndex !== -1) allKeys[prevIndex] = location.key;\n\n          setState({ action: action, location: location });\n        }\n      } else {\n        warning(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');\n\n        window.location.replace(href);\n      }\n    });\n  };\n\n  var go = function go(n) {\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      addEventListener(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, PopStateEvent, handlePopState);\n\n      if (needsHashChangeListener) removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createBrowserHistory;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport invariant from 'invariant';\nimport { createLocation, locationsAreEqual } from './LocationUtils';\nimport { addLeadingSlash, stripLeadingSlash, stripTrailingSlash, hasBasename, stripBasename, createPath } from './PathUtils';\nimport createTransitionManager from './createTransitionManager';\nimport { canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsGoWithoutReloadUsingHash } from './DOMUtils';\n\nvar HashChangeEvent = 'hashchange';\n\nvar HashPathCoders = {\n  hashbang: {\n    encodePath: function encodePath(path) {\n      return path.charAt(0) === '!' ? path : '!/' + stripLeadingSlash(path);\n    },\n    decodePath: function decodePath(path) {\n      return path.charAt(0) === '!' ? path.substr(1) : path;\n    }\n  },\n  noslash: {\n    encodePath: stripLeadingSlash,\n    decodePath: addLeadingSlash\n  },\n  slash: {\n    encodePath: addLeadingSlash,\n    decodePath: addLeadingSlash\n  }\n};\n\nvar getHashPath = function getHashPath() {\n  // We can't use window.location.hash here because it's not\n  // consistent across browsers - Firefox will pre-decode it!\n  var href = window.location.href;\n  var hashIndex = href.indexOf('#');\n  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);\n};\n\nvar pushHashPath = function pushHashPath(path) {\n  return window.location.hash = path;\n};\n\nvar replaceHashPath = function replaceHashPath(path) {\n  var hashIndex = window.location.href.indexOf('#');\n\n  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);\n};\n\nvar createHashHistory = function createHashHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  invariant(canUseDOM, 'Hash history needs a DOM');\n\n  var globalHistory = window.history;\n  var canGoWithoutReload = supportsGoWithoutReloadUsingHash();\n\n  var _props$getUserConfirm = props.getUserConfirmation,\n      getUserConfirmation = _props$getUserConfirm === undefined ? getConfirmation : _props$getUserConfirm,\n      _props$hashType = props.hashType,\n      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;\n\n  var basename = props.basename ? stripTrailingSlash(addLeadingSlash(props.basename)) : '';\n\n  var _HashPathCoders$hashT = HashPathCoders[hashType],\n      encodePath = _HashPathCoders$hashT.encodePath,\n      decodePath = _HashPathCoders$hashT.decodePath;\n\n\n  var getDOMLocation = function getDOMLocation() {\n    var path = decodePath(getHashPath());\n\n    warning(!basename || hasBasename(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path \"' + path + '\" to begin with \"' + basename + '\".');\n\n    if (basename) path = stripBasename(path, basename);\n\n    return createLocation(path);\n  };\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = globalHistory.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var forceNextPop = false;\n  var ignorePath = null;\n\n  var handleHashChange = function handleHashChange() {\n    var path = getHashPath();\n    var encodedPath = encodePath(path);\n\n    if (path !== encodedPath) {\n      // Ensure we always have a properly-encoded hash.\n      replaceHashPath(encodedPath);\n    } else {\n      var location = getDOMLocation();\n      var prevLocation = history.location;\n\n      if (!forceNextPop && locationsAreEqual(prevLocation, location)) return; // A hashchange doesn't always == location change.\n\n      if (ignorePath === createPath(location)) return; // Ignore this change; we already setState in push/replace.\n\n      ignorePath = null;\n\n      handlePop(location);\n    }\n  };\n\n  var handlePop = function handlePop(location) {\n    if (forceNextPop) {\n      forceNextPop = false;\n      setState();\n    } else {\n      var action = 'POP';\n\n      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n        if (ok) {\n          setState({ action: action, location: location });\n        } else {\n          revertPop(location);\n        }\n      });\n    }\n  };\n\n  var revertPop = function revertPop(fromLocation) {\n    var toLocation = history.location;\n\n    // TODO: We could probably make this more reliable by\n    // keeping a list of paths we've seen in sessionStorage.\n    // Instead, we just default to 0 for paths we don't know.\n\n    var toIndex = allPaths.lastIndexOf(createPath(toLocation));\n\n    if (toIndex === -1) toIndex = 0;\n\n    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));\n\n    if (fromIndex === -1) fromIndex = 0;\n\n    var delta = toIndex - fromIndex;\n\n    if (delta) {\n      forceNextPop = true;\n      go(delta);\n    }\n  };\n\n  // Ensure the hash is encoded properly before doing anything else.\n  var path = getHashPath();\n  var encodedPath = encodePath(path);\n\n  if (path !== encodedPath) replaceHashPath(encodedPath);\n\n  var initialLocation = getDOMLocation();\n  var allPaths = [createPath(initialLocation)];\n\n  // Public interface\n\n  var createHref = function createHref(location) {\n    return '#' + encodePath(basename + createPath(location));\n  };\n\n  var push = function push(path, state) {\n    warning(state === undefined, 'Hash history cannot push state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a PUSH, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        pushHashPath(encodedPath);\n\n        var prevIndex = allPaths.lastIndexOf(createPath(history.location));\n        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);\n\n        nextPaths.push(path);\n        allPaths = nextPaths;\n\n        setState({ action: action, location: location });\n      } else {\n        warning(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');\n\n        setState();\n      }\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(state === undefined, 'Hash history cannot replace state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, undefined, undefined, history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var path = createPath(location);\n      var encodedPath = encodePath(basename + path);\n      var hashChanged = getHashPath() !== encodedPath;\n\n      if (hashChanged) {\n        // We cannot tell if a hashchange was caused by a REPLACE, so we'd\n        // rather setState here and ignore the hashchange. The caveat here\n        // is that other hash histories in the page will consider it a POP.\n        ignorePath = path;\n        replaceHashPath(encodedPath);\n      }\n\n      var prevIndex = allPaths.indexOf(createPath(history.location));\n\n      if (prevIndex !== -1) allPaths[prevIndex] = path;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    warning(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');\n\n    globalHistory.go(n);\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var listenerCount = 0;\n\n  var checkDOMListeners = function checkDOMListeners(delta) {\n    listenerCount += delta;\n\n    if (listenerCount === 1) {\n      addEventListener(window, HashChangeEvent, handleHashChange);\n    } else if (listenerCount === 0) {\n      removeEventListener(window, HashChangeEvent, handleHashChange);\n    }\n  };\n\n  var isBlocked = false;\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var unblock = transitionManager.setPrompt(prompt);\n\n    if (!isBlocked) {\n      checkDOMListeners(1);\n      isBlocked = true;\n    }\n\n    return function () {\n      if (isBlocked) {\n        isBlocked = false;\n        checkDOMListeners(-1);\n      }\n\n      return unblock();\n    };\n  };\n\n  var listen = function listen(listener) {\n    var unlisten = transitionManager.appendListener(listener);\n    checkDOMListeners(1);\n\n    return function () {\n      checkDOMListeners(-1);\n      unlisten();\n    };\n  };\n\n  var history = {\n    length: globalHistory.length,\n    action: 'POP',\n    location: initialLocation,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createHashHistory;","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport warning from 'warning';\nimport { createPath } from './PathUtils';\nimport { createLocation } from './LocationUtils';\nimport createTransitionManager from './createTransitionManager';\n\nvar clamp = function clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n};\n\n/**\n * Creates a history object that stores locations in memory.\n */\nvar createMemoryHistory = function createMemoryHistory() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var getUserConfirmation = props.getUserConfirmation,\n      _props$initialEntries = props.initialEntries,\n      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,\n      _props$initialIndex = props.initialIndex,\n      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,\n      _props$keyLength = props.keyLength,\n      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;\n\n\n  var transitionManager = createTransitionManager();\n\n  var setState = function setState(nextState) {\n    _extends(history, nextState);\n\n    history.length = history.entries.length;\n\n    transitionManager.notifyListeners(history.location, history.action);\n  };\n\n  var createKey = function createKey() {\n    return Math.random().toString(36).substr(2, keyLength);\n  };\n\n  var index = clamp(initialIndex, 0, initialEntries.length - 1);\n  var entries = initialEntries.map(function (entry) {\n    return typeof entry === 'string' ? createLocation(entry, undefined, createKey()) : createLocation(entry, undefined, entry.key || createKey());\n  });\n\n  // Public interface\n\n  var createHref = createPath;\n\n  var push = function push(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'PUSH';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      var prevIndex = history.index;\n      var nextIndex = prevIndex + 1;\n\n      var nextEntries = history.entries.slice(0);\n      if (nextEntries.length > nextIndex) {\n        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);\n      } else {\n        nextEntries.push(location);\n      }\n\n      setState({\n        action: action,\n        location: location,\n        index: nextIndex,\n        entries: nextEntries\n      });\n    });\n  };\n\n  var replace = function replace(path, state) {\n    warning(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');\n\n    var action = 'REPLACE';\n    var location = createLocation(path, state, createKey(), history.location);\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (!ok) return;\n\n      history.entries[history.index] = location;\n\n      setState({ action: action, location: location });\n    });\n  };\n\n  var go = function go(n) {\n    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);\n\n    var action = 'POP';\n    var location = history.entries[nextIndex];\n\n    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {\n      if (ok) {\n        setState({\n          action: action,\n          location: location,\n          index: nextIndex\n        });\n      } else {\n        // Mimic the behavior of DOM histories by\n        // causing a render after a cancelled POP.\n        setState();\n      }\n    });\n  };\n\n  var goBack = function goBack() {\n    return go(-1);\n  };\n\n  var goForward = function goForward() {\n    return go(1);\n  };\n\n  var canGo = function canGo(n) {\n    var nextIndex = history.index + n;\n    return nextIndex >= 0 && nextIndex < history.entries.length;\n  };\n\n  var block = function block() {\n    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return transitionManager.setPrompt(prompt);\n  };\n\n  var listen = function listen(listener) {\n    return transitionManager.appendListener(listener);\n  };\n\n  var history = {\n    length: entries.length,\n    action: 'POP',\n    location: entries[index],\n    index: index,\n    entries: entries,\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    goBack: goBack,\n    goForward: goForward,\n    canGo: canGo,\n    block: block,\n    listen: listen\n  };\n\n  return history;\n};\n\nexport default createMemoryHistory;","import warning from 'warning';\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    warning(prompt == null, 'A history supports only one prompt at a time');\n\n    prompt = nextPrompt;\n\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          warning(false, 'A history needs a getUserConfirmation function in order to use a prompt message');\n\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(fn) {\n    var isActive = true;\n\n    var listener = function listener() {\n      if (isActive) fn.apply(undefined, arguments);\n    };\n\n    listeners.push(listener);\n\n    return function () {\n      isActive = false;\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\nexport default createTransitionManager;","import _createBrowserHistory from './createBrowserHistory';\nexport { _createBrowserHistory as createBrowserHistory };\nimport _createHashHistory from './createHashHistory';\nexport { _createHashHistory as createHashHistory };\nimport _createMemoryHistory from './createMemoryHistory';\nexport { _createMemoryHistory as createMemoryHistory };\n\nexport { createLocation, locationsAreEqual } from './LocationUtils';\nexport { parsePath, createPath } from './PathUtils';","'use strict';\n\n/**\n * Copyright 2015, Yahoo! Inc.\n * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\nvar REACT_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    getDerivedStateFromProps: true,\n    mixins: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    callee: true,\n    arguments: true,\n    arity: true\n};\n\nvar defineProperty = Object.defineProperty;\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar getPrototypeOf = Object.getPrototypeOf;\nvar objectPrototype = getPrototypeOf && getPrototypeOf(Object);\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n\n        if (objectPrototype) {\n            var inheritedComponent = getPrototypeOf(sourceComponent);\n            if (inheritedComponent && inheritedComponent !== objectPrototype) {\n                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);\n            }\n        }\n\n        var keys = getOwnPropertyNames(sourceComponent);\n\n        if (getOwnPropertySymbols) {\n            keys = keys.concat(getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {\n                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);\n                try { // Avoid failures from read-only properties\n                    defineProperty(targetComponent, key, descriptor);\n                } catch (e) {}\n            }\n        }\n\n        return targetComponent;\n    }\n\n    return targetComponent;\n}\n\nmodule.exports = hoistNonReactStatics;\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n","var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar printWarning = function() {};\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n  var loggedTypeFailures = {};\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (process.env.NODE_ENV !== 'production') {\n    for (var typeSpecName in typeSpecs) {\n      if (typeSpecs.hasOwnProperty(typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          )\n\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = checkPropTypes;\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar assign = require('object-assign');\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\nvar checkPropTypes = require('./checkPropTypes');\n\nvar printWarning = function() {};\n\nif (process.env.NODE_ENV !== 'production') {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message) {\n    this.message = message;\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (process.env.NODE_ENV !== 'production') {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues);\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (propValue.hasOwnProperty(key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n      process.env.NODE_ENV !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {\n          return null;\n        }\n      }\n\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          continue;\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from\n      // props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&\n    Symbol.for &&\n    Symbol.for('react.element')) ||\n    0xeac7;\n\n  var isValidElement = function(object) {\n    return typeof object === 'object' &&\n      object !== null &&\n      object.$$typeof === REACT_ELEMENT_TYPE;\n  };\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n","/** @license React v16.5.2\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar React = require('react');\nvar _assign = require('object-assign');\nvar checkPropTypes = require('prop-types/checkPropTypes');\nvar schedule = require('schedule');\nvar tracing = require('schedule/tracing');\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function () {};\n\n{\n  validateFormat = function (format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error = void 0;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\n// Relying on the `invariant()` implementation lets us\n// preserve the format and params in the www builds.\n\n!React ? invariant(false, 'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.') : void 0;\n\nvar invokeGuardedCallbackImpl = function (name, func, context, a, b, c, d, e, f) {\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n};\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    var invokeGuardedCallbackDev = function (name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebookincubator/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      !(typeof document !== 'undefined') ? invariant(false, 'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.') : void 0;\n      var evt = document.createEvent('Event');\n\n      // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n      var didError = true;\n\n      // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n      var windowEvent = window.event;\n\n      // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n      function callCallback() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false);\n\n        // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {\n          window.event = windowEvent;\n        }\n\n        func.apply(context, funcArgs);\n        didError = false;\n      }\n\n      // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n      var error = void 0;\n      // Use this to track whether the error event is ever called.\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === 'object') {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {\n              // Ignore.\n            }\n          }\n        }\n      }\n\n      // Create a fake event type.\n      var evtType = 'react-' + (name ? name : 'invokeguardedcallback');\n\n      // Attach our event handlers\n      window.addEventListener('error', handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false);\n\n      // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://fb.me/react-crossorigin-error for more information.');\n        }\n        this.onError(error);\n      }\n\n      // Remove our event listeners\n      window.removeEventListener('error', handleWindowError);\n    };\n\n    invokeGuardedCallbackImpl = invokeGuardedCallbackDev;\n  }\n}\n\nvar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n\n// Used by Fiber to simulate a try-catch.\nvar hasError = false;\nvar caughtError = null;\n\n// Used by event system to capture/rethrow the first error.\nvar hasRethrowError = false;\nvar rethrowError = null;\n\nvar reporter = {\n  onError: function (error) {\n    hasError = true;\n    caughtError = error;\n  }\n};\n\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nfunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n}\n\n/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\nfunction invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n  invokeGuardedCallback.apply(this, arguments);\n  if (hasError) {\n    var error = clearCaughtError();\n    if (!hasRethrowError) {\n      hasRethrowError = true;\n      rethrowError = error;\n    }\n  }\n}\n\n/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */\nfunction rethrowCaughtError() {\n  if (hasRethrowError) {\n    var error = rethrowError;\n    hasRethrowError = false;\n    rethrowError = null;\n    throw error;\n  }\n}\n\nfunction hasCaughtError() {\n  return hasError;\n}\n\nfunction clearCaughtError() {\n  if (hasError) {\n    var error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    invariant(false, 'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\n/**\n * Injectable ordering of event plugins.\n */\nvar eventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!eventPluginOrder) {\n    // Wait until an `eventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var pluginModule = namesToPlugins[pluginName];\n    var pluginIndex = eventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : void 0;\n    if (plugins[pluginIndex]) {\n      continue;\n    }\n    !pluginModule.extractEvents ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : void 0;\n    plugins[pluginIndex] = pluginModule;\n    var publishedEvents = pluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : void 0;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, pluginModule, eventName) {\n  !!eventNameDispatchConfigs.hasOwnProperty(eventName) ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : void 0;\n  eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, pluginModule, eventName) {\n  !!registrationNameModules[registrationName] ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : void 0;\n  registrationNameModules[registrationName] = pluginModule;\n  registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;\n\n  {\n    var lowerCasedName = registrationName.toLowerCase();\n    possibleRegistrationNames[lowerCasedName] = registrationName;\n\n    if (registrationName === 'onDoubleClick') {\n      possibleRegistrationNames.ondblclick = registrationName;\n    }\n  }\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\nvar plugins = [];\n\n/**\n * Mapping from event name to dispatch config\n */\nvar eventNameDispatchConfigs = {};\n\n/**\n * Mapping from registration name to plugin module\n */\nvar registrationNameModules = {};\n\n/**\n * Mapping from registration name to event name\n */\nvar registrationNameDependencies = {};\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\nvar possibleRegistrationNames = {};\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\nfunction injectEventPluginOrder(injectedEventPluginOrder) {\n  !!eventPluginOrder ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : void 0;\n  // Clone the ordering so it cannot be dynamically mutated.\n  eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);\n  recomputePluginOrdering();\n}\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\nfunction injectEventPluginsByName(injectedNamesToPlugins) {\n  var isOrderingDirty = false;\n  for (var pluginName in injectedNamesToPlugins) {\n    if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n      continue;\n    }\n    var pluginModule = injectedNamesToPlugins[pluginName];\n    if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {\n      !!namesToPlugins[pluginName] ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : void 0;\n      namesToPlugins[pluginName] = pluginModule;\n      isOrderingDirty = true;\n    }\n  }\n  if (isOrderingDirty) {\n    recomputePluginOrdering();\n  }\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warningWithoutStack = function () {};\n\n{\n  warningWithoutStack = function (condition, format) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (args.length > 8) {\n      // Check before the condition to catch violations early.\n      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n    }\n    if (condition) {\n      return;\n    }\n    if (typeof console !== 'undefined') {\n      var _args$map = args.map(function (item) {\n        return '' + item;\n      }),\n          a = _args$map[0],\n          b = _args$map[1],\n          c = _args$map[2],\n          d = _args$map[3],\n          e = _args$map[4],\n          f = _args$map[5],\n          g = _args$map[6],\n          h = _args$map[7];\n\n      var message = 'Warning: ' + format;\n\n      // We intentionally don't use spread (or .apply) because it breaks IE9:\n      // https://github.com/facebook/react/issues/13610\n      switch (args.length) {\n        case 0:\n          console.error(message);\n          break;\n        case 1:\n          console.error(message, a);\n          break;\n        case 2:\n          console.error(message, a, b);\n          break;\n        case 3:\n          console.error(message, a, b, c);\n          break;\n        case 4:\n          console.error(message, a, b, c, d);\n          break;\n        case 5:\n          console.error(message, a, b, c, d, e);\n          break;\n        case 6:\n          console.error(message, a, b, c, d, e, f);\n          break;\n        case 7:\n          console.error(message, a, b, c, d, e, f, g);\n          break;\n        case 8:\n          console.error(message, a, b, c, d, e, f, g, h);\n          break;\n        default:\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n      }\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var _message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(_message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nfunction setComponentTree(getFiberCurrentPropsFromNodeImpl, getInstanceFromNodeImpl, getNodeFromInstanceImpl) {\n  getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNodeImpl;\n  getInstanceFromNode = getInstanceFromNodeImpl;\n  getNodeFromInstance = getNodeFromInstanceImpl;\n  {\n    !(getNodeFromInstance && getInstanceFromNode) ? warningWithoutStack$1(false, 'EventPluginUtils.setComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;\n  }\n}\n\nvar validateEventDispatches = void 0;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    !(instancesIsArr === listenersIsArr && instancesLen === listenersLen) ? warningWithoutStack$1(false, 'EventPluginUtils: Invalid `event`.') : void 0;\n  };\n}\n\n/**\n * Dispatch the event to the listener.\n * @param {SyntheticEvent} event SyntheticEvent to handle\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @param {function} listener Application-level callback\n * @param {*} inst Internal component instance\n */\nfunction executeDispatch(event, simulated, listener, inst) {\n  var type = event.type || 'unknown-event';\n  event.currentTarget = getNodeFromInstance(inst);\n  invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);\n  event.currentTarget = null;\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\nfunction executeDispatchesInOrder(event, simulated) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);\n    }\n  } else if (dispatchListeners) {\n    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);\n  }\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\n\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\n\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\n/**\n * Internal queue of events that have accumulated their dispatches and are\n * waiting to have their dispatches executed.\n */\nvar eventQueue = null;\n\n/**\n * Dispatches an event and releases it back into the pool, unless persistent.\n *\n * @param {?object} event Synthetic event to be dispatched.\n * @param {boolean} simulated If the event is simulated (changes exn behavior)\n * @private\n */\nvar executeDispatchesAndRelease = function (event, simulated) {\n  if (event) {\n    executeDispatchesInOrder(event, simulated);\n\n    if (!event.isPersistent()) {\n      event.constructor.release(event);\n    }\n  }\n};\nvar executeDispatchesAndReleaseSimulated = function (e) {\n  return executeDispatchesAndRelease(e, true);\n};\nvar executeDispatchesAndReleaseTopLevel = function (e) {\n  return executeDispatchesAndRelease(e, false);\n};\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\nvar injection = {\n  /**\n   * @param {array} InjectedEventPluginOrder\n   * @public\n   */\n  injectEventPluginOrder: injectEventPluginOrder,\n\n  /**\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   */\n  injectEventPluginsByName: injectEventPluginsByName\n};\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener = void 0;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\nfunction extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = null;\n  for (var i = 0; i < plugins.length; i++) {\n    // Not every plugin in the ordering may be loaded at runtime.\n    var possiblePlugin = plugins[i];\n    if (possiblePlugin) {\n      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n      if (extractedEvents) {\n        events = accumulateInto(events, extractedEvents);\n      }\n    }\n  }\n  return events;\n}\n\nfunction runEventsInBatch(events, simulated) {\n  if (events !== null) {\n    eventQueue = accumulateInto(eventQueue, events);\n  }\n\n  // Set `eventQueue` to null before processing it so that we can tell if more\n  // events get enqueued while processing.\n  var processingEventQueue = eventQueue;\n  eventQueue = null;\n\n  if (!processingEventQueue) {\n    return;\n  }\n\n  if (simulated) {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);\n  } else {\n    forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);\n  }\n  !!eventQueue ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : void 0;\n  // This would be a good time to rethrow if any of the event handlers threw.\n  rethrowCaughtError();\n}\n\nfunction runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n  runEventsInBatch(events, false);\n}\n\nvar FunctionalComponent = 0;\nvar FunctionalComponentLazy = 1;\nvar ClassComponent = 2;\nvar ClassComponentLazy = 3;\nvar IndeterminateComponent = 4; // Before we know whether it is functional or class\nvar HostRoot = 5; // Root of a host tree. Could be nested inside another node.\nvar HostPortal = 6; // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 7;\nvar HostText = 8;\nvar Fragment = 9;\nvar Mode = 10;\nvar ContextConsumer = 11;\nvar ContextProvider = 12;\nvar ForwardRef = 13;\nvar ForwardRefLazy = 14;\nvar Profiler = 15;\nvar PlaceholderComponent = 16;\n\nvar randomKey = Math.random().toString(36).slice(2);\nvar internalInstanceKey = '__reactInternalInstance$' + randomKey;\nvar internalEventHandlersKey = '__reactEventHandlers$' + randomKey;\n\nfunction precacheFiberNode(hostInst, node) {\n  node[internalInstanceKey] = hostInst;\n}\n\n/**\n * Given a DOM node, return the closest ReactDOMComponent or\n * ReactDOMTextComponent instance ancestor.\n */\nfunction getClosestInstanceFromNode(node) {\n  if (node[internalInstanceKey]) {\n    return node[internalInstanceKey];\n  }\n\n  while (!node[internalInstanceKey]) {\n    if (node.parentNode) {\n      node = node.parentNode;\n    } else {\n      // Top of the tree. This node must not be part of a React tree (or is\n      // unmounted, potentially).\n      return null;\n    }\n  }\n\n  var inst = node[internalInstanceKey];\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber, this will always be the deepest root.\n    return inst;\n  }\n\n  return null;\n}\n\n/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */\nfunction getInstanceFromNode$1(node) {\n  var inst = node[internalInstanceKey];\n  if (inst) {\n    if (inst.tag === HostComponent || inst.tag === HostText) {\n      return inst;\n    } else {\n      return null;\n    }\n  }\n  return null;\n}\n\n/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */\nfunction getNodeFromInstance$1(inst) {\n  if (inst.tag === HostComponent || inst.tag === HostText) {\n    // In Fiber this, is just the state node right now. We assume it will be\n    // a host component or host text.\n    return inst.stateNode;\n  }\n\n  // Without this first invariant, passing a non-DOM-component triggers the next\n  // invariant for a missing parent, which is super confusing.\n  invariant(false, 'getNodeFromInstance: Invalid argument.');\n}\n\nfunction getFiberCurrentPropsFromNode$1(node) {\n  return node[internalEventHandlersKey] || null;\n}\n\nfunction updateFiberProps(node, props) {\n  node[internalEventHandlersKey] = props;\n}\n\nfunction getParent(inst) {\n  do {\n    inst = inst.return;\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\n\n\n/**\n * Return the parent instance of the passed-in instance.\n */\n\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i = void 0;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\nfunction traverseEnterLeave(from, to, fn, argFrom, argTo) {\n  var common = from && to ? getLowestCommonAncestor(from, to) : null;\n  var pathFrom = [];\n  while (true) {\n    if (!from) {\n      break;\n    }\n    if (from === common) {\n      break;\n    }\n    var alternate = from.alternate;\n    if (alternate !== null && alternate === common) {\n      break;\n    }\n    pathFrom.push(from);\n    from = getParent(from);\n  }\n  var pathTo = [];\n  while (true) {\n    if (!to) {\n      break;\n    }\n    if (to === common) {\n      break;\n    }\n    var _alternate = to.alternate;\n    if (_alternate !== null && _alternate === common) {\n      break;\n    }\n    pathTo.push(to);\n    to = getParent(to);\n  }\n  for (var i = 0; i < pathFrom.length; i++) {\n    fn(pathFrom[i], 'bubbled', argFrom);\n  }\n  for (var _i = pathTo.length; _i-- > 0;) {\n    fn(pathTo[_i], 'captured', argTo);\n  }\n}\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    !inst ? warningWithoutStack$1(false, 'Dispatching inst must not be null') : void 0;\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\n\n\nfunction accumulateEnterLeaveDispatches(leave, enter, from, to) {\n  traverseEnterLeave(from, to, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n// Do not uses the below two methods directly!\n// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.\n// (It is the only module that is allowed to access these methods.)\n\nfunction unsafeCastStringToDOMTopLevelType(topLevelType) {\n  return topLevelType;\n}\n\nfunction unsafeCastDOMTopLevelTypeToString(topLevelType) {\n  return topLevelType;\n}\n\n/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes['Webkit' + styleProp] = 'webkit' + eventName;\n  prefixes['Moz' + styleProp] = 'moz' + eventName;\n\n  return prefixes;\n}\n\n/**\n * A list of event names to a configurable list of vendor prefixes.\n */\nvar vendorPrefixes = {\n  animationend: makePrefixMap('Animation', 'AnimationEnd'),\n  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),\n  animationstart: makePrefixMap('Animation', 'AnimationStart'),\n  transitionend: makePrefixMap('Transition', 'TransitionEnd')\n};\n\n/**\n * Event names that have already been detected and prefixed (if applicable).\n */\nvar prefixedEventNames = {};\n\n/**\n * Element to check for prefixes on.\n */\nvar style = {};\n\n/**\n * Bootstrap if a DOM exists.\n */\nif (canUseDOM) {\n  style = document.createElement('div').style;\n\n  // On some platforms, in particular some releases of Android 4.x,\n  // the un-prefixed \"animation\" and \"transition\" properties are defined on the\n  // style object but the events that fire will still be prefixed, so we need\n  // to check if the un-prefixed events are usable, and if not remove them from the map.\n  if (!('AnimationEvent' in window)) {\n    delete vendorPrefixes.animationend.animation;\n    delete vendorPrefixes.animationiteration.animation;\n    delete vendorPrefixes.animationstart.animation;\n  }\n\n  // Same as above\n  if (!('TransitionEvent' in window)) {\n    delete vendorPrefixes.transitionend.transition;\n  }\n}\n\n/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) {\n    return prefixedEventNames[eventName];\n  } else if (!vendorPrefixes[eventName]) {\n    return eventName;\n  }\n\n  var prefixMap = vendorPrefixes[eventName];\n\n  for (var styleProp in prefixMap) {\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n      return prefixedEventNames[eventName] = prefixMap[styleProp];\n    }\n  }\n\n  return eventName;\n}\n\n/**\n * To identify top level events in ReactDOM, we use constants defined by this\n * module. This is the only module that uses the unsafe* methods to express\n * that the constants actually correspond to the browser event names. This lets\n * us save some bundle size by avoiding a top level type -> event name map.\n * The rest of ReactDOM code should import top level types from this file.\n */\nvar TOP_ABORT = unsafeCastStringToDOMTopLevelType('abort');\nvar TOP_ANIMATION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));\nvar TOP_ANIMATION_ITERATION = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));\nvar TOP_ANIMATION_START = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));\nvar TOP_BLUR = unsafeCastStringToDOMTopLevelType('blur');\nvar TOP_CAN_PLAY = unsafeCastStringToDOMTopLevelType('canplay');\nvar TOP_CAN_PLAY_THROUGH = unsafeCastStringToDOMTopLevelType('canplaythrough');\nvar TOP_CANCEL = unsafeCastStringToDOMTopLevelType('cancel');\nvar TOP_CHANGE = unsafeCastStringToDOMTopLevelType('change');\nvar TOP_CLICK = unsafeCastStringToDOMTopLevelType('click');\nvar TOP_CLOSE = unsafeCastStringToDOMTopLevelType('close');\nvar TOP_COMPOSITION_END = unsafeCastStringToDOMTopLevelType('compositionend');\nvar TOP_COMPOSITION_START = unsafeCastStringToDOMTopLevelType('compositionstart');\nvar TOP_COMPOSITION_UPDATE = unsafeCastStringToDOMTopLevelType('compositionupdate');\nvar TOP_CONTEXT_MENU = unsafeCastStringToDOMTopLevelType('contextmenu');\nvar TOP_COPY = unsafeCastStringToDOMTopLevelType('copy');\nvar TOP_CUT = unsafeCastStringToDOMTopLevelType('cut');\nvar TOP_DOUBLE_CLICK = unsafeCastStringToDOMTopLevelType('dblclick');\nvar TOP_AUX_CLICK = unsafeCastStringToDOMTopLevelType('auxclick');\nvar TOP_DRAG = unsafeCastStringToDOMTopLevelType('drag');\nvar TOP_DRAG_END = unsafeCastStringToDOMTopLevelType('dragend');\nvar TOP_DRAG_ENTER = unsafeCastStringToDOMTopLevelType('dragenter');\nvar TOP_DRAG_EXIT = unsafeCastStringToDOMTopLevelType('dragexit');\nvar TOP_DRAG_LEAVE = unsafeCastStringToDOMTopLevelType('dragleave');\nvar TOP_DRAG_OVER = unsafeCastStringToDOMTopLevelType('dragover');\nvar TOP_DRAG_START = unsafeCastStringToDOMTopLevelType('dragstart');\nvar TOP_DROP = unsafeCastStringToDOMTopLevelType('drop');\nvar TOP_DURATION_CHANGE = unsafeCastStringToDOMTopLevelType('durationchange');\nvar TOP_EMPTIED = unsafeCastStringToDOMTopLevelType('emptied');\nvar TOP_ENCRYPTED = unsafeCastStringToDOMTopLevelType('encrypted');\nvar TOP_ENDED = unsafeCastStringToDOMTopLevelType('ended');\nvar TOP_ERROR = unsafeCastStringToDOMTopLevelType('error');\nvar TOP_FOCUS = unsafeCastStringToDOMTopLevelType('focus');\nvar TOP_GOT_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('gotpointercapture');\nvar TOP_INPUT = unsafeCastStringToDOMTopLevelType('input');\nvar TOP_INVALID = unsafeCastStringToDOMTopLevelType('invalid');\nvar TOP_KEY_DOWN = unsafeCastStringToDOMTopLevelType('keydown');\nvar TOP_KEY_PRESS = unsafeCastStringToDOMTopLevelType('keypress');\nvar TOP_KEY_UP = unsafeCastStringToDOMTopLevelType('keyup');\nvar TOP_LOAD = unsafeCastStringToDOMTopLevelType('load');\nvar TOP_LOAD_START = unsafeCastStringToDOMTopLevelType('loadstart');\nvar TOP_LOADED_DATA = unsafeCastStringToDOMTopLevelType('loadeddata');\nvar TOP_LOADED_METADATA = unsafeCastStringToDOMTopLevelType('loadedmetadata');\nvar TOP_LOST_POINTER_CAPTURE = unsafeCastStringToDOMTopLevelType('lostpointercapture');\nvar TOP_MOUSE_DOWN = unsafeCastStringToDOMTopLevelType('mousedown');\nvar TOP_MOUSE_MOVE = unsafeCastStringToDOMTopLevelType('mousemove');\nvar TOP_MOUSE_OUT = unsafeCastStringToDOMTopLevelType('mouseout');\nvar TOP_MOUSE_OVER = unsafeCastStringToDOMTopLevelType('mouseover');\nvar TOP_MOUSE_UP = unsafeCastStringToDOMTopLevelType('mouseup');\nvar TOP_PASTE = unsafeCastStringToDOMTopLevelType('paste');\nvar TOP_PAUSE = unsafeCastStringToDOMTopLevelType('pause');\nvar TOP_PLAY = unsafeCastStringToDOMTopLevelType('play');\nvar TOP_PLAYING = unsafeCastStringToDOMTopLevelType('playing');\nvar TOP_POINTER_CANCEL = unsafeCastStringToDOMTopLevelType('pointercancel');\nvar TOP_POINTER_DOWN = unsafeCastStringToDOMTopLevelType('pointerdown');\n\n\nvar TOP_POINTER_MOVE = unsafeCastStringToDOMTopLevelType('pointermove');\nvar TOP_POINTER_OUT = unsafeCastStringToDOMTopLevelType('pointerout');\nvar TOP_POINTER_OVER = unsafeCastStringToDOMTopLevelType('pointerover');\nvar TOP_POINTER_UP = unsafeCastStringToDOMTopLevelType('pointerup');\nvar TOP_PROGRESS = unsafeCastStringToDOMTopLevelType('progress');\nvar TOP_RATE_CHANGE = unsafeCastStringToDOMTopLevelType('ratechange');\nvar TOP_RESET = unsafeCastStringToDOMTopLevelType('reset');\nvar TOP_SCROLL = unsafeCastStringToDOMTopLevelType('scroll');\nvar TOP_SEEKED = unsafeCastStringToDOMTopLevelType('seeked');\nvar TOP_SEEKING = unsafeCastStringToDOMTopLevelType('seeking');\nvar TOP_SELECTION_CHANGE = unsafeCastStringToDOMTopLevelType('selectionchange');\nvar TOP_STALLED = unsafeCastStringToDOMTopLevelType('stalled');\nvar TOP_SUBMIT = unsafeCastStringToDOMTopLevelType('submit');\nvar TOP_SUSPEND = unsafeCastStringToDOMTopLevelType('suspend');\nvar TOP_TEXT_INPUT = unsafeCastStringToDOMTopLevelType('textInput');\nvar TOP_TIME_UPDATE = unsafeCastStringToDOMTopLevelType('timeupdate');\nvar TOP_TOGGLE = unsafeCastStringToDOMTopLevelType('toggle');\nvar TOP_TOUCH_CANCEL = unsafeCastStringToDOMTopLevelType('touchcancel');\nvar TOP_TOUCH_END = unsafeCastStringToDOMTopLevelType('touchend');\nvar TOP_TOUCH_MOVE = unsafeCastStringToDOMTopLevelType('touchmove');\nvar TOP_TOUCH_START = unsafeCastStringToDOMTopLevelType('touchstart');\nvar TOP_TRANSITION_END = unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));\nvar TOP_VOLUME_CHANGE = unsafeCastStringToDOMTopLevelType('volumechange');\nvar TOP_WAITING = unsafeCastStringToDOMTopLevelType('waiting');\nvar TOP_WHEEL = unsafeCastStringToDOMTopLevelType('wheel');\n\n// List of events that need to be individually attached to media elements.\n// Note that events in this list will *not* be listened to at the top level\n// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.\nvar mediaEventTypes = [TOP_ABORT, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_VOLUME_CHANGE, TOP_WAITING];\n\nfunction getRawEventName(topLevelType) {\n  return unsafeCastDOMTopLevelTypeToString(topLevelType);\n}\n\n/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */\n\nvar root = null;\nvar startText = null;\nvar fallbackText = null;\n\nfunction initialize(nativeEventTarget) {\n  root = nativeEventTarget;\n  startText = getText();\n  return true;\n}\n\nfunction reset() {\n  root = null;\n  startText = null;\n  fallbackText = null;\n}\n\nfunction getData() {\n  if (fallbackText) {\n    return fallbackText;\n  }\n\n  var start = void 0;\n  var startValue = startText;\n  var startLength = startValue.length;\n  var end = void 0;\n  var endValue = getText();\n  var endLength = endValue.length;\n\n  for (start = 0; start < startLength; start++) {\n    if (startValue[start] !== endValue[start]) {\n      break;\n    }\n  }\n\n  var minEnd = startLength - start;\n  for (end = 1; end <= minEnd; end++) {\n    if (startValue[startLength - end] !== endValue[endLength - end]) {\n      break;\n    }\n  }\n\n  var sliceTail = end > 1 ? 1 - end : undefined;\n  fallbackText = endValue.slice(start, sliceTail);\n  return fallbackText;\n}\n\nfunction getText() {\n  if ('value' in root) {\n    return root.value;\n  }\n  return root.textContent;\n}\n\n/* eslint valid-typeof: 0 */\n\nvar EVENT_POOL_SIZE = 10;\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: function () {\n    return null;\n  },\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\nfunction functionThatReturnsTrue() {\n  return true;\n}\n\nfunction functionThatReturnsFalse() {\n  return false;\n}\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n    delete this.isDefaultPrevented;\n    delete this.isPropagationStopped;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = functionThatReturnsFalse;\n  }\n  this.isPropagationStopped = functionThatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = functionThatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = functionThatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = functionThatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: functionThatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    this.dispatchConfig = null;\n    this._targetInst = null;\n    this.nativeEvent = null;\n    this.isDefaultPrevented = functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    this._dispatchListeners = null;\n    this._dispatchInstances = null;\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'isDefaultPrevented', getPooledWarningPropertyDefinition('isDefaultPrevented', functionThatReturnsFalse));\n      Object.defineProperty(this, 'isPropagationStopped', getPooledWarningPropertyDefinition('isPropagationStopped', functionThatReturnsFalse));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', function () {}));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', function () {}));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n */\nSyntheticEvent.extend = function (Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  function Class() {\n    return Super.apply(this, arguments);\n  }\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.extend = Super.extend;\n  addEventPoolingTo(Class);\n\n  return Class;\n};\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    !warningCondition ? warningWithoutStack$1(false, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */\nvar SyntheticCompositionEvent = SyntheticEvent.extend({\n  data: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */\nvar SyntheticInputEvent = SyntheticEvent.extend({\n  data: null\n});\n\nvar END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space\nvar START_KEYCODE = 229;\n\nvar canUseCompositionEvent = canUseDOM && 'CompositionEvent' in window;\n\nvar documentMode = null;\nif (canUseDOM && 'documentMode' in document) {\n  documentMode = document.documentMode;\n}\n\n// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent = canUseDOM && 'TextEvent' in window && !documentMode;\n\n// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n\nvar SPACEBAR_CODE = 32;\nvar SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n\n// Events and their corresponding property names.\nvar eventTypes = {\n  beforeInput: {\n    phasedRegistrationNames: {\n      bubbled: 'onBeforeInput',\n      captured: 'onBeforeInputCapture'\n    },\n    dependencies: [TOP_COMPOSITION_END, TOP_KEY_PRESS, TOP_TEXT_INPUT, TOP_PASTE]\n  },\n  compositionEnd: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionEnd',\n      captured: 'onCompositionEndCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_END, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  },\n  compositionStart: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionStart',\n      captured: 'onCompositionStartCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_START, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  },\n  compositionUpdate: {\n    phasedRegistrationNames: {\n      bubbled: 'onCompositionUpdate',\n      captured: 'onCompositionUpdateCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_COMPOSITION_UPDATE, TOP_KEY_DOWN, TOP_KEY_PRESS, TOP_KEY_UP, TOP_MOUSE_DOWN]\n  }\n};\n\n// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress = false;\n\n/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */\nfunction isKeypressCommand(nativeEvent) {\n  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&\n  // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n  !(nativeEvent.ctrlKey && nativeEvent.altKey);\n}\n\n/**\n * Translate native top level events into event types.\n *\n * @param {string} topLevelType\n * @return {object}\n */\nfunction getCompositionEventType(topLevelType) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_START:\n      return eventTypes.compositionStart;\n    case TOP_COMPOSITION_END:\n      return eventTypes.compositionEnd;\n    case TOP_COMPOSITION_UPDATE:\n      return eventTypes.compositionUpdate;\n  }\n}\n\n/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionStart(topLevelType, nativeEvent) {\n  return topLevelType === TOP_KEY_DOWN && nativeEvent.keyCode === START_KEYCODE;\n}\n\n/**\n * Does our fallback mode think that this event is the end of composition?\n *\n * @param {string} topLevelType\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isFallbackCompositionEnd(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_KEY_UP:\n      // Command keys insert or clear IME input.\n      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n    case TOP_KEY_DOWN:\n      // Expect IME keyCode on each keydown. If we get any other\n      // code we must have exited earlier.\n      return nativeEvent.keyCode !== START_KEYCODE;\n    case TOP_KEY_PRESS:\n    case TOP_MOUSE_DOWN:\n    case TOP_BLUR:\n      // Events are not possible without cancelling IME.\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */\nfunction getDataFromCustomEvent(nativeEvent) {\n  var detail = nativeEvent.detail;\n  if (typeof detail === 'object' && 'data' in detail) {\n    return detail.data;\n  }\n  return null;\n}\n\n/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */\nfunction isUsingKoreanIME(nativeEvent) {\n  return nativeEvent.locale === 'ko';\n}\n\n// Track the current IME composition status, if any.\nvar isComposing = false;\n\n/**\n * @return {?object} A SyntheticCompositionEvent.\n */\nfunction extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var eventType = void 0;\n  var fallbackData = void 0;\n\n  if (canUseCompositionEvent) {\n    eventType = getCompositionEventType(topLevelType);\n  } else if (!isComposing) {\n    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {\n      eventType = eventTypes.compositionStart;\n    }\n  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n    eventType = eventTypes.compositionEnd;\n  }\n\n  if (!eventType) {\n    return null;\n  }\n\n  if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n    // The current composition is stored statically and must not be\n    // overwritten while composition continues.\n    if (!isComposing && eventType === eventTypes.compositionStart) {\n      isComposing = initialize(nativeEventTarget);\n    } else if (eventType === eventTypes.compositionEnd) {\n      if (isComposing) {\n        fallbackData = getData();\n      }\n    }\n  }\n\n  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);\n\n  if (fallbackData) {\n    // Inject data generated from fallback path into the synthetic event.\n    // This matches the property of native CompositionEventInterface.\n    event.data = fallbackData;\n  } else {\n    var customData = getDataFromCustomEvent(nativeEvent);\n    if (customData !== null) {\n      event.data = customData;\n    }\n  }\n\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * @param {TopLevelType} topLevelType Number from `TopLevelType`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The string corresponding to this `beforeInput` event.\n */\nfunction getNativeBeforeInputChars(topLevelType, nativeEvent) {\n  switch (topLevelType) {\n    case TOP_COMPOSITION_END:\n      return getDataFromCustomEvent(nativeEvent);\n    case TOP_KEY_PRESS:\n      /**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */\n      var which = nativeEvent.which;\n      if (which !== SPACEBAR_CODE) {\n        return null;\n      }\n\n      hasSpaceKeypress = true;\n      return SPACEBAR_CHAR;\n\n    case TOP_TEXT_INPUT:\n      // Record the characters to be added to the DOM.\n      var chars = nativeEvent.data;\n\n      // If it's a spacebar character, assume that we have already handled\n      // it at the keypress level and bail immediately. Android Chrome\n      // doesn't give us keycodes, so we need to ignore it.\n      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n        return null;\n      }\n\n      return chars;\n\n    default:\n      // For other native event types, do nothing.\n      return null;\n  }\n}\n\n/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} nativeEvent Native browser event.\n * @return {?string} The fallback string for this `beforeInput` event.\n */\nfunction getFallbackBeforeInputChars(topLevelType, nativeEvent) {\n  // If we are currently composing (IME) and using a fallback to do so,\n  // try to extract the composed characters from the fallback object.\n  // If composition event is available, we extract a string only at\n  // compositionevent, otherwise extract it at fallback events.\n  if (isComposing) {\n    if (topLevelType === TOP_COMPOSITION_END || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {\n      var chars = getData();\n      reset();\n      isComposing = false;\n      return chars;\n    }\n    return null;\n  }\n\n  switch (topLevelType) {\n    case TOP_PASTE:\n      // If a paste event occurs after a keypress, throw out the input\n      // chars. Paste events should not lead to BeforeInput events.\n      return null;\n    case TOP_KEY_PRESS:\n      /**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */\n      if (!isKeypressCommand(nativeEvent)) {\n        // IE fires the `keypress` event when a user types an emoji via\n        // Touch keyboard of Windows.  In such a case, the `char` property\n        // holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n        // is 2, the property `which` does not represent an emoji correctly.\n        // In such a case, we directly return the `char` property instead of\n        // using `which`.\n        if (nativeEvent.char && nativeEvent.char.length > 1) {\n          return nativeEvent.char;\n        } else if (nativeEvent.which) {\n          return String.fromCharCode(nativeEvent.which);\n        }\n      }\n      return null;\n    case TOP_COMPOSITION_END:\n      return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n    default:\n      return null;\n  }\n}\n\n/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */\nfunction extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var chars = void 0;\n\n  if (canUseTextInputEvent) {\n    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);\n  } else {\n    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);\n  }\n\n  // If no characters are being inserted, no BeforeInput event should\n  // be fired.\n  if (!chars) {\n    return null;\n  }\n\n  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);\n\n  event.data = chars;\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n\n/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */\nvar BeforeInputEventPlugin = {\n  eventTypes: eventTypes,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var composition = extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    var beforeInput = extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget);\n\n    if (composition === null) {\n      return beforeInput;\n    }\n\n    if (beforeInput === null) {\n      return composition;\n    }\n\n    return [composition, beforeInput];\n  }\n};\n\n// Use to restore controlled state after a change event has fired.\n\nvar restoreImpl = null;\nvar restoreTarget = null;\nvar restoreQueue = null;\n\nfunction restoreStateOfTarget(target) {\n  // We perform this translation at the end of the event loop so that we\n  // always receive the correct fiber here\n  var internalInstance = getInstanceFromNode(target);\n  if (!internalInstance) {\n    // Unmounted\n    return;\n  }\n  !(typeof restoreImpl === 'function') ? invariant(false, 'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var props = getFiberCurrentPropsFromNode(internalInstance.stateNode);\n  restoreImpl(internalInstance.stateNode, internalInstance.type, props);\n}\n\nfunction setRestoreImplementation(impl) {\n  restoreImpl = impl;\n}\n\nfunction enqueueStateRestore(target) {\n  if (restoreTarget) {\n    if (restoreQueue) {\n      restoreQueue.push(target);\n    } else {\n      restoreQueue = [target];\n    }\n  } else {\n    restoreTarget = target;\n  }\n}\n\nfunction needsStateRestore() {\n  return restoreTarget !== null || restoreQueue !== null;\n}\n\nfunction restoreStateIfNeeded() {\n  if (!restoreTarget) {\n    return;\n  }\n  var target = restoreTarget;\n  var queuedTargets = restoreQueue;\n  restoreTarget = null;\n  restoreQueue = null;\n\n  restoreStateOfTarget(target);\n  if (queuedTargets) {\n    for (var i = 0; i < queuedTargets.length; i++) {\n      restoreStateOfTarget(queuedTargets[i]);\n    }\n  }\n}\n\n// Used as a way to call batchedUpdates when we don't have a reference to\n// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n\n// Defaults\nvar _batchedUpdatesImpl = function (fn, bookkeeping) {\n  return fn(bookkeeping);\n};\nvar _interactiveUpdatesImpl = function (fn, a, b) {\n  return fn(a, b);\n};\nvar _flushInteractiveUpdatesImpl = function () {};\n\nvar isBatching = false;\nfunction batchedUpdates(fn, bookkeeping) {\n  if (isBatching) {\n    // If we are currently inside another batch, we need to wait until it\n    // fully completes before restoring state.\n    return fn(bookkeeping);\n  }\n  isBatching = true;\n  try {\n    return _batchedUpdatesImpl(fn, bookkeeping);\n  } finally {\n    // Here we wait until all updates have propagated, which is important\n    // when using controlled components within layers:\n    // https://github.com/facebook/react/issues/1698\n    // Then we restore state of any controlled component.\n    isBatching = false;\n    var controlledComponentsHavePendingUpdates = needsStateRestore();\n    if (controlledComponentsHavePendingUpdates) {\n      // If a controlled event was fired, we may need to restore the state of\n      // the DOM node back to the controlled value. This is necessary when React\n      // bails out of the update without touching the DOM.\n      _flushInteractiveUpdatesImpl();\n      restoreStateIfNeeded();\n    }\n  }\n}\n\nfunction interactiveUpdates(fn, a, b) {\n  return _interactiveUpdatesImpl(fn, a, b);\n}\n\n\n\nfunction setBatchingImplementation(batchedUpdatesImpl, interactiveUpdatesImpl, flushInteractiveUpdatesImpl) {\n  _batchedUpdatesImpl = batchedUpdatesImpl;\n  _interactiveUpdatesImpl = interactiveUpdatesImpl;\n  _flushInteractiveUpdatesImpl = flushInteractiveUpdatesImpl;\n}\n\n/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */\nvar supportedInputTypes = {\n  color: true,\n  date: true,\n  datetime: true,\n  'datetime-local': true,\n  email: true,\n  month: true,\n  number: true,\n  password: true,\n  range: true,\n  search: true,\n  tel: true,\n  text: true,\n  time: true,\n  url: true,\n  week: true\n};\n\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n\n  if (nodeName === 'input') {\n    return !!supportedInputTypes[elem.type];\n  }\n\n  if (nodeName === 'textarea') {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * HTML nodeType values that represent the type of the node\n */\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\n\n/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */\nfunction getEventTarget(nativeEvent) {\n  // Fallback to nativeEvent.srcElement for IE9\n  // https://github.com/facebook/react/issues/12506\n  var target = nativeEvent.target || nativeEvent.srcElement || window;\n\n  // Normalize SVG <use> element events #4963\n  if (target.correspondingUseElement) {\n    target = target.correspondingUseElement;\n  }\n\n  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n  // @see http://www.quirksmode.org/js/events_properties.html\n  return target.nodeType === TEXT_NODE ? target.parentNode : target;\n}\n\n/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */\nfunction isEventSupported(eventNameSuffix) {\n  if (!canUseDOM) {\n    return false;\n  }\n\n  var eventName = 'on' + eventNameSuffix;\n  var isSupported = eventName in document;\n\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n\n  return isSupported;\n}\n\nfunction isCheckable(elem) {\n  var type = elem.type;\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');\n}\n\nfunction getTracker(node) {\n  return node._valueTracker;\n}\n\nfunction detachTracker(node) {\n  node._valueTracker = null;\n}\n\nfunction getValueFromNode(node) {\n  var value = '';\n  if (!node) {\n    return value;\n  }\n\n  if (isCheckable(node)) {\n    value = node.checked ? 'true' : 'false';\n  } else {\n    value = node.value;\n  }\n\n  return value;\n}\n\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? 'checked' : 'value';\n  var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n\n  var currentValue = '' + node[valueField];\n\n  // if someone has already defined a value or Safari, then bail\n  // and don't track value will cause over reporting of changes,\n  // but it's better then a hard failure\n  // (needed for certain tests that spyOn input values and Safari)\n  if (node.hasOwnProperty(valueField) || typeof descriptor === 'undefined' || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {\n    return;\n  }\n  var get = descriptor.get,\n      set = descriptor.set;\n\n  Object.defineProperty(node, valueField, {\n    configurable: true,\n    get: function () {\n      return get.call(this);\n    },\n    set: function (value) {\n      currentValue = '' + value;\n      set.call(this, value);\n    }\n  });\n  // We could've passed this the first time\n  // but it triggers a bug in IE11 and Edge 14/15.\n  // Calling defineProperty() again should be equivalent.\n  // https://github.com/facebook/react/issues/11768\n  Object.defineProperty(node, valueField, {\n    enumerable: descriptor.enumerable\n  });\n\n  var tracker = {\n    getValue: function () {\n      return currentValue;\n    },\n    setValue: function (value) {\n      currentValue = '' + value;\n    },\n    stopTracking: function () {\n      detachTracker(node);\n      delete node[valueField];\n    }\n  };\n  return tracker;\n}\n\nfunction track(node) {\n  if (getTracker(node)) {\n    return;\n  }\n\n  // TODO: Once it's just Fiber we can move this to node._wrapperState\n  node._valueTracker = trackValueOnNode(node);\n}\n\nfunction updateValueIfChanged(node) {\n  if (!node) {\n    return false;\n  }\n\n  var tracker = getTracker(node);\n  // if there is no tracker at this point it's unlikely\n  // that trying again will succeed\n  if (!tracker) {\n    return true;\n  }\n\n  var lastValue = tracker.getValue();\n  var nextValue = getValueFromNode(node);\n  if (nextValue !== lastValue) {\n    tracker.setValue(nextValue);\n    return true;\n  }\n  return false;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  var sourceInfo = '';\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, '');\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n        if (match) {\n          var pathBeforeSlash = match[1];\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n};\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for('react.placeholder') : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction getResultFromResolvedThenable(thenable) {\n  return thenable._reactResult;\n}\n\nfunction refineResolvedThenable(thenable) {\n  return thenable._reactStatus === Resolved ? thenable._reactResult : null;\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  {\n    if (typeof type.tag === 'number') {\n      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return 'AsyncMode';\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_PLACEHOLDER_TYPE:\n      return 'Placeholder';\n  }\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return 'Context.Consumer';\n      case REACT_PROVIDER_TYPE:\n        return 'Context.Provider';\n      case REACT_FORWARD_REF_TYPE:\n        var renderFn = type.render;\n        var functionName = renderFn.displayName || renderFn.name || '';\n        return type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');\n    }\n    if (typeof type.then === 'function') {\n      var thenable = type;\n      var resolvedThenable = refineResolvedThenable(thenable);\n      if (resolvedThenable) {\n        return getComponentName(resolvedThenable);\n      }\n    }\n  }\n  return null;\n}\n\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case IndeterminateComponent:\n    case FunctionalComponent:\n    case FunctionalComponentLazy:\n    case ClassComponent:\n    case ClassComponentLazy:\n    case HostComponent:\n    case Mode:\n      var owner = fiber._debugOwner;\n      var source = fiber._debugSource;\n      var name = getComponentName(fiber.type);\n      var ownerName = null;\n      if (owner) {\n        ownerName = getComponentName(owner.type);\n      }\n      return describeComponentFrame(name, source, ownerName);\n    default:\n      return '';\n  }\n}\n\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  var info = '';\n  var node = workInProgress;\n  do {\n    info += describeFiber(node);\n    node = node.return;\n  } while (node);\n  return info;\n}\n\nvar current = null;\nvar phase = null;\n\nfunction getCurrentFiberOwnerNameInDevOrNull() {\n  {\n    if (current === null) {\n      return null;\n    }\n    var owner = current._debugOwner;\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentName(owner.type);\n    }\n  }\n  return null;\n}\n\nfunction getCurrentFiberStackInDev() {\n  {\n    if (current === null) {\n      return '';\n    }\n    // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n    return getStackByFiberInDevAndProd(current);\n  }\n  return '';\n}\n\nfunction resetCurrentFiber() {\n  {\n    ReactDebugCurrentFrame.getCurrentStack = null;\n    current = null;\n    phase = null;\n  }\n}\n\nfunction setCurrentFiber(fiber) {\n  {\n    ReactDebugCurrentFrame.getCurrentStack = getCurrentFiberStackInDev;\n    current = fiber;\n    phase = null;\n  }\n}\n\nfunction setCurrentPhase(lifeCyclePhase) {\n  {\n    phase = lifeCyclePhase;\n  }\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = warningWithoutStack$1;\n\n{\n  warning = function (condition, format) {\n    if (condition) {\n      return;\n    }\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n    // eslint-disable-next-line react-internal/warning-and-invariant-args\n\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));\n  };\n}\n\nvar warning$1 = warning;\n\n// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED = 0;\n\n// A simple string attribute.\n// Attributes that aren't in the whitelist are presumed to have this type.\nvar STRING = 1;\n\n// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING = 2;\n\n// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN = 3;\n\n// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN = 4;\n\n// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC = 5;\n\n// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC = 6;\n\n/* eslint-disable max-len */\nvar ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\n/* eslint-enable max-len */\nvar ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + '\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\n\n\nvar ROOT_ATTRIBUTE_NAME = 'data-reactroot';\nvar VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + ATTRIBUTE_NAME_START_CHAR + '][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar illegalAttributeNameCache = {};\nvar validatedAttributeNameCache = {};\n\nfunction isAttributeNameSafe(attributeName) {\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n    return true;\n  }\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n    return false;\n  }\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n    validatedAttributeNameCache[attributeName] = true;\n    return true;\n  }\n  illegalAttributeNameCache[attributeName] = true;\n  {\n    warning$1(false, 'Invalid attribute name: `%s`', attributeName);\n  }\n  return false;\n}\n\nfunction shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null) {\n    return propertyInfo.type === RESERVED;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (name.length > 2 && (name[0] === 'o' || name[0] === 'O') && (name[1] === 'n' || name[1] === 'N')) {\n    return true;\n  }\n  return false;\n}\n\nfunction shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n  if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n    return false;\n  }\n  switch (typeof value) {\n    case 'function':\n    // $FlowIssue symbol is perfectly valid here\n    case 'symbol':\n      // eslint-disable-line\n      return true;\n    case 'boolean':\n      {\n        if (isCustomComponentTag) {\n          return false;\n        }\n        if (propertyInfo !== null) {\n          return !propertyInfo.acceptsBooleans;\n        } else {\n          var prefix = name.toLowerCase().slice(0, 5);\n          return prefix !== 'data-' && prefix !== 'aria-';\n        }\n      }\n    default:\n      return false;\n  }\n}\n\nfunction shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\n  if (value === null || typeof value === 'undefined') {\n    return true;\n  }\n  if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\n    return true;\n  }\n  if (isCustomComponentTag) {\n    return false;\n  }\n  if (propertyInfo !== null) {\n    switch (propertyInfo.type) {\n      case BOOLEAN:\n        return !value;\n      case OVERLOADED_BOOLEAN:\n        return value === false;\n      case NUMERIC:\n        return isNaN(value);\n      case POSITIVE_NUMERIC:\n        return isNaN(value) || value < 1;\n    }\n  }\n  return false;\n}\n\nfunction getPropertyInfo(name) {\n  return properties.hasOwnProperty(name) ? properties[name] : null;\n}\n\nfunction PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace) {\n  this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n  this.attributeName = attributeName;\n  this.attributeNamespace = attributeNamespace;\n  this.mustUseProperty = mustUseProperty;\n  this.propertyName = name;\n  this.type = type;\n}\n\n// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties = {};\n\n// These props are reserved by React. They shouldn't be written to the DOM.\n['children', 'dangerouslySetInnerHTML',\n// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue', 'defaultChecked', 'innerHTML', 'suppressContentEditableWarning', 'suppressHydrationWarning', 'style'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, RESERVED, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset', 'accept-charset'], ['className', 'class'], ['htmlFor', 'for'], ['httpEquiv', 'http-equiv']].forEach(function (_ref) {\n  var name = _ref[0],\n      attributeName = _ref[1];\n\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML boolean attributes.\n['allowFullScreen', 'async',\n// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus', 'autoPlay', 'controls', 'default', 'defer', 'disabled', 'formNoValidate', 'hidden', 'loop', 'noModule', 'noValidate', 'open', 'playsInline', 'readOnly', 'required', 'reversed', 'scoped', 'seamless',\n// Microdata\n'itemScope'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',\n// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple', 'muted', 'selected'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture', 'download'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that must be positive numbers.\n['cols', 'rows', 'size', 'span'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, // mustUseProperty\n  name, // attributeName\n  null);\n} // attributeNamespace\n);\n\n// These are HTML attributes that must be numbers.\n['rowSpan', 'start'].forEach(function (name) {\n  properties[name] = new PropertyInfoRecord(name, NUMERIC, false, // mustUseProperty\n  name.toLowerCase(), // attributeName\n  null);\n} // attributeNamespace\n);\n\nvar CAMELIZE = /[\\-\\:]([a-z])/g;\nvar capitalize = function (token) {\n  return token[1].toUpperCase();\n};\n\n// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML whitelist.\n// Some of these attributes can be hard to find. This list was created by\n// scrapping the MDN documentation.\n['accent-height', 'alignment-baseline', 'arabic-form', 'baseline-shift', 'cap-height', 'clip-path', 'clip-rule', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'dominant-baseline', 'enable-background', 'fill-opacity', 'fill-rule', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'glyph-name', 'glyph-orientation-horizontal', 'glyph-orientation-vertical', 'horiz-adv-x', 'horiz-origin-x', 'image-rendering', 'letter-spacing', 'lighting-color', 'marker-end', 'marker-mid', 'marker-start', 'overline-position', 'overline-thickness', 'paint-order', 'panose-1', 'pointer-events', 'rendering-intent', 'shape-rendering', 'stop-color', 'stop-opacity', 'strikethrough-position', 'strikethrough-thickness', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke-width', 'text-anchor', 'text-decoration', 'text-rendering', 'underline-position', 'underline-thickness', 'unicode-bidi', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'vector-effect', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'word-spacing', 'writing-mode', 'xmlns:xlink', 'x-height'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, null);\n} // attributeNamespace\n);\n\n// String SVG attributes with the xlink namespace.\n['xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/1999/xlink');\n});\n\n// String SVG attributes with the xml namespace.\n['xml:base', 'xml:lang', 'xml:space'].forEach(function (attributeName) {\n  var name = attributeName.replace(CAMELIZE, capitalize);\n  properties[name] = new PropertyInfoRecord(name, STRING, false, // mustUseProperty\n  attributeName, 'http://www.w3.org/XML/1998/namespace');\n});\n\n// Special case: this attribute exists both in HTML and SVG.\n// Its \"tabindex\" attribute name is case-sensitive in SVG so we can't just use\n// its React `tabIndex` name, like we do for attributes that exist only in HTML.\nproperties.tabIndex = new PropertyInfoRecord('tabIndex', STRING, false, // mustUseProperty\n'tabindex', // attributeName\nnull);\n\n/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */\nfunction getValueForProperty(node, name, expected, propertyInfo) {\n  {\n    if (propertyInfo.mustUseProperty) {\n      var propertyName = propertyInfo.propertyName;\n\n      return node[propertyName];\n    } else {\n      var attributeName = propertyInfo.attributeName;\n\n      var stringValue = null;\n\n      if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n        if (node.hasAttribute(attributeName)) {\n          var value = node.getAttribute(attributeName);\n          if (value === '') {\n            return true;\n          }\n          if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n            return value;\n          }\n          if (value === '' + expected) {\n            return expected;\n          }\n          return value;\n        }\n      } else if (node.hasAttribute(attributeName)) {\n        if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n          // We had an attribute but shouldn't have had one, so read it\n          // for the error message.\n          return node.getAttribute(attributeName);\n        }\n        if (propertyInfo.type === BOOLEAN) {\n          // If this was a boolean, it doesn't matter what the value is\n          // the fact that we have it is the same as the expected.\n          return expected;\n        }\n        // Even if this property uses a namespace we use getAttribute\n        // because we assume its namespaced name is the same as our config.\n        // To use getAttributeNS we need the local name which we don't have\n        // in our config atm.\n        stringValue = node.getAttribute(attributeName);\n      }\n\n      if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n        return stringValue === null ? expected : stringValue;\n      } else if (stringValue === '' + expected) {\n        return expected;\n      } else {\n        return stringValue;\n      }\n    }\n  }\n}\n\n/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */\nfunction getValueForAttribute(node, name, expected) {\n  {\n    if (!isAttributeNameSafe(name)) {\n      return;\n    }\n    if (!node.hasAttribute(name)) {\n      return expected === undefined ? undefined : null;\n    }\n    var value = node.getAttribute(name);\n    if (value === '' + expected) {\n      return expected;\n    }\n    return value;\n  }\n}\n\n/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */\nfunction setValueForProperty(node, name, value, isCustomComponentTag) {\n  var propertyInfo = getPropertyInfo(name);\n  if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n    return;\n  }\n  if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n    value = null;\n  }\n  // If the prop isn't in the special list, treat it as a simple attribute.\n  if (isCustomComponentTag || propertyInfo === null) {\n    if (isAttributeNameSafe(name)) {\n      var _attributeName = name;\n      if (value === null) {\n        node.removeAttribute(_attributeName);\n      } else {\n        node.setAttribute(_attributeName, '' + value);\n      }\n    }\n    return;\n  }\n  var mustUseProperty = propertyInfo.mustUseProperty;\n\n  if (mustUseProperty) {\n    var propertyName = propertyInfo.propertyName;\n\n    if (value === null) {\n      var type = propertyInfo.type;\n\n      node[propertyName] = type === BOOLEAN ? false : '';\n    } else {\n      // Contrary to `setAttribute`, object properties are properly\n      // `toString`ed by IE8/9.\n      node[propertyName] = value;\n    }\n    return;\n  }\n  // The rest are treated as attributes with special cases.\n  var attributeName = propertyInfo.attributeName,\n      attributeNamespace = propertyInfo.attributeNamespace;\n\n  if (value === null) {\n    node.removeAttribute(attributeName);\n  } else {\n    var _type = propertyInfo.type;\n\n    var attributeValue = void 0;\n    if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\n      attributeValue = '';\n    } else {\n      // `setAttribute` with objects becomes only `[object]` in IE8/9,\n      // ('' + value) makes it output the correct toString()-value.\n      attributeValue = '' + value;\n    }\n    if (attributeNamespace) {\n      node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n    } else {\n      node.setAttribute(attributeName, attributeValue);\n    }\n  }\n}\n\n// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value) {\n  return '' + value;\n}\n\nfunction getToStringValue(value) {\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'object':\n    case 'string':\n    case 'undefined':\n      return value;\n    default:\n      // function, symbol are assigned as empty strings\n      return '';\n  }\n}\n\nvar ReactDebugCurrentFrame$1 = null;\n\nvar ReactControlledValuePropTypes = {\n  checkPropTypes: null\n};\n\n{\n  ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n  var hasReadOnlyValue = {\n    button: true,\n    checkbox: true,\n    image: true,\n    hidden: true,\n    radio: true,\n    reset: true,\n    submit: true\n  };\n\n  var propTypes = {\n    value: function (props, propName, componentName) {\n      if (hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled || props[propName] == null) {\n        return null;\n      }\n      return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    },\n    checked: function (props, propName, componentName) {\n      if (props.onChange || props.readOnly || props.disabled || props[propName] == null) {\n        return null;\n      }\n      return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');\n    }\n  };\n\n  /**\n   * Provide a linked `value` attribute for controlled forms. You should not use\n   * this outside of the ReactDOM controlled form components.\n   */\n  ReactControlledValuePropTypes.checkPropTypes = function (tagName, props) {\n    checkPropTypes(propTypes, props, 'prop', tagName, ReactDebugCurrentFrame$1.getStackAddendum);\n  };\n}\n\n// Exports ReactDOM.createRoot\nvar enableUserTimingAPI = true;\n\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\nvar enableGetDerivedStateFromCatch = false;\n// Suspense\nvar enableSuspense = false;\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\nvar debugRenderPhaseSideEffects = false;\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\nvar debugRenderPhaseSideEffectsForStrictMode = true;\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\nvar replayFailedUnitOfWorkWithInvokeGuardedCallback = true;\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\nvar warnAboutDeprecatedLifecycles = false;\n\n// Warn about legacy context API\nvar warnAboutLegacyContextAPI = false;\n\n// Gather advanced timing metrics for Profiler subtrees.\nvar enableProfilerTimer = true;\n\n// Trace which interactions trigger each commit.\nvar enableSchedulerTracing = true;\n\n// Only used in www builds.\n\n\n// Only used in www builds.\n\n\n// React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\nvar disableInputAttributeSyncing = false;\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar didWarnValueDefaultValue = false;\nvar didWarnCheckedDefaultChecked = false;\nvar didWarnControlledToUncontrolled = false;\nvar didWarnUncontrolledToControlled = false;\n\nfunction isControlled(props) {\n  var usesChecked = props.type === 'checkbox' || props.type === 'radio';\n  return usesChecked ? props.checked != null : props.value != null;\n}\n\n/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */\n\nfunction getHostProps(element, props) {\n  var node = element;\n  var checked = props.checked;\n\n  var hostProps = _assign({}, props, {\n    defaultChecked: undefined,\n    defaultValue: undefined,\n    value: undefined,\n    checked: checked != null ? checked : node._wrapperState.initialChecked\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState(element, props) {\n  {\n    ReactControlledValuePropTypes.checkPropTypes('input', props);\n\n    if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {\n      warning$1(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);\n      didWarnCheckedDefaultChecked = true;\n    }\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {\n      warning$1(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component', props.type);\n      didWarnValueDefaultValue = true;\n    }\n  }\n\n  var node = element;\n  var defaultValue = props.defaultValue == null ? '' : props.defaultValue;\n\n  node._wrapperState = {\n    initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n    initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\n    controlled: isControlled(props)\n  };\n}\n\nfunction updateChecked(element, props) {\n  var node = element;\n  var checked = props.checked;\n  if (checked != null) {\n    setValueForProperty(node, 'checked', checked, false);\n  }\n}\n\nfunction updateWrapper(element, props) {\n  var node = element;\n  {\n    var _controlled = isControlled(props);\n\n    if (!node._wrapperState.controlled && _controlled && !didWarnUncontrolledToControlled) {\n      warning$1(false, 'A component is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);\n      didWarnUncontrolledToControlled = true;\n    }\n    if (node._wrapperState.controlled && !_controlled && !didWarnControlledToUncontrolled) {\n      warning$1(false, 'A component is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', props.type);\n      didWarnControlledToUncontrolled = true;\n    }\n  }\n\n  updateChecked(element, props);\n\n  var value = getToStringValue(props.value);\n  var type = props.type;\n\n  if (value != null) {\n    if (type === 'number') {\n      if (value === 0 && node.value === '' ||\n      // We explicitly want to coerce to number here if possible.\n      // eslint-disable-next-line\n      node.value != value) {\n        node.value = toString(value);\n      }\n    } else if (node.value !== toString(value)) {\n      node.value = toString(value);\n    }\n  } else if (type === 'submit' || type === 'reset') {\n    // Submit/reset inputs need the attribute removed completely to avoid\n    // blank-text buttons.\n    node.removeAttribute('value');\n    return;\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the value attribute, React only assigns a new value\n    // whenever the defaultValue React prop has changed. When not present,\n    // React does nothing\n    if (props.hasOwnProperty('defaultValue')) {\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n    }\n  } else {\n    // When syncing the value attribute, the value comes from a cascade of\n    // properties:\n    //  1. The value React property\n    //  2. The defaultValue React property\n    //  3. Otherwise there should be no change\n    if (props.hasOwnProperty('value')) {\n      setDefaultValue(node, props.type, value);\n    } else if (props.hasOwnProperty('defaultValue')) {\n      setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n    }\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the checked attribute, the attribute is directly\n    // controllable from the defaultValue React property. It needs to be\n    // updated as new props come in.\n    if (props.defaultChecked == null) {\n      node.removeAttribute('checked');\n    } else {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  } else {\n    // When syncing the checked attribute, it only changes when it needs\n    // to be removed, such as transitioning from a checkbox into a text input\n    if (props.checked == null && props.defaultChecked != null) {\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  }\n}\n\nfunction postMountWrapper(element, props, isHydrating) {\n  var node = element;\n\n  // Do not assign value if it is already set. This prevents user text input\n  // from being lost during SSR hydration.\n  if (props.hasOwnProperty('value') || props.hasOwnProperty('defaultValue')) {\n    var type = props.type;\n    var isButton = type === 'submit' || type === 'reset';\n\n    // Avoid setting value attribute on submit/reset inputs as it overrides the\n    // default value provided by the browser. See: #12872\n    if (isButton && (props.value === undefined || props.value === null)) {\n      return;\n    }\n\n    var _initialValue = toString(node._wrapperState.initialValue);\n\n    // Do not assign value if it is already set. This prevents user text input\n    // from being lost during SSR hydration.\n    if (!isHydrating) {\n      if (disableInputAttributeSyncing) {\n        var value = getToStringValue(props.value);\n\n        // When not syncing the value attribute, the value property points\n        // directly to the React prop. Only assign it if it exists.\n        if (value != null) {\n          // Always assign on buttons so that it is possible to assign an\n          // empty string to clear button text.\n          //\n          // Otherwise, do not re-assign the value property if is empty. This\n          // potentially avoids a DOM write and prevents Firefox (~60.0.1) from\n          // prematurely marking required inputs as invalid. Equality is compared\n          // to the current value in case the browser provided value is not an\n          // empty string.\n          if (isButton || value !== node.value) {\n            node.value = toString(value);\n          }\n        }\n      } else {\n        // When syncing the value attribute, the value property should use\n        // the the wrapperState._initialValue property. This uses:\n        //\n        //   1. The value React property when present\n        //   2. The defaultValue React property when present\n        //   3. An empty string\n        if (_initialValue !== node.value) {\n          node.value = _initialValue;\n        }\n      }\n    }\n\n    if (disableInputAttributeSyncing) {\n      // When not syncing the value attribute, assign the value attribute\n      // directly from the defaultValue React property (when present)\n      var defaultValue = getToStringValue(props.defaultValue);\n      if (defaultValue != null) {\n        node.defaultValue = toString(defaultValue);\n      }\n    } else {\n      // Otherwise, the value attribute is synchronized to the property,\n      // so we assign defaultValue to the same thing as the value property\n      // assignment step above.\n      node.defaultValue = _initialValue;\n    }\n  }\n\n  // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n  // this is needed to work around a chrome bug where setting defaultChecked\n  // will sometimes influence the value of checked (even after detachment).\n  // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n  // We need to temporarily unset name to avoid disrupting radio button groups.\n  var name = node.name;\n  if (name !== '') {\n    node.name = '';\n  }\n\n  if (disableInputAttributeSyncing) {\n    // When not syncing the checked attribute, the checked property\n    // never gets assigned. It must be manually set. We don't want\n    // to do this when hydrating so that existing user input isn't\n    // modified\n    if (!isHydrating) {\n      updateChecked(element, props);\n    }\n\n    // Only assign the checked attribute if it is defined. This saves\n    // a DOM write when controlling the checked attribute isn't needed\n    // (text inputs, submit/reset)\n    if (props.hasOwnProperty('defaultChecked')) {\n      node.defaultChecked = !node.defaultChecked;\n      node.defaultChecked = !!props.defaultChecked;\n    }\n  } else {\n    // When syncing the checked attribute, both the the checked property and\n    // attribute are assigned at the same time using defaultChecked. This uses:\n    //\n    //   1. The checked React property when present\n    //   2. The defaultChecked React property when present\n    //   3. Otherwise, false\n    node.defaultChecked = !node.defaultChecked;\n    node.defaultChecked = !!node._wrapperState.initialChecked;\n  }\n\n  if (name !== '') {\n    node.name = name;\n  }\n}\n\nfunction restoreControlledState(element, props) {\n  var node = element;\n  updateWrapper(node, props);\n  updateNamedCousins(node, props);\n}\n\nfunction updateNamedCousins(rootNode, props) {\n  var name = props.name;\n  if (props.type === 'radio' && name != null) {\n    var queryRoot = rootNode;\n\n    while (queryRoot.parentNode) {\n      queryRoot = queryRoot.parentNode;\n    }\n\n    // If `rootNode.form` was non-null, then we could try `form.elements`,\n    // but that sometimes behaves strangely in IE8. We could also try using\n    // `form.getElementsByName`, but that will only return direct children\n    // and won't include inputs that use the HTML5 `form=` attribute. Since\n    // the input might not even be in a form. It might not even be in the\n    // document. Let's just use the local `querySelectorAll` to ensure we don't\n    // miss anything.\n    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type=\"radio\"]');\n\n    for (var i = 0; i < group.length; i++) {\n      var otherNode = group[i];\n      if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n        continue;\n      }\n      // This will throw if radio buttons rendered by different copies of React\n      // and the same name are rendered into the same form (same as #1939).\n      // That's probably okay; we don't support it just as we don't support\n      // mixing React radio buttons with non-React ones.\n      var otherProps = getFiberCurrentPropsFromNode$1(otherNode);\n      !otherProps ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : void 0;\n\n      // We need update the tracked value on the named cousin since the value\n      // was changed but the input saw no event or value set\n      updateValueIfChanged(otherNode);\n\n      // If this is a controlled radio button group, forcing the input that\n      // was previously checked to update will cause it to be come re-checked\n      // as appropriate.\n      updateWrapper(otherNode, otherProps);\n    }\n  }\n}\n\n// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node, type, value) {\n  if (\n  // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n  type !== 'number' || node.ownerDocument.activeElement !== node) {\n    if (value == null) {\n      node.defaultValue = toString(node._wrapperState.initialValue);\n    } else if (node.defaultValue !== toString(value)) {\n      node.defaultValue = toString(value);\n    }\n  }\n}\n\nvar eventTypes$1 = {\n  change: {\n    phasedRegistrationNames: {\n      bubbled: 'onChange',\n      captured: 'onChangeCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_CHANGE, TOP_CLICK, TOP_FOCUS, TOP_INPUT, TOP_KEY_DOWN, TOP_KEY_UP, TOP_SELECTION_CHANGE]\n  }\n};\n\nfunction createAndAccumulateChangeEvent(inst, nativeEvent, target) {\n  var event = SyntheticEvent.getPooled(eventTypes$1.change, inst, nativeEvent, target);\n  event.type = 'change';\n  // Flag this event loop as needing state restore.\n  enqueueStateRestore(target);\n  accumulateTwoPhaseDispatches(event);\n  return event;\n}\n/**\n * For IE shims\n */\nvar activeElement = null;\nvar activeElementInst = null;\n\n/**\n * SECTION: handle `change` event\n */\nfunction shouldUseChangeEvent(elem) {\n  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';\n}\n\nfunction manualDispatchChangeEvent(nativeEvent) {\n  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n\n  // If change and propertychange bubbled, we'd just bind to it like all the\n  // other events and have it go through ReactBrowserEventEmitter. Since it\n  // doesn't, we manually listen for the events and so we have to enqueue and\n  // process the abstract event manually.\n  //\n  // Batching is necessary here in order to ensure that all event handlers run\n  // before the next rerender (including event handlers attached to ancestor\n  // elements instead of directly on the input). Without this, controlled\n  // components don't work properly in conjunction with event bubbling because\n  // the component is rerendered and the value reverted before all the event\n  // handlers can run. See https://github.com/facebook/react/issues/708.\n  batchedUpdates(runEventInBatch, event);\n}\n\nfunction runEventInBatch(event) {\n  runEventsInBatch(event, false);\n}\n\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance$1(targetInst);\n  if (updateValueIfChanged(targetNode)) {\n    return targetInst;\n  }\n}\n\nfunction getTargetInstForChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CHANGE) {\n    return targetInst;\n  }\n}\n\n/**\n * SECTION: handle `input` event\n */\nvar isInputEventSupported = false;\nif (canUseDOM) {\n  // IE9 claims to support the input event but fails to trigger it when\n  // deleting text, so we ignore its input events.\n  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 9);\n}\n\n/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */\nfunction startWatchingForValueChange(target, targetInst) {\n  activeElement = target;\n  activeElementInst = targetInst;\n  activeElement.attachEvent('onpropertychange', handlePropertyChange);\n}\n\n/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */\nfunction stopWatchingForValueChange() {\n  if (!activeElement) {\n    return;\n  }\n  activeElement.detachEvent('onpropertychange', handlePropertyChange);\n  activeElement = null;\n  activeElementInst = null;\n}\n\n/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */\nfunction handlePropertyChange(nativeEvent) {\n  if (nativeEvent.propertyName !== 'value') {\n    return;\n  }\n  if (getInstIfValueChanged(activeElementInst)) {\n    manualDispatchChangeEvent(nativeEvent);\n  }\n}\n\nfunction handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {\n  if (topLevelType === TOP_FOCUS) {\n    // In IE9, propertychange fires for most input events but is buggy and\n    // doesn't fire when text is deleted, but conveniently, selectionchange\n    // appears to fire in all of the remaining cases so we catch those and\n    // forward the event if the value has changed\n    // In either case, we don't want to call the event handler if the value\n    // is changed from JS so we redefine a setter for `.value` that updates\n    // our activeElementValue variable, allowing us to ignore those changes\n    //\n    // stopWatching() should be a noop here but we call it just in case we\n    // missed a blur event somehow.\n    stopWatchingForValueChange();\n    startWatchingForValueChange(target, targetInst);\n  } else if (topLevelType === TOP_BLUR) {\n    stopWatchingForValueChange();\n  }\n}\n\n// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(topLevelType, targetInst) {\n  if (topLevelType === TOP_SELECTION_CHANGE || topLevelType === TOP_KEY_UP || topLevelType === TOP_KEY_DOWN) {\n    // On the selectionchange event, the target is just document which isn't\n    // helpful for us so just check activeElement instead.\n    //\n    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n    // propertychange on the first input event after setting `value` from a\n    // script and fires only keydown, keypress, keyup. Catching keyup usually\n    // gets it and catching keydown lets us fire an event for the first\n    // keystroke if user does a key repeat (it'll be a little delayed: right\n    // before the second keystroke). Other input methods (e.g., paste) seem to\n    // fire selectionchange normally.\n    return getInstIfValueChanged(activeElementInst);\n  }\n}\n\n/**\n * SECTION: handle `click` event\n */\nfunction shouldUseClickEvent(elem) {\n  // Use the `click` event to detect changes to checkbox and radio inputs.\n  // This approach works across all browsers, whereas `change` does not fire\n  // until `blur` in IE8.\n  var nodeName = elem.nodeName;\n  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');\n}\n\nfunction getTargetInstForClickEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_CLICK) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction getTargetInstForInputOrChangeEvent(topLevelType, targetInst) {\n  if (topLevelType === TOP_INPUT || topLevelType === TOP_CHANGE) {\n    return getInstIfValueChanged(targetInst);\n  }\n}\n\nfunction handleControlledInputBlur(node) {\n  var state = node._wrapperState;\n\n  if (!state || !state.controlled || node.type !== 'number') {\n    return;\n  }\n\n  if (!disableInputAttributeSyncing) {\n    // If controlled, assign the value attribute to the current value on blur\n    setDefaultValue(node, 'number', node.value);\n  }\n}\n\n/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */\nvar ChangeEventPlugin = {\n  eventTypes: eventTypes$1,\n\n  _isInputEventSupported: isInputEventSupported,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    var getTargetInstFunc = void 0,\n        handleEventFunc = void 0;\n    if (shouldUseChangeEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForChangeEvent;\n    } else if (isTextInputElement(targetNode)) {\n      if (isInputEventSupported) {\n        getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n      } else {\n        getTargetInstFunc = getTargetInstForInputEventPolyfill;\n        handleEventFunc = handleEventsForInputEventPolyfill;\n      }\n    } else if (shouldUseClickEvent(targetNode)) {\n      getTargetInstFunc = getTargetInstForClickEvent;\n    }\n\n    if (getTargetInstFunc) {\n      var inst = getTargetInstFunc(topLevelType, targetInst);\n      if (inst) {\n        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);\n        return event;\n      }\n    }\n\n    if (handleEventFunc) {\n      handleEventFunc(topLevelType, targetNode, targetInst);\n    }\n\n    // When blurring, set the value attribute for number inputs\n    if (topLevelType === TOP_BLUR) {\n      handleControlledInputBlur(targetNode);\n    }\n  }\n};\n\n/**\n * Module that is injectable into `EventPluginHub`, that specifies a\n * deterministic ordering of `EventPlugin`s. A convenient way to reason about\n * plugins, without having to package every one of them. This is better than\n * having plugins be ordered in the same order that they are injected because\n * that ordering would be influenced by the packaging order.\n * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that\n * preventing default on events is convenient in `SimpleEventPlugin` handlers.\n */\nvar DOMEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];\n\nvar SyntheticUIEvent = SyntheticEvent.extend({\n  view: null,\n  detail: null\n});\n\n/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */\n\nvar modifierKeyToProp = {\n  Alt: 'altKey',\n  Control: 'ctrlKey',\n  Meta: 'metaKey',\n  Shift: 'shiftKey'\n};\n\n// IE8 does not implement getModifierState so we simply map it to the only\n// modifier keys exposed by the event itself, does not support Lock-keys.\n// Currently, all major browsers except Chrome seems to support Lock-keys.\nfunction modifierStateGetter(keyArg) {\n  var syntheticEvent = this;\n  var nativeEvent = syntheticEvent.nativeEvent;\n  if (nativeEvent.getModifierState) {\n    return nativeEvent.getModifierState(keyArg);\n  }\n  var keyProp = modifierKeyToProp[keyArg];\n  return keyProp ? !!nativeEvent[keyProp] : false;\n}\n\nfunction getEventModifierState(nativeEvent) {\n  return modifierStateGetter;\n}\n\nvar previousScreenX = 0;\nvar previousScreenY = 0;\n// Use flags to signal movementX/Y has already been set\nvar isMovementXSet = false;\nvar isMovementYSet = false;\n\n/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticMouseEvent = SyntheticUIEvent.extend({\n  screenX: null,\n  screenY: null,\n  clientX: null,\n  clientY: null,\n  pageX: null,\n  pageY: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  getModifierState: getEventModifierState,\n  button: null,\n  buttons: null,\n  relatedTarget: function (event) {\n    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);\n  },\n  movementX: function (event) {\n    if ('movementX' in event) {\n      return event.movementX;\n    }\n\n    var screenX = previousScreenX;\n    previousScreenX = event.screenX;\n\n    if (!isMovementXSet) {\n      isMovementXSet = true;\n      return 0;\n    }\n\n    return event.type === 'mousemove' ? event.screenX - screenX : 0;\n  },\n  movementY: function (event) {\n    if ('movementY' in event) {\n      return event.movementY;\n    }\n\n    var screenY = previousScreenY;\n    previousScreenY = event.screenY;\n\n    if (!isMovementYSet) {\n      isMovementYSet = true;\n      return 0;\n    }\n\n    return event.type === 'mousemove' ? event.screenY - screenY : 0;\n  }\n});\n\n/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */\nvar SyntheticPointerEvent = SyntheticMouseEvent.extend({\n  pointerId: null,\n  width: null,\n  height: null,\n  pressure: null,\n  tangentialPressure: null,\n  tiltX: null,\n  tiltY: null,\n  twist: null,\n  pointerType: null,\n  isPrimary: null\n});\n\nvar eventTypes$2 = {\n  mouseEnter: {\n    registrationName: 'onMouseEnter',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\n  },\n  mouseLeave: {\n    registrationName: 'onMouseLeave',\n    dependencies: [TOP_MOUSE_OUT, TOP_MOUSE_OVER]\n  },\n  pointerEnter: {\n    registrationName: 'onPointerEnter',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\n  },\n  pointerLeave: {\n    registrationName: 'onPointerLeave',\n    dependencies: [TOP_POINTER_OUT, TOP_POINTER_OVER]\n  }\n};\n\nvar EnterLeaveEventPlugin = {\n  eventTypes: eventTypes$2,\n\n  /**\n   * For almost every interaction we care about, there will be both a top-level\n   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n   * we do not extract duplicate events. However, moving the mouse into the\n   * browser from outside will not fire a `mouseout` event. In this case, we use\n   * the `mouseover` top-level event.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var isOverEvent = topLevelType === TOP_MOUSE_OVER || topLevelType === TOP_POINTER_OVER;\n    var isOutEvent = topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_POINTER_OUT;\n\n    if (isOverEvent && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {\n      return null;\n    }\n\n    if (!isOutEvent && !isOverEvent) {\n      // Must not be a mouse or pointer in or out - ignoring.\n      return null;\n    }\n\n    var win = void 0;\n    if (nativeEventTarget.window === nativeEventTarget) {\n      // `nativeEventTarget` is probably a window object.\n      win = nativeEventTarget;\n    } else {\n      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n      var doc = nativeEventTarget.ownerDocument;\n      if (doc) {\n        win = doc.defaultView || doc.parentWindow;\n      } else {\n        win = window;\n      }\n    }\n\n    var from = void 0;\n    var to = void 0;\n    if (isOutEvent) {\n      from = targetInst;\n      var related = nativeEvent.relatedTarget || nativeEvent.toElement;\n      to = related ? getClosestInstanceFromNode(related) : null;\n    } else {\n      // Moving to a node from outside the window.\n      from = null;\n      to = targetInst;\n    }\n\n    if (from === to) {\n      // Nothing pertains to our managed components.\n      return null;\n    }\n\n    var eventInterface = void 0,\n        leaveEventType = void 0,\n        enterEventType = void 0,\n        eventTypePrefix = void 0;\n\n    if (topLevelType === TOP_MOUSE_OUT || topLevelType === TOP_MOUSE_OVER) {\n      eventInterface = SyntheticMouseEvent;\n      leaveEventType = eventTypes$2.mouseLeave;\n      enterEventType = eventTypes$2.mouseEnter;\n      eventTypePrefix = 'mouse';\n    } else if (topLevelType === TOP_POINTER_OUT || topLevelType === TOP_POINTER_OVER) {\n      eventInterface = SyntheticPointerEvent;\n      leaveEventType = eventTypes$2.pointerLeave;\n      enterEventType = eventTypes$2.pointerEnter;\n      eventTypePrefix = 'pointer';\n    }\n\n    var fromNode = from == null ? win : getNodeFromInstance$1(from);\n    var toNode = to == null ? win : getNodeFromInstance$1(to);\n\n    var leave = eventInterface.getPooled(leaveEventType, from, nativeEvent, nativeEventTarget);\n    leave.type = eventTypePrefix + 'leave';\n    leave.target = fromNode;\n    leave.relatedTarget = toNode;\n\n    var enter = eventInterface.getPooled(enterEventType, to, nativeEvent, nativeEventTarget);\n    enter.type = eventTypePrefix + 'enter';\n    enter.target = toNode;\n    enter.relatedTarget = fromNode;\n\n    accumulateEnterLeaveDispatches(leave, enter, from, to);\n\n    return [leave, enter];\n  }\n};\n\n/*eslint-disable no-self-compare */\n\nvar hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  // SameValue algorithm\n  if (x === y) {\n    // Steps 1-5, 7-10\n    // Steps 6.b-6.e: +0 != -0\n    // Added the nonzero y check to make Flow happy, but it is redundant\n    return x !== 0 || y !== 0 || 1 / x === 1 / y;\n  } else {\n    // Step 6.a: NaN == NaN\n    return x !== x && y !== y;\n  }\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\nfunction shallowEqual(objA, objB) {\n  if (is(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n\n  // Test for A's keys different from B.\n  for (var i = 0; i < keysA.length; i++) {\n    if (!hasOwnProperty$1.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\n\n/**\n * This API should be called `delete` but we'd have to make sure to always\n * transform these to strings for IE support. When this transform is fully\n * supported we can rename it.\n */\n\n\nfunction get(key) {\n  return key._reactInternalFiber;\n}\n\nfunction has(key) {\n  return key._reactInternalFiber !== undefined;\n}\n\nfunction set(key, value) {\n  key._reactInternalFiber = value;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoEffect = /*              */0;\nvar PerformedWork = /*         */1;\n\n// You can change the rest (and add more).\nvar Placement = /*             */2;\nvar Update = /*                */4;\nvar PlacementAndUpdate = /*    */6;\nvar Deletion = /*              */8;\nvar ContentReset = /*          */16;\nvar Callback = /*              */32;\nvar DidCapture = /*            */64;\nvar Ref = /*                   */128;\nvar Snapshot = /*              */256;\n\n// Update & Callback & Ref & Snapshot\nvar LifecycleEffectMask = /*   */420;\n\n// Union of all host effects\nvar HostEffectMask = /*        */511;\n\nvar Incomplete = /*            */512;\nvar ShouldCapture = /*         */1024;\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n\nvar MOUNTING = 1;\nvar MOUNTED = 2;\nvar UNMOUNTED = 3;\n\nfunction isFiberMountedImpl(fiber) {\n  var node = fiber;\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    if ((node.effectTag & Placement) !== NoEffect) {\n      return MOUNTING;\n    }\n    while (node.return) {\n      node = node.return;\n      if ((node.effectTag & Placement) !== NoEffect) {\n        return MOUNTING;\n      }\n    }\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return MOUNTED;\n  }\n  // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n  return UNMOUNTED;\n}\n\nfunction isFiberMounted(fiber) {\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner$1.current;\n    if (owner !== null && (owner.tag === ClassComponent || owner.tag === ClassComponentLazy)) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n      !instance._warnedAboutRefsInRender ? warningWithoutStack$1(false, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(ownerFiber.type) || 'A component') : void 0;\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n  if (!fiber) {\n    return false;\n  }\n  return isFiberMountedImpl(fiber) === MOUNTED;\n}\n\nfunction assertIsMounted(fiber) {\n  !(isFiberMountedImpl(fiber) === MOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var state = isFiberMountedImpl(fiber);\n    !(state !== UNMOUNTED) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n    if (state === MOUNTING) {\n      return null;\n    }\n    return fiber;\n  }\n  // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n  var a = fiber;\n  var b = alternate;\n  while (true) {\n    var parentA = a.return;\n    var parentB = parentA ? parentA.alternate : null;\n    if (!parentA || !parentB) {\n      // We're at the root.\n      break;\n    }\n\n    // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n        child = child.sibling;\n      }\n      // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n      invariant(false, 'Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        _child = _child.sibling;\n      }\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          _child = _child.sibling;\n        }\n        !didFindChild ? invariant(false, 'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.') : void 0;\n      }\n    }\n\n    !(a.alternate === b) ? invariant(false, 'Return fibers should always be each others\\' alternates. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  }\n  // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n  !(a.tag === HostRoot) ? invariant(false, 'Unable to find node on an unmounted component.') : void 0;\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  }\n  // Otherwise B has to be current branch.\n  return alternate;\n}\n\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  if (!currentParent) {\n    return null;\n  }\n\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  var node = currentParent;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      return node;\n    } else if (node.child && node.tag !== HostPortal) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === currentParent) {\n      return null;\n    }\n    while (!node.sibling) {\n      if (!node.return || node.return === currentParent) {\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  // Flow needs the return null here, but ESLint complains about it.\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction addEventBubbleListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, false);\n}\n\nfunction addEventCaptureListener(element, eventType, listener) {\n  element.addEventListener(eventType, listener, true);\n}\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */\nvar SyntheticAnimationEvent = SyntheticEvent.extend({\n  animationName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */\nvar SyntheticClipboardEvent = SyntheticEvent.extend({\n  clipboardData: function (event) {\n    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;\n  }\n});\n\n/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticFocusEvent = SyntheticUIEvent.extend({\n  relatedTarget: null\n});\n\n/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */\nfunction getEventCharCode(nativeEvent) {\n  var charCode = void 0;\n  var keyCode = nativeEvent.keyCode;\n\n  if ('charCode' in nativeEvent) {\n    charCode = nativeEvent.charCode;\n\n    // FF does not set `charCode` for the Enter-key, check against `keyCode`.\n    if (charCode === 0 && keyCode === 13) {\n      charCode = 13;\n    }\n  } else {\n    // IE8 does not implement `charCode`, but `keyCode` has the correct value.\n    charCode = keyCode;\n  }\n\n  // IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n  // report Enter as charCode 10 when ctrl is pressed.\n  if (charCode === 10) {\n    charCode = 13;\n  }\n\n  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n  // Must not discard the (non-)printable Enter-key.\n  if (charCode >= 32 || charCode === 13) {\n    return charCode;\n  }\n\n  return 0;\n}\n\n/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar normalizeKey = {\n  Esc: 'Escape',\n  Spacebar: ' ',\n  Left: 'ArrowLeft',\n  Up: 'ArrowUp',\n  Right: 'ArrowRight',\n  Down: 'ArrowDown',\n  Del: 'Delete',\n  Win: 'OS',\n  Menu: 'ContextMenu',\n  Apps: 'ContextMenu',\n  Scroll: 'ScrollLock',\n  MozPrintableKey: 'Unidentified'\n};\n\n/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */\nvar translateToKey = {\n  '8': 'Backspace',\n  '9': 'Tab',\n  '12': 'Clear',\n  '13': 'Enter',\n  '16': 'Shift',\n  '17': 'Control',\n  '18': 'Alt',\n  '19': 'Pause',\n  '20': 'CapsLock',\n  '27': 'Escape',\n  '32': ' ',\n  '33': 'PageUp',\n  '34': 'PageDown',\n  '35': 'End',\n  '36': 'Home',\n  '37': 'ArrowLeft',\n  '38': 'ArrowUp',\n  '39': 'ArrowRight',\n  '40': 'ArrowDown',\n  '45': 'Insert',\n  '46': 'Delete',\n  '112': 'F1',\n  '113': 'F2',\n  '114': 'F3',\n  '115': 'F4',\n  '116': 'F5',\n  '117': 'F6',\n  '118': 'F7',\n  '119': 'F8',\n  '120': 'F9',\n  '121': 'F10',\n  '122': 'F11',\n  '123': 'F12',\n  '144': 'NumLock',\n  '145': 'ScrollLock',\n  '224': 'Meta'\n};\n\n/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */\nfunction getEventKey(nativeEvent) {\n  if (nativeEvent.key) {\n    // Normalize inconsistent values reported by browsers due to\n    // implementations of a working draft specification.\n\n    // FireFox implements `key` but returns `MozPrintableKey` for all\n    // printable characters (normalized to `Unidentified`), ignore it.\n    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n    if (key !== 'Unidentified') {\n      return key;\n    }\n  }\n\n  // Browser does not implement `key`, polyfill as much of it as we can.\n  if (nativeEvent.type === 'keypress') {\n    var charCode = getEventCharCode(nativeEvent);\n\n    // The enter-key is technically both printable and non-printable and can\n    // thus be captured by `keypress`, no other non-printable key should.\n    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);\n  }\n  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {\n    // While user keyboard layout determines the actual meaning of each\n    // `keyCode` value, almost all function keys have a universal value.\n    return translateToKey[nativeEvent.keyCode] || 'Unidentified';\n  }\n  return '';\n}\n\n/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticKeyboardEvent = SyntheticUIEvent.extend({\n  key: getEventKey,\n  location: null,\n  ctrlKey: null,\n  shiftKey: null,\n  altKey: null,\n  metaKey: null,\n  repeat: null,\n  locale: null,\n  getModifierState: getEventModifierState,\n  // Legacy Interface\n  charCode: function (event) {\n    // `charCode` is the result of a KeyPress event and represents the value of\n    // the actual printable character.\n\n    // KeyPress is deprecated, but its replacement is not yet final and not\n    // implemented in any major browser. Only KeyPress has charCode.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    return 0;\n  },\n  keyCode: function (event) {\n    // `keyCode` is the result of a KeyDown/Up event and represents the value of\n    // physical keyboard key.\n\n    // The actual meaning of the value depends on the users' keyboard layout\n    // which cannot be detected. Assuming that it is a US keyboard layout\n    // provides a surprisingly accurate mapping for US and European users.\n    // Due to this, it is left to the user to implement at this time.\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  },\n  which: function (event) {\n    // `which` is an alias for either `keyCode` or `charCode` depending on the\n    // type of the event.\n    if (event.type === 'keypress') {\n      return getEventCharCode(event);\n    }\n    if (event.type === 'keydown' || event.type === 'keyup') {\n      return event.keyCode;\n    }\n    return 0;\n  }\n});\n\n/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticDragEvent = SyntheticMouseEvent.extend({\n  dataTransfer: null\n});\n\n/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */\nvar SyntheticTouchEvent = SyntheticUIEvent.extend({\n  touches: null,\n  targetTouches: null,\n  changedTouches: null,\n  altKey: null,\n  metaKey: null,\n  ctrlKey: null,\n  shiftKey: null,\n  getModifierState: getEventModifierState\n});\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */\nvar SyntheticTransitionEvent = SyntheticEvent.extend({\n  propertyName: null,\n  elapsedTime: null,\n  pseudoElement: null\n});\n\n/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar SyntheticWheelEvent = SyntheticMouseEvent.extend({\n  deltaX: function (event) {\n    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;\n  },\n  deltaY: function (event) {\n    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n    'wheelDelta' in event ? -event.wheelDelta : 0;\n  },\n\n  deltaZ: null,\n\n  // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n  // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n  deltaMode: null\n});\n\n/**\n * Turns\n * ['abort', ...]\n * into\n * eventTypes = {\n *   'abort': {\n *     phasedRegistrationNames: {\n *       bubbled: 'onAbort',\n *       captured: 'onAbortCapture',\n *     },\n *     dependencies: [TOP_ABORT],\n *   },\n *   ...\n * };\n * topLevelEventsToDispatchConfig = new Map([\n *   [TOP_ABORT, { sameConfig }],\n * ]);\n */\n\nvar interactiveEventTypeNames = [[TOP_BLUR, 'blur'], [TOP_CANCEL, 'cancel'], [TOP_CLICK, 'click'], [TOP_CLOSE, 'close'], [TOP_CONTEXT_MENU, 'contextMenu'], [TOP_COPY, 'copy'], [TOP_CUT, 'cut'], [TOP_AUX_CLICK, 'auxClick'], [TOP_DOUBLE_CLICK, 'doubleClick'], [TOP_DRAG_END, 'dragEnd'], [TOP_DRAG_START, 'dragStart'], [TOP_DROP, 'drop'], [TOP_FOCUS, 'focus'], [TOP_INPUT, 'input'], [TOP_INVALID, 'invalid'], [TOP_KEY_DOWN, 'keyDown'], [TOP_KEY_PRESS, 'keyPress'], [TOP_KEY_UP, 'keyUp'], [TOP_MOUSE_DOWN, 'mouseDown'], [TOP_MOUSE_UP, 'mouseUp'], [TOP_PASTE, 'paste'], [TOP_PAUSE, 'pause'], [TOP_PLAY, 'play'], [TOP_POINTER_CANCEL, 'pointerCancel'], [TOP_POINTER_DOWN, 'pointerDown'], [TOP_POINTER_UP, 'pointerUp'], [TOP_RATE_CHANGE, 'rateChange'], [TOP_RESET, 'reset'], [TOP_SEEKED, 'seeked'], [TOP_SUBMIT, 'submit'], [TOP_TOUCH_CANCEL, 'touchCancel'], [TOP_TOUCH_END, 'touchEnd'], [TOP_TOUCH_START, 'touchStart'], [TOP_VOLUME_CHANGE, 'volumeChange']];\nvar nonInteractiveEventTypeNames = [[TOP_ABORT, 'abort'], [TOP_ANIMATION_END, 'animationEnd'], [TOP_ANIMATION_ITERATION, 'animationIteration'], [TOP_ANIMATION_START, 'animationStart'], [TOP_CAN_PLAY, 'canPlay'], [TOP_CAN_PLAY_THROUGH, 'canPlayThrough'], [TOP_DRAG, 'drag'], [TOP_DRAG_ENTER, 'dragEnter'], [TOP_DRAG_EXIT, 'dragExit'], [TOP_DRAG_LEAVE, 'dragLeave'], [TOP_DRAG_OVER, 'dragOver'], [TOP_DURATION_CHANGE, 'durationChange'], [TOP_EMPTIED, 'emptied'], [TOP_ENCRYPTED, 'encrypted'], [TOP_ENDED, 'ended'], [TOP_ERROR, 'error'], [TOP_GOT_POINTER_CAPTURE, 'gotPointerCapture'], [TOP_LOAD, 'load'], [TOP_LOADED_DATA, 'loadedData'], [TOP_LOADED_METADATA, 'loadedMetadata'], [TOP_LOAD_START, 'loadStart'], [TOP_LOST_POINTER_CAPTURE, 'lostPointerCapture'], [TOP_MOUSE_MOVE, 'mouseMove'], [TOP_MOUSE_OUT, 'mouseOut'], [TOP_MOUSE_OVER, 'mouseOver'], [TOP_PLAYING, 'playing'], [TOP_POINTER_MOVE, 'pointerMove'], [TOP_POINTER_OUT, 'pointerOut'], [TOP_POINTER_OVER, 'pointerOver'], [TOP_PROGRESS, 'progress'], [TOP_SCROLL, 'scroll'], [TOP_SEEKING, 'seeking'], [TOP_STALLED, 'stalled'], [TOP_SUSPEND, 'suspend'], [TOP_TIME_UPDATE, 'timeUpdate'], [TOP_TOGGLE, 'toggle'], [TOP_TOUCH_MOVE, 'touchMove'], [TOP_TRANSITION_END, 'transitionEnd'], [TOP_WAITING, 'waiting'], [TOP_WHEEL, 'wheel']];\n\nvar eventTypes$4 = {};\nvar topLevelEventsToDispatchConfig = {};\n\nfunction addEventTypeNameToConfig(_ref, isInteractive) {\n  var topEvent = _ref[0],\n      event = _ref[1];\n\n  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);\n  var onEvent = 'on' + capitalizedEvent;\n\n  var type = {\n    phasedRegistrationNames: {\n      bubbled: onEvent,\n      captured: onEvent + 'Capture'\n    },\n    dependencies: [topEvent],\n    isInteractive: isInteractive\n  };\n  eventTypes$4[event] = type;\n  topLevelEventsToDispatchConfig[topEvent] = type;\n}\n\ninteractiveEventTypeNames.forEach(function (eventTuple) {\n  addEventTypeNameToConfig(eventTuple, true);\n});\nnonInteractiveEventTypeNames.forEach(function (eventTuple) {\n  addEventTypeNameToConfig(eventTuple, false);\n});\n\n// Only used in DEV for exhaustiveness validation.\nvar knownHTMLTopLevelTypes = [TOP_ABORT, TOP_CANCEL, TOP_CAN_PLAY, TOP_CAN_PLAY_THROUGH, TOP_CLOSE, TOP_DURATION_CHANGE, TOP_EMPTIED, TOP_ENCRYPTED, TOP_ENDED, TOP_ERROR, TOP_INPUT, TOP_INVALID, TOP_LOAD, TOP_LOADED_DATA, TOP_LOADED_METADATA, TOP_LOAD_START, TOP_PAUSE, TOP_PLAY, TOP_PLAYING, TOP_PROGRESS, TOP_RATE_CHANGE, TOP_RESET, TOP_SEEKED, TOP_SEEKING, TOP_STALLED, TOP_SUBMIT, TOP_SUSPEND, TOP_TIME_UPDATE, TOP_TOGGLE, TOP_VOLUME_CHANGE, TOP_WAITING];\n\nvar SimpleEventPlugin = {\n  eventTypes: eventTypes$4,\n\n  isInteractiveTopLevelEventType: function (topLevelType) {\n    var config = topLevelEventsToDispatchConfig[topLevelType];\n    return config !== undefined && config.isInteractive === true;\n  },\n\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];\n    if (!dispatchConfig) {\n      return null;\n    }\n    var EventConstructor = void 0;\n    switch (topLevelType) {\n      case TOP_KEY_PRESS:\n        // Firefox creates a keypress event for function keys too. This removes\n        // the unwanted keypress events. Enter is however both printable and\n        // non-printable. One would expect Tab to be as well (but it isn't).\n        if (getEventCharCode(nativeEvent) === 0) {\n          return null;\n        }\n      /* falls through */\n      case TOP_KEY_DOWN:\n      case TOP_KEY_UP:\n        EventConstructor = SyntheticKeyboardEvent;\n        break;\n      case TOP_BLUR:\n      case TOP_FOCUS:\n        EventConstructor = SyntheticFocusEvent;\n        break;\n      case TOP_CLICK:\n        // Firefox creates a click event on right mouse clicks. This removes the\n        // unwanted click events.\n        if (nativeEvent.button === 2) {\n          return null;\n        }\n      /* falls through */\n      case TOP_AUX_CLICK:\n      case TOP_DOUBLE_CLICK:\n      case TOP_MOUSE_DOWN:\n      case TOP_MOUSE_MOVE:\n      case TOP_MOUSE_UP:\n      // TODO: Disabled elements should not respond to mouse events\n      /* falls through */\n      case TOP_MOUSE_OUT:\n      case TOP_MOUSE_OVER:\n      case TOP_CONTEXT_MENU:\n        EventConstructor = SyntheticMouseEvent;\n        break;\n      case TOP_DRAG:\n      case TOP_DRAG_END:\n      case TOP_DRAG_ENTER:\n      case TOP_DRAG_EXIT:\n      case TOP_DRAG_LEAVE:\n      case TOP_DRAG_OVER:\n      case TOP_DRAG_START:\n      case TOP_DROP:\n        EventConstructor = SyntheticDragEvent;\n        break;\n      case TOP_TOUCH_CANCEL:\n      case TOP_TOUCH_END:\n      case TOP_TOUCH_MOVE:\n      case TOP_TOUCH_START:\n        EventConstructor = SyntheticTouchEvent;\n        break;\n      case TOP_ANIMATION_END:\n      case TOP_ANIMATION_ITERATION:\n      case TOP_ANIMATION_START:\n        EventConstructor = SyntheticAnimationEvent;\n        break;\n      case TOP_TRANSITION_END:\n        EventConstructor = SyntheticTransitionEvent;\n        break;\n      case TOP_SCROLL:\n        EventConstructor = SyntheticUIEvent;\n        break;\n      case TOP_WHEEL:\n        EventConstructor = SyntheticWheelEvent;\n        break;\n      case TOP_COPY:\n      case TOP_CUT:\n      case TOP_PASTE:\n        EventConstructor = SyntheticClipboardEvent;\n        break;\n      case TOP_GOT_POINTER_CAPTURE:\n      case TOP_LOST_POINTER_CAPTURE:\n      case TOP_POINTER_CANCEL:\n      case TOP_POINTER_DOWN:\n      case TOP_POINTER_MOVE:\n      case TOP_POINTER_OUT:\n      case TOP_POINTER_OVER:\n      case TOP_POINTER_UP:\n        EventConstructor = SyntheticPointerEvent;\n        break;\n      default:\n        {\n          if (knownHTMLTopLevelTypes.indexOf(topLevelType) === -1) {\n            warningWithoutStack$1(false, 'SimpleEventPlugin: Unhandled event type, `%s`. This warning ' + 'is likely caused by a bug in React. Please file an issue.', topLevelType);\n          }\n        }\n        // HTML Events\n        // @see http://www.w3.org/TR/html5/index.html#events-0\n        EventConstructor = SyntheticEvent;\n        break;\n    }\n    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);\n    accumulateTwoPhaseDispatches(event);\n    return event;\n  }\n};\n\nvar isInteractiveTopLevelEventType = SimpleEventPlugin.isInteractiveTopLevelEventType;\n\n\nvar CALLBACK_BOOKKEEPING_POOL_SIZE = 10;\nvar callbackBookkeepingPool = [];\n\n/**\n * Find the deepest React component completely containing the root of the\n * passed-in instance (for use when entire React trees are nested within each\n * other). If React trees are not nested, returns null.\n */\nfunction findRootContainerNode(inst) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  while (inst.return) {\n    inst = inst.return;\n  }\n  if (inst.tag !== HostRoot) {\n    // This can happen if we're in a detached tree.\n    return null;\n  }\n  return inst.stateNode.containerInfo;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst) {\n  if (callbackBookkeepingPool.length) {\n    var instance = callbackBookkeepingPool.pop();\n    instance.topLevelType = topLevelType;\n    instance.nativeEvent = nativeEvent;\n    instance.targetInst = targetInst;\n    return instance;\n  }\n  return {\n    topLevelType: topLevelType,\n    nativeEvent: nativeEvent,\n    targetInst: targetInst,\n    ancestors: []\n  };\n}\n\nfunction releaseTopLevelCallbackBookKeeping(instance) {\n  instance.topLevelType = null;\n  instance.nativeEvent = null;\n  instance.targetInst = null;\n  instance.ancestors.length = 0;\n  if (callbackBookkeepingPool.length < CALLBACK_BOOKKEEPING_POOL_SIZE) {\n    callbackBookkeepingPool.push(instance);\n  }\n}\n\nfunction handleTopLevel(bookKeeping) {\n  var targetInst = bookKeeping.targetInst;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = targetInst;\n  do {\n    if (!ancestor) {\n      bookKeeping.ancestors.push(ancestor);\n      break;\n    }\n    var root = findRootContainerNode(ancestor);\n    if (!root) {\n      break;\n    }\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = getClosestInstanceFromNode(root);\n  } while (ancestor);\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    targetInst = bookKeeping.ancestors[i];\n    runExtractedEventsInBatch(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// TODO: can we stop exporting these?\nvar _enabled = true;\n\nfunction setEnabled(enabled) {\n  _enabled = !!enabled;\n}\n\nfunction isEnabled() {\n  return _enabled;\n}\n\n/**\n * Traps top-level events by using event bubbling.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapBubbledEvent(topLevelType, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventBubbleListener(element, getRawEventName(topLevelType),\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\n/**\n * Traps a top-level event by using event capturing.\n *\n * @param {number} topLevelType Number from `TopLevelEventTypes`.\n * @param {object} element Element on which to attach listener.\n * @return {?object} An object with a remove function which will forcefully\n *                  remove the listener.\n * @internal\n */\nfunction trapCapturedEvent(topLevelType, element) {\n  if (!element) {\n    return null;\n  }\n  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;\n\n  addEventCaptureListener(element, getRawEventName(topLevelType),\n  // Check if interactive and wrap in interactiveUpdates\n  dispatch.bind(null, topLevelType));\n}\n\nfunction dispatchInteractiveEvent(topLevelType, nativeEvent) {\n  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);\n}\n\nfunction dispatchEvent(topLevelType, nativeEvent) {\n  if (!_enabled) {\n    return;\n  }\n\n  var nativeEventTarget = getEventTarget(nativeEvent);\n  var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n  if (targetInst !== null && typeof targetInst.tag === 'number' && !isFiberMounted(targetInst)) {\n    // If we get an event (ex: img onload) before committing that\n    // component's mount, ignore it for now (that is, treat it as if it was an\n    // event on a non-React tree). We might also consider queueing events and\n    // dispatching them after the mount.\n    targetInst = null;\n  }\n\n  var bookKeeping = getTopLevelCallbackBookKeeping(topLevelType, nativeEvent, targetInst);\n\n  try {\n    // Event queue being processed in the same cycle allows\n    // `preventDefault`.\n    batchedUpdates(handleTopLevel, bookKeeping);\n  } finally {\n    releaseTopLevelCallbackBookKeeping(bookKeeping);\n  }\n}\n\n/**\n * Summary of `ReactBrowserEventEmitter` event handling:\n *\n *  - Top-level delegation is used to trap most native browser events. This\n *    may only occur in the main thread and is the responsibility of\n *    ReactDOMEventListener, which is injected and can therefore support\n *    pluggable event sources. This is the only work that occurs in the main\n *    thread.\n *\n *  - We normalize and de-duplicate events to account for browser quirks. This\n *    may be done in the worker thread.\n *\n *  - Forward these native events (with the associated top-level type used to\n *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want\n *    to extract any synthetic events.\n *\n *  - The `EventPluginHub` will then process each event by annotating them with\n *    \"dispatches\", a sequence of listeners and IDs that care about that event.\n *\n *  - The `EventPluginHub` then dispatches the events.\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.--->|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.--->|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n *    React Core     .  General Purpose Event Plugin System\n */\n\nvar alreadyListeningTo = {};\nvar reactTopListenersCounter = 0;\n\n/**\n * To ensure no conflicts with other potential React instances on the page\n */\nvar topListenersIDKey = '_reactListenersID' + ('' + Math.random()).slice(2);\n\nfunction getListeningForDocument(mountAt) {\n  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`\n  // directly.\n  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {\n    mountAt[topListenersIDKey] = reactTopListenersCounter++;\n    alreadyListeningTo[mountAt[topListenersIDKey]] = {};\n  }\n  return alreadyListeningTo[mountAt[topListenersIDKey]];\n}\n\n/**\n * We listen for bubbled touch events on the document object.\n *\n * Firefox v8.01 (and possibly others) exhibited strange behavior when\n * mounting `onmousemove` events at some node that was not the document\n * element. The symptoms were that if your mouse is not moving over something\n * contained within that mount point (for example on the background) the\n * top-level listeners for `onmousemove` won't be called. However, if you\n * register the `mousemove` on the document object, then it will of course\n * catch all `mousemove`s. This along with iOS quirks, justifies restricting\n * top-level listeners to the document object only, at least for these\n * movement types of events and possibly all events.\n *\n * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n *\n * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but\n * they bubble to document.\n *\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @param {object} mountAt Container where to mount the listener\n */\nfunction listenTo(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      switch (dependency) {\n        case TOP_SCROLL:\n          trapCapturedEvent(TOP_SCROLL, mountAt);\n          break;\n        case TOP_FOCUS:\n        case TOP_BLUR:\n          trapCapturedEvent(TOP_FOCUS, mountAt);\n          trapCapturedEvent(TOP_BLUR, mountAt);\n          // We set the flag for a single dependency later in this function,\n          // but this ensures we mark both as attached rather than just one.\n          isListening[TOP_BLUR] = true;\n          isListening[TOP_FOCUS] = true;\n          break;\n        case TOP_CANCEL:\n        case TOP_CLOSE:\n          if (isEventSupported(getRawEventName(dependency))) {\n            trapCapturedEvent(dependency, mountAt);\n          }\n          break;\n        case TOP_INVALID:\n        case TOP_SUBMIT:\n        case TOP_RESET:\n          // We listen to them on the target DOM elements.\n          // Some of them bubble so we don't want them to fire twice.\n          break;\n        default:\n          // By default, listen on the top level to all non-media events.\n          // Media events don't bubble so adding the listener wouldn't do anything.\n          var isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;\n          if (!isMediaEvent) {\n            trapBubbledEvent(dependency, mountAt);\n          }\n          break;\n      }\n      isListening[dependency] = true;\n    }\n  }\n}\n\nfunction isListeningToAllDependencies(registrationName, mountAt) {\n  var isListening = getListeningForDocument(mountAt);\n  var dependencies = registrationNameDependencies[registrationName];\n  for (var i = 0; i < dependencies.length; i++) {\n    var dependency = dependencies[i];\n    if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getActiveElement(doc) {\n  doc = doc || (typeof document !== 'undefined' ? document : undefined);\n  if (typeof doc === 'undefined') {\n    return null;\n  }\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\n\n/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */\nfunction getLeafNode(node) {\n  while (node && node.firstChild) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */\nfunction getSiblingNode(node) {\n  while (node) {\n    if (node.nextSibling) {\n      return node.nextSibling;\n    }\n    node = node.parentNode;\n  }\n}\n\n/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  var nodeStart = 0;\n  var nodeEnd = 0;\n\n  while (node) {\n    if (node.nodeType === TEXT_NODE) {\n      nodeEnd = nodeStart + node.textContent.length;\n\n      if (nodeStart <= offset && nodeEnd >= offset) {\n        return {\n          node: node,\n          offset: offset - nodeStart\n        };\n      }\n\n      nodeStart = nodeEnd;\n    }\n\n    node = getLeafNode(getSiblingNode(node));\n  }\n}\n\n/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */\nfunction getOffsets(outerNode) {\n  var ownerDocument = outerNode.ownerDocument;\n\n  var win = ownerDocument && ownerDocument.defaultView || window;\n  var selection = win.getSelection && win.getSelection();\n\n  if (!selection || selection.rangeCount === 0) {\n    return null;\n  }\n\n  var anchorNode = selection.anchorNode,\n      anchorOffset = selection.anchorOffset,\n      focusNode = selection.focusNode,\n      focusOffset = selection.focusOffset;\n\n  // In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n  // up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n  // expose properties, triggering a \"Permission denied error\" if any of its\n  // properties are accessed. The only seemingly possible way to avoid erroring\n  // is to access a property that typically works for non-anonymous divs and\n  // catch any error that may otherwise arise. See\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\n  try {\n    /* eslint-disable no-unused-expressions */\n    anchorNode.nodeType;\n    focusNode.nodeType;\n    /* eslint-enable no-unused-expressions */\n  } catch (e) {\n    return null;\n  }\n\n  return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n}\n\n/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */\nfunction getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var length = 0;\n  var start = -1;\n  var end = -1;\n  var indexWithinAnchor = 0;\n  var indexWithinFocus = 0;\n  var node = outerNode;\n  var parentNode = null;\n\n  outer: while (true) {\n    var next = null;\n\n    while (true) {\n      if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n        start = length + anchorOffset;\n      }\n      if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n        end = length + focusOffset;\n      }\n\n      if (node.nodeType === TEXT_NODE) {\n        length += node.nodeValue.length;\n      }\n\n      if ((next = node.firstChild) === null) {\n        break;\n      }\n      // Moving from `node` to its first child `next`.\n      parentNode = node;\n      node = next;\n    }\n\n    while (true) {\n      if (node === outerNode) {\n        // If `outerNode` has children, this is always the second time visiting\n        // it. If it has no children, this is still the first loop, and the only\n        // valid selection is anchorNode and focusNode both equal to this node\n        // and both offsets 0, in which case we will have handled above.\n        break outer;\n      }\n      if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n        start = length;\n      }\n      if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n        end = length;\n      }\n      if ((next = node.nextSibling) !== null) {\n        break;\n      }\n      node = parentNode;\n      parentNode = node.parentNode;\n    }\n\n    // Moving from `node` to its next sibling `next`.\n    node = next;\n  }\n\n  if (start === -1 || end === -1) {\n    // This should never happen. (Would happen if the anchor/focus nodes aren't\n    // actually inside the passed-in node.)\n    return null;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\n/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */\nfunction setOffsets(node, offsets) {\n  var doc = node.ownerDocument || document;\n  var win = doc && doc.defaultView || window;\n  var selection = win.getSelection();\n  var length = node.textContent.length;\n  var start = Math.min(offsets.start, length);\n  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);\n\n  // IE 11 uses modern selection, but doesn't support the extend method.\n  // Flip backward selections, so we can set with a single range.\n  if (!selection.extend && start > end) {\n    var temp = end;\n    end = start;\n    start = temp;\n  }\n\n  var startMarker = getNodeForCharacterOffset(node, start);\n  var endMarker = getNodeForCharacterOffset(node, end);\n\n  if (startMarker && endMarker) {\n    if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n      return;\n    }\n    var range = doc.createRange();\n    range.setStart(startMarker.node, startMarker.offset);\n    selection.removeAllRanges();\n\n    if (start > end) {\n      selection.addRange(range);\n      selection.extend(endMarker.node, endMarker.offset);\n    } else {\n      range.setEnd(endMarker.node, endMarker.offset);\n      selection.addRange(range);\n    }\n  }\n}\n\nfunction isTextNode(node) {\n  return node && node.nodeType === TEXT_NODE;\n}\n\nfunction containsNode(outerNode, innerNode) {\n  if (!outerNode || !innerNode) {\n    return false;\n  } else if (outerNode === innerNode) {\n    return true;\n  } else if (isTextNode(outerNode)) {\n    return false;\n  } else if (isTextNode(innerNode)) {\n    return containsNode(outerNode, innerNode.parentNode);\n  } else if ('contains' in outerNode) {\n    return outerNode.contains(innerNode);\n  } else if (outerNode.compareDocumentPosition) {\n    return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n  } else {\n    return false;\n  }\n}\n\nfunction isInDocument(node) {\n  return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\n}\n\nfunction getActiveElementDeep() {\n  var win = window;\n  var element = getActiveElement();\n  while (element instanceof win.HTMLIFrameElement) {\n    // Accessing the contentDocument of a HTMLIframeElement can cause the browser\n    // to throw, e.g. if it has a cross-origin src attribute\n    try {\n      win = element.contentDocument.defaultView;\n    } catch (e) {\n      return element;\n    }\n    element = getActiveElement(win.document);\n  }\n  return element;\n}\n\n/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */\n\n/**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return nodeName && (nodeName === 'input' && (elem.type === 'text' || elem.type === 'search' || elem.type === 'tel' || elem.type === 'url' || elem.type === 'password') || nodeName === 'textarea' || elem.contentEditable === 'true');\n}\n\nfunction getSelectionInformation() {\n  var focusedElem = getActiveElementDeep();\n  return {\n    focusedElem: focusedElem,\n    selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection$1(focusedElem) : null\n  };\n}\n\n/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */\nfunction restoreSelection(priorSelectionInformation) {\n  var curFocusedElem = getActiveElementDeep();\n  var priorFocusedElem = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n    if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\n      setSelection(priorFocusedElem, priorSelectionRange);\n    }\n\n    // Focusing a node can change the scroll position, which is undesirable\n    var ancestors = [];\n    var ancestor = priorFocusedElem;\n    while (ancestor = ancestor.parentNode) {\n      if (ancestor.nodeType === ELEMENT_NODE) {\n        ancestors.push({\n          element: ancestor,\n          left: ancestor.scrollLeft,\n          top: ancestor.scrollTop\n        });\n      }\n    }\n\n    if (typeof priorFocusedElem.focus === 'function') {\n      priorFocusedElem.focus();\n    }\n\n    for (var i = 0; i < ancestors.length; i++) {\n      var info = ancestors[i];\n      info.element.scrollLeft = info.left;\n      info.element.scrollTop = info.top;\n    }\n  }\n}\n\n/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */\nfunction getSelection$1(input) {\n  var selection = void 0;\n\n  if ('selectionStart' in input) {\n    // Modern browser with input or textarea.\n    selection = {\n      start: input.selectionStart,\n      end: input.selectionEnd\n    };\n  } else {\n    // Content editable or old IE textarea.\n    selection = getOffsets(input);\n  }\n\n  return selection || { start: 0, end: 0 };\n}\n\n/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */\nfunction setSelection(input, offsets) {\n  var start = offsets.start,\n      end = offsets.end;\n\n  if (end === undefined) {\n    end = start;\n  }\n\n  if ('selectionStart' in input) {\n    input.selectionStart = start;\n    input.selectionEnd = Math.min(end, input.value.length);\n  } else {\n    setOffsets(input, offsets);\n  }\n}\n\nvar skipSelectionChangeEvent = canUseDOM && 'documentMode' in document && document.documentMode <= 11;\n\nvar eventTypes$3 = {\n  select: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelect',\n      captured: 'onSelectCapture'\n    },\n    dependencies: [TOP_BLUR, TOP_CONTEXT_MENU, TOP_DRAG_END, TOP_FOCUS, TOP_KEY_DOWN, TOP_KEY_UP, TOP_MOUSE_DOWN, TOP_MOUSE_UP, TOP_SELECTION_CHANGE]\n  }\n};\n\nvar activeElement$1 = null;\nvar activeElementInst$1 = null;\nvar lastSelection = null;\nvar mouseDown = false;\n\n/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n *\n * @param {DOMElement} node\n * @return {object}\n */\nfunction getSelection(node) {\n  if ('selectionStart' in node && hasSelectionCapabilities(node)) {\n    return {\n      start: node.selectionStart,\n      end: node.selectionEnd\n    };\n  } else {\n    var win = node.ownerDocument && node.ownerDocument.defaultView || window;\n    var selection = win.getSelection();\n    return {\n      anchorNode: selection.anchorNode,\n      anchorOffset: selection.anchorOffset,\n      focusNode: selection.focusNode,\n      focusOffset: selection.focusOffset\n    };\n  }\n}\n\n/**\n * Get document associated with the event target.\n *\n * @param {object} nativeEventTarget\n * @return {Document}\n */\nfunction getEventTargetDocument(eventTarget) {\n  return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n}\n\n/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */\nfunction constructSelectEvent(nativeEvent, nativeEventTarget) {\n  // Ensure we have the right element, and that the user is not dragging a\n  // selection (this matches native `select` event behavior). In HTML5, select\n  // fires only on input and textarea thus if there's no focused element we\n  // won't dispatch.\n  var doc = getEventTargetDocument(nativeEventTarget);\n\n  if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\n    return null;\n  }\n\n  // Only fire when selection has actually changed.\n  var currentSelection = getSelection(activeElement$1);\n  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n    lastSelection = currentSelection;\n\n    var syntheticEvent = SyntheticEvent.getPooled(eventTypes$3.select, activeElementInst$1, nativeEvent, nativeEventTarget);\n\n    syntheticEvent.type = 'select';\n    syntheticEvent.target = activeElement$1;\n\n    accumulateTwoPhaseDispatches(syntheticEvent);\n\n    return syntheticEvent;\n  }\n\n  return null;\n}\n\n/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */\nvar SelectEventPlugin = {\n  eventTypes: eventTypes$3,\n\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    var doc = getEventTargetDocument(nativeEventTarget);\n    // Track whether all listeners exists for this plugin. If none exist, we do\n    // not extract events. See #3639.\n    if (!doc || !isListeningToAllDependencies('onSelect', doc)) {\n      return null;\n    }\n\n    var targetNode = targetInst ? getNodeFromInstance$1(targetInst) : window;\n\n    switch (topLevelType) {\n      // Track the input node that has focus.\n      case TOP_FOCUS:\n        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {\n          activeElement$1 = targetNode;\n          activeElementInst$1 = targetInst;\n          lastSelection = null;\n        }\n        break;\n      case TOP_BLUR:\n        activeElement$1 = null;\n        activeElementInst$1 = null;\n        lastSelection = null;\n        break;\n      // Don't fire the event while the user is dragging. This matches the\n      // semantics of the native select event.\n      case TOP_MOUSE_DOWN:\n        mouseDown = true;\n        break;\n      case TOP_CONTEXT_MENU:\n      case TOP_MOUSE_UP:\n      case TOP_DRAG_END:\n        mouseDown = false;\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n      // Chrome and IE fire non-standard event when selection is changed (and\n      // sometimes when it hasn't). IE's event fires out of order with respect\n      // to key and input events on deletion, so we discard it.\n      //\n      // Firefox doesn't support selectionchange, so check selection status\n      // after each key entry. The selection changes after keydown and before\n      // keyup, but we check on keydown as well in the case of holding down a\n      // key, when multiple keydown events are fired but only one keyup is.\n      // This is also our approach for IE handling, for the reason above.\n      case TOP_SELECTION_CHANGE:\n        if (skipSelectionChangeEvent) {\n          break;\n        }\n      // falls through\n      case TOP_KEY_DOWN:\n      case TOP_KEY_UP:\n        return constructSelectEvent(nativeEvent, nativeEventTarget);\n    }\n\n    return null;\n  }\n};\n\n/**\n * Inject modules for resolving DOM hierarchy and plugin ordering.\n */\ninjection.injectEventPluginOrder(DOMEventPluginOrder);\nsetComponentTree(getFiberCurrentPropsFromNode$1, getInstanceFromNode$1, getNodeFromInstance$1);\n\n/**\n * Some important event plugins included by default (without having to require\n * them).\n */\ninjection.injectEventPluginsByName({\n  SimpleEventPlugin: SimpleEventPlugin,\n  EnterLeaveEventPlugin: EnterLeaveEventPlugin,\n  ChangeEventPlugin: ChangeEventPlugin,\n  SelectEventPlugin: SelectEventPlugin,\n  BeforeInputEventPlugin: BeforeInputEventPlugin\n});\n\nvar didWarnSelectedSetOnOption = false;\nvar didWarnInvalidChild = false;\n\nfunction flattenChildren(children) {\n  var content = '';\n\n  // Flatten children. We'll warn if they are invalid\n  // during validateProps() which runs for hydration too.\n  // Note that this would throw on non-element objects.\n  // Elements are stringified (which is normally irrelevant\n  // but matters for <fbt>).\n  React.Children.forEach(children, function (child) {\n    if (child == null) {\n      return;\n    }\n    content += child;\n    // Note: we don't warn about invalid children here.\n    // Instead, this is done separately below so that\n    // it happens during the hydration codepath too.\n  });\n\n  return content;\n}\n\n/**\n * Implements an <option> host component that warns when `selected` is set.\n */\n\nfunction validateProps(element, props) {\n  {\n    // This mirrors the codepath above, but runs for hydration too.\n    // Warn about invalid children here so that client and hydration are consistent.\n    // TODO: this seems like it could cause a DEV-only throw for hydration\n    // if children contains a non-element object. We should try to avoid that.\n    if (typeof props.children === 'object' && props.children !== null) {\n      React.Children.forEach(props.children, function (child) {\n        if (child == null) {\n          return;\n        }\n        if (typeof child === 'string' || typeof child === 'number') {\n          return;\n        }\n        if (typeof child.type !== 'string') {\n          return;\n        }\n        if (!didWarnInvalidChild) {\n          didWarnInvalidChild = true;\n          warning$1(false, 'Only strings and numbers are supported as <option> children.');\n        }\n      });\n    }\n\n    // TODO: Remove support for `selected` in <option>.\n    if (props.selected != null && !didWarnSelectedSetOnOption) {\n      warning$1(false, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.');\n      didWarnSelectedSetOnOption = true;\n    }\n  }\n}\n\nfunction postMountWrapper$1(element, props) {\n  // value=\"\" should make a value attribute (#6219)\n  if (props.value != null) {\n    element.setAttribute('value', toString(getToStringValue(props.value)));\n  }\n}\n\nfunction getHostProps$1(element, props) {\n  var hostProps = _assign({ children: undefined }, props);\n  var content = flattenChildren(props.children);\n\n  if (content) {\n    hostProps.children = content;\n  }\n\n  return hostProps;\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar didWarnValueDefaultValue$1 = void 0;\n\n{\n  didWarnValueDefaultValue$1 = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n  if (ownerName) {\n    return '\\n\\nCheck the render method of `' + ownerName + '`.';\n  }\n  return '';\n}\n\nvar valuePropNames = ['value', 'defaultValue'];\n\n/**\n * Validation function for `value` and `defaultValue`.\n */\nfunction checkSelectPropTypes(props) {\n  ReactControlledValuePropTypes.checkPropTypes('select', props);\n\n  for (var i = 0; i < valuePropNames.length; i++) {\n    var propName = valuePropNames[i];\n    if (props[propName] == null) {\n      continue;\n    }\n    var isArray = Array.isArray(props[propName]);\n    if (props.multiple && !isArray) {\n      warning$1(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum());\n    } else if (!props.multiple && isArray) {\n      warning$1(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum());\n    }\n  }\n}\n\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  var options = node.options;\n\n  if (multiple) {\n    var selectedValues = propValue;\n    var selectedValue = {};\n    for (var i = 0; i < selectedValues.length; i++) {\n      // Prefix to avoid chaos with special keys.\n      selectedValue['$' + selectedValues[i]] = true;\n    }\n    for (var _i = 0; _i < options.length; _i++) {\n      var selected = selectedValue.hasOwnProperty('$' + options[_i].value);\n      if (options[_i].selected !== selected) {\n        options[_i].selected = selected;\n      }\n      if (selected && setDefaultSelected) {\n        options[_i].defaultSelected = true;\n      }\n    }\n  } else {\n    // Do not set `select.value` as exact behavior isn't consistent across all\n    // browsers for all cases.\n    var _selectedValue = toString(getToStringValue(propValue));\n    var defaultSelected = null;\n    for (var _i2 = 0; _i2 < options.length; _i2++) {\n      if (options[_i2].value === _selectedValue) {\n        options[_i2].selected = true;\n        if (setDefaultSelected) {\n          options[_i2].defaultSelected = true;\n        }\n        return;\n      }\n      if (defaultSelected === null && !options[_i2].disabled) {\n        defaultSelected = options[_i2];\n      }\n    }\n    if (defaultSelected !== null) {\n      defaultSelected.selected = true;\n    }\n  }\n}\n\n/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */\n\nfunction getHostProps$2(element, props) {\n  return _assign({}, props, {\n    value: undefined\n  });\n}\n\nfunction initWrapperState$1(element, props) {\n  var node = element;\n  {\n    checkSelectPropTypes(props);\n  }\n\n  node._wrapperState = {\n    wasMultiple: !!props.multiple\n  };\n\n  {\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {\n      warning$1(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components');\n      didWarnValueDefaultValue$1 = true;\n    }\n  }\n}\n\nfunction postMountWrapper$2(element, props) {\n  var node = element;\n  node.multiple = !!props.multiple;\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (props.defaultValue != null) {\n    updateOptions(node, !!props.multiple, props.defaultValue, true);\n  }\n}\n\nfunction postUpdateWrapper(element, props) {\n  var node = element;\n  var wasMultiple = node._wrapperState.wasMultiple;\n  node._wrapperState.wasMultiple = !!props.multiple;\n\n  var value = props.value;\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  } else if (wasMultiple !== !!props.multiple) {\n    // For simplicity, reapply `defaultValue` if `multiple` is toggled.\n    if (props.defaultValue != null) {\n      updateOptions(node, !!props.multiple, props.defaultValue, true);\n    } else {\n      // Revert the select back to its default unselected state.\n      updateOptions(node, !!props.multiple, props.multiple ? [] : '', false);\n    }\n  }\n}\n\nfunction restoreControlledState$2(element, props) {\n  var node = element;\n  var value = props.value;\n\n  if (value != null) {\n    updateOptions(node, !!props.multiple, value, false);\n  }\n}\n\nvar didWarnValDefaultVal = false;\n\n/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */\n\nfunction getHostProps$3(element, props) {\n  var node = element;\n  !(props.dangerouslySetInnerHTML == null) ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : void 0;\n\n  // Always set children to the same thing. In IE9, the selection range will\n  // get reset if `textContent` is mutated.  We could add a check in setTextContent\n  // to only set the value if/when the value differs from the node value (which would\n  // completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n  // solution. The value can be a boolean or object so that's why it's forced\n  // to be a string.\n  var hostProps = _assign({}, props, {\n    value: undefined,\n    defaultValue: undefined,\n    children: toString(node._wrapperState.initialValue)\n  });\n\n  return hostProps;\n}\n\nfunction initWrapperState$2(element, props) {\n  var node = element;\n  {\n    ReactControlledValuePropTypes.checkPropTypes('textarea', props);\n    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {\n      warning$1(false, '%s contains a textarea with both value and defaultValue props. ' + 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', getCurrentFiberOwnerNameInDevOrNull() || 'A component');\n      didWarnValDefaultVal = true;\n    }\n  }\n\n  var initialValue = props.value;\n\n  // Only bother fetching default value if we're going to use it\n  if (initialValue == null) {\n    var defaultValue = props.defaultValue;\n    // TODO (yungsters): Remove support for children content in <textarea>.\n    var children = props.children;\n    if (children != null) {\n      {\n        warning$1(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.');\n      }\n      !(defaultValue == null) ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : void 0;\n      if (Array.isArray(children)) {\n        !(children.length <= 1) ? invariant(false, '<textarea> can only have at most one child.') : void 0;\n        children = children[0];\n      }\n\n      defaultValue = children;\n    }\n    if (defaultValue == null) {\n      defaultValue = '';\n    }\n    initialValue = defaultValue;\n  }\n\n  node._wrapperState = {\n    initialValue: getToStringValue(initialValue)\n  };\n}\n\nfunction updateWrapper$1(element, props) {\n  var node = element;\n  var value = getToStringValue(props.value);\n  var defaultValue = getToStringValue(props.defaultValue);\n  if (value != null) {\n    // Cast `value` to a string to ensure the value is set correctly. While\n    // browsers typically do this as necessary, jsdom doesn't.\n    var newValue = toString(value);\n    // To avoid side effects (such as losing text selection), only set value if changed\n    if (newValue !== node.value) {\n      node.value = newValue;\n    }\n    if (props.defaultValue == null && node.defaultValue !== newValue) {\n      node.defaultValue = newValue;\n    }\n  }\n  if (defaultValue != null) {\n    node.defaultValue = toString(defaultValue);\n  }\n}\n\nfunction postMountWrapper$3(element, props) {\n  var node = element;\n  // This is in postMount because we need access to the DOM node, which is not\n  // available until after the component has mounted.\n  var textContent = node.textContent;\n\n  // Only set node.value if textContent is equal to the expected\n  // initial value. In IE10/IE11 there is a bug where the placeholder attribute\n  // will populate textContent as well.\n  // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n  if (textContent === node._wrapperState.initialValue) {\n    node.value = textContent;\n  }\n}\n\nfunction restoreControlledState$3(element, props) {\n  // DOM component is still mounted; update\n  updateWrapper$1(element, props);\n}\n\nvar HTML_NAMESPACE$1 = 'http://www.w3.org/1999/xhtml';\nvar MATH_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\nvar SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nvar Namespaces = {\n  html: HTML_NAMESPACE$1,\n  mathml: MATH_NAMESPACE,\n  svg: SVG_NAMESPACE\n};\n\n// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type) {\n  switch (type) {\n    case 'svg':\n      return SVG_NAMESPACE;\n    case 'math':\n      return MATH_NAMESPACE;\n    default:\n      return HTML_NAMESPACE$1;\n  }\n}\n\nfunction getChildNamespace(parentNamespace, type) {\n  if (parentNamespace == null || parentNamespace === HTML_NAMESPACE$1) {\n    // No (or default) parent namespace: potential entry point.\n    return getIntrinsicNamespace(type);\n  }\n  if (parentNamespace === SVG_NAMESPACE && type === 'foreignObject') {\n    // We're leaving SVG.\n    return HTML_NAMESPACE$1;\n  }\n  // By default, pass namespace below.\n  return parentNamespace;\n}\n\n/* globals MSApp */\n\n/**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */\nvar createMicrosoftUnsafeLocalFunction = function (func) {\n  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {\n    return function (arg0, arg1, arg2, arg3) {\n      MSApp.execUnsafeLocalFunction(function () {\n        return func(arg0, arg1, arg2, arg3);\n      });\n    };\n  } else {\n    return func;\n  }\n};\n\n// SVG temp container for IE lacking innerHTML\nvar reusableSVGContainer = void 0;\n\n/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */\nvar setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {\n  // IE does not have innerHTML for SVG nodes, so instead we inject the\n  // new markup in a temp node and then move the child nodes across into\n  // the target node\n\n  if (node.namespaceURI === Namespaces.svg && !('innerHTML' in node)) {\n    reusableSVGContainer = reusableSVGContainer || document.createElement('div');\n    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';\n    var svgNode = reusableSVGContainer.firstChild;\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    while (svgNode.firstChild) {\n      node.appendChild(svgNode.firstChild);\n    }\n  } else {\n    node.innerHTML = html;\n  }\n});\n\n/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */\nvar setTextContent = function (node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n\n    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n};\n\n/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */\nvar isUnitlessNumber = {\n  animationIterationCount: true,\n  borderImageOutset: true,\n  borderImageSlice: true,\n  borderImageWidth: true,\n  boxFlex: true,\n  boxFlexGroup: true,\n  boxOrdinalGroup: true,\n  columnCount: true,\n  columns: true,\n  flex: true,\n  flexGrow: true,\n  flexPositive: true,\n  flexShrink: true,\n  flexNegative: true,\n  flexOrder: true,\n  gridArea: true,\n  gridRow: true,\n  gridRowEnd: true,\n  gridRowSpan: true,\n  gridRowStart: true,\n  gridColumn: true,\n  gridColumnEnd: true,\n  gridColumnSpan: true,\n  gridColumnStart: true,\n  fontWeight: true,\n  lineClamp: true,\n  lineHeight: true,\n  opacity: true,\n  order: true,\n  orphans: true,\n  tabSize: true,\n  widows: true,\n  zIndex: true,\n  zoom: true,\n\n  // SVG-related properties\n  fillOpacity: true,\n  floodOpacity: true,\n  stopOpacity: true,\n  strokeDasharray: true,\n  strokeDashoffset: true,\n  strokeMiterlimit: true,\n  strokeOpacity: true,\n  strokeWidth: true\n};\n\n/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */\nfunction prefixKey(prefix, key) {\n  return prefix + key.charAt(0).toUpperCase() + key.substring(1);\n}\n\n/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */\nvar prefixes = ['Webkit', 'ms', 'Moz', 'O'];\n\n// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function (prop) {\n  prefixes.forEach(function (prefix) {\n    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];\n  });\n});\n\n/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */\nfunction dangerousStyleValue(name, value, isCustomProperty) {\n  // Note that we've removed escapeTextForBrowser() calls here since the\n  // whole string will be escaped when the attribute is injected into\n  // the markup. If you provide unsafe user data here they can inject\n  // arbitrary CSS which may be problematic (I couldn't repro this):\n  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n  // This is not an XSS hole but instead a potential CSS injection issue\n  // which has lead to a greater discussion about how we're going to\n  // trust URLs moving forward. See #2115901\n\n  var isEmpty = value == null || typeof value === 'boolean' || value === '';\n  if (isEmpty) {\n    return '';\n  }\n\n  if (!isCustomProperty && typeof value === 'number' && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n    return value + 'px'; // Presumes implicit 'px' suffix for unitless numbers\n  }\n\n  return ('' + value).trim();\n}\n\nvar uppercasePattern = /([A-Z])/g;\nvar msPattern = /^ms-/;\n\n/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */\nfunction hyphenateStyleName(name) {\n  return name.replace(uppercasePattern, '-$1').toLowerCase().replace(msPattern, '-ms-');\n}\n\nvar warnValidStyle = function () {};\n\n{\n  // 'msTransform' is correct, but the other prefixes should be capitalized\n  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n  var msPattern$1 = /^-ms-/;\n  var hyphenPattern = /-(.)/g;\n\n  // style values shouldn't contain a semicolon\n  var badStyleValueWithSemicolonPattern = /;\\s*$/;\n\n  var warnedStyleNames = {};\n  var warnedStyleValues = {};\n  var warnedForNaNValue = false;\n  var warnedForInfinityValue = false;\n\n  var camelize = function (string) {\n    return string.replace(hyphenPattern, function (_, character) {\n      return character.toUpperCase();\n    });\n  };\n\n  var warnHyphenatedStyleName = function (name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning$1(false, 'Unsupported style property %s. Did you mean %s?', name,\n    // As Andi Smith suggests\n    // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n    // is converted to lowercase `ms`.\n    camelize(name.replace(msPattern$1, 'ms-')));\n  };\n\n  var warnBadVendoredStyleName = function (name) {\n    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n      return;\n    }\n\n    warnedStyleNames[name] = true;\n    warning$1(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1));\n  };\n\n  var warnStyleValueWithSemicolon = function (name, value) {\n    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n      return;\n    }\n\n    warnedStyleValues[value] = true;\n    warning$1(false, \"Style property values shouldn't contain a semicolon. \" + 'Try \"%s: %s\" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ''));\n  };\n\n  var warnStyleValueIsNaN = function (name, value) {\n    if (warnedForNaNValue) {\n      return;\n    }\n\n    warnedForNaNValue = true;\n    warning$1(false, '`NaN` is an invalid value for the `%s` css style property.', name);\n  };\n\n  var warnStyleValueIsInfinity = function (name, value) {\n    if (warnedForInfinityValue) {\n      return;\n    }\n\n    warnedForInfinityValue = true;\n    warning$1(false, '`Infinity` is an invalid value for the `%s` css style property.', name);\n  };\n\n  warnValidStyle = function (name, value) {\n    if (name.indexOf('-') > -1) {\n      warnHyphenatedStyleName(name);\n    } else if (badVendoredStyleNamePattern.test(name)) {\n      warnBadVendoredStyleName(name);\n    } else if (badStyleValueWithSemicolonPattern.test(value)) {\n      warnStyleValueWithSemicolon(name, value);\n    }\n\n    if (typeof value === 'number') {\n      if (isNaN(value)) {\n        warnStyleValueIsNaN(name, value);\n      } else if (!isFinite(value)) {\n        warnStyleValueIsInfinity(name, value);\n      }\n    }\n  };\n}\n\nvar warnValidStyle$1 = warnValidStyle;\n\n/**\n * Operations for dealing with CSS properties.\n */\n\n/**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */\nfunction createDangerousStringForStyles(styles) {\n  {\n    var serialized = '';\n    var delimiter = '';\n    for (var styleName in styles) {\n      if (!styles.hasOwnProperty(styleName)) {\n        continue;\n      }\n      var styleValue = styles[styleName];\n      if (styleValue != null) {\n        var isCustomProperty = styleName.indexOf('--') === 0;\n        serialized += delimiter + hyphenateStyleName(styleName) + ':';\n        serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n\n        delimiter = ';';\n      }\n    }\n    return serialized || null;\n  }\n}\n\n/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */\nfunction setValueForStyles(node, styles) {\n  var style = node.style;\n  for (var styleName in styles) {\n    if (!styles.hasOwnProperty(styleName)) {\n      continue;\n    }\n    var isCustomProperty = styleName.indexOf('--') === 0;\n    {\n      if (!isCustomProperty) {\n        warnValidStyle$1(styleName, styles[styleName]);\n      }\n    }\n    var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n    if (styleName === 'float') {\n      styleName = 'cssFloat';\n    }\n    if (isCustomProperty) {\n      style.setProperty(styleName, styleValue);\n    } else {\n      style[styleName] = styleValue;\n    }\n  }\n}\n\n// For HTML, certain tags should omit their close tag. We keep a whitelist for\n// those special-case tags.\n\nvar omittedCloseTags = {\n  area: true,\n  base: true,\n  br: true,\n  col: true,\n  embed: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n  // NOTE: menuitem's close tag should be omitted, but that causes problems.\n};\n\n// For HTML, certain tags cannot have children. This has the same purpose as\n// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\nvar voidElementTags = _assign({\n  menuitem: true\n}, omittedCloseTags);\n\n// TODO: We can remove this if we add invariantWithStack()\n// or add stack by default to invariants where possible.\nvar HTML$1 = '__html';\n\nvar ReactDebugCurrentFrame$2 = null;\n{\n  ReactDebugCurrentFrame$2 = ReactSharedInternals.ReactDebugCurrentFrame;\n}\n\nfunction assertValidProps(tag, props) {\n  if (!props) {\n    return;\n  }\n  // Note the use of `==` which checks for null or undefined.\n  if (voidElementTags[tag]) {\n    !(props.children == null && props.dangerouslySetInnerHTML == null) ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', tag, ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;\n  }\n  if (props.dangerouslySetInnerHTML != null) {\n    !(props.children == null) ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : void 0;\n    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML$1 in props.dangerouslySetInnerHTML) ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : void 0;\n  }\n  {\n    !(props.suppressContentEditableWarning || !props.contentEditable || props.children == null) ? warning$1(false, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;\n  }\n  !(props.style == null || typeof props.style === 'object') ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \\'em\\'}} when using JSX.%s', ReactDebugCurrentFrame$2.getStackAddendum()) : void 0;\n}\n\nfunction isCustomComponent(tagName, props) {\n  if (tagName.indexOf('-') === -1) {\n    return typeof props.is === 'string';\n  }\n  switch (tagName) {\n    // These are reserved SVG and MathML elements.\n    // We don't mind this whitelist too much because we expect it to never grow.\n    // The alternative is to track the namespace in a few places which is convoluted.\n    // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n    case 'annotation-xml':\n    case 'color-profile':\n    case 'font-face':\n    case 'font-face-src':\n    case 'font-face-uri':\n    case 'font-face-format':\n    case 'font-face-name':\n    case 'missing-glyph':\n      return false;\n    default:\n      return true;\n  }\n}\n\n// When adding attributes to the HTML or SVG whitelist, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames = {\n  // HTML\n  accept: 'accept',\n  acceptcharset: 'acceptCharset',\n  'accept-charset': 'acceptCharset',\n  accesskey: 'accessKey',\n  action: 'action',\n  allowfullscreen: 'allowFullScreen',\n  alt: 'alt',\n  as: 'as',\n  async: 'async',\n  autocapitalize: 'autoCapitalize',\n  autocomplete: 'autoComplete',\n  autocorrect: 'autoCorrect',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  autosave: 'autoSave',\n  capture: 'capture',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  challenge: 'challenge',\n  charset: 'charSet',\n  checked: 'checked',\n  children: 'children',\n  cite: 'cite',\n  class: 'className',\n  classid: 'classID',\n  classname: 'className',\n  cols: 'cols',\n  colspan: 'colSpan',\n  content: 'content',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  controls: 'controls',\n  controlslist: 'controlsList',\n  coords: 'coords',\n  crossorigin: 'crossOrigin',\n  dangerouslysetinnerhtml: 'dangerouslySetInnerHTML',\n  data: 'data',\n  datetime: 'dateTime',\n  default: 'default',\n  defaultchecked: 'defaultChecked',\n  defaultvalue: 'defaultValue',\n  defer: 'defer',\n  dir: 'dir',\n  disabled: 'disabled',\n  download: 'download',\n  draggable: 'draggable',\n  enctype: 'encType',\n  for: 'htmlFor',\n  form: 'form',\n  formmethod: 'formMethod',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  headers: 'headers',\n  height: 'height',\n  hidden: 'hidden',\n  high: 'high',\n  href: 'href',\n  hreflang: 'hrefLang',\n  htmlfor: 'htmlFor',\n  httpequiv: 'httpEquiv',\n  'http-equiv': 'httpEquiv',\n  icon: 'icon',\n  id: 'id',\n  innerhtml: 'innerHTML',\n  inputmode: 'inputMode',\n  integrity: 'integrity',\n  is: 'is',\n  itemid: 'itemID',\n  itemprop: 'itemProp',\n  itemref: 'itemRef',\n  itemscope: 'itemScope',\n  itemtype: 'itemType',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  kind: 'kind',\n  label: 'label',\n  lang: 'lang',\n  list: 'list',\n  loop: 'loop',\n  low: 'low',\n  manifest: 'manifest',\n  marginwidth: 'marginWidth',\n  marginheight: 'marginHeight',\n  max: 'max',\n  maxlength: 'maxLength',\n  media: 'media',\n  mediagroup: 'mediaGroup',\n  method: 'method',\n  min: 'min',\n  minlength: 'minLength',\n  multiple: 'multiple',\n  muted: 'muted',\n  name: 'name',\n  nomodule: 'noModule',\n  nonce: 'nonce',\n  novalidate: 'noValidate',\n  open: 'open',\n  optimum: 'optimum',\n  pattern: 'pattern',\n  placeholder: 'placeholder',\n  playsinline: 'playsInline',\n  poster: 'poster',\n  preload: 'preload',\n  profile: 'profile',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  referrerpolicy: 'referrerPolicy',\n  rel: 'rel',\n  required: 'required',\n  reversed: 'reversed',\n  role: 'role',\n  rows: 'rows',\n  rowspan: 'rowSpan',\n  sandbox: 'sandbox',\n  scope: 'scope',\n  scoped: 'scoped',\n  scrolling: 'scrolling',\n  seamless: 'seamless',\n  selected: 'selected',\n  shape: 'shape',\n  size: 'size',\n  sizes: 'sizes',\n  span: 'span',\n  spellcheck: 'spellCheck',\n  src: 'src',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  start: 'start',\n  step: 'step',\n  style: 'style',\n  summary: 'summary',\n  tabindex: 'tabIndex',\n  target: 'target',\n  title: 'title',\n  type: 'type',\n  usemap: 'useMap',\n  value: 'value',\n  width: 'width',\n  wmode: 'wmode',\n  wrap: 'wrap',\n\n  // SVG\n  about: 'about',\n  accentheight: 'accentHeight',\n  'accent-height': 'accentHeight',\n  accumulate: 'accumulate',\n  additive: 'additive',\n  alignmentbaseline: 'alignmentBaseline',\n  'alignment-baseline': 'alignmentBaseline',\n  allowreorder: 'allowReorder',\n  alphabetic: 'alphabetic',\n  amplitude: 'amplitude',\n  arabicform: 'arabicForm',\n  'arabic-form': 'arabicForm',\n  ascent: 'ascent',\n  attributename: 'attributeName',\n  attributetype: 'attributeType',\n  autoreverse: 'autoReverse',\n  azimuth: 'azimuth',\n  basefrequency: 'baseFrequency',\n  baselineshift: 'baselineShift',\n  'baseline-shift': 'baselineShift',\n  baseprofile: 'baseProfile',\n  bbox: 'bbox',\n  begin: 'begin',\n  bias: 'bias',\n  by: 'by',\n  calcmode: 'calcMode',\n  capheight: 'capHeight',\n  'cap-height': 'capHeight',\n  clip: 'clip',\n  clippath: 'clipPath',\n  'clip-path': 'clipPath',\n  clippathunits: 'clipPathUnits',\n  cliprule: 'clipRule',\n  'clip-rule': 'clipRule',\n  color: 'color',\n  colorinterpolation: 'colorInterpolation',\n  'color-interpolation': 'colorInterpolation',\n  colorinterpolationfilters: 'colorInterpolationFilters',\n  'color-interpolation-filters': 'colorInterpolationFilters',\n  colorprofile: 'colorProfile',\n  'color-profile': 'colorProfile',\n  colorrendering: 'colorRendering',\n  'color-rendering': 'colorRendering',\n  contentscripttype: 'contentScriptType',\n  contentstyletype: 'contentStyleType',\n  cursor: 'cursor',\n  cx: 'cx',\n  cy: 'cy',\n  d: 'd',\n  datatype: 'datatype',\n  decelerate: 'decelerate',\n  descent: 'descent',\n  diffuseconstant: 'diffuseConstant',\n  direction: 'direction',\n  display: 'display',\n  divisor: 'divisor',\n  dominantbaseline: 'dominantBaseline',\n  'dominant-baseline': 'dominantBaseline',\n  dur: 'dur',\n  dx: 'dx',\n  dy: 'dy',\n  edgemode: 'edgeMode',\n  elevation: 'elevation',\n  enablebackground: 'enableBackground',\n  'enable-background': 'enableBackground',\n  end: 'end',\n  exponent: 'exponent',\n  externalresourcesrequired: 'externalResourcesRequired',\n  fill: 'fill',\n  fillopacity: 'fillOpacity',\n  'fill-opacity': 'fillOpacity',\n  fillrule: 'fillRule',\n  'fill-rule': 'fillRule',\n  filter: 'filter',\n  filterres: 'filterRes',\n  filterunits: 'filterUnits',\n  floodopacity: 'floodOpacity',\n  'flood-opacity': 'floodOpacity',\n  floodcolor: 'floodColor',\n  'flood-color': 'floodColor',\n  focusable: 'focusable',\n  fontfamily: 'fontFamily',\n  'font-family': 'fontFamily',\n  fontsize: 'fontSize',\n  'font-size': 'fontSize',\n  fontsizeadjust: 'fontSizeAdjust',\n  'font-size-adjust': 'fontSizeAdjust',\n  fontstretch: 'fontStretch',\n  'font-stretch': 'fontStretch',\n  fontstyle: 'fontStyle',\n  'font-style': 'fontStyle',\n  fontvariant: 'fontVariant',\n  'font-variant': 'fontVariant',\n  fontweight: 'fontWeight',\n  'font-weight': 'fontWeight',\n  format: 'format',\n  from: 'from',\n  fx: 'fx',\n  fy: 'fy',\n  g1: 'g1',\n  g2: 'g2',\n  glyphname: 'glyphName',\n  'glyph-name': 'glyphName',\n  glyphorientationhorizontal: 'glyphOrientationHorizontal',\n  'glyph-orientation-horizontal': 'glyphOrientationHorizontal',\n  glyphorientationvertical: 'glyphOrientationVertical',\n  'glyph-orientation-vertical': 'glyphOrientationVertical',\n  glyphref: 'glyphRef',\n  gradienttransform: 'gradientTransform',\n  gradientunits: 'gradientUnits',\n  hanging: 'hanging',\n  horizadvx: 'horizAdvX',\n  'horiz-adv-x': 'horizAdvX',\n  horizoriginx: 'horizOriginX',\n  'horiz-origin-x': 'horizOriginX',\n  ideographic: 'ideographic',\n  imagerendering: 'imageRendering',\n  'image-rendering': 'imageRendering',\n  in2: 'in2',\n  in: 'in',\n  inlist: 'inlist',\n  intercept: 'intercept',\n  k1: 'k1',\n  k2: 'k2',\n  k3: 'k3',\n  k4: 'k4',\n  k: 'k',\n  kernelmatrix: 'kernelMatrix',\n  kernelunitlength: 'kernelUnitLength',\n  kerning: 'kerning',\n  keypoints: 'keyPoints',\n  keysplines: 'keySplines',\n  keytimes: 'keyTimes',\n  lengthadjust: 'lengthAdjust',\n  letterspacing: 'letterSpacing',\n  'letter-spacing': 'letterSpacing',\n  lightingcolor: 'lightingColor',\n  'lighting-color': 'lightingColor',\n  limitingconeangle: 'limitingConeAngle',\n  local: 'local',\n  markerend: 'markerEnd',\n  'marker-end': 'markerEnd',\n  markerheight: 'markerHeight',\n  markermid: 'markerMid',\n  'marker-mid': 'markerMid',\n  markerstart: 'markerStart',\n  'marker-start': 'markerStart',\n  markerunits: 'markerUnits',\n  markerwidth: 'markerWidth',\n  mask: 'mask',\n  maskcontentunits: 'maskContentUnits',\n  maskunits: 'maskUnits',\n  mathematical: 'mathematical',\n  mode: 'mode',\n  numoctaves: 'numOctaves',\n  offset: 'offset',\n  opacity: 'opacity',\n  operator: 'operator',\n  order: 'order',\n  orient: 'orient',\n  orientation: 'orientation',\n  origin: 'origin',\n  overflow: 'overflow',\n  overlineposition: 'overlinePosition',\n  'overline-position': 'overlinePosition',\n  overlinethickness: 'overlineThickness',\n  'overline-thickness': 'overlineThickness',\n  paintorder: 'paintOrder',\n  'paint-order': 'paintOrder',\n  panose1: 'panose1',\n  'panose-1': 'panose1',\n  pathlength: 'pathLength',\n  patterncontentunits: 'patternContentUnits',\n  patterntransform: 'patternTransform',\n  patternunits: 'patternUnits',\n  pointerevents: 'pointerEvents',\n  'pointer-events': 'pointerEvents',\n  points: 'points',\n  pointsatx: 'pointsAtX',\n  pointsaty: 'pointsAtY',\n  pointsatz: 'pointsAtZ',\n  prefix: 'prefix',\n  preservealpha: 'preserveAlpha',\n  preserveaspectratio: 'preserveAspectRatio',\n  primitiveunits: 'primitiveUnits',\n  property: 'property',\n  r: 'r',\n  radius: 'radius',\n  refx: 'refX',\n  refy: 'refY',\n  renderingintent: 'renderingIntent',\n  'rendering-intent': 'renderingIntent',\n  repeatcount: 'repeatCount',\n  repeatdur: 'repeatDur',\n  requiredextensions: 'requiredExtensions',\n  requiredfeatures: 'requiredFeatures',\n  resource: 'resource',\n  restart: 'restart',\n  result: 'result',\n  results: 'results',\n  rotate: 'rotate',\n  rx: 'rx',\n  ry: 'ry',\n  scale: 'scale',\n  security: 'security',\n  seed: 'seed',\n  shaperendering: 'shapeRendering',\n  'shape-rendering': 'shapeRendering',\n  slope: 'slope',\n  spacing: 'spacing',\n  specularconstant: 'specularConstant',\n  specularexponent: 'specularExponent',\n  speed: 'speed',\n  spreadmethod: 'spreadMethod',\n  startoffset: 'startOffset',\n  stddeviation: 'stdDeviation',\n  stemh: 'stemh',\n  stemv: 'stemv',\n  stitchtiles: 'stitchTiles',\n  stopcolor: 'stopColor',\n  'stop-color': 'stopColor',\n  stopopacity: 'stopOpacity',\n  'stop-opacity': 'stopOpacity',\n  strikethroughposition: 'strikethroughPosition',\n  'strikethrough-position': 'strikethroughPosition',\n  strikethroughthickness: 'strikethroughThickness',\n  'strikethrough-thickness': 'strikethroughThickness',\n  string: 'string',\n  stroke: 'stroke',\n  strokedasharray: 'strokeDasharray',\n  'stroke-dasharray': 'strokeDasharray',\n  strokedashoffset: 'strokeDashoffset',\n  'stroke-dashoffset': 'strokeDashoffset',\n  strokelinecap: 'strokeLinecap',\n  'stroke-linecap': 'strokeLinecap',\n  strokelinejoin: 'strokeLinejoin',\n  'stroke-linejoin': 'strokeLinejoin',\n  strokemiterlimit: 'strokeMiterlimit',\n  'stroke-miterlimit': 'strokeMiterlimit',\n  strokewidth: 'strokeWidth',\n  'stroke-width': 'strokeWidth',\n  strokeopacity: 'strokeOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  suppresscontenteditablewarning: 'suppressContentEditableWarning',\n  suppresshydrationwarning: 'suppressHydrationWarning',\n  surfacescale: 'surfaceScale',\n  systemlanguage: 'systemLanguage',\n  tablevalues: 'tableValues',\n  targetx: 'targetX',\n  targety: 'targetY',\n  textanchor: 'textAnchor',\n  'text-anchor': 'textAnchor',\n  textdecoration: 'textDecoration',\n  'text-decoration': 'textDecoration',\n  textlength: 'textLength',\n  textrendering: 'textRendering',\n  'text-rendering': 'textRendering',\n  to: 'to',\n  transform: 'transform',\n  typeof: 'typeof',\n  u1: 'u1',\n  u2: 'u2',\n  underlineposition: 'underlinePosition',\n  'underline-position': 'underlinePosition',\n  underlinethickness: 'underlineThickness',\n  'underline-thickness': 'underlineThickness',\n  unicode: 'unicode',\n  unicodebidi: 'unicodeBidi',\n  'unicode-bidi': 'unicodeBidi',\n  unicoderange: 'unicodeRange',\n  'unicode-range': 'unicodeRange',\n  unitsperem: 'unitsPerEm',\n  'units-per-em': 'unitsPerEm',\n  unselectable: 'unselectable',\n  valphabetic: 'vAlphabetic',\n  'v-alphabetic': 'vAlphabetic',\n  values: 'values',\n  vectoreffect: 'vectorEffect',\n  'vector-effect': 'vectorEffect',\n  version: 'version',\n  vertadvy: 'vertAdvY',\n  'vert-adv-y': 'vertAdvY',\n  vertoriginx: 'vertOriginX',\n  'vert-origin-x': 'vertOriginX',\n  vertoriginy: 'vertOriginY',\n  'vert-origin-y': 'vertOriginY',\n  vhanging: 'vHanging',\n  'v-hanging': 'vHanging',\n  videographic: 'vIdeographic',\n  'v-ideographic': 'vIdeographic',\n  viewbox: 'viewBox',\n  viewtarget: 'viewTarget',\n  visibility: 'visibility',\n  vmathematical: 'vMathematical',\n  'v-mathematical': 'vMathematical',\n  vocab: 'vocab',\n  widths: 'widths',\n  wordspacing: 'wordSpacing',\n  'word-spacing': 'wordSpacing',\n  writingmode: 'writingMode',\n  'writing-mode': 'writingMode',\n  x1: 'x1',\n  x2: 'x2',\n  x: 'x',\n  xchannelselector: 'xChannelSelector',\n  xheight: 'xHeight',\n  'x-height': 'xHeight',\n  xlinkactuate: 'xlinkActuate',\n  'xlink:actuate': 'xlinkActuate',\n  xlinkarcrole: 'xlinkArcrole',\n  'xlink:arcrole': 'xlinkArcrole',\n  xlinkhref: 'xlinkHref',\n  'xlink:href': 'xlinkHref',\n  xlinkrole: 'xlinkRole',\n  'xlink:role': 'xlinkRole',\n  xlinkshow: 'xlinkShow',\n  'xlink:show': 'xlinkShow',\n  xlinktitle: 'xlinkTitle',\n  'xlink:title': 'xlinkTitle',\n  xlinktype: 'xlinkType',\n  'xlink:type': 'xlinkType',\n  xmlbase: 'xmlBase',\n  'xml:base': 'xmlBase',\n  xmllang: 'xmlLang',\n  'xml:lang': 'xmlLang',\n  xmlns: 'xmlns',\n  'xml:space': 'xmlSpace',\n  xmlnsxlink: 'xmlnsXlink',\n  'xmlns:xlink': 'xmlnsXlink',\n  xmlspace: 'xmlSpace',\n  y1: 'y1',\n  y2: 'y2',\n  y: 'y',\n  ychannelselector: 'yChannelSelector',\n  z: 'z',\n  zoomandpan: 'zoomAndPan'\n};\n\nvar ariaProperties = {\n  'aria-current': 0, // state\n  'aria-details': 0,\n  'aria-disabled': 0, // state\n  'aria-hidden': 0, // state\n  'aria-invalid': 0, // state\n  'aria-keyshortcuts': 0,\n  'aria-label': 0,\n  'aria-roledescription': 0,\n  // Widget Attributes\n  'aria-autocomplete': 0,\n  'aria-checked': 0,\n  'aria-expanded': 0,\n  'aria-haspopup': 0,\n  'aria-level': 0,\n  'aria-modal': 0,\n  'aria-multiline': 0,\n  'aria-multiselectable': 0,\n  'aria-orientation': 0,\n  'aria-placeholder': 0,\n  'aria-pressed': 0,\n  'aria-readonly': 0,\n  'aria-required': 0,\n  'aria-selected': 0,\n  'aria-sort': 0,\n  'aria-valuemax': 0,\n  'aria-valuemin': 0,\n  'aria-valuenow': 0,\n  'aria-valuetext': 0,\n  // Live Region Attributes\n  'aria-atomic': 0,\n  'aria-busy': 0,\n  'aria-live': 0,\n  'aria-relevant': 0,\n  // Drag-and-Drop Attributes\n  'aria-dropeffect': 0,\n  'aria-grabbed': 0,\n  // Relationship Attributes\n  'aria-activedescendant': 0,\n  'aria-colcount': 0,\n  'aria-colindex': 0,\n  'aria-colspan': 0,\n  'aria-controls': 0,\n  'aria-describedby': 0,\n  'aria-errormessage': 0,\n  'aria-flowto': 0,\n  'aria-labelledby': 0,\n  'aria-owns': 0,\n  'aria-posinset': 0,\n  'aria-rowcount': 0,\n  'aria-rowindex': 0,\n  'aria-rowspan': 0,\n  'aria-setsize': 0\n};\n\nvar warnedProperties = {};\nvar rARIA = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\nvar rARIACamel = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\nvar hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\nfunction validateProperty(tagName, name) {\n  if (hasOwnProperty$2.call(warnedProperties, name) && warnedProperties[name]) {\n    return true;\n  }\n\n  if (rARIACamel.test(name)) {\n    var ariaName = 'aria-' + name.slice(4).toLowerCase();\n    var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (correctName == null) {\n      warning$1(false, 'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.', name);\n      warnedProperties[name] = true;\n      return true;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== correctName) {\n      warning$1(false, 'Invalid ARIA attribute `%s`. Did you mean `%s`?', name, correctName);\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  if (rARIA.test(name)) {\n    var lowerCasedName = name.toLowerCase();\n    var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n\n    // If this is an aria-* attribute, but is not listed in the known DOM\n    // DOM properties, then it is an invalid aria-* attribute.\n    if (standardName == null) {\n      warnedProperties[name] = true;\n      return false;\n    }\n    // aria-* attributes should be lowercase; suggest the lowercase version.\n    if (name !== standardName) {\n      warning$1(false, 'Unknown ARIA attribute `%s`. Did you mean `%s`?', name, standardName);\n      warnedProperties[name] = true;\n      return true;\n    }\n  }\n\n  return true;\n}\n\nfunction warnInvalidARIAProps(type, props) {\n  var invalidProps = [];\n\n  for (var key in props) {\n    var isValid = validateProperty(type, key);\n    if (!isValid) {\n      invalidProps.push(key);\n    }\n  }\n\n  var unknownPropString = invalidProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n\n  if (invalidProps.length === 1) {\n    warning$1(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);\n  } else if (invalidProps.length > 1) {\n    warning$1(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop', unknownPropString, type);\n  }\n}\n\nfunction validateProperties(type, props) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnInvalidARIAProps(type, props);\n}\n\nvar didWarnValueNull = false;\n\nfunction validateProperties$1(type, props) {\n  if (type !== 'input' && type !== 'textarea' && type !== 'select') {\n    return;\n  }\n\n  if (props != null && props.value === null && !didWarnValueNull) {\n    didWarnValueNull = true;\n    if (type === 'select' && props.multiple) {\n      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty array when `multiple` is set to `true` ' + 'to clear the component or `undefined` for uncontrolled components.', type);\n    } else {\n      warning$1(false, '`value` prop on `%s` should not be null. ' + 'Consider using an empty string to clear the component or `undefined` ' + 'for uncontrolled components.', type);\n    }\n  }\n}\n\nvar validateProperty$1 = function () {};\n\n{\n  var warnedProperties$1 = {};\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n  var EVENT_NAME_REGEX = /^on./;\n  var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n  var rARIA$1 = new RegExp('^(aria)-[' + ATTRIBUTE_NAME_CHAR + ']*$');\n  var rARIACamel$1 = new RegExp('^(aria)[A-Z][' + ATTRIBUTE_NAME_CHAR + ']*$');\n\n  validateProperty$1 = function (tagName, name, value, canUseEventSystem) {\n    if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n      return true;\n    }\n\n    var lowerCasedName = name.toLowerCase();\n    if (lowerCasedName === 'onfocusin' || lowerCasedName === 'onfocusout') {\n      warning$1(false, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // We can't rely on the event system being injected on the server.\n    if (canUseEventSystem) {\n      if (registrationNameModules.hasOwnProperty(name)) {\n        return true;\n      }\n      var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;\n      if (registrationName != null) {\n        warning$1(false, 'Invalid event handler property `%s`. Did you mean `%s`?', name, registrationName);\n        warnedProperties$1[name] = true;\n        return true;\n      }\n      if (EVENT_NAME_REGEX.test(name)) {\n        warning$1(false, 'Unknown event handler property `%s`. It will be ignored.', name);\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (EVENT_NAME_REGEX.test(name)) {\n      // If no event plugins have been injected, we are in a server environment.\n      // So we can't tell if the event name is correct for sure, but we can filter\n      // out known bad ones like `onclick`. We can't suggest a specific replacement though.\n      if (INVALID_EVENT_NAME_REGEX.test(name)) {\n        warning$1(false, 'Invalid event handler property `%s`. ' + 'React events use the camelCase naming convention, for example `onClick`.', name);\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Let the ARIA attribute hook validate ARIA attributes\n    if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n      return true;\n    }\n\n    if (lowerCasedName === 'innerhtml') {\n      warning$1(false, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'aria') {\n      warning$1(false, 'The `aria` attribute is reserved for future use in React. ' + 'Pass individual `aria-` attributes instead.');\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (lowerCasedName === 'is' && value !== null && value !== undefined && typeof value !== 'string') {\n      warning$1(false, 'Received a `%s` for a string attribute `is`. If this is expected, cast ' + 'the value to a string.', typeof value);\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'number' && isNaN(value)) {\n      warning$1(false, 'Received NaN for the `%s` attribute. If this is expected, cast ' + 'the value to a string.', name);\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    var propertyInfo = getPropertyInfo(name);\n    var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\n\n    // Known attributes should match the casing specified in the property config.\n    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      var standardName = possibleStandardNames[lowerCasedName];\n      if (standardName !== name) {\n        warning$1(false, 'Invalid DOM property `%s`. Did you mean `%s`?', name, standardName);\n        warnedProperties$1[name] = true;\n        return true;\n      }\n    } else if (!isReserved && name !== lowerCasedName) {\n      // Unknown attributes should have lowercase casing since that's how they\n      // will be cased anyway with server rendering.\n      warning$1(false, 'React does not recognize the `%s` prop on a DOM element. If you ' + 'intentionally want it to appear in the DOM as a custom ' + 'attribute, spell it as lowercase `%s` instead. ' + 'If you accidentally passed it from a parent component, remove ' + 'it from the DOM element.', name, lowerCasedName);\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    if (typeof value === 'boolean' && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      if (value) {\n        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n      } else {\n        warning$1(false, 'Received `%s` for a non-boolean attribute `%s`.\\n\\n' + 'If you want to write it to the DOM, pass a string instead: ' + '%s=\"%s\" or %s={value.toString()}.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);\n      }\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    // Now that we've validated casing, do not validate\n    // data types for reserved props\n    if (isReserved) {\n      return true;\n    }\n\n    // Warn when a known attribute is a bad type\n    if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n      warnedProperties$1[name] = true;\n      return false;\n    }\n\n    // Warn when passing the strings 'false' or 'true' into a boolean prop\n    if ((value === 'false' || value === 'true') && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\n      warning$1(false, 'Received the string `%s` for the boolean attribute `%s`. ' + '%s ' + 'Did you mean %s={%s}?', value, name, value === 'false' ? 'The browser will interpret it as a truthy value.' : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n      warnedProperties$1[name] = true;\n      return true;\n    }\n\n    return true;\n  };\n}\n\nvar warnUnknownProperties = function (type, props, canUseEventSystem) {\n  var unknownProps = [];\n  for (var key in props) {\n    var isValid = validateProperty$1(type, key, props[key], canUseEventSystem);\n    if (!isValid) {\n      unknownProps.push(key);\n    }\n  }\n\n  var unknownPropString = unknownProps.map(function (prop) {\n    return '`' + prop + '`';\n  }).join(', ');\n  if (unknownProps.length === 1) {\n    warning$1(false, 'Invalid value for prop %s on <%s> tag. Either remove it from the element, ' + 'or pass a string or number value to keep it in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);\n  } else if (unknownProps.length > 1) {\n    warning$1(false, 'Invalid values for props %s on <%s> tag. Either remove them from the element, ' + 'or pass a string or number value to keep them in the DOM. ' + 'For details, see https://fb.me/react-attribute-behavior', unknownPropString, type);\n  }\n};\n\nfunction validateProperties$2(type, props, canUseEventSystem) {\n  if (isCustomComponent(type, props)) {\n    return;\n  }\n  warnUnknownProperties(type, props, canUseEventSystem);\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar didWarnInvalidHydration = false;\nvar didWarnShadyDOM = false;\n\nvar DANGEROUSLY_SET_INNER_HTML = 'dangerouslySetInnerHTML';\nvar SUPPRESS_CONTENT_EDITABLE_WARNING = 'suppressContentEditableWarning';\nvar SUPPRESS_HYDRATION_WARNING$1 = 'suppressHydrationWarning';\nvar AUTOFOCUS = 'autoFocus';\nvar CHILDREN = 'children';\nvar STYLE = 'style';\nvar HTML = '__html';\n\nvar HTML_NAMESPACE = Namespaces.html;\n\n\nvar warnedUnknownTags = void 0;\nvar suppressHydrationWarning = void 0;\n\nvar validatePropertiesInDevelopment = void 0;\nvar warnForTextDifference = void 0;\nvar warnForPropDifference = void 0;\nvar warnForExtraAttributes = void 0;\nvar warnForInvalidEventListener = void 0;\nvar canDiffStyleForHydrationWarning = void 0;\n\nvar normalizeMarkupForTextOrAttribute = void 0;\nvar normalizeHTML = void 0;\n\n{\n  warnedUnknownTags = {\n    // Chrome is the only major browser not shipping <time>. But as of July\n    // 2017 it intends to ship it due to widespread usage. We intentionally\n    // *don't* warn for <time> even if it's unrecognized by Chrome because\n    // it soon will be, and many apps have been using it anyway.\n    time: true,\n    // There are working polyfills for <dialog>. Let people use it.\n    dialog: true,\n    // Electron ships a custom <webview> tag to display external web content in\n    // an isolated frame and process.\n    // This tag is not present in non Electron environments such as JSDom which\n    // is often used for testing purposes.\n    // @see https://electronjs.org/docs/api/webview-tag\n    webview: true\n  };\n\n  validatePropertiesInDevelopment = function (type, props) {\n    validateProperties(type, props);\n    validateProperties$1(type, props);\n    validateProperties$2(type, props, /* canUseEventSystem */true);\n  };\n\n  // IE 11 parses & normalizes the style attribute as opposed to other\n  // browsers. It adds spaces and sorts the properties in some\n  // non-alphabetical order. Handling that would require sorting CSS\n  // properties in the client & server versions or applying\n  // `expectedStyle` to a temporary DOM node to read its `style` attribute\n  // normalized. Since it only affects IE, we're skipping style warnings\n  // in that browser completely in favor of doing all that work.\n  // See https://github.com/facebook/react/issues/11807\n  canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;\n\n  // HTML parsing normalizes CR and CRLF to LF.\n  // It also can turn \\u0000 into \\uFFFD inside attributes.\n  // https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n  // If we have a mismatch, it might be caused by that.\n  // We will still patch up in this case but not fire the warning.\n  var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n  var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n\n  normalizeMarkupForTextOrAttribute = function (markup) {\n    var markupString = typeof markup === 'string' ? markup : '' + markup;\n    return markupString.replace(NORMALIZE_NEWLINES_REGEX, '\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, '');\n  };\n\n  warnForTextDifference = function (serverText, clientText) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n    var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n    if (normalizedServerText === normalizedClientText) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n  };\n\n  warnForPropDifference = function (propName, serverValue, clientValue) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n    var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n    if (normalizedServerValue === normalizedClientValue) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Prop `%s` did not match. Server: %s Client: %s', propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n  };\n\n  warnForExtraAttributes = function (attributeNames) {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    var names = [];\n    attributeNames.forEach(function (name) {\n      names.push(name);\n    });\n    warningWithoutStack$1(false, 'Extra attributes from the server: %s', names);\n  };\n\n  warnForInvalidEventListener = function (registrationName, listener) {\n    if (listener === false) {\n      warning$1(false, 'Expected `%s` listener to be a function, instead got `false`.\\n\\n' + 'If you used to conditionally omit it with %s={condition && value}, ' + 'pass %s={condition ? value : undefined} instead.', registrationName, registrationName, registrationName);\n    } else {\n      warning$1(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener);\n    }\n  };\n\n  // Parse the HTML and read it back to normalize the HTML string so that it\n  // can be used for comparison.\n  normalizeHTML = function (parent, html) {\n    // We could have created a separate document here to avoid\n    // re-initializing custom elements if they exist. But this breaks\n    // how <noscript> is being handled. So we use the same document.\n    // See the discussion in https://github.com/facebook/react/pull/11157.\n    var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n    testElement.innerHTML = html;\n    return testElement.innerHTML;\n  };\n}\n\nfunction ensureListeningTo(rootContainerElement, registrationName) {\n  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;\n  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;\n  listenTo(registrationName, doc);\n}\n\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n}\n\nfunction noop() {}\n\nfunction trapClickOnNonInteractiveElement(node) {\n  // Mobile Safari does not fire properly bubble click events on\n  // non-interactive elements, which means delegated click listeners do not\n  // fire. The workaround for this bug involves attaching an empty click\n  // listener on the target node.\n  // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n  // Just set it using the onclick property so that we don't have to manage any\n  // bookkeeping for it. Not sure if we need to clear it when the listener is\n  // removed.\n  // TODO: Only do this for the relevant Safaris maybe?\n  node.onclick = noop;\n}\n\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n  for (var propKey in nextProps) {\n    if (!nextProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = nextProps[propKey];\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      // Relies on `updateStylesByID` not mutating `styleUpdates`.\n      setValueForStyles(domElement, nextProp);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      if (nextHtml != null) {\n        setInnerHTML(domElement, nextHtml);\n      }\n    } else if (propKey === CHILDREN) {\n      if (typeof nextProp === 'string') {\n        // Avoid setting initial textContent when the text is empty. In IE11 setting\n        // textContent on a <textarea> will cause the placeholder to not\n        // show within the <textarea> until it has been focused and blurred again.\n        // https://github.com/facebook/react/issues/6731#issuecomment-254874553\n        var canSetTextContent = tag !== 'textarea' || nextProp !== '';\n        if (canSetTextContent) {\n          setTextContent(domElement, nextProp);\n        }\n      } else if (typeof nextProp === 'number') {\n        setTextContent(domElement, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // We polyfill it separately on the client during commit.\n      // We could have excluded it in the property list instead of\n      // adding a special case here, but then it wouldn't be emitted\n      // on server rendering (but we *do* want to emit it in SSR).\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (nextProp != null) {\n      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\n    }\n  }\n}\n\nfunction updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n  // TODO: Handle wasCustomComponentTag\n  for (var i = 0; i < updatePayload.length; i += 2) {\n    var propKey = updatePayload[i];\n    var propValue = updatePayload[i + 1];\n    if (propKey === STYLE) {\n      setValueForStyles(domElement, propValue);\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      setInnerHTML(domElement, propValue);\n    } else if (propKey === CHILDREN) {\n      setTextContent(domElement, propValue);\n    } else {\n      setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n    }\n  }\n}\n\nfunction createElement(type, props, rootContainerElement, parentNamespace) {\n  var isCustomComponentTag = void 0;\n\n  // We create tags in the namespace of their parent container, except HTML\n  // tags get no namespace.\n  var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n  var domElement = void 0;\n  var namespaceURI = parentNamespace;\n  if (namespaceURI === HTML_NAMESPACE) {\n    namespaceURI = getIntrinsicNamespace(type);\n  }\n  if (namespaceURI === HTML_NAMESPACE) {\n    {\n      isCustomComponentTag = isCustomComponent(type, props);\n      // Should this check be gated by parent namespace? Not sure we want to\n      // allow <SVG> or <mATH>.\n      !(isCustomComponentTag || type === type.toLowerCase()) ? warning$1(false, '<%s /> is using incorrect casing. ' + 'Use PascalCase for React components, ' + 'or lowercase for HTML elements.', type) : void 0;\n    }\n\n    if (type === 'script') {\n      // Create the script via .innerHTML so its \"parser-inserted\" flag is\n      // set to true and it does not execute\n      var div = ownerDocument.createElement('div');\n      div.innerHTML = '<script><' + '/script>'; // eslint-disable-line\n      // This is guaranteed to yield a script element.\n      var firstChild = div.firstChild;\n      domElement = div.removeChild(firstChild);\n    } else if (typeof props.is === 'string') {\n      // $FlowIssue `createElement` should be updated for Web Components\n      domElement = ownerDocument.createElement(type, { is: props.is });\n    } else {\n      // Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n      // See discussion in https://github.com/facebook/react/pull/6896\n      // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n      domElement = ownerDocument.createElement(type);\n      // Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple`\n      // attribute on `select`s needs to be added before `option`s are inserted. This prevents\n      // a bug where the `select` does not scroll to the correct option because singular\n      // `select` elements automatically pick the first item.\n      // See https://github.com/facebook/react/issues/13222\n      if (type === 'select' && props.multiple) {\n        var node = domElement;\n        node.multiple = true;\n      }\n    }\n  } else {\n    domElement = ownerDocument.createElementNS(namespaceURI, type);\n  }\n\n  {\n    if (namespaceURI === HTML_NAMESPACE) {\n      if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === '[object HTMLUnknownElement]' && !Object.prototype.hasOwnProperty.call(warnedUnknownTags, type)) {\n        warnedUnknownTags[type] = true;\n        warning$1(false, 'The tag <%s> is unrecognized in this browser. ' + 'If you meant to render a React component, start its name with ' + 'an uppercase letter.', type);\n      }\n    }\n  }\n\n  return domElement;\n}\n\nfunction createTextNode(text, rootContainerElement) {\n  return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n}\n\nfunction setInitialProperties(domElement, tag, rawProps, rootContainerElement) {\n  var isCustomComponentTag = isCustomComponent(tag, rawProps);\n  {\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning$1(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerNameInDevOrNull() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  var props = void 0;\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent(TOP_LOAD, domElement);\n      props = rawProps;\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var i = 0; i < mediaEventTypes.length; i++) {\n        trapBubbledEvent(mediaEventTypes[i], domElement);\n      }\n      props = rawProps;\n      break;\n    case 'source':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      props = rawProps;\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      trapBubbledEvent(TOP_LOAD, domElement);\n      props = rawProps;\n      break;\n    case 'form':\n      trapBubbledEvent(TOP_RESET, domElement);\n      trapBubbledEvent(TOP_SUBMIT, domElement);\n      props = rawProps;\n      break;\n    case 'details':\n      trapBubbledEvent(TOP_TOGGLE, domElement);\n      props = rawProps;\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      props = getHostProps(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      props = getHostProps$1(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      props = getHostProps$2(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      props = getHostProps$3(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    default:\n      props = rawProps;\n  }\n\n  assertValidProps(tag, props);\n\n  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps, false);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'option':\n      postMountWrapper$1(domElement, rawProps);\n      break;\n    case 'select':\n      postMountWrapper$2(domElement, rawProps);\n      break;\n    default:\n      if (typeof props.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n}\n\n// Calculate the diff between the two objects.\nfunction diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n  {\n    validatePropertiesInDevelopment(tag, nextRawProps);\n  }\n\n  var updatePayload = null;\n\n  var lastProps = void 0;\n  var nextProps = void 0;\n  switch (tag) {\n    case 'input':\n      lastProps = getHostProps(domElement, lastRawProps);\n      nextProps = getHostProps(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'option':\n      lastProps = getHostProps$1(domElement, lastRawProps);\n      nextProps = getHostProps$1(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'select':\n      lastProps = getHostProps$2(domElement, lastRawProps);\n      nextProps = getHostProps$2(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    case 'textarea':\n      lastProps = getHostProps$3(domElement, lastRawProps);\n      nextProps = getHostProps$3(domElement, nextRawProps);\n      updatePayload = [];\n      break;\n    default:\n      lastProps = lastRawProps;\n      nextProps = nextRawProps;\n      if (typeof lastProps.onClick !== 'function' && typeof nextProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  assertValidProps(tag, nextProps);\n\n  var propKey = void 0;\n  var styleName = void 0;\n  var styleUpdates = null;\n  for (propKey in lastProps) {\n    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      var lastStyle = lastProps[propKey];\n      for (styleName in lastStyle) {\n        if (lastStyle.hasOwnProperty(styleName)) {\n          if (!styleUpdates) {\n            styleUpdates = {};\n          }\n          styleUpdates[styleName] = '';\n        }\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {\n      // Noop. This is handled by the clear text mechanism.\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (propKey === AUTOFOCUS) {\n      // Noop. It doesn't work on updates anyway.\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      // This is a special case. If any listener updates we need to ensure\n      // that the \"current\" fiber pointer gets updated so we need a commit\n      // to update this element.\n      if (!updatePayload) {\n        updatePayload = [];\n      }\n    } else {\n      // For all other deleted properties we add it to the queue. We use\n      // the whitelist in the commit phase instead.\n      (updatePayload = updatePayload || []).push(propKey, null);\n    }\n  }\n  for (propKey in nextProps) {\n    var nextProp = nextProps[propKey];\n    var lastProp = lastProps != null ? lastProps[propKey] : undefined;\n    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n      continue;\n    }\n    if (propKey === STYLE) {\n      {\n        if (nextProp) {\n          // Freeze the next style object so that we can assume it won't be\n          // mutated. We have already warned for this in the past.\n          Object.freeze(nextProp);\n        }\n      }\n      if (lastProp) {\n        // Unset styles on `lastProp` but not on `nextProp`.\n        for (styleName in lastProp) {\n          if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = '';\n          }\n        }\n        // Update styles that changed since `lastProp`.\n        for (styleName in nextProp) {\n          if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n            if (!styleUpdates) {\n              styleUpdates = {};\n            }\n            styleUpdates[styleName] = nextProp[styleName];\n          }\n        }\n      } else {\n        // Relies on `updateStylesByID` not mutating `styleUpdates`.\n        if (!styleUpdates) {\n          if (!updatePayload) {\n            updatePayload = [];\n          }\n          updatePayload.push(propKey, styleUpdates);\n        }\n        styleUpdates = nextProp;\n      }\n    } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n      var nextHtml = nextProp ? nextProp[HTML] : undefined;\n      var lastHtml = lastProp ? lastProp[HTML] : undefined;\n      if (nextHtml != null) {\n        if (lastHtml !== nextHtml) {\n          (updatePayload = updatePayload || []).push(propKey, '' + nextHtml);\n        }\n      } else {\n        // TODO: It might be too late to clear this if we have children\n        // inserted already.\n      }\n    } else if (propKey === CHILDREN) {\n      if (lastProp !== nextProp && (typeof nextProp === 'string' || typeof nextProp === 'number')) {\n        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);\n      }\n    } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1) {\n      // Noop\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        // We eagerly listen to this even though we haven't committed yet.\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n      if (!updatePayload && lastProp !== nextProp) {\n        // This is a special case. If any listener updates we need to ensure\n        // that the \"current\" props pointer gets updated so we need a commit\n        // to update this element.\n        updatePayload = [];\n      }\n    } else {\n      // For any other property we always add it to the queue and then we\n      // filter it out using the whitelist during the commit.\n      (updatePayload = updatePayload || []).push(propKey, nextProp);\n    }\n  }\n  if (styleUpdates) {\n    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n  }\n  return updatePayload;\n}\n\n// Apply the diff.\nfunction updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n  // Update checked *before* name.\n  // In the middle of an update, it is possible to have multiple checked.\n  // When a checked radio tries to change name, browser makes another radio's checked false.\n  if (tag === 'input' && nextRawProps.type === 'radio' && nextRawProps.name != null) {\n    updateChecked(domElement, nextRawProps);\n  }\n\n  var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n  var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n  // Apply the diff.\n  updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n\n  // TODO: Ensure that an update gets scheduled if any of the special props\n  // changed.\n  switch (tag) {\n    case 'input':\n      // Update the wrapper around inputs *after* updating props. This has to\n      // happen after `updateDOMProperties`. Otherwise HTML5 input validations\n      // raise warnings and prevent the new value from being assigned.\n      updateWrapper(domElement, nextRawProps);\n      break;\n    case 'textarea':\n      updateWrapper$1(domElement, nextRawProps);\n      break;\n    case 'select':\n      // <select> value update needs to occur after <option> children\n      // reconciliation\n      postUpdateWrapper(domElement, nextRawProps);\n      break;\n  }\n}\n\nfunction getPossibleStandardName(propName) {\n  {\n    var lowerCasedName = propName.toLowerCase();\n    if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n      return null;\n    }\n    return possibleStandardNames[lowerCasedName] || null;\n  }\n  return null;\n}\n\nfunction diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement) {\n  var isCustomComponentTag = void 0;\n  var extraAttributeNames = void 0;\n\n  {\n    suppressHydrationWarning = rawProps[SUPPRESS_HYDRATION_WARNING$1] === true;\n    isCustomComponentTag = isCustomComponent(tag, rawProps);\n    validatePropertiesInDevelopment(tag, rawProps);\n    if (isCustomComponentTag && !didWarnShadyDOM && domElement.shadyRoot) {\n      warning$1(false, '%s is using shady DOM. Using shady DOM with React can ' + 'cause things to break subtly.', getCurrentFiberOwnerNameInDevOrNull() || 'A component');\n      didWarnShadyDOM = true;\n    }\n  }\n\n  // TODO: Make sure that we check isMounted before firing any of these events.\n  switch (tag) {\n    case 'iframe':\n    case 'object':\n      trapBubbledEvent(TOP_LOAD, domElement);\n      break;\n    case 'video':\n    case 'audio':\n      // Create listener for each media event\n      for (var i = 0; i < mediaEventTypes.length; i++) {\n        trapBubbledEvent(mediaEventTypes[i], domElement);\n      }\n      break;\n    case 'source':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      break;\n    case 'img':\n    case 'image':\n    case 'link':\n      trapBubbledEvent(TOP_ERROR, domElement);\n      trapBubbledEvent(TOP_LOAD, domElement);\n      break;\n    case 'form':\n      trapBubbledEvent(TOP_RESET, domElement);\n      trapBubbledEvent(TOP_SUBMIT, domElement);\n      break;\n    case 'details':\n      trapBubbledEvent(TOP_TOGGLE, domElement);\n      break;\n    case 'input':\n      initWrapperState(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'option':\n      validateProps(domElement, rawProps);\n      break;\n    case 'select':\n      initWrapperState$1(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n    case 'textarea':\n      initWrapperState$2(domElement, rawProps);\n      trapBubbledEvent(TOP_INVALID, domElement);\n      // For controlled components we always need to ensure we're listening\n      // to onChange. Even if there is no listener.\n      ensureListeningTo(rootContainerElement, 'onChange');\n      break;\n  }\n\n  assertValidProps(tag, rawProps);\n\n  {\n    extraAttributeNames = new Set();\n    var attributes = domElement.attributes;\n    for (var _i = 0; _i < attributes.length; _i++) {\n      var name = attributes[_i].name.toLowerCase();\n      switch (name) {\n        // Built-in SSR attribute is whitelisted\n        case 'data-reactroot':\n          break;\n        // Controlled attributes are not validated\n        // TODO: Only ignore them on controlled tags.\n        case 'value':\n          break;\n        case 'checked':\n          break;\n        case 'selected':\n          break;\n        default:\n          // Intentionally use the original name.\n          // See discussion in https://github.com/facebook/react/pull/10676.\n          extraAttributeNames.add(attributes[_i].name);\n      }\n    }\n  }\n\n  var updatePayload = null;\n  for (var propKey in rawProps) {\n    if (!rawProps.hasOwnProperty(propKey)) {\n      continue;\n    }\n    var nextProp = rawProps[propKey];\n    if (propKey === CHILDREN) {\n      // For text content children we compare against textContent. This\n      // might match additional HTML that is hidden when we read it using\n      // textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n      // satisfies our requirement. Our requirement is not to produce perfect\n      // HTML and attributes. Ideally we should preserve structure but it's\n      // ok not to if the visible content is still enough to indicate what\n      // even listeners these nodes might be wired up to.\n      // TODO: Warn if there is more than a single textNode as a child.\n      // TODO: Should we use domElement.firstChild.nodeValue to compare?\n      if (typeof nextProp === 'string') {\n        if (domElement.textContent !== nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, nextProp];\n        }\n      } else if (typeof nextProp === 'number') {\n        if (domElement.textContent !== '' + nextProp) {\n          if (true && !suppressHydrationWarning) {\n            warnForTextDifference(domElement.textContent, nextProp);\n          }\n          updatePayload = [CHILDREN, '' + nextProp];\n        }\n      }\n    } else if (registrationNameModules.hasOwnProperty(propKey)) {\n      if (nextProp != null) {\n        if (true && typeof nextProp !== 'function') {\n          warnForInvalidEventListener(propKey, nextProp);\n        }\n        ensureListeningTo(rootContainerElement, propKey);\n      }\n    } else if (true &&\n    // Convince Flow we've calculated it (it's DEV-only in this method.)\n    typeof isCustomComponentTag === 'boolean') {\n      // Validate that the properties correspond to their expected values.\n      var serverValue = void 0;\n      var propertyInfo = getPropertyInfo(propKey);\n      if (suppressHydrationWarning) {\n        // Don't bother comparing. We're ignoring all these warnings.\n      } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING$1 ||\n      // Controlled attributes are not validated\n      // TODO: Only ignore them on controlled tags.\n      propKey === 'value' || propKey === 'checked' || propKey === 'selected') {\n        // Noop\n      } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n        var serverHTML = domElement.innerHTML;\n        var nextHtml = nextProp ? nextProp[HTML] : undefined;\n        var expectedHTML = normalizeHTML(domElement, nextHtml != null ? nextHtml : '');\n        if (expectedHTML !== serverHTML) {\n          warnForPropDifference(propKey, serverHTML, expectedHTML);\n        }\n      } else if (propKey === STYLE) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames.delete(propKey);\n\n        if (canDiffStyleForHydrationWarning) {\n          var expectedStyle = createDangerousStringForStyles(nextProp);\n          serverValue = domElement.getAttribute('style');\n          if (expectedStyle !== serverValue) {\n            warnForPropDifference(propKey, serverValue, expectedStyle);\n          }\n        }\n      } else if (isCustomComponentTag) {\n        // $FlowFixMe - Should be inferred as not undefined.\n        extraAttributeNames.delete(propKey.toLowerCase());\n        serverValue = getValueForAttribute(domElement, propKey, nextProp);\n\n        if (nextProp !== serverValue) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\n        var isMismatchDueToBadCasing = false;\n        if (propertyInfo !== null) {\n          // $FlowFixMe - Should be inferred as not undefined.\n          extraAttributeNames.delete(propertyInfo.attributeName);\n          serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\n        } else {\n          var ownNamespace = parentNamespace;\n          if (ownNamespace === HTML_NAMESPACE) {\n            ownNamespace = getIntrinsicNamespace(tag);\n          }\n          if (ownNamespace === HTML_NAMESPACE) {\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames.delete(propKey.toLowerCase());\n          } else {\n            var standardName = getPossibleStandardName(propKey);\n            if (standardName !== null && standardName !== propKey) {\n              // If an SVG prop is supplied with bad casing, it will\n              // be successfully parsed from HTML, but will produce a mismatch\n              // (and would be incorrectly rendered on the client).\n              // However, we already warn about bad casing elsewhere.\n              // So we'll skip the misleading extra mismatch warning in this case.\n              isMismatchDueToBadCasing = true;\n              // $FlowFixMe - Should be inferred as not undefined.\n              extraAttributeNames.delete(standardName);\n            }\n            // $FlowFixMe - Should be inferred as not undefined.\n            extraAttributeNames.delete(propKey);\n          }\n          serverValue = getValueForAttribute(domElement, propKey, nextProp);\n        }\n\n        if (nextProp !== serverValue && !isMismatchDueToBadCasing) {\n          warnForPropDifference(propKey, serverValue, nextProp);\n        }\n      }\n    }\n  }\n\n  {\n    // $FlowFixMe - Should be inferred as not undefined.\n    if (extraAttributeNames.size > 0 && !suppressHydrationWarning) {\n      // $FlowFixMe - Should be inferred as not undefined.\n      warnForExtraAttributes(extraAttributeNames);\n    }\n  }\n\n  switch (tag) {\n    case 'input':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper(domElement, rawProps, true);\n      break;\n    case 'textarea':\n      // TODO: Make sure we check if this is still unmounted or do any clean\n      // up necessary since we never stop tracking anymore.\n      track(domElement);\n      postMountWrapper$3(domElement, rawProps);\n      break;\n    case 'select':\n    case 'option':\n      // For input and textarea we current always set the value property at\n      // post mount to force it to diverge from attributes. However, for\n      // option and select we don't quite do the same thing and select\n      // is not resilient to the DOM state changing so we don't do that here.\n      // TODO: Consider not doing this for input and textarea.\n      break;\n    default:\n      if (typeof rawProps.onClick === 'function') {\n        // TODO: This cast may not be sound for SVG, MathML or custom elements.\n        trapClickOnNonInteractiveElement(domElement);\n      }\n      break;\n  }\n\n  return updatePayload;\n}\n\nfunction diffHydratedText(textNode, text) {\n  var isDifferent = textNode.nodeValue !== text;\n  return isDifferent;\n}\n\nfunction warnForUnmatchedText(textNode, text) {\n  {\n    warnForTextDifference(textNode.nodeValue, text);\n  }\n}\n\nfunction warnForDeletedHydratableElement(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Did not expect server HTML to contain a <%s> in <%s>.', child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForDeletedHydratableText(parentNode, child) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedElement(parentNode, tag, props) {\n  {\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Expected server HTML to contain a matching <%s> in <%s>.', tag, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction warnForInsertedHydratedText(parentNode, text) {\n  {\n    if (text === '') {\n      // We expect to insert empty text nodes since they're not represented in\n      // the HTML.\n      // TODO: Remove this special case if we can just avoid inserting empty\n      // text nodes.\n      return;\n    }\n    if (didWarnInvalidHydration) {\n      return;\n    }\n    didWarnInvalidHydration = true;\n    warningWithoutStack$1(false, 'Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n  }\n}\n\nfunction restoreControlledState$1(domElement, tag, props) {\n  switch (tag) {\n    case 'input':\n      restoreControlledState(domElement, props);\n      return;\n    case 'textarea':\n      restoreControlledState$3(domElement, props);\n      return;\n    case 'select':\n      restoreControlledState$2(domElement, props);\n      return;\n  }\n}\n\n// TODO: direct imports like some-package/src/* are bad. Fix me.\nvar validateDOMNesting = function () {};\nvar updatedAncestorInfo = function () {};\n\n{\n  // This validation code was written based on the HTML5 parsing spec:\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  //\n  // Note: this does not catch all invalid nesting, nor does it try to (as it's\n  // not clear what practical benefit doing so provides); instead, we warn only\n  // for cases where the parser will give a parse tree differing from what React\n  // intended. For example, <b><div></div></b> is invalid but we don't warn\n  // because it still parses correctly; we do warn for other cases like nested\n  // <p> tags where the beginning of the second element implicitly closes the\n  // first, causing a confusing mess.\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#special\n  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n  // TODO: Distinguish by namespace here -- for <title>, including it here\n  // errs on the side of fewer warnings\n  'foreignObject', 'desc', 'title'];\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n  var buttonScopeTags = inScopeTags.concat(['button']);\n\n  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n  var emptyAncestorInfo = {\n    current: null,\n\n    formTag: null,\n    aTagInScope: null,\n    buttonTagInScope: null,\n    nobrTagInScope: null,\n    pTagInButtonScope: null,\n\n    listItemTagAutoclosing: null,\n    dlItemTagAutoclosing: null\n  };\n\n  updatedAncestorInfo = function (oldInfo, tag) {\n    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);\n    var info = { tag: tag };\n\n    if (inScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.aTagInScope = null;\n      ancestorInfo.buttonTagInScope = null;\n      ancestorInfo.nobrTagInScope = null;\n    }\n    if (buttonScopeTags.indexOf(tag) !== -1) {\n      ancestorInfo.pTagInButtonScope = null;\n    }\n\n    // See rules for 'li', 'dd', 'dt' start tags in\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {\n      ancestorInfo.listItemTagAutoclosing = null;\n      ancestorInfo.dlItemTagAutoclosing = null;\n    }\n\n    ancestorInfo.current = info;\n\n    if (tag === 'form') {\n      ancestorInfo.formTag = info;\n    }\n    if (tag === 'a') {\n      ancestorInfo.aTagInScope = info;\n    }\n    if (tag === 'button') {\n      ancestorInfo.buttonTagInScope = info;\n    }\n    if (tag === 'nobr') {\n      ancestorInfo.nobrTagInScope = info;\n    }\n    if (tag === 'p') {\n      ancestorInfo.pTagInButtonScope = info;\n    }\n    if (tag === 'li') {\n      ancestorInfo.listItemTagAutoclosing = info;\n    }\n    if (tag === 'dd' || tag === 'dt') {\n      ancestorInfo.dlItemTagAutoclosing = info;\n    }\n\n    return ancestorInfo;\n  };\n\n  /**\n   * Returns whether\n   */\n  var isTagValidWithParent = function (tag, parentTag) {\n    // First, let's check if we're in an unusual parsing mode...\n    switch (parentTag) {\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n      case 'select':\n        return tag === 'option' || tag === 'optgroup' || tag === '#text';\n      case 'optgroup':\n        return tag === 'option' || tag === '#text';\n      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n      // but\n      case 'option':\n        return tag === '#text';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n      // No special behavior since these rules fall back to \"in body\" mode for\n      // all except special table nodes which cause bad parsing behavior anyway.\n\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n      case 'tr':\n        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n      case 'tbody':\n      case 'thead':\n      case 'tfoot':\n        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n      case 'colgroup':\n        return tag === 'col' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n      case 'table':\n        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n      case 'head':\n        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';\n      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n      case 'html':\n        return tag === 'head' || tag === 'body';\n      case '#document':\n        return tag === 'html';\n    }\n\n    // Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n    // where the parsing rules cause implicit opens or closes to be added.\n    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n    switch (tag) {\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';\n\n      case 'rp':\n      case 'rt':\n        return impliedEndTags.indexOf(parentTag) === -1;\n\n      case 'body':\n      case 'caption':\n      case 'col':\n      case 'colgroup':\n      case 'frame':\n      case 'head':\n      case 'html':\n      case 'tbody':\n      case 'td':\n      case 'tfoot':\n      case 'th':\n      case 'thead':\n      case 'tr':\n        // These tags are only valid with a few parents that have special child\n        // parsing rules -- if we're down here, then none of those matched and\n        // so we allow it only if we don't know what the parent is, as all other\n        // cases are invalid.\n        return parentTag == null;\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns whether\n   */\n  var findInvalidAncestorForTag = function (tag, ancestorInfo) {\n    switch (tag) {\n      case 'address':\n      case 'article':\n      case 'aside':\n      case 'blockquote':\n      case 'center':\n      case 'details':\n      case 'dialog':\n      case 'dir':\n      case 'div':\n      case 'dl':\n      case 'fieldset':\n      case 'figcaption':\n      case 'figure':\n      case 'footer':\n      case 'header':\n      case 'hgroup':\n      case 'main':\n      case 'menu':\n      case 'nav':\n      case 'ol':\n      case 'p':\n      case 'section':\n      case 'summary':\n      case 'ul':\n      case 'pre':\n      case 'listing':\n      case 'table':\n      case 'hr':\n      case 'xmp':\n      case 'h1':\n      case 'h2':\n      case 'h3':\n      case 'h4':\n      case 'h5':\n      case 'h6':\n        return ancestorInfo.pTagInButtonScope;\n\n      case 'form':\n        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n\n      case 'li':\n        return ancestorInfo.listItemTagAutoclosing;\n\n      case 'dd':\n      case 'dt':\n        return ancestorInfo.dlItemTagAutoclosing;\n\n      case 'button':\n        return ancestorInfo.buttonTagInScope;\n\n      case 'a':\n        // Spec says something about storing a list of markers, but it sounds\n        // equivalent to this check.\n        return ancestorInfo.aTagInScope;\n\n      case 'nobr':\n        return ancestorInfo.nobrTagInScope;\n    }\n\n    return null;\n  };\n\n  var didWarn = {};\n\n  validateDOMNesting = function (childTag, childText, ancestorInfo) {\n    ancestorInfo = ancestorInfo || emptyAncestorInfo;\n    var parentInfo = ancestorInfo.current;\n    var parentTag = parentInfo && parentInfo.tag;\n\n    if (childText != null) {\n      !(childTag == null) ? warningWithoutStack$1(false, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;\n      childTag = '#text';\n    }\n\n    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n    var invalidParentOrAncestor = invalidParent || invalidAncestor;\n    if (!invalidParentOrAncestor) {\n      return;\n    }\n\n    var ancestorTag = invalidParentOrAncestor.tag;\n    var addendum = getCurrentFiberStackInDev();\n\n    var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + addendum;\n    if (didWarn[warnKey]) {\n      return;\n    }\n    didWarn[warnKey] = true;\n\n    var tagDisplayName = childTag;\n    var whitespaceInfo = '';\n    if (childTag === '#text') {\n      if (/\\S/.test(childText)) {\n        tagDisplayName = 'Text nodes';\n      } else {\n        tagDisplayName = 'Whitespace text nodes';\n        whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on \" + 'each line of your source code.';\n      }\n    } else {\n      tagDisplayName = '<' + childTag + '>';\n    }\n\n    if (invalidParent) {\n      var info = '';\n      if (ancestorTag === 'table' && childTag === 'tr') {\n        info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';\n      }\n      warningWithoutStack$1(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s', tagDisplayName, ancestorTag, whitespaceInfo, info, addendum);\n    } else {\n      warningWithoutStack$1(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>.%s', tagDisplayName, ancestorTag, addendum);\n    }\n  };\n}\n\n// Renderers that don't support persistence\n// can re-export everything from this module.\n\nfunction shim() {\n  invariant(false, 'The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.');\n}\n\n// Persistence (when unsupported)\nvar supportsPersistence = false;\nvar cloneInstance = shim;\nvar createContainerChildSet = shim;\nvar appendChildToContainerChildSet = shim;\nvar finalizeContainerChildren = shim;\nvar replaceContainerChildren = shim;\n\nvar SUPPRESS_HYDRATION_WARNING = void 0;\n{\n  SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning';\n}\n\nvar eventsEnabled = null;\nvar selectionInformation = null;\n\nfunction shouldAutoFocusHostComponent(type, props) {\n  switch (type) {\n    case 'button':\n    case 'input':\n    case 'select':\n    case 'textarea':\n      return !!props.autoFocus;\n  }\n  return false;\n}\n\nfunction getRootHostContext(rootContainerInstance) {\n  var type = void 0;\n  var namespace = void 0;\n  var nodeType = rootContainerInstance.nodeType;\n  switch (nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      {\n        type = nodeType === DOCUMENT_NODE ? '#document' : '#fragment';\n        var root = rootContainerInstance.documentElement;\n        namespace = root ? root.namespaceURI : getChildNamespace(null, '');\n        break;\n      }\n    default:\n      {\n        var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n        var ownNamespace = container.namespaceURI || null;\n        type = container.tagName;\n        namespace = getChildNamespace(ownNamespace, type);\n        break;\n      }\n  }\n  {\n    var validatedTag = type.toLowerCase();\n    var _ancestorInfo = updatedAncestorInfo(null, validatedTag);\n    return { namespace: namespace, ancestorInfo: _ancestorInfo };\n  }\n  return namespace;\n}\n\nfunction getChildHostContext(parentHostContext, type, rootContainerInstance) {\n  {\n    var parentHostContextDev = parentHostContext;\n    var _namespace = getChildNamespace(parentHostContextDev.namespace, type);\n    var _ancestorInfo2 = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n    return { namespace: _namespace, ancestorInfo: _ancestorInfo2 };\n  }\n  var parentNamespace = parentHostContext;\n  return getChildNamespace(parentNamespace, type);\n}\n\nfunction getPublicInstance(instance) {\n  return instance;\n}\n\nfunction prepareForCommit(containerInfo) {\n  eventsEnabled = isEnabled();\n  selectionInformation = getSelectionInformation();\n  setEnabled(false);\n}\n\nfunction resetAfterCommit(containerInfo) {\n  restoreSelection(selectionInformation);\n  selectionInformation = null;\n  setEnabled(eventsEnabled);\n  eventsEnabled = null;\n}\n\nfunction createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  var parentNamespace = void 0;\n  {\n    // TODO: take namespace into account when validating.\n    var hostContextDev = hostContext;\n    validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n    if (typeof props.children === 'string' || typeof props.children === 'number') {\n      var string = '' + props.children;\n      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n    parentNamespace = hostContextDev.namespace;\n  }\n  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n  precacheFiberNode(internalInstanceHandle, domElement);\n  updateFiberProps(domElement, props);\n  return domElement;\n}\n\nfunction appendInitialChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\n\nfunction finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n  setInitialProperties(domElement, type, props, rootContainerInstance);\n  return shouldAutoFocusHostComponent(type, props);\n}\n\nfunction prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n  {\n    var hostContextDev = hostContext;\n    if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === 'string' || typeof newProps.children === 'number')) {\n      var string = '' + newProps.children;\n      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n      validateDOMNesting(null, string, ownAncestorInfo);\n    }\n  }\n  return diffProperties(domElement, type, oldProps, newProps, rootContainerInstance);\n}\n\nfunction shouldSetTextContent(type, props) {\n  return type === 'textarea' || type === 'option' || type === 'noscript' || typeof props.children === 'string' || typeof props.children === 'number' || typeof props.dangerouslySetInnerHTML === 'object' && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n}\n\nfunction shouldDeprioritizeSubtree(type, props) {\n  return !!props.hidden;\n}\n\nfunction createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n  {\n    var hostContextDev = hostContext;\n    validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n  }\n  var textNode = createTextNode(text, rootContainerInstance);\n  precacheFiberNode(internalInstanceHandle, textNode);\n  return textNode;\n}\n\nvar isPrimaryRenderer = true;\nvar scheduleTimeout = setTimeout;\nvar cancelTimeout = clearTimeout;\nvar noTimeout = -1;\n\n// -------------------\n//     Mutation\n// -------------------\n\nvar supportsMutation = true;\n\nfunction commitMount(domElement, type, newProps, internalInstanceHandle) {\n  // Despite the naming that might imply otherwise, this method only\n  // fires if there is an `Update` effect scheduled during mounting.\n  // This happens if `finalizeInitialChildren` returns `true` (which it\n  // does to implement the `autoFocus` attribute on the client). But\n  // there are also other cases when this might happen (such as patching\n  // up text content during hydration mismatch). So we'll check this again.\n  if (shouldAutoFocusHostComponent(type, newProps)) {\n    domElement.focus();\n  }\n}\n\nfunction commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n  // Update the props handle so that we know which props are the ones with\n  // with current event handlers.\n  updateFiberProps(domElement, newProps);\n  // Apply the diff to the DOM node.\n  updateProperties(domElement, updatePayload, type, oldProps, newProps);\n}\n\nfunction resetTextContent(domElement) {\n  setTextContent(domElement, '');\n}\n\nfunction commitTextUpdate(textInstance, oldText, newText) {\n  textInstance.nodeValue = newText;\n}\n\nfunction appendChild(parentInstance, child) {\n  parentInstance.appendChild(child);\n}\n\nfunction appendChildToContainer(container, child) {\n  var parentNode = void 0;\n  if (container.nodeType === COMMENT_NODE) {\n    parentNode = container.parentNode;\n    parentNode.insertBefore(child, container);\n  } else {\n    parentNode = container;\n    parentNode.appendChild(child);\n  }\n  // This container might be used for a portal.\n  // If something inside a portal is clicked, that click should bubble\n  // through the React tree. However, on Mobile Safari the click would\n  // never bubble through the *DOM* tree unless an ancestor with onclick\n  // event exists. So we wouldn't see it and dispatch it.\n  // This is why we ensure that containers have inline onclick defined.\n  // https://github.com/facebook/react/issues/11918\n  if (parentNode.onclick === null) {\n    // TODO: This cast may not be sound for SVG, MathML or custom elements.\n    trapClickOnNonInteractiveElement(parentNode);\n  }\n}\n\nfunction insertBefore(parentInstance, child, beforeChild) {\n  parentInstance.insertBefore(child, beforeChild);\n}\n\nfunction insertInContainerBefore(container, child, beforeChild) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.insertBefore(child, beforeChild);\n  } else {\n    container.insertBefore(child, beforeChild);\n  }\n}\n\nfunction removeChild(parentInstance, child) {\n  parentInstance.removeChild(child);\n}\n\nfunction removeChildFromContainer(container, child) {\n  if (container.nodeType === COMMENT_NODE) {\n    container.parentNode.removeChild(child);\n  } else {\n    container.removeChild(child);\n  }\n}\n\n// -------------------\n//     Hydration\n// -------------------\n\nvar supportsHydration = true;\n\nfunction canHydrateInstance(instance, type, props) {\n  if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n    return null;\n  }\n  // This has now been refined to an element node.\n  return instance;\n}\n\nfunction canHydrateTextInstance(instance, text) {\n  if (text === '' || instance.nodeType !== TEXT_NODE) {\n    // Empty strings are not parsed by HTML so there won't be a correct match here.\n    return null;\n  }\n  // This has now been refined to a text node.\n  return instance;\n}\n\nfunction getNextHydratableSibling(instance) {\n  var node = instance.nextSibling;\n  // Skip non-hydratable nodes.\n  while (node && node.nodeType !== ELEMENT_NODE && node.nodeType !== TEXT_NODE) {\n    node = node.nextSibling;\n  }\n  return node;\n}\n\nfunction getFirstHydratableChild(parentInstance) {\n  var next = parentInstance.firstChild;\n  // Skip non-hydratable nodes.\n  while (next && next.nodeType !== ELEMENT_NODE && next.nodeType !== TEXT_NODE) {\n    next = next.nextSibling;\n  }\n  return next;\n}\n\nfunction hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, instance);\n  // TODO: Possibly defer this until the commit phase where all the events\n  // get attached.\n  updateFiberProps(instance, props);\n  var parentNamespace = void 0;\n  {\n    var hostContextDev = hostContext;\n    parentNamespace = hostContextDev.namespace;\n  }\n  return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance);\n}\n\nfunction hydrateTextInstance(textInstance, text, internalInstanceHandle) {\n  precacheFiberNode(internalInstanceHandle, textInstance);\n  return diffHydratedText(textInstance, text);\n}\n\nfunction didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text) {\n  {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nfunction didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForUnmatchedText(textInstance, text);\n  }\n}\n\nfunction didNotHydrateContainerInstance(parentContainer, instance) {\n  {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentContainer, instance);\n    } else {\n      warnForDeletedHydratableText(parentContainer, instance);\n    }\n  }\n}\n\nfunction didNotHydrateInstance(parentType, parentProps, parentInstance, instance) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    if (instance.nodeType === ELEMENT_NODE) {\n      warnForDeletedHydratableElement(parentInstance, instance);\n    } else {\n      warnForDeletedHydratableText(parentInstance, instance);\n    }\n  }\n}\n\nfunction didNotFindHydratableContainerInstance(parentContainer, type, props) {\n  {\n    warnForInsertedHydratedElement(parentContainer, type, props);\n  }\n}\n\nfunction didNotFindHydratableContainerTextInstance(parentContainer, text) {\n  {\n    warnForInsertedHydratedText(parentContainer, text);\n  }\n}\n\nfunction didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedElement(parentInstance, type, props);\n  }\n}\n\nfunction didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text) {\n  if (true && parentProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n    warnForInsertedHydratedText(parentInstance, text);\n  }\n}\n\n// Prefix measurements so that it's possible to filter them.\n// Longer prefixes are hard to read in DevTools.\nvar reactEmoji = '\\u269B';\nvar warningEmoji = '\\u26D4';\nvar supportsUserTiming = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';\n\n// Keep track of current fiber so that we know the path to unwind on pause.\n// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?\nvar currentFiber = null;\n// If we're in the middle of user code, which fiber and method is it?\n// Reusing `currentFiber` would be confusing for this because user code fiber\n// can change during commit phase too, but we don't need to unwind it (since\n// lifecycles in the commit phase don't resemble a tree).\nvar currentPhase = null;\nvar currentPhaseFiber = null;\n// Did lifecycle hook schedule an update? This is often a performance problem,\n// so we will keep track of it, and include it in the report.\n// Track commits caused by cascading updates.\nvar isCommitting = false;\nvar hasScheduledUpdateInCurrentCommit = false;\nvar hasScheduledUpdateInCurrentPhase = false;\nvar commitCountInCurrentWorkLoop = 0;\nvar effectCountInCurrentCommit = 0;\nvar isWaitingForCallback = false;\n// During commits, we only show a measurement once per method name\n// to avoid stretch the commit phase with measurement overhead.\nvar labelsInCurrentCommit = new Set();\n\nvar formatMarkName = function (markName) {\n  return reactEmoji + ' ' + markName;\n};\n\nvar formatLabel = function (label, warning) {\n  var prefix = warning ? warningEmoji + ' ' : reactEmoji + ' ';\n  var suffix = warning ? ' Warning: ' + warning : '';\n  return '' + prefix + label + suffix;\n};\n\nvar beginMark = function (markName) {\n  performance.mark(formatMarkName(markName));\n};\n\nvar clearMark = function (markName) {\n  performance.clearMarks(formatMarkName(markName));\n};\n\nvar endMark = function (label, markName, warning) {\n  var formattedMarkName = formatMarkName(markName);\n  var formattedLabel = formatLabel(label, warning);\n  try {\n    performance.measure(formattedLabel, formattedMarkName);\n  } catch (err) {}\n  // If previous mark was missing for some reason, this will throw.\n  // This could only happen if React crashed in an unexpected place earlier.\n  // Don't pile on with more errors.\n\n  // Clear marks immediately to avoid growing buffer.\n  performance.clearMarks(formattedMarkName);\n  performance.clearMeasures(formattedLabel);\n};\n\nvar getFiberMarkName = function (label, debugID) {\n  return label + ' (#' + debugID + ')';\n};\n\nvar getFiberLabel = function (componentName, isMounted, phase) {\n  if (phase === null) {\n    // These are composite component total time measurements.\n    return componentName + ' [' + (isMounted ? 'update' : 'mount') + ']';\n  } else {\n    // Composite component methods.\n    return componentName + '.' + phase;\n  }\n};\n\nvar beginFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber.type) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n\n  if (isCommitting && labelsInCurrentCommit.has(label)) {\n    // During the commit phase, we don't show duplicate labels because\n    // there is a fixed overhead for every measurement, and we don't\n    // want to stretch the commit phase beyond necessary.\n    return false;\n  }\n  labelsInCurrentCommit.add(label);\n\n  var markName = getFiberMarkName(label, debugID);\n  beginMark(markName);\n  return true;\n};\n\nvar clearFiberMark = function (fiber, phase) {\n  var componentName = getComponentName(fiber.type) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  clearMark(markName);\n};\n\nvar endFiberMark = function (fiber, phase, warning) {\n  var componentName = getComponentName(fiber.type) || 'Unknown';\n  var debugID = fiber._debugID;\n  var isMounted = fiber.alternate !== null;\n  var label = getFiberLabel(componentName, isMounted, phase);\n  var markName = getFiberMarkName(label, debugID);\n  endMark(label, markName, warning);\n};\n\nvar shouldIgnoreFiber = function (fiber) {\n  // Host components should be skipped in the timeline.\n  // We could check typeof fiber.type, but does this work with RN?\n  switch (fiber.tag) {\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n    case Fragment:\n    case ContextProvider:\n    case ContextConsumer:\n    case Mode:\n      return true;\n    default:\n      return false;\n  }\n};\n\nvar clearPendingPhaseMeasurement = function () {\n  if (currentPhase !== null && currentPhaseFiber !== null) {\n    clearFiberMark(currentPhaseFiber, currentPhase);\n  }\n  currentPhaseFiber = null;\n  currentPhase = null;\n  hasScheduledUpdateInCurrentPhase = false;\n};\n\nvar pauseTimers = function () {\n  // Stops all currently active measurements so that they can be resumed\n  // if we continue in a later deferred loop from the same unit of work.\n  var fiber = currentFiber;\n  while (fiber) {\n    if (fiber._debugIsCurrentlyTiming) {\n      endFiberMark(fiber, null, null);\n    }\n    fiber = fiber.return;\n  }\n};\n\nvar resumeTimersRecursively = function (fiber) {\n  if (fiber.return !== null) {\n    resumeTimersRecursively(fiber.return);\n  }\n  if (fiber._debugIsCurrentlyTiming) {\n    beginFiberMark(fiber, null);\n  }\n};\n\nvar resumeTimers = function () {\n  // Resumes all measurements that were active during the last deferred loop.\n  if (currentFiber !== null) {\n    resumeTimersRecursively(currentFiber);\n  }\n};\n\nfunction recordEffect() {\n  if (enableUserTimingAPI) {\n    effectCountInCurrentCommit++;\n  }\n}\n\nfunction recordScheduleUpdate() {\n  if (enableUserTimingAPI) {\n    if (isCommitting) {\n      hasScheduledUpdateInCurrentCommit = true;\n    }\n    if (currentPhase !== null && currentPhase !== 'componentWillMount' && currentPhase !== 'componentWillReceiveProps') {\n      hasScheduledUpdateInCurrentPhase = true;\n    }\n  }\n}\n\nfunction startRequestCallbackTimer() {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming && !isWaitingForCallback) {\n      isWaitingForCallback = true;\n      beginMark('(Waiting for async callback...)');\n    }\n  }\n}\n\nfunction stopRequestCallbackTimer(didExpire, expirationTime) {\n  if (enableUserTimingAPI) {\n    if (supportsUserTiming) {\n      isWaitingForCallback = false;\n      var warning = didExpire ? 'React was blocked by main thread' : null;\n      endMark('(Waiting for async callback... will force flush in ' + expirationTime + ' ms)', '(Waiting for async callback...)', warning);\n    }\n  }\n}\n\nfunction startWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, this is the fiber to unwind from.\n    currentFiber = fiber;\n    if (!beginFiberMark(fiber, null)) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = true;\n  }\n}\n\nfunction cancelWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // Remember we shouldn't complete measurement for this fiber.\n    // Otherwise flamechart will be deep even for small updates.\n    fiber._debugIsCurrentlyTiming = false;\n    clearFiberMark(fiber, null);\n  }\n}\n\nfunction stopWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    endFiberMark(fiber, null, null);\n  }\n}\n\nfunction stopFailedWorkTimer(fiber) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming || shouldIgnoreFiber(fiber)) {\n      return;\n    }\n    // If we pause, its parent is the fiber to unwind from.\n    currentFiber = fiber.return;\n    if (!fiber._debugIsCurrentlyTiming) {\n      return;\n    }\n    fiber._debugIsCurrentlyTiming = false;\n    var warning = 'An error was thrown inside this error boundary';\n    endFiberMark(fiber, null, warning);\n  }\n}\n\nfunction startPhaseTimer(fiber, phase) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    clearPendingPhaseMeasurement();\n    if (!beginFiberMark(fiber, phase)) {\n      return;\n    }\n    currentPhaseFiber = fiber;\n    currentPhase = phase;\n  }\n}\n\nfunction stopPhaseTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    if (currentPhase !== null && currentPhaseFiber !== null) {\n      var warning = hasScheduledUpdateInCurrentPhase ? 'Scheduled a cascading update' : null;\n      endFiberMark(currentPhaseFiber, currentPhase, warning);\n    }\n    currentPhase = null;\n    currentPhaseFiber = null;\n  }\n}\n\nfunction startWorkLoopTimer(nextUnitOfWork) {\n  if (enableUserTimingAPI) {\n    currentFiber = nextUnitOfWork;\n    if (!supportsUserTiming) {\n      return;\n    }\n    commitCountInCurrentWorkLoop = 0;\n    // This is top level call.\n    // Any other measurements are performed within.\n    beginMark('(React Tree Reconciliation)');\n    // Resume any measurements that were in progress during the last loop.\n    resumeTimers();\n  }\n}\n\nfunction stopWorkLoopTimer(interruptedBy, didCompleteRoot) {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var warning = null;\n    if (interruptedBy !== null) {\n      if (interruptedBy.tag === HostRoot) {\n        warning = 'A top-level update interrupted the previous render';\n      } else {\n        var componentName = getComponentName(interruptedBy.type) || 'Unknown';\n        warning = 'An update to ' + componentName + ' interrupted the previous render';\n      }\n    } else if (commitCountInCurrentWorkLoop > 1) {\n      warning = 'There were cascading updates';\n    }\n    commitCountInCurrentWorkLoop = 0;\n    var label = didCompleteRoot ? '(React Tree Reconciliation: Completed Root)' : '(React Tree Reconciliation: Yielded)';\n    // Pause any measurements until the next loop.\n    pauseTimers();\n    endMark(label, '(React Tree Reconciliation)', warning);\n  }\n}\n\nfunction startCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    isCommitting = true;\n    hasScheduledUpdateInCurrentCommit = false;\n    labelsInCurrentCommit.clear();\n    beginMark('(Committing Changes)');\n  }\n}\n\nfunction stopCommitTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n\n    var warning = null;\n    if (hasScheduledUpdateInCurrentCommit) {\n      warning = 'Lifecycle hook scheduled a cascading update';\n    } else if (commitCountInCurrentWorkLoop > 0) {\n      warning = 'Caused by a cascading update in earlier commit';\n    }\n    hasScheduledUpdateInCurrentCommit = false;\n    commitCountInCurrentWorkLoop++;\n    isCommitting = false;\n    labelsInCurrentCommit.clear();\n\n    endMark('(Committing Changes)', '(Committing Changes)', warning);\n  }\n}\n\nfunction startCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Snapshot Effects)');\n  }\n}\n\nfunction stopCommitSnapshotEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Snapshot Effects: ' + count + ' Total)', '(Committing Snapshot Effects)', null);\n  }\n}\n\nfunction startCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Committing Host Effects)');\n  }\n}\n\nfunction stopCommitHostEffectsTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Committing Host Effects: ' + count + ' Total)', '(Committing Host Effects)', null);\n  }\n}\n\nfunction startCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    effectCountInCurrentCommit = 0;\n    beginMark('(Calling Lifecycle Methods)');\n  }\n}\n\nfunction stopCommitLifeCyclesTimer() {\n  if (enableUserTimingAPI) {\n    if (!supportsUserTiming) {\n      return;\n    }\n    var count = effectCountInCurrentCommit;\n    effectCountInCurrentCommit = 0;\n    endMark('(Calling Lifecycle Methods: ' + count + ' Total)', '(Calling Lifecycle Methods)', null);\n  }\n}\n\nvar valueStack = [];\n\nvar fiberStack = void 0;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      warningWithoutStack$1(false, 'Unexpected pop.');\n    }\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      warningWithoutStack$1(false, 'Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nfunction checkThatStackIsEmpty() {\n  {\n    if (index !== -1) {\n      warningWithoutStack$1(false, 'Expected an empty stack. Something was not reset properly.');\n    }\n  }\n}\n\nfunction resetStackAfterFatalErrorInDev() {\n  {\n    index = -1;\n    valueStack.length = 0;\n    fiberStack.length = 0;\n  }\n}\n\nvar warnedAboutMissingGetChildContext = void 0;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar emptyContextObject = {};\n{\n  Object.freeze(emptyContextObject);\n}\n\n// A cursor to the current merged context object on the stack.\nvar contextStackCursor = createCursor(emptyContextObject);\n// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor = createCursor(false);\n// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n  if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n    // If the fiber is a context provider itself, when we read its context\n    // we may have already pushed its own child context on the stack. A context\n    // provider should not \"see\" its own child context. Therefore we read the\n    // previous (parent) context instead for a context provider.\n    return previousContext;\n  }\n  return contextStackCursor.current;\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  var instance = workInProgress.stateNode;\n  instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n  instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  var type = workInProgress.type;\n  var contextTypes = type.contextTypes;\n  if (!contextTypes) {\n    return emptyContextObject;\n  }\n\n  // Avoid recreating masked context unless unmasked context has changed.\n  // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n  // This may trigger infinite loops if componentWillReceiveProps calls setState.\n  var instance = workInProgress.stateNode;\n  if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n    return instance.__reactInternalMemoizedMaskedChildContext;\n  }\n\n  var context = {};\n  for (var key in contextTypes) {\n    context[key] = unmaskedContext[key];\n  }\n\n  {\n    var name = getComponentName(type) || 'Unknown';\n    checkPropTypes(contextTypes, context, 'context', name, getCurrentFiberStackInDev);\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // Context is created before the class component is instantiated so check for instance.\n  if (instance) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return context;\n}\n\nfunction hasContextChanged() {\n  return didPerformWorkStackCursor.current;\n}\n\nfunction isContextProvider(type) {\n  var childContextTypes = type.childContextTypes;\n  return childContextTypes !== null && childContextTypes !== undefined;\n}\n\nfunction popContext(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction popTopLevelContextObject(fiber) {\n  pop(didPerformWorkStackCursor, fiber);\n  pop(contextStackCursor, fiber);\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  !(contextStackCursor.current === emptyContextObject) ? invariant(false, 'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  push(contextStackCursor, context, fiber);\n  push(didPerformWorkStackCursor, didChange, fiber);\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  var instance = fiber.stateNode;\n  var childContextTypes = type.childContextTypes;\n\n  // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n  // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n  if (typeof instance.getChildContext !== 'function') {\n    {\n      var componentName = getComponentName(type) || 'Unknown';\n\n      if (!warnedAboutMissingGetChildContext[componentName]) {\n        warnedAboutMissingGetChildContext[componentName] = true;\n        warningWithoutStack$1(false, '%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n      }\n    }\n    return parentContext;\n  }\n\n  var childContext = void 0;\n  {\n    setCurrentPhase('getChildContext');\n  }\n  startPhaseTimer(fiber, 'getChildContext');\n  childContext = instance.getChildContext();\n  stopPhaseTimer();\n  {\n    setCurrentPhase(null);\n  }\n  for (var contextKey in childContext) {\n    !(contextKey in childContextTypes) ? invariant(false, '%s.getChildContext(): key \"%s\" is not defined in childContextTypes.', getComponentName(type) || 'Unknown', contextKey) : void 0;\n  }\n  {\n    var name = getComponentName(type) || 'Unknown';\n    checkPropTypes(childContextTypes, childContext, 'child context', name,\n    // In practice, there is one case in which we won't get a stack. It's when\n    // somebody calls unstable_renderSubtreeIntoContainer() and we process\n    // context from the parent component instance. The stack will be missing\n    // because it's outside of the reconciliation, and so the pointer has not\n    // been set. This is rare and doesn't matter. We'll also remove that API.\n    getCurrentFiberStackInDev);\n  }\n\n  return _assign({}, parentContext, childContext);\n}\n\nfunction pushContextProvider(workInProgress) {\n  var instance = workInProgress.stateNode;\n  // We push the context as early as possible to ensure stack integrity.\n  // If the instance does not exist yet, we will push null at first,\n  // and replace it on the stack later when invalidating the context.\n  var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;\n\n  // Remember the parent context so we can merge with it later.\n  // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n  previousContext = contextStackCursor.current;\n  push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n  push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n\n  return true;\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  var instance = workInProgress.stateNode;\n  !instance ? invariant(false, 'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  if (didChange) {\n    // Merge parent and own context.\n    // Skip this if we're not updating due to sCU.\n    // This avoids unnecessarily recomputing memoized values.\n    var mergedContext = processChildContext(workInProgress, type, previousContext);\n    instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n\n    // Replace the old (or empty) context with the new one.\n    // It is important to unwind the context in the reverse order.\n    pop(didPerformWorkStackCursor, workInProgress);\n    pop(contextStackCursor, workInProgress);\n    // Now push the new context and mark that it has changed.\n    push(contextStackCursor, mergedContext, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  } else {\n    pop(didPerformWorkStackCursor, workInProgress);\n    push(didPerformWorkStackCursor, didChange, workInProgress);\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n  // makes sense elsewhere\n  !(isFiberMounted(fiber) && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)) ? invariant(false, 'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var node = fiber;\n  do {\n    switch (node.tag) {\n      case HostRoot:\n        return node.stateNode.context;\n      case ClassComponent:\n        {\n          var Component = node.type;\n          if (isContextProvider(Component)) {\n            return node.stateNode.__reactInternalMemoizedMergedChildContext;\n          }\n          break;\n        }\n      case ClassComponentLazy:\n        {\n          var _Component = getResultFromResolvedThenable(node.type);\n          if (isContextProvider(_Component)) {\n            return node.stateNode.__reactInternalMemoizedMergedChildContext;\n          }\n          break;\n        }\n    }\n    node = node.return;\n  } while (node !== null);\n  invariant(false, 'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.');\n}\n\nvar onCommitFiberRoot = null;\nvar onCommitFiberUnmount = null;\nvar hasLoggedError = false;\n\nfunction catchErrors(fn) {\n  return function (arg) {\n    try {\n      return fn(arg);\n    } catch (err) {\n      if (true && !hasLoggedError) {\n        hasLoggedError = true;\n        warningWithoutStack$1(false, 'React DevTools encountered an error: %s', err);\n      }\n    }\n  };\n}\n\nvar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\n\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n  if (!hook.supportsFiber) {\n    {\n      warningWithoutStack$1(false, 'The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://fb.me/react-devtools');\n    }\n    // DevTools exists, even though it doesn't support Fiber.\n    return true;\n  }\n  try {\n    var rendererID = hook.inject(internals);\n    // We have successfully injected, so now it is safe to set up hooks.\n    onCommitFiberRoot = catchErrors(function (root) {\n      return hook.onCommitFiberRoot(rendererID, root);\n    });\n    onCommitFiberUnmount = catchErrors(function (fiber) {\n      return hook.onCommitFiberUnmount(rendererID, fiber);\n    });\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      warningWithoutStack$1(false, 'React DevTools encountered an error: %s.', err);\n    }\n  }\n  // DevTools exists\n  return true;\n}\n\nfunction onCommitRoot(root) {\n  if (typeof onCommitFiberRoot === 'function') {\n    onCommitFiberRoot(root);\n  }\n}\n\nfunction onCommitUnmount(fiber) {\n  if (typeof onCommitFiberUnmount === 'function') {\n    onCommitFiberUnmount(fiber);\n  }\n}\n\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\nvar maxSigned31BitInt = 1073741823;\n\nvar NoWork = 0;\nvar Sync = 1;\nvar Never = maxSigned31BitInt;\n\nvar UNIT_SIZE = 10;\nvar MAGIC_NUMBER_OFFSET = 2;\n\n// 1 unit of expiration time represents 10ms.\nfunction msToExpirationTime(ms) {\n  // Always add an offset so that we don't clash with the magic number for NoWork.\n  return (ms / UNIT_SIZE | 0) + MAGIC_NUMBER_OFFSET;\n}\n\nfunction expirationTimeToMs(expirationTime) {\n  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;\n}\n\nfunction ceiling(num, precision) {\n  return ((num / precision | 0) + 1) * precision;\n}\n\nfunction computeExpirationBucket(currentTime, expirationInMs, bucketSizeMs) {\n  return MAGIC_NUMBER_OFFSET + ceiling(currentTime - MAGIC_NUMBER_OFFSET + expirationInMs / UNIT_SIZE, bucketSizeMs / UNIT_SIZE);\n}\n\nvar LOW_PRIORITY_EXPIRATION = 5000;\nvar LOW_PRIORITY_BATCH_SIZE = 250;\n\nfunction computeAsyncExpiration(currentTime) {\n  return computeExpirationBucket(currentTime, LOW_PRIORITY_EXPIRATION, LOW_PRIORITY_BATCH_SIZE);\n}\n\n// We intentionally set a higher expiration time for interactive updates in\n// dev than in production.\n//\n// If the main thread is being blocked so long that you hit the expiration,\n// it's a problem that could be solved with better scheduling.\n//\n// People will be more likely to notice this and fix it with the long\n// expiration time in development.\n//\n// In production we opt for better UX at the risk of masking scheduling\n// problems, by expiring fast.\nvar HIGH_PRIORITY_EXPIRATION = 500;\nvar HIGH_PRIORITY_BATCH_SIZE = 100;\n\nfunction computeInteractiveExpiration(currentTime) {\n  return computeExpirationBucket(currentTime, HIGH_PRIORITY_EXPIRATION, HIGH_PRIORITY_BATCH_SIZE);\n}\n\nvar NoContext = 0;\nvar AsyncMode = 1;\nvar StrictMode = 2;\nvar ProfileMode = 4;\n\nvar hasBadMapPolyfill = void 0;\n\n{\n  hasBadMapPolyfill = false;\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    var testMap = new Map([[nonExtensibleObject, null]]);\n    var testSet = new Set([nonExtensibleObject]);\n    // This is necessary for Rollup to not consider these unused.\n    // https://github.com/rollup/rollup/issues/1771\n    // TODO: we can remove these if Rollup fixes the bug.\n    testMap.set(0, 0);\n    testSet.add(0);\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\n// A Fiber is work on a Component that needs to be done or was done. There can\n// be more than one per component.\n\n\nvar debugCounter = void 0;\n\n{\n  debugCounter = 1;\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.firstContextDependency = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  {\n    this._debugID = debugCounter++;\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugIsCurrentlyTiming = false;\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n}\n\n// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction resolveLazyComponentTag(fiber, Component) {\n  if (typeof Component === 'function') {\n    return shouldConstruct(Component) ? ClassComponentLazy : FunctionalComponentLazy;\n  } else if (Component !== undefined && Component !== null && Component.$$typeof) {\n    return ForwardRefLazy;\n  }\n  return IndeterminateComponent;\n}\n\n// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current, pendingProps, expirationTime) {\n  var workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugID = current._debugID;\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  }\n\n  // Don't touching the subtree's expiration time, which has not changed.\n  workInProgress.childExpirationTime = current.childExpirationTime;\n  if (pendingProps !== current.pendingProps) {\n    // This fiber has new props.\n    workInProgress.expirationTime = expirationTime;\n  } else {\n    // This fiber's props have not changed.\n    workInProgress.expirationTime = current.expirationTime;\n  }\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.firstContextDependency = current.firstContextDependency;\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  return workInProgress;\n}\n\nfunction createHostRootFiber(isAsync) {\n  var mode = isAsync ? AsyncMode | StrictMode : NoContext;\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\n\nfunction createFiberFromElement(element, mode, expirationTime) {\n  var owner = null;\n  {\n    owner = element._owner;\n  }\n\n  var fiber = void 0;\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n\n  var fiberTag = void 0;\n  if (typeof type === 'function') {\n    fiberTag = shouldConstruct(type) ? ClassComponent : IndeterminateComponent;\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, expirationTime, key);\n      case REACT_ASYNC_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= AsyncMode | StrictMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n      case REACT_PLACEHOLDER_TYPE:\n        fiberTag = PlaceholderComponent;\n        break;\n      default:\n        {\n          if (typeof type === 'object' && type !== null) {\n            switch (type.$$typeof) {\n              case REACT_PROVIDER_TYPE:\n                fiberTag = ContextProvider;\n                break getTag;\n              case REACT_CONTEXT_TYPE:\n                // This is a consumer\n                fiberTag = ContextConsumer;\n                break getTag;\n              case REACT_FORWARD_REF_TYPE:\n                fiberTag = ForwardRef;\n                break getTag;\n              default:\n                {\n                  if (typeof type.then === 'function') {\n                    fiberTag = IndeterminateComponent;\n                    break getTag;\n                  }\n                }\n            }\n          }\n          var info = '';\n          {\n            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n              info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n            }\n            var ownerName = owner ? getComponentName(owner.type) : null;\n            if (ownerName) {\n              info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n            }\n          }\n          invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info);\n        }\n    }\n  }\n\n  fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.type = type;\n  fiber.expirationTime = expirationTime;\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\n\nfunction createFiberFromFragment(elements, mode, expirationTime, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, expirationTime, key) {\n  {\n    if (typeof pendingProps.id !== 'string' || typeof pendingProps.onRender !== 'function') {\n      warningWithoutStack$1(false, 'Profiler must specify an \"id\" string and \"onRender\" function as props');\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.type = REACT_PROFILER_TYPE;\n  fiber.expirationTime = expirationTime;\n\n  return fiber;\n}\n\nfunction createFiberFromText(content, mode, expirationTime) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.expirationTime = expirationTime;\n  return fiber;\n}\n\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoContext);\n  fiber.type = 'DELETED';\n  return fiber;\n}\n\nfunction createFiberFromPortal(portal, mode, expirationTime) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.expirationTime = expirationTime;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null, // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n}\n\n// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoContext);\n  }\n\n  // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.firstContextDependency = source.firstContextDependency;\n  target.mode = source.mode;\n  target.effectTag = source.effectTag;\n  target.nextEffect = source.nextEffect;\n  target.firstEffect = source.firstEffect;\n  target.lastEffect = source.lastEffect;\n  target.expirationTime = source.expirationTime;\n  target.childExpirationTime = source.childExpirationTime;\n  target.alternate = source.alternate;\n  if (enableProfilerTimer) {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n  target._debugID = source._debugID;\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugIsCurrentlyTiming = source._debugIsCurrentlyTiming;\n  return target;\n}\n\n/* eslint-disable no-use-before-define */\n// TODO: This should be lifted into the renderer.\n\n\n// The following attributes are only used by interaction tracing builds.\n// They enable interactions to be associated with their async work,\n// And expose interaction metadata to the React DevTools Profiler plugin.\n// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.\n\n\n// Exported FiberRoot type includes all properties,\n// To avoid requiring potentially error-prone :any casts throughout the project.\n// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).\n// The types are defined separately within this file to ensure they stay in sync.\n// (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)\n\n/* eslint-enable no-use-before-define */\n\nfunction createFiberRoot(containerInfo, isAsync, hydrate) {\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  var uninitializedFiber = createHostRootFiber(isAsync);\n\n  var root = void 0;\n  if (enableSchedulerTracing) {\n    root = {\n      current: uninitializedFiber,\n      containerInfo: containerInfo,\n      pendingChildren: null,\n\n      earliestPendingTime: NoWork,\n      latestPendingTime: NoWork,\n      earliestSuspendedTime: NoWork,\n      latestSuspendedTime: NoWork,\n      latestPingedTime: NoWork,\n\n      didError: false,\n\n      pendingCommitExpirationTime: NoWork,\n      finishedWork: null,\n      timeoutHandle: noTimeout,\n      context: null,\n      pendingContext: null,\n      hydrate: hydrate,\n      nextExpirationTimeToWorkOn: NoWork,\n      expirationTime: NoWork,\n      firstBatch: null,\n      nextScheduledRoot: null,\n\n      interactionThreadID: tracing.unstable_getThreadID(),\n      memoizedInteractions: new Set(),\n      pendingInteractionMap: new Map()\n    };\n  } else {\n    root = {\n      current: uninitializedFiber,\n      containerInfo: containerInfo,\n      pendingChildren: null,\n\n      earliestPendingTime: NoWork,\n      latestPendingTime: NoWork,\n      earliestSuspendedTime: NoWork,\n      latestSuspendedTime: NoWork,\n      latestPingedTime: NoWork,\n\n      didError: false,\n\n      pendingCommitExpirationTime: NoWork,\n      finishedWork: null,\n      timeoutHandle: noTimeout,\n      context: null,\n      pendingContext: null,\n      hydrate: hydrate,\n      nextExpirationTimeToWorkOn: NoWork,\n      expirationTime: NoWork,\n      firstBatch: null,\n      nextScheduledRoot: null\n    };\n  }\n\n  uninitializedFiber.stateNode = root;\n\n  // The reason for the way the Flow types are structured in this file,\n  // Is to avoid needing :any casts everywhere interaction tracing fields are used.\n  // Unfortunately that requires an :any cast for non-interaction tracing capable builds.\n  // $FlowFixMe Remove this :any cast and replace it with something better.\n  return root;\n}\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\nvar ReactStrictModeWarnings = {\n  discardPendingWarnings: function () {},\n  flushPendingDeprecationWarnings: function () {},\n  flushPendingUnsafeLifecycleWarnings: function () {},\n  recordDeprecationWarnings: function (fiber, instance) {},\n  recordUnsafeLifecycleWarnings: function (fiber, instance) {},\n  recordLegacyContextWarning: function (fiber, instance) {},\n  flushLegacyContextWarning: function () {}\n};\n\n{\n  var LIFECYCLE_SUGGESTIONS = {\n    UNSAFE_componentWillMount: 'componentDidMount',\n    UNSAFE_componentWillReceiveProps: 'static getDerivedStateFromProps',\n    UNSAFE_componentWillUpdate: 'componentDidUpdate'\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUnsafeLifecycleWarnings = new Map();\n  var pendingLegacyContextWarning = new Map();\n\n  // Tracks components we have already warned about.\n  var didWarnAboutDeprecatedLifecycles = new Set();\n  var didWarnAboutUnsafeLifecycles = new Set();\n  var didWarnAboutLegacyContext = new Set();\n\n  var setToSortedString = function (set) {\n    var array = [];\n    set.forEach(function (value) {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function () {\n    pendingComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUnsafeLifecycleWarnings = new Map();\n    pendingLegacyContextWarning = new Map();\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n    pendingUnsafeLifecycleWarnings.forEach(function (lifecycleWarningsMap, strictRoot) {\n      var lifecyclesWarningMesages = [];\n\n      Object.keys(lifecycleWarningsMap).forEach(function (lifecycle) {\n        var lifecycleWarnings = lifecycleWarningsMap[lifecycle];\n        if (lifecycleWarnings.length > 0) {\n          var componentNames = new Set();\n          lifecycleWarnings.forEach(function (fiber) {\n            componentNames.add(getComponentName(fiber.type) || 'Component');\n            didWarnAboutUnsafeLifecycles.add(fiber.type);\n          });\n\n          var formatted = lifecycle.replace('UNSAFE_', '');\n          var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];\n          var sortedComponentNames = setToSortedString(componentNames);\n\n          lifecyclesWarningMesages.push(formatted + ': Please update the following components to use ' + (suggestion + ' instead: ' + sortedComponentNames));\n        }\n      });\n\n      if (lifecyclesWarningMesages.length > 0) {\n        var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n\n        warningWithoutStack$1(false, 'Unsafe lifecycle methods were found within a strict-mode tree:%s' + '\\n\\n%s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, lifecyclesWarningMesages.join('\\n\\n'));\n      }\n    });\n\n    pendingUnsafeLifecycleWarnings = new Map();\n  };\n\n  var findStrictRoot = function (fiber) {\n    var maybeStrictRoot = null;\n\n    var node = fiber;\n    while (node !== null) {\n      if (node.mode & StrictMode) {\n        maybeStrictRoot = node;\n      }\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  ReactStrictModeWarnings.flushPendingDeprecationWarnings = function () {\n    if (pendingComponentWillMountWarnings.length > 0) {\n      var uniqueNames = new Set();\n      pendingComponentWillMountWarnings.forEach(function (fiber) {\n        uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillMount is deprecated and will be removed in the next major version. ' + 'Use componentDidMount instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillMount.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', sortedNames);\n\n      pendingComponentWillMountWarnings = [];\n    }\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      var _uniqueNames = new Set();\n      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        _uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames = setToSortedString(_uniqueNames);\n\n      lowPriorityWarning$1(false, 'componentWillReceiveProps is deprecated and will be removed in the next major version. ' + 'Use static getDerivedStateFromProps instead.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames);\n\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      var _uniqueNames2 = new Set();\n      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n        _uniqueNames2.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutDeprecatedLifecycles.add(fiber.type);\n      });\n\n      var _sortedNames2 = setToSortedString(_uniqueNames2);\n\n      lowPriorityWarning$1(false, 'componentWillUpdate is deprecated and will be removed in the next major version. ' + 'Use componentDidUpdate instead. As a temporary workaround, ' + 'you can rename to UNSAFE_componentWillUpdate.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-async-component-lifecycle-hooks', _sortedNames2);\n\n      pendingComponentWillUpdateWarnings = [];\n    }\n  };\n\n  ReactStrictModeWarnings.recordDeprecationWarnings = function (fiber, instance) {\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutDeprecatedLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    // Don't warn about react-lifecycles-compat polyfilled components.\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack$1(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    // This is difficult to track any other way since component names\n    // are often vague and are likely to collide between 3rd party libraries.\n    // An expand property is probably okay to use here since it's DEV-only,\n    // and will only be set in the event of serious warnings.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = void 0;\n    if (!pendingUnsafeLifecycleWarnings.has(strictRoot)) {\n      warningsForRoot = {\n        UNSAFE_componentWillMount: [],\n        UNSAFE_componentWillReceiveProps: [],\n        UNSAFE_componentWillUpdate: []\n      };\n\n      pendingUnsafeLifecycleWarnings.set(strictRoot, warningsForRoot);\n    } else {\n      warningsForRoot = pendingUnsafeLifecycleWarnings.get(strictRoot);\n    }\n\n    var unsafeLifecycles = [];\n    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillMount === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillMount');\n    }\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');\n    }\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true || typeof instance.UNSAFE_componentWillUpdate === 'function') {\n      unsafeLifecycles.push('UNSAFE_componentWillUpdate');\n    }\n\n    if (unsafeLifecycles.length > 0) {\n      unsafeLifecycles.forEach(function (lifecycle) {\n        warningsForRoot[lifecycle].push(fiber);\n      });\n    }\n  };\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n    if (strictRoot === null) {\n      warningWithoutStack$1(false, 'Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n      return;\n    }\n\n    // Dedup strategy: Warn once per component.\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function () {\n    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\n      var uniqueNames = new Set();\n      fiberArray.forEach(function (fiber) {\n        uniqueNames.add(getComponentName(fiber.type) || 'Component');\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n\n      var sortedNames = setToSortedString(uniqueNames);\n      var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);\n\n      warningWithoutStack$1(false, 'Legacy context API has been detected within a strict-mode tree: %s' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here:' + '\\nhttps://fb.me/react-strict-mode-warnings', strictRootComponentStack, sortedNames);\n    });\n  };\n}\n\n// This lets us hook into Fiber to debug what it's doing.\n// See https://github.com/facebook/react/pull/8033.\n// This is not part of the public API, not even for React DevTools.\n// You may only inject a debugTool if you work on React Fiber itself.\nvar ReactFiberInstrumentation = {\n  debugTool: null\n};\n\nvar ReactFiberInstrumentation_1 = ReactFiberInstrumentation;\n\n// TODO: Offscreen updates should never suspend. However, a promise that\n// suspended inside an offscreen subtree should be able to ping at the priority\n// of the outer render.\n\nfunction markPendingPriorityLevel(root, expirationTime) {\n  // If there's a gap between completing a failed root and retrying it,\n  // additional updates may be scheduled. Clear `didError`, in case the update\n  // is sufficient to fix the error.\n  root.didError = false;\n\n  // Update the latest and earliest pending times\n  var earliestPendingTime = root.earliestPendingTime;\n  if (earliestPendingTime === NoWork) {\n    // No other pending updates.\n    root.earliestPendingTime = root.latestPendingTime = expirationTime;\n  } else {\n    if (earliestPendingTime > expirationTime) {\n      // This is the earliest pending update.\n      root.earliestPendingTime = expirationTime;\n    } else {\n      var latestPendingTime = root.latestPendingTime;\n      if (latestPendingTime < expirationTime) {\n        // This is the latest pending update\n        root.latestPendingTime = expirationTime;\n      }\n    }\n  }\n  findNextExpirationTimeToWorkOn(expirationTime, root);\n}\n\nfunction markCommittedPriorityLevels(root, earliestRemainingTime) {\n  root.didError = false;\n\n  if (earliestRemainingTime === NoWork) {\n    // Fast path. There's no remaining work. Clear everything.\n    root.earliestPendingTime = NoWork;\n    root.latestPendingTime = NoWork;\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  // Let's see if the previous latest known pending level was just flushed.\n  var latestPendingTime = root.latestPendingTime;\n  if (latestPendingTime !== NoWork) {\n    if (latestPendingTime < earliestRemainingTime) {\n      // We've flushed all the known pending levels.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      var earliestPendingTime = root.earliestPendingTime;\n      if (earliestPendingTime < earliestRemainingTime) {\n        // We've flushed the earliest known pending level. Set this to the\n        // latest pending time.\n        root.earliestPendingTime = root.latestPendingTime;\n      }\n    }\n  }\n\n  // Now let's handle the earliest remaining level in the whole tree. We need to\n  // decide whether to treat it as a pending level or as suspended. Check\n  // it falls within the range of known suspended levels.\n\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestRemainingTime > latestSuspendedTime) {\n    // The earliest remaining level is later than all the suspended work. That\n    // means we've flushed all the suspended work.\n    root.earliestSuspendedTime = NoWork;\n    root.latestSuspendedTime = NoWork;\n    root.latestPingedTime = NoWork;\n\n    // There's no suspended work. Treat the earliest remaining level as a\n    // pending level.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  if (earliestRemainingTime < earliestSuspendedTime) {\n    // The earliest remaining time is earlier than all the suspended work.\n    // Treat it as a pending update.\n    markPendingPriorityLevel(root, earliestRemainingTime);\n    findNextExpirationTimeToWorkOn(NoWork, root);\n    return;\n  }\n\n  // The earliest remaining time falls within the range of known suspended\n  // levels. We should treat this as suspended work.\n  findNextExpirationTimeToWorkOn(NoWork, root);\n}\n\nfunction hasLowerPriorityWork(root, erroredExpirationTime) {\n  var latestPendingTime = root.latestPendingTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  var latestPingedTime = root.latestPingedTime;\n  return latestPendingTime !== NoWork && latestPendingTime > erroredExpirationTime || latestSuspendedTime !== NoWork && latestSuspendedTime > erroredExpirationTime || latestPingedTime !== NoWork && latestPingedTime > erroredExpirationTime;\n}\n\nfunction isPriorityLevelSuspended(root, expirationTime) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  return earliestSuspendedTime !== NoWork && expirationTime >= earliestSuspendedTime && expirationTime <= latestSuspendedTime;\n}\n\nfunction markSuspendedPriorityLevel(root, suspendedTime) {\n  root.didError = false;\n  clearPing(root, suspendedTime);\n\n  // First, check the known pending levels and update them if needed.\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPendingTime = root.latestPendingTime;\n  if (earliestPendingTime === suspendedTime) {\n    if (latestPendingTime === suspendedTime) {\n      // Both known pending levels were suspended. Clear them.\n      root.earliestPendingTime = root.latestPendingTime = NoWork;\n    } else {\n      // The earliest pending level was suspended. Clear by setting it to the\n      // latest pending level.\n      root.earliestPendingTime = latestPendingTime;\n    }\n  } else if (latestPendingTime === suspendedTime) {\n    // The latest pending level was suspended. Clear by setting it to the\n    // latest pending level.\n    root.latestPendingTime = earliestPendingTime;\n  }\n\n  // Finally, update the known suspended levels.\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  if (earliestSuspendedTime === NoWork) {\n    // No other suspended levels.\n    root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime;\n  } else {\n    if (earliestSuspendedTime > suspendedTime) {\n      // This is the earliest suspended level.\n      root.earliestSuspendedTime = suspendedTime;\n    } else if (latestSuspendedTime < suspendedTime) {\n      // This is the latest suspended level\n      root.latestSuspendedTime = suspendedTime;\n    }\n  }\n\n  findNextExpirationTimeToWorkOn(suspendedTime, root);\n}\n\nfunction markPingedPriorityLevel(root, pingedTime) {\n  root.didError = false;\n\n  // TODO: When we add back resuming, we need to ensure the progressed work\n  // is thrown out and not reused during the restarted render. One way to\n  // invalidate the progressed work is to restart at expirationTime + 1.\n  var latestPingedTime = root.latestPingedTime;\n  if (latestPingedTime === NoWork || latestPingedTime < pingedTime) {\n    root.latestPingedTime = pingedTime;\n  }\n  findNextExpirationTimeToWorkOn(pingedTime, root);\n}\n\nfunction clearPing(root, completedTime) {\n  // TODO: Track whether the root was pinged during the render phase. If so,\n  // we need to make sure we don't lose track of it.\n  var latestPingedTime = root.latestPingedTime;\n  if (latestPingedTime !== NoWork && latestPingedTime <= completedTime) {\n    root.latestPingedTime = NoWork;\n  }\n}\n\nfunction findEarliestOutstandingPriorityLevel(root, renderExpirationTime) {\n  var earliestExpirationTime = renderExpirationTime;\n\n  var earliestPendingTime = root.earliestPendingTime;\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  if (earliestExpirationTime === NoWork || earliestPendingTime !== NoWork && earliestPendingTime < earliestExpirationTime) {\n    earliestExpirationTime = earliestPendingTime;\n  }\n  if (earliestExpirationTime === NoWork || earliestSuspendedTime !== NoWork && earliestSuspendedTime < earliestExpirationTime) {\n    earliestExpirationTime = earliestSuspendedTime;\n  }\n  return earliestExpirationTime;\n}\n\nfunction didExpireAtExpirationTime(root, currentTime) {\n  var expirationTime = root.expirationTime;\n  if (expirationTime !== NoWork && currentTime >= expirationTime) {\n    // The root has expired. Flush all work up to the current time.\n    root.nextExpirationTimeToWorkOn = currentTime;\n  }\n}\n\nfunction findNextExpirationTimeToWorkOn(completedExpirationTime, root) {\n  var earliestSuspendedTime = root.earliestSuspendedTime;\n  var latestSuspendedTime = root.latestSuspendedTime;\n  var earliestPendingTime = root.earliestPendingTime;\n  var latestPingedTime = root.latestPingedTime;\n\n  // Work on the earliest pending time. Failing that, work on the latest\n  // pinged time.\n  var nextExpirationTimeToWorkOn = earliestPendingTime !== NoWork ? earliestPendingTime : latestPingedTime;\n\n  // If there is no pending or pinged work, check if there's suspended work\n  // that's lower priority than what we just completed.\n  if (nextExpirationTimeToWorkOn === NoWork && (completedExpirationTime === NoWork || latestSuspendedTime > completedExpirationTime)) {\n    // The lowest priority suspended work is the work most likely to be\n    // committed next. Let's start rendering it again, so that if it times out,\n    // it's ready to commit.\n    nextExpirationTimeToWorkOn = latestSuspendedTime;\n  }\n\n  var expirationTime = nextExpirationTimeToWorkOn;\n  if (expirationTime !== NoWork && earliestSuspendedTime !== NoWork && earliestSuspendedTime < expirationTime) {\n    // Expire using the earliest known expiration time.\n    expirationTime = earliestSuspendedTime;\n  }\n\n  root.nextExpirationTimeToWorkOn = nextExpirationTimeToWorkOn;\n  root.expirationTime = expirationTime;\n}\n\n// UpdateQueue is a linked list of prioritized updates.\n//\n// Like fibers, update queues come in pairs: a current queue, which represents\n// the visible state of the screen, and a work-in-progress queue, which is\n// can be mutated and processed asynchronously before it is committed  a form\n// of double buffering. If a work-in-progress render is discarded before\n// finishing, we create a new work-in-progress by cloning the current queue.\n//\n// Both queues share a persistent, singly-linked list structure. To schedule an\n// update, we append it to the end of both queues. Each queue maintains a\n// pointer to first update in the persistent list that hasn't been processed.\n// The work-in-progress pointer always has a position equal to or greater than\n// the current queue, since we always work on that one. The current queue's\n// pointer is only updated during the commit phase, when we swap in the\n// work-in-progress.\n//\n// For example:\n//\n//   Current pointer:           A - B - C - D - E - F\n//   Work-in-progress pointer:              D - E - F\n//                                          ^\n//                                          The work-in-progress queue has\n//                                          processed more updates than current.\n//\n// The reason we append to both queues is because otherwise we might drop\n// updates without ever processing them. For example, if we only add updates to\n// the work-in-progress queue, some updates could be lost whenever a work-in\n// -progress render restarts by cloning from current. Similarly, if we only add\n// updates to the current queue, the updates will be lost whenever an already\n// in-progress queue commits and swaps with the current queue. However, by\n// adding to both queues, we guarantee that the update will be part of the next\n// work-in-progress. (And because the work-in-progress queue becomes the\n// current queue once it commits, there's no danger of applying the same\n// update twice.)\n//\n// Prioritization\n// --------------\n//\n// Updates are not sorted by priority, but by insertion; new updates are always\n// appended to the end of the list.\n//\n// The priority is still important, though. When processing the update queue\n// during the render phase, only the updates with sufficient priority are\n// included in the result. If we skip an update because it has insufficient\n// priority, it remains in the queue to be processed later, during a lower\n// priority render. Crucially, all updates subsequent to a skipped update also\n// remain in the queue *regardless of their priority*. That means high priority\n// updates are sometimes processed twice, at two separate priorities. We also\n// keep track of a base state, that represents the state before the first\n// update in the queue is applied.\n//\n// For example:\n//\n//   Given a base state of '', and the following queue of updates\n//\n//     A1 - B2 - C1 - D2\n//\n//   where the number indicates the priority, and the update is applied to the\n//   previous state by appending a letter, React will process these updates as\n//   two separate renders, one per distinct priority level:\n//\n//   First render, at priority 1:\n//     Base state: ''\n//     Updates: [A1, C1]\n//     Result state: 'AC'\n//\n//   Second render, at priority 2:\n//     Base state: 'A'            <-  The base state does not include C1,\n//                                    because B2 was skipped.\n//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2\n//     Result state: 'ABCD'\n//\n// Because we process updates in insertion order, and rebase high priority\n// updates when preceding updates are skipped, the final result is deterministic\n// regardless of priority. Intermediate state may vary according to system\n// resources, but the final state is always the same.\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3;\n\n// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate = false;\n\nvar didWarnUpdateInsideUpdate = void 0;\nvar currentlyProcessingQueue = void 0;\nvar resetCurrentlyProcessingQueue = void 0;\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n  resetCurrentlyProcessingQueue = function () {\n    currentlyProcessingQueue = null;\n  };\n}\n\nfunction createUpdateQueue(baseState) {\n  var queue = {\n    baseState: baseState,\n    firstUpdate: null,\n    lastUpdate: null,\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n    firstEffect: null,\n    lastEffect: null,\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction cloneUpdateQueue(currentQueue) {\n  var queue = {\n    baseState: currentQueue.baseState,\n    firstUpdate: currentQueue.firstUpdate,\n    lastUpdate: currentQueue.lastUpdate,\n\n    // TODO: With resuming, if we bail out and resuse the child tree, we should\n    // keep these effects.\n    firstCapturedUpdate: null,\n    lastCapturedUpdate: null,\n\n    firstEffect: null,\n    lastEffect: null,\n\n    firstCapturedEffect: null,\n    lastCapturedEffect: null\n  };\n  return queue;\n}\n\nfunction createUpdate(expirationTime) {\n  return {\n    expirationTime: expirationTime,\n\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n\n    next: null,\n    nextEffect: null\n  };\n}\n\nfunction appendUpdateToQueue(queue, update) {\n  // Append the update to the end of the list.\n  if (queue.lastUpdate === null) {\n    // Queue is empty\n    queue.firstUpdate = queue.lastUpdate = update;\n  } else {\n    queue.lastUpdate.next = update;\n    queue.lastUpdate = update;\n  }\n}\n\nfunction enqueueUpdate(fiber, update) {\n  // Update queues are created lazily.\n  var alternate = fiber.alternate;\n  var queue1 = void 0;\n  var queue2 = void 0;\n  if (alternate === null) {\n    // There's only one fiber.\n    queue1 = fiber.updateQueue;\n    queue2 = null;\n    if (queue1 === null) {\n      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n    }\n  } else {\n    // There are two owners.\n    queue1 = fiber.updateQueue;\n    queue2 = alternate.updateQueue;\n    if (queue1 === null) {\n      if (queue2 === null) {\n        // Neither fiber has an update queue. Create new ones.\n        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);\n        queue2 = alternate.updateQueue = createUpdateQueue(alternate.memoizedState);\n      } else {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);\n      }\n    } else {\n      if (queue2 === null) {\n        // Only one fiber has an update queue. Clone to create a new one.\n        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);\n      } else {\n        // Both owners have an update queue.\n      }\n    }\n  }\n  if (queue2 === null || queue1 === queue2) {\n    // There's only a single queue.\n    appendUpdateToQueue(queue1, update);\n  } else {\n    // There are two queues. We need to append the update to both queues,\n    // while accounting for the persistent structure of the list  we don't\n    // want the same update to be added multiple times.\n    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {\n      // One of the queues is not empty. We must add the update to both queues.\n      appendUpdateToQueue(queue1, update);\n      appendUpdateToQueue(queue2, update);\n    } else {\n      // Both queues are non-empty. The last update is the same in both lists,\n      // because of structural sharing. So, only append to one of the lists.\n      appendUpdateToQueue(queue1, update);\n      // But we still need to update the `lastUpdate` pointer of queue2.\n      queue2.lastUpdate = update;\n    }\n  }\n\n  {\n    if ((fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) && (currentlyProcessingQueue === queue1 || queue2 !== null && currentlyProcessingQueue === queue2) && !didWarnUpdateInsideUpdate) {\n      warningWithoutStack$1(false, 'An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\n\nfunction enqueueCapturedUpdate(workInProgress, update) {\n  // Captured updates go into a separate list, and only on the work-in-\n  // progress queue.\n  var workInProgressQueue = workInProgress.updateQueue;\n  if (workInProgressQueue === null) {\n    workInProgressQueue = workInProgress.updateQueue = createUpdateQueue(workInProgress.memoizedState);\n  } else {\n    // TODO: I put this here rather than createWorkInProgress so that we don't\n    // clone the queue unnecessarily. There's probably a better way to\n    // structure this.\n    workInProgressQueue = ensureWorkInProgressQueueIsAClone(workInProgress, workInProgressQueue);\n  }\n\n  // Append the update to the end of the list.\n  if (workInProgressQueue.lastCapturedUpdate === null) {\n    // This is the first render phase update\n    workInProgressQueue.firstCapturedUpdate = workInProgressQueue.lastCapturedUpdate = update;\n  } else {\n    workInProgressQueue.lastCapturedUpdate.next = update;\n    workInProgressQueue.lastCapturedUpdate = update;\n  }\n}\n\nfunction ensureWorkInProgressQueueIsAClone(workInProgress, queue) {\n  var current = workInProgress.alternate;\n  if (current !== null) {\n    // If the work-in-progress queue is equal to the current queue,\n    // we need to clone it first.\n    if (queue === current.updateQueue) {\n      queue = workInProgress.updateQueue = cloneUpdateQueue(queue);\n    }\n  }\n  return queue;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        var _payload = update.payload;\n        if (typeof _payload === 'function') {\n          // Updater function\n          {\n            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              _payload.call(instance, prevState, nextProps);\n            }\n          }\n          return _payload.call(instance, prevState, nextProps);\n        }\n        // State object\n        return _payload;\n      }\n    case CaptureUpdate:\n      {\n        workInProgress.effectTag = workInProgress.effectTag & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n    case UpdateState:\n      {\n        var _payload2 = update.payload;\n        var partialState = void 0;\n        if (typeof _payload2 === 'function') {\n          // Updater function\n          {\n            if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n              _payload2.call(instance, prevState, nextProps);\n            }\n          }\n          partialState = _payload2.call(instance, prevState, nextProps);\n        } else {\n          // Partial state object\n          partialState = _payload2;\n        }\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        }\n        // Merge the partial state and the previous state.\n        return _assign({}, prevState, partialState);\n      }\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n  return prevState;\n}\n\nfunction processUpdateQueue(workInProgress, queue, props, instance, renderExpirationTime) {\n  hasForceUpdate = false;\n\n  queue = ensureWorkInProgressQueueIsAClone(workInProgress, queue);\n\n  {\n    currentlyProcessingQueue = queue;\n  }\n\n  // These values may change as we process the queue.\n  var newBaseState = queue.baseState;\n  var newFirstUpdate = null;\n  var newExpirationTime = NoWork;\n\n  // Iterate through the list of updates to compute the result.\n  var update = queue.firstUpdate;\n  var resultState = newBaseState;\n  while (update !== null) {\n    var updateExpirationTime = update.expirationTime;\n    if (updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstUpdate === null) {\n        // This is the first skipped update. It will be the first update in\n        // the new list.\n        newFirstUpdate = update;\n        // Since this is the first update that was skipped, the current result\n        // is the new base state.\n        newBaseState = resultState;\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime === NoWork || newExpirationTime > updateExpirationTime) {\n        newExpirationTime = updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n      var _callback = update.callback;\n      if (_callback !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastEffect === null) {\n          queue.firstEffect = queue.lastEffect = update;\n        } else {\n          queue.lastEffect.nextEffect = update;\n          queue.lastEffect = update;\n        }\n      }\n    }\n    // Continue to the next update.\n    update = update.next;\n  }\n\n  // Separately, iterate though the list of captured updates.\n  var newFirstCapturedUpdate = null;\n  update = queue.firstCapturedUpdate;\n  while (update !== null) {\n    var _updateExpirationTime = update.expirationTime;\n    if (_updateExpirationTime > renderExpirationTime) {\n      // This update does not have sufficient priority. Skip it.\n      if (newFirstCapturedUpdate === null) {\n        // This is the first skipped captured update. It will be the first\n        // update in the new list.\n        newFirstCapturedUpdate = update;\n        // If this is the first update that was skipped, the current result is\n        // the new base state.\n        if (newFirstUpdate === null) {\n          newBaseState = resultState;\n        }\n      }\n      // Since this update will remain in the list, update the remaining\n      // expiration time.\n      if (newExpirationTime === NoWork || newExpirationTime > _updateExpirationTime) {\n        newExpirationTime = _updateExpirationTime;\n      }\n    } else {\n      // This update does have sufficient priority. Process it and compute\n      // a new result.\n      resultState = getStateFromUpdate(workInProgress, queue, update, resultState, props, instance);\n      var _callback2 = update.callback;\n      if (_callback2 !== null) {\n        workInProgress.effectTag |= Callback;\n        // Set this to null, in case it was mutated during an aborted render.\n        update.nextEffect = null;\n        if (queue.lastCapturedEffect === null) {\n          queue.firstCapturedEffect = queue.lastCapturedEffect = update;\n        } else {\n          queue.lastCapturedEffect.nextEffect = update;\n          queue.lastCapturedEffect = update;\n        }\n      }\n    }\n    update = update.next;\n  }\n\n  if (newFirstUpdate === null) {\n    queue.lastUpdate = null;\n  }\n  if (newFirstCapturedUpdate === null) {\n    queue.lastCapturedUpdate = null;\n  } else {\n    workInProgress.effectTag |= Callback;\n  }\n  if (newFirstUpdate === null && newFirstCapturedUpdate === null) {\n    // We processed every update, without skipping. That means the new base\n    // state is the same as the result state.\n    newBaseState = resultState;\n  }\n\n  queue.baseState = newBaseState;\n  queue.firstUpdate = newFirstUpdate;\n  queue.firstCapturedUpdate = newFirstCapturedUpdate;\n\n  // Set the remaining expiration time to be whatever is remaining in the queue.\n  // This should be fine because the only two other things that contribute to\n  // expiration time are props and context. We're already in the middle of the\n  // begin phase by the time we start processing the queue, so we've already\n  // dealt with the props. Context in components that specify\n  // shouldComponentUpdate is tricky; but we'll have to account for\n  // that regardless.\n  workInProgress.expirationTime = newExpirationTime;\n  workInProgress.memoizedState = resultState;\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  !(typeof callback === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', callback) : void 0;\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\n\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\n\nfunction commitUpdateQueue(finishedWork, finishedQueue, instance, renderExpirationTime) {\n  // If the finished render included captured updates, and there are still\n  // lower priority updates left over, we need to keep the captured updates\n  // in the queue so that they are rebased and not dropped once we process the\n  // queue again at the lower priority.\n  if (finishedQueue.firstCapturedUpdate !== null) {\n    // Join the captured update list to the end of the normal list.\n    if (finishedQueue.lastUpdate !== null) {\n      finishedQueue.lastUpdate.next = finishedQueue.firstCapturedUpdate;\n      finishedQueue.lastUpdate = finishedQueue.lastCapturedUpdate;\n    }\n    // Clear the list of captured updates.\n    finishedQueue.firstCapturedUpdate = finishedQueue.lastCapturedUpdate = null;\n  }\n\n  // Commit the effects\n  commitUpdateEffects(finishedQueue.firstEffect, instance);\n  finishedQueue.firstEffect = finishedQueue.lastEffect = null;\n\n  commitUpdateEffects(finishedQueue.firstCapturedEffect, instance);\n  finishedQueue.firstCapturedEffect = finishedQueue.lastCapturedEffect = null;\n}\n\nfunction commitUpdateEffects(effect, instance) {\n  while (effect !== null) {\n    var _callback3 = effect.callback;\n    if (_callback3 !== null) {\n      effect.callback = null;\n      callCallback(_callback3, instance);\n    }\n    effect = effect.nextEffect;\n  }\n}\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\n\nvar valueCursor = createCursor(null);\n\nvar rendererSigil = void 0;\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nvar currentlyRenderingFiber = null;\nvar lastContextDependency = null;\nvar lastContextWithAllBitsObserved = null;\n\nfunction resetContextDependences() {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastContextWithAllBitsObserved = null;\n}\n\nfunction pushProvider(providerFiber, nextValue) {\n  var context = providerFiber.type._context;\n\n  if (isPrimaryRenderer) {\n    push(valueCursor, context._currentValue, providerFiber);\n\n    context._currentValue = nextValue;\n    {\n      !(context._currentRenderer === undefined || context._currentRenderer === null || context._currentRenderer === rendererSigil) ? warningWithoutStack$1(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(valueCursor, context._currentValue2, providerFiber);\n\n    context._currentValue2 = nextValue;\n    {\n      !(context._currentRenderer2 === undefined || context._currentRenderer2 === null || context._currentRenderer2 === rendererSigil) ? warningWithoutStack$1(false, 'Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.') : void 0;\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\n\nfunction popProvider(providerFiber) {\n  var currentValue = valueCursor.current;\n\n  pop(valueCursor, providerFiber);\n\n  var context = providerFiber.type._context;\n  if (isPrimaryRenderer) {\n    context._currentValue = currentValue;\n  } else {\n    context._currentValue2 = currentValue;\n  }\n}\n\nfunction calculateChangedBits(context, newValue, oldValue) {\n  // Use Object.is to compare the new context value to the old value. Inlined\n  // Object.is polyfill.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n  if (oldValue === newValue && (oldValue !== 0 || 1 / oldValue === 1 / newValue) || oldValue !== oldValue && newValue !== newValue // eslint-disable-line no-self-compare\n  ) {\n      // No change\n      return 0;\n    } else {\n    var changedBits = typeof context._calculateChangedBits === 'function' ? context._calculateChangedBits(oldValue, newValue) : maxSigned31BitInt;\n\n    {\n      !((changedBits & maxSigned31BitInt) === changedBits) ? warning$1(false, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: %s', changedBits) : void 0;\n    }\n    return changedBits | 0;\n  }\n}\n\nfunction propagateContextChange(workInProgress, context, changedBits, renderExpirationTime) {\n  var fiber = workInProgress.child;\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n  while (fiber !== null) {\n    var nextFiber = void 0;\n\n    // Visit this fiber.\n    var dependency = fiber.firstContextDependency;\n    if (dependency !== null) {\n      do {\n        // Check if the context matches.\n        if (dependency.context === context && (dependency.observedBits & changedBits) !== 0) {\n          // Match! Schedule an update on this fiber.\n\n          if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {\n            // Schedule a force update on the work-in-progress.\n            var update = createUpdate(renderExpirationTime);\n            update.tag = ForceUpdate;\n            // TODO: Because we don't have a work-in-progress, this will add the\n            // update to the current fiber, too, which means it will persist even if\n            // this render is thrown away. Since it's a race condition, not sure it's\n            // worth fixing.\n            enqueueUpdate(fiber, update);\n          }\n\n          if (fiber.expirationTime === NoWork || fiber.expirationTime > renderExpirationTime) {\n            fiber.expirationTime = renderExpirationTime;\n          }\n          var alternate = fiber.alternate;\n          if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > renderExpirationTime)) {\n            alternate.expirationTime = renderExpirationTime;\n          }\n          // Update the child expiration time of all the ancestors, including\n          // the alternates.\n          var node = fiber.return;\n          while (node !== null) {\n            alternate = node.alternate;\n            if (node.childExpirationTime === NoWork || node.childExpirationTime > renderExpirationTime) {\n              node.childExpirationTime = renderExpirationTime;\n              if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {\n                alternate.childExpirationTime = renderExpirationTime;\n              }\n            } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > renderExpirationTime)) {\n              alternate.childExpirationTime = renderExpirationTime;\n            } else {\n              // Neither alternate was updated, which means the rest of the\n              // ancestor path already has sufficient priority.\n              break;\n            }\n            node = node.return;\n          }\n        }\n        nextFiber = fiber.child;\n        dependency = dependency.next;\n      } while (dependency !== null);\n    } else if (fiber.tag === ContextProvider) {\n      // Don't scan deeper if this is a matching provider\n      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n    } else {\n      // Traverse down.\n      nextFiber = fiber.child;\n    }\n\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n        var sibling = nextFiber.sibling;\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        }\n        // No more siblings. Traverse up.\n        nextFiber = nextFiber.return;\n      }\n    }\n    fiber = nextFiber;\n  }\n}\n\nfunction prepareToReadContext(workInProgress, renderExpirationTime) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  lastContextWithAllBitsObserved = null;\n\n  // Reset the work-in-progress list\n  workInProgress.firstContextDependency = null;\n}\n\nfunction readContext(context, observedBits) {\n  if (lastContextWithAllBitsObserved === context) {\n    // Nothing to do. We already observe everything in this context.\n  } else if (observedBits === false || observedBits === 0) {\n    // Do not observe any updates.\n  } else {\n    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.\n    if (typeof observedBits !== 'number' || observedBits === maxSigned31BitInt) {\n      // Observe all updates.\n      lastContextWithAllBitsObserved = context;\n      resolvedObservedBits = maxSigned31BitInt;\n    } else {\n      resolvedObservedBits = observedBits;\n    }\n\n    var contextItem = {\n      context: context,\n      observedBits: resolvedObservedBits,\n      next: null\n    };\n\n    if (lastContextDependency === null) {\n      !(currentlyRenderingFiber !== null) ? invariant(false, 'Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps.') : void 0;\n      // This is the first dependency in the list\n      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;\n    } else {\n      // Append a new context item.\n      lastContextDependency = lastContextDependency.next = contextItem;\n    }\n  }\n  return isPrimaryRenderer ? context._currentValue : context._currentValue2;\n}\n\nvar NO_CONTEXT = {};\n\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  !(c !== NO_CONTEXT) ? invariant(false, 'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber);\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n\n  // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance);\n  // Now that we know this function doesn't throw, replace it.\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance);\n\n  // Don't push this Fiber's context unless it's unique.\n  if (context === nextContext) {\n    return;\n  }\n\n  // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar commitTime = 0;\nvar profilerStartTime = -1;\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  commitTime = schedule.unstable_now();\n}\n\nfunction startProfilerTimer(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  profilerStartTime = schedule.unstable_now();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = schedule.unstable_now();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n  if (!enableProfilerTimer) {\n    return;\n  }\n\n  if (profilerStartTime >= 0) {\n    var elapsedTime = schedule.unstable_now() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n    profilerStartTime = -1;\n  }\n}\n\nvar fakeInternalInstance = {};\nvar isArray = Array.isArray;\n\n// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nvar emptyRefsObject = new React.Component().refs;\n\nvar didWarnAboutStateAssignmentForComponent = void 0;\nvar didWarnAboutUninitializedState = void 0;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;\nvar didWarnAboutLegacyLifecyclesAndDerivedState = void 0;\nvar didWarnAboutUndefinedDerivedState = void 0;\nvar warnOnUndefinedDerivedState = void 0;\nvar warnOnInvalidCallback$1 = void 0;\nvar didWarnAboutDirectlyAssigningPropsToState = void 0;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback$1 = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n    var key = callerName + '_' + callback;\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n      warningWithoutStack$1(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentName(type) || 'Component';\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n        warningWithoutStack$1(false, '%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  };\n\n  // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      invariant(false, '_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  var prevState = workInProgress.memoizedState;\n\n  {\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      // Invoke the function an extra time to help detect side-effects.\n      getDerivedStateFromProps(nextProps, prevState);\n    }\n  }\n\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    warnOnUndefinedDerivedState(ctor, partialState);\n  }\n  // Merge the partial state and the previous state.\n  var memoizedState = partialState === null || partialState === undefined ? prevState : _assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState;\n\n  // Once the update queue is empty, persist the derived state onto the\n  // base state.\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.payload = payload;\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'setState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'replaceState');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    var fiber = get(inst);\n    var currentTime = requestCurrentTime();\n    var expirationTime = computeExpirationForFiber(currentTime, fiber);\n\n    var update = createUpdate(expirationTime);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback$1(callback, 'forceUpdate');\n      }\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    scheduleWork(fiber, expirationTime);\n  }\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext) {\n  var instance = workInProgress.stateNode;\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    startPhaseTimer(workInProgress, 'shouldComponentUpdate');\n    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextLegacyContext);\n    stopPhaseTimer();\n\n    {\n      !(shouldUpdate !== undefined) ? warningWithoutStack$1(false, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentName(ctor) || 'Component') : void 0;\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  var instance = workInProgress.stateNode;\n  {\n    var name = getComponentName(ctor) || 'Component';\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        warningWithoutStack$1(false, '%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        warningWithoutStack$1(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    var noGetInitialStateOnES6 = !instance.getInitialState || instance.getInitialState.isReactClassApproved || instance.state;\n    !noGetInitialStateOnES6 ? warningWithoutStack$1(false, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name) : void 0;\n    var noGetDefaultPropsOnES6 = !instance.getDefaultProps || instance.getDefaultProps.isReactClassApproved;\n    !noGetDefaultPropsOnES6 ? warningWithoutStack$1(false, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name) : void 0;\n    var noInstancePropTypes = !instance.propTypes;\n    !noInstancePropTypes ? warningWithoutStack$1(false, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name) : void 0;\n    var noInstanceContextTypes = !instance.contextTypes;\n    !noInstanceContextTypes ? warningWithoutStack$1(false, 'contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name) : void 0;\n    var noComponentShouldUpdate = typeof instance.componentShouldUpdate !== 'function';\n    !noComponentShouldUpdate ? warningWithoutStack$1(false, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name) : void 0;\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      warningWithoutStack$1(false, '%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentName(ctor) || 'A pure component');\n    }\n    var noComponentDidUnmount = typeof instance.componentDidUnmount !== 'function';\n    !noComponentDidUnmount ? warningWithoutStack$1(false, '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name) : void 0;\n    var noComponentDidReceiveProps = typeof instance.componentDidReceiveProps !== 'function';\n    !noComponentDidReceiveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name) : void 0;\n    var noComponentWillRecieveProps = typeof instance.componentWillRecieveProps !== 'function';\n    !noComponentWillRecieveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name) : void 0;\n    var noUnsafeComponentWillRecieveProps = typeof instance.UNSAFE_componentWillRecieveProps !== 'function';\n    !noUnsafeComponentWillRecieveProps ? warningWithoutStack$1(false, '%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name) : void 0;\n    var hasMutatedProps = instance.props !== newProps;\n    !(instance.props === undefined || !hasMutatedProps) ? warningWithoutStack$1(false, '%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name) : void 0;\n    var noInstanceDefaultProps = !instance.defaultProps;\n    !noInstanceDefaultProps ? warningWithoutStack$1(false, 'Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name) : void 0;\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n      warningWithoutStack$1(false, '%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentName(ctor));\n    }\n\n    var noInstanceGetDerivedStateFromProps = typeof instance.getDerivedStateFromProps !== 'function';\n    !noInstanceGetDerivedStateFromProps ? warningWithoutStack$1(false, '%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n    var noInstanceGetDerivedStateFromCatch = typeof instance.getDerivedStateFromCatch !== 'function';\n    !noInstanceGetDerivedStateFromCatch ? warningWithoutStack$1(false, '%s: getDerivedStateFromCatch() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name) : void 0;\n    var noStaticGetSnapshotBeforeUpdate = typeof ctor.getSnapshotBeforeUpdate !== 'function';\n    !noStaticGetSnapshotBeforeUpdate ? warningWithoutStack$1(false, '%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name) : void 0;\n    var _state = instance.state;\n    if (_state && (typeof _state !== 'object' || isArray(_state))) {\n      warningWithoutStack$1(false, '%s.state: must be set to an object or null', name);\n    }\n    if (typeof instance.getChildContext === 'function') {\n      !(typeof ctor.childContextTypes === 'object') ? warningWithoutStack$1(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name) : void 0;\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance;\n  // The instance needs access to the fiber so that it can schedule updates\n  set(instance, workInProgress);\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props, renderExpirationTime) {\n  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n  var contextTypes = ctor.contextTypes;\n  var isContextConsumer = contextTypes !== null && contextTypes !== undefined;\n  var context = isContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n\n  // Instantiate twice to help detect side-effects.\n  {\n    if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n      new ctor(props, context); // eslint-disable-line no-new\n    }\n  }\n\n  var instance = new ctor(props, context);\n  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      var componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n        warningWithoutStack$1(false, '`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    }\n\n    // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        var _componentName = getComponentName(ctor) || 'Component';\n        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n          warningWithoutStack$1(false, 'Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://fb.me/react-async-component-lifecycle-hooks', _componentName, newApiName, foundWillMountName !== null ? '\\n  ' + foundWillMountName : '', foundWillReceivePropsName !== null ? '\\n  ' + foundWillReceivePropsName : '', foundWillUpdateName !== null ? '\\n  ' + foundWillUpdateName : '');\n        }\n      }\n    }\n  }\n\n  // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n  if (isContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  startPhaseTimer(workInProgress, 'componentWillMount');\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  stopPhaseTimer();\n\n  if (oldState !== instance.state) {\n    {\n      warningWithoutStack$1(false, '%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentName(workInProgress.type) || 'Component');\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext) {\n  var oldState = instance.state;\n  startPhaseTimer(workInProgress, 'componentWillReceiveProps');\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextLegacyContext);\n  }\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextLegacyContext);\n  }\n  stopPhaseTimer();\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentName(workInProgress.type) || 'Component';\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n        warningWithoutStack$1(false, '%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\n// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n  {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  var instance = workInProgress.stateNode;\n  var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  instance.context = getMaskedContext(workInProgress, unmaskedContext);\n\n  {\n    if (instance.state === newProps) {\n      var componentName = getComponentName(ctor) || 'Component';\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n        warningWithoutStack$1(false, '%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress, instance);\n    }\n  }\n\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance);\n    // If we had additional state updates during this life-cycle, let's\n    // process them now.\n    updateQueue = workInProgress.updateQueue;\n    if (updateQueue !== null) {\n      processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n      instance.state = workInProgress.memoizedState;\n    }\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    workInProgress.effectTag |= Update;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderExpirationTime) {\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n  var nextLegacyContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    newState = workInProgress.memoizedState;\n  }\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillMount');\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextLegacyContext;\n\n  return shouldUpdate;\n}\n\n// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderExpirationTime) {\n  var instance = workInProgress.stateNode;\n\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n\n  var oldContext = instance.context;\n  var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n  var nextLegacyContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function';\n\n  // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextLegacyContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextLegacyContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  var updateQueue = workInProgress.updateQueue;\n  if (updateQueue !== null) {\n    processUpdateQueue(workInProgress, updateQueue, newProps, instance, renderExpirationTime);\n    newState = workInProgress.memoizedState;\n  }\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextLegacyContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      startPhaseTimer(workInProgress, 'componentWillUpdate');\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextLegacyContext);\n      }\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextLegacyContext);\n      }\n      stopPhaseTimer();\n    }\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.effectTag |= Update;\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.effectTag |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Update;\n      }\n    }\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (oldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.effectTag |= Snapshot;\n      }\n    }\n\n    // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  }\n\n  // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextLegacyContext;\n\n  return shouldUpdate;\n}\n\nvar didWarnAboutMaps = void 0;\nvar didWarnAboutGenerators = void 0;\nvar didWarnAboutStringRefInStrictMode = void 0;\nvar ownerHasKeyUseWarning = void 0;\nvar ownerHasFunctionTypeWarning = void 0;\nvar warnForMissingKey = function (child) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefInStrictMode = {};\n\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function (child) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n    !(typeof child._store === 'object') ? invariant(false, 'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n    child._store.validated = true;\n\n    var currentComponentErrorInfo = 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.' + getCurrentFiberStackInDev();\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n    warning$1(false, 'Each child in an array or iterator should have a unique ' + '\"key\" prop. See https://fb.me/react-warning-keys for ' + 'more information.');\n  };\n}\n\nvar isArray$1 = Array.isArray;\n\nfunction coerceRef(returnFiber, current$$1, element) {\n  var mixedRef = element.ref;\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    {\n      if (returnFiber.mode & StrictMode) {\n        var componentName = getComponentName(returnFiber.type) || 'Component';\n        if (!didWarnAboutStringRefInStrictMode[componentName]) {\n          warningWithoutStack$1(false, 'A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using createRef() instead.' + '\\n%s' + '\\n\\nLearn more about using refs safely here:' + '\\nhttps://fb.me/react-strict-mode-string-ref', mixedRef, getStackByFiberInDevAndProd(returnFiber));\n          didWarnAboutStringRefInStrictMode[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst = void 0;\n      if (owner) {\n        var ownerFiber = owner;\n        !(ownerFiber.tag === ClassComponent || ownerFiber.tag === ClassComponentLazy) ? invariant(false, 'Stateless function components cannot have refs.') : void 0;\n        inst = ownerFiber.stateNode;\n      }\n      !inst ? invariant(false, 'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.', mixedRef) : void 0;\n      var stringRef = '' + mixedRef;\n      // Check if previous string ref matches new string ref\n      if (current$$1 !== null && current$$1.ref !== null && typeof current$$1.ref === 'function' && current$$1.ref._stringRef === stringRef) {\n        return current$$1.ref;\n      }\n      var ref = function (value) {\n        var refs = inst.refs;\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = inst.refs = {};\n        }\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      !(typeof mixedRef === 'string') ? invariant(false, 'Expected ref to be a function, a string, an object returned by React.createRef(), or null.') : void 0;\n      !element._owner ? invariant(false, 'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a functional component\\n2. You may be adding a ref to a component that was not created inside a component\\'s render method\\n3. You have multiple copies of React loaded\\nSee https://fb.me/react-refs-must-have-owner for more information.', mixedRef) : void 0;\n    }\n  }\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (returnFiber.type !== 'textarea') {\n    var addendum = '';\n    {\n      addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + getCurrentFiberStackInDev();\n    }\n    invariant(false, 'Objects are not valid as a React child (found: %s).%s', Object.prototype.toString.call(newChild) === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : newChild, addendum);\n  }\n}\n\nfunction warnOnFunctionType() {\n  var currentComponentErrorInfo = 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.' + getCurrentFiberStackInDev();\n\n  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;\n\n  warning$1(false, 'Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n}\n\n// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n    // Deletions are added in reversed order so we add it to the front.\n    // At this point, the return fiber's effect list is empty except for\n    // deletions, so we can just append the deletion to the list. The remaining\n    // effects aren't added until the complete phase. Once we implement\n    // resuming, this may not be true.\n    var last = returnFiber.lastEffect;\n    if (last !== null) {\n      last.nextEffect = childToDelete;\n      returnFiber.lastEffect = childToDelete;\n    } else {\n      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n    }\n    childToDelete.nextEffect = null;\n    childToDelete.effectTag = Deletion;\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    }\n\n    // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n    var childToDelete = currentFirstChild;\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    var existingChildren = new Map();\n\n    var existingChild = currentFirstChild;\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n      existingChild = existingChild.sibling;\n    }\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps, expirationTime) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return lastPlacedIndex;\n    }\n    var current$$1 = newFiber.alternate;\n    if (current$$1 !== null) {\n      var oldIndex = current$$1.index;\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.effectTag = Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.effectTag = Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.effectTag = Placement;\n    }\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current$$1, textContent, expirationTime) {\n    if (current$$1 === null || current$$1.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current$$1, element, expirationTime) {\n    if (current$$1 !== null && current$$1.type === element.type) {\n      // Move based on index\n      var existing = useFiber(current$$1, element.props, expirationTime);\n      existing.ref = coerceRef(returnFiber, current$$1, element);\n      existing.return = returnFiber;\n      {\n        existing._debugSource = element._source;\n        existing._debugOwner = element._owner;\n      }\n      return existing;\n    } else {\n      // Insert\n      var created = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      created.ref = coerceRef(returnFiber, current$$1, element);\n      created.return = returnFiber;\n      return created;\n    }\n  }\n\n  function updatePortal(returnFiber, current$$1, portal, expirationTime) {\n    if (current$$1 === null || current$$1.tag !== HostPortal || current$$1.stateNode.containerInfo !== portal.containerInfo || current$$1.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, portal.children || [], expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current$$1, fragment, expirationTime, key) {\n    if (current$$1 === null || current$$1.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.mode, expirationTime, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current$$1, fragment, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.mode, expirationTime);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement(newChild, returnFiber.mode, expirationTime);\n            _created.ref = coerceRef(returnFiber, null, newChild);\n            _created.return = returnFiber;\n            return _created;\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, expirationTime);\n            _created2.return = returnFiber;\n            return _created2;\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, expirationTime, null);\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {\n    // Update the fiber if the keys match, otherwise return null.\n\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              if (newChild.type === REACT_FRAGMENT_TYPE) {\n                return updateFragment(returnFiber, oldFiber, newChild.props.children, expirationTime, key);\n              }\n              return updateElement(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, expirationTime);\n            } else {\n              return null;\n            }\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, expirationTime) {\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, expirationTime);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            if (newChild.type === REACT_FRAGMENT_TYPE) {\n              return updateFragment(returnFiber, _matchedFiber, newChild.props.children, expirationTime, newChild.key);\n            }\n            return updateElement(returnFiber, _matchedFiber, newChild, expirationTime);\n          }\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n            return updatePortal(returnFiber, _matchedFiber2, newChild, expirationTime);\n          }\n      }\n\n      if (isArray$1(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n        return updateFragment(returnFiber, _matchedFiber3, newChild, expirationTime, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n  function warnOnInvalidKey(child, knownKeys) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child);\n          var key = child.key;\n          if (typeof key !== 'string') {\n            break;\n          }\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n          warning$1(false, 'Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.', key);\n          break;\n        default:\n          break;\n      }\n    }\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, expirationTime) {\n    // This algorithm can't optimize by searching from boths ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n\n    {\n      // First, validate keys.\n      var knownKeys = null;\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], expirationTime);\n        if (!_newFiber) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n        previousNewFiber = _newFiber;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], expirationTime);\n      if (_newFiber2) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, expirationTime) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n    !(typeof iteratorFn === 'function') ? invariant(false, 'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n    {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' &&\n      // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        !didWarnAboutGenerators ? warning$1(false, 'Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.') : void 0;\n        didWarnAboutGenerators = true;\n      }\n\n      // Warn about using Maps as children\n      if (newChildrenIterable.entries === iteratorFn) {\n        !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;\n        didWarnAboutMaps = true;\n      }\n\n      // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n      if (_newChildren) {\n        var knownKeys = null;\n        var _step = _newChildren.next();\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n    !(newChildren != null) ? invariant(false, 'An iterable object provided no iterator.') : void 0;\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    var step = newChildren.next();\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, expirationTime);\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (!oldFiber) {\n          oldFiber = nextOldFiber;\n        }\n        break;\n      }\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);\n        if (_newFiber3 === null) {\n          continue;\n        }\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n        previousNewFiber = _newFiber3;\n      }\n      return resultingFirstChild;\n    }\n\n    // Add all children to a key map for quick lookups.\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n\n    // Keep scanning and use the map to restore deleted items as moves.\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, expirationTime);\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, expirationTime) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent, expirationTime);\n      existing.return = returnFiber;\n      return existing;\n    }\n    // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, expirationTime) {\n    var key = element.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === Fragment ? element.type === REACT_FRAGMENT_TYPE : child.type === element.type) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, element.type === REACT_FRAGMENT_TYPE ? element.props.children : element.props, expirationTime);\n          existing.ref = coerceRef(returnFiber, child, element);\n          existing.return = returnFiber;\n          {\n            existing._debugSource = element._source;\n            existing._debugOwner = element._owner;\n          }\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.mode, expirationTime, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(element, returnFiber.mode, expirationTime);\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, expirationTime) {\n    var key = portal.key;\n    var child = currentFirstChild;\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || [], expirationTime);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.mode, expirationTime);\n    created.return = returnFiber;\n    return created;\n  }\n\n  // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, expirationTime) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    }\n\n    // Handle object types\n    var isObject = typeof newChild === 'object' && newChild !== null;\n\n    if (isObject) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, expirationTime));\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, expirationTime));\n      }\n    }\n\n    if (typeof newChild === 'string' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, expirationTime));\n    }\n\n    if (isArray$1(newChild)) {\n      return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (getIteratorFn(newChild)) {\n      return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, expirationTime);\n    }\n\n    if (isObject) {\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType();\n      }\n    }\n    if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n      // If the new child is undefined, and the return fiber is a composite\n      // component, throw an error. If Fiber return types are disabled,\n      // we already threw above.\n      switch (returnFiber.tag) {\n        case ClassComponent:\n        case ClassComponentLazy:\n          {\n            {\n              var instance = returnFiber.stateNode;\n              if (instance.render._isMockFunction) {\n                // We allow auto-mocks to proceed as if they're returning null.\n                break;\n              }\n            }\n          }\n        // Intentionally fall through to the next case, which handles both\n        // functions and classes\n        // eslint-disable-next-lined no-fallthrough\n        case FunctionalComponent:\n          {\n            var Component = returnFiber.type;\n            invariant(false, '%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.', Component.displayName || Component.name || 'Component');\n          }\n      }\n    }\n\n    // Remaining cases are all treated as empty.\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\n\nfunction cloneChildFibers(current$$1, workInProgress) {\n  !(current$$1 === null || workInProgress.child === current$$1.child) ? invariant(false, 'Resuming work not yet implemented.') : void 0;\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n  workInProgress.child = newChild;\n\n  newChild.return = workInProgress;\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps, currentChild.expirationTime);\n    newChild.return = workInProgress;\n  }\n  newChild.sibling = null;\n}\n\n// The deepest Fiber on the stack involved in a hydration context.\n// This may have been an insertion or a hydration.\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false;\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChild(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  return true;\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo, instance);\n        break;\n      case HostComponent:\n        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n        break;\n    }\n  }\n\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  childToDelete.effectTag = Deletion;\n\n  // This might seem like it belongs on progressedFirstDeletion. However,\n  // these children are not part of the reconciliation list of children.\n  // Even if we abort and rereconcile the children, that will try to hydrate\n  // again and the nodes are still in the host tree so these will be\n  // recreated.\n  if (returnFiber.lastEffect !== null) {\n    returnFiber.lastEffect.nextEffect = childToDelete;\n    returnFiber.lastEffect = childToDelete;\n  } else {\n    returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.effectTag |= Placement;\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableContainerInstance(parentContainer, type, props);\n              break;\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableContainerTextInstance(parentContainer, text);\n              break;\n          }\n          break;\n        }\n      case HostComponent:\n        {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n          switch (fiber.tag) {\n            case HostComponent:\n              var _type = fiber.type;\n              var _props = fiber.pendingProps;\n              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n              break;\n            case HostText:\n              var _text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n              break;\n          }\n          break;\n        }\n      default:\n        return;\n    }\n  }\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          return true;\n        }\n        return false;\n      }\n    case HostText:\n      {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          return true;\n        }\n        return false;\n      }\n    default:\n      return false;\n  }\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n  var nextInstance = nextHydratableInstance;\n  if (!nextInstance) {\n    // Nothing to hydrate. Make it an insertion.\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n  var firstAttemptedInstance = nextInstance;\n  if (!tryHydrate(fiber, nextInstance)) {\n    // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    }\n    // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n    deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance);\n  }\n  hydrationParentFiber = fiber;\n  nextHydratableInstance = getFirstHydratableChild(nextInstance);\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var instance = fiber.stateNode;\n  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber);\n  // TODO: Type this specific to this type of component.\n  fiber.updateQueue = updatePayload;\n  // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n  if (updatePayload !== null) {\n    return true;\n  }\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    invariant(false, 'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n  {\n    if (shouldUpdate) {\n      // We assume that prepareToHydrateHostTextInstance is called in a context where the\n      // hydration parent is the parent host component of this host text.\n      var returnFiber = hydrationParentFiber;\n      if (returnFiber !== null) {\n        switch (returnFiber.tag) {\n          case HostRoot:\n            {\n              var parentContainer = returnFiber.stateNode.containerInfo;\n              didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent);\n              break;\n            }\n          case HostComponent:\n            {\n              var parentType = returnFiber.type;\n              var parentProps = returnFiber.memoizedProps;\n              var parentInstance = returnFiber.stateNode;\n              didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent);\n              break;\n            }\n        }\n      }\n    }\n  }\n  return shouldUpdate;\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot) {\n    parent = parent.return;\n  }\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  }\n\n  var type = fiber.type;\n\n  // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them.\n  // TODO: Better heuristic.\n  if (fiber.tag !== HostComponent || type !== 'head' && type !== 'body' && !shouldSetTextContent(type, fiber.memoizedProps)) {\n    var nextInstance = nextHydratableInstance;\n    while (nextInstance) {\n      deleteHydratableInstance(fiber, nextInstance);\n      nextInstance = getNextHydratableSibling(nextInstance);\n    }\n  }\n\n  popToNextHostParent(fiber);\n  nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  return true;\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n}\n\nfunction readLazyComponentType(thenable) {\n  var status = thenable._reactStatus;\n  switch (status) {\n    case Resolved:\n      var Component = thenable._reactResult;\n      return Component;\n    case Rejected:\n      throw thenable._reactResult;\n    case Pending:\n      throw thenable;\n    default:\n      {\n        thenable._reactStatus = Pending;\n        thenable.then(function (resolvedValue) {\n          if (thenable._reactStatus === Pending) {\n            thenable._reactStatus = Resolved;\n            if (typeof resolvedValue === 'object' && resolvedValue !== null) {\n              // If the `default` property is not empty, assume it's the result\n              // of an async import() and use that. Otherwise, use the\n              // resolved value itself.\n              var defaultExport = resolvedValue.default;\n              resolvedValue = defaultExport !== undefined && defaultExport !== null ? defaultExport : resolvedValue;\n            } else {\n              resolvedValue = resolvedValue;\n            }\n            thenable._reactResult = resolvedValue;\n          }\n        }, function (error) {\n          if (thenable._reactStatus === Pending) {\n            thenable._reactStatus = Rejected;\n            thenable._reactResult = error;\n          }\n        });\n        throw thenable;\n      }\n  }\n}\n\nvar ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\n\nvar didWarnAboutBadClass = void 0;\nvar didWarnAboutGetDerivedStateOnFunctionalComponent = void 0;\nvar didWarnAboutStatelessRefs = void 0;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutGetDerivedStateOnFunctionalComponent = {};\n  didWarnAboutStatelessRefs = {};\n}\n\nfunction reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime) {\n  if (current$$1 === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current$$1.child, nextChildren, renderExpirationTime);\n  }\n}\n\nfunction updateForwardRef(current$$1, workInProgress, type, nextProps, renderExpirationTime) {\n  var render = type.render;\n  var ref = workInProgress.ref;\n  if (hasContextChanged()) {\n    // Normally we can bail out on props equality but if context has changed\n    // we don't do the bailout and we have to reuse existing props instead.\n  } else if (workInProgress.memoizedProps === nextProps) {\n    var currentRef = current$$1 !== null ? current$$1.ref : null;\n    if (ref === currentRef) {\n      return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n    }\n  }\n\n  var nextChildren = void 0;\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase('render');\n    nextChildren = render(nextProps, ref);\n    setCurrentPhase(null);\n  }\n\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateFragment(current$$1, workInProgress, renderExpirationTime) {\n  var nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateMode(current$$1, workInProgress, renderExpirationTime) {\n  var nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextChildren);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current$$1, workInProgress, renderExpirationTime) {\n  if (enableProfilerTimer) {\n    workInProgress.effectTag |= Update;\n  }\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction markRef(current$$1, workInProgress) {\n  var ref = workInProgress.ref;\n  if (current$$1 === null && ref !== null || current$$1 !== null && current$$1.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.effectTag |= Ref;\n  }\n}\n\nfunction updateFunctionalComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {\n  var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  var nextChildren = void 0;\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase('render');\n    nextChildren = Component(nextProps, context);\n    setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current$$1, workInProgress, Component, nextProps, renderExpirationTime) {\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n  var hasContext = void 0;\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  var shouldUpdate = void 0;\n  if (current$$1 === null) {\n    if (workInProgress.stateNode === null) {\n      // In the initial pass we might need to construct the instance.\n      constructClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n      mountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n      shouldUpdate = true;\n    } else {\n      // In a resume, we'll already have an instance we can reuse.\n      shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderExpirationTime);\n    }\n  } else {\n    shouldUpdate = updateClassInstance(current$$1, workInProgress, Component, nextProps, renderExpirationTime);\n  }\n  return finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime);\n}\n\nfunction finishClassComponent(current$$1, workInProgress, Component, shouldUpdate, hasContext, renderExpirationTime) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef(current$$1, workInProgress);\n\n  var didCaptureError = (workInProgress.effectTag & DidCapture) !== NoEffect;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n  }\n\n  var instance = workInProgress.stateNode;\n\n  // Rerender\n  ReactCurrentOwner$3.current = workInProgress;\n  var nextChildren = void 0;\n  if (didCaptureError && (!enableGetDerivedStateFromCatch || typeof Component.getDerivedStateFromCatch !== 'function')) {\n    // If we captured an error, but getDerivedStateFrom catch is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    if (enableProfilerTimer) {\n      stopProfilerTimerIfRunning(workInProgress);\n    }\n  } else {\n    {\n      setCurrentPhase('render');\n      nextChildren = instance.render();\n      if (debugRenderPhaseSideEffects || debugRenderPhaseSideEffectsForStrictMode && workInProgress.mode & StrictMode) {\n        instance.render();\n      }\n      setCurrentPhase(null);\n    }\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  if (current$$1 !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile twice: first to delete\n    // all the existing children.\n    reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n    workInProgress.child = null;\n    // Now we can continue reconciling like normal. This has the effect of\n    // remounting all children regardless of whether their their\n    // identity matches.\n  }\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  // Memoize props and state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n  memoizeState(workInProgress, instance.state);\n  memoizeProps(workInProgress, instance.props);\n\n  // The context might have changed so we need to recalculate it.\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current$$1, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  var updateQueue = workInProgress.updateQueue;\n  !(updateQueue !== null) ? invariant(false, 'If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var nextProps = workInProgress.pendingProps;\n  var prevState = workInProgress.memoizedState;\n  var prevChildren = prevState !== null ? prevState.element : null;\n  processUpdateQueue(workInProgress, updateQueue, nextProps, null, renderExpirationTime);\n  var nextState = workInProgress.memoizedState;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  var nextChildren = nextState.element;\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n  }\n  var root = workInProgress.stateNode;\n  if ((current$$1 === null || current$$1.child === null) && root.hydrate && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n\n    // This is a bit of a hack. We track the host root as a placement to\n    // know that we're currently in a mounting state. That way isMounted\n    // works as expected. We must reset this before committing.\n    // TODO: Delete this when we delete isMounted and findDOMNode.\n    workInProgress.effectTag |= Placement;\n\n    // Ensure that children mount into this root without tracking\n    // side-effects. This ensures that we don't store Placement effects on\n    // nodes that will be hydrated.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n    resetHydrationState();\n  }\n  return workInProgress.child;\n}\n\nfunction updateHostComponent(current$$1, workInProgress, renderExpirationTime) {\n  pushHostContext(workInProgress);\n\n  if (current$$1 === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current$$1 !== null ? current$$1.memoizedProps : null;\n\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also have access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.effectTag |= ContentReset;\n  }\n\n  markRef(current$$1, workInProgress);\n\n  // Check the host config to see if the children are offscreen/hidden.\n  if (renderExpirationTime !== Never && workInProgress.mode & AsyncMode && shouldDeprioritizeSubtree(type, nextProps)) {\n    // Schedule this fiber to re-render at offscreen priority. Then bailout.\n    workInProgress.expirationTime = Never;\n    workInProgress.memoizedProps = nextProps;\n    return null;\n  }\n\n  reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n  memoizeProps(workInProgress, nextProps);\n  return workInProgress.child;\n}\n\nfunction updateHostText(current$$1, workInProgress) {\n  if (current$$1 === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n  var nextProps = workInProgress.pendingProps;\n  memoizeProps(workInProgress, nextProps);\n  // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n  return null;\n}\n\nfunction resolveDefaultProps(Component, baseProps) {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    var props = _assign({}, baseProps);\n    var defaultProps = Component.defaultProps;\n    for (var propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n    return props;\n  }\n  return baseProps;\n}\n\nfunction mountIndeterminateComponent(current$$1, workInProgress, Component, renderExpirationTime) {\n  !(current$$1 === null) ? invariant(false, 'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  var props = workInProgress.pendingProps;\n  if (typeof Component === 'object' && Component !== null && typeof Component.then === 'function') {\n    Component = readLazyComponentType(Component);\n    var resolvedTag = workInProgress.tag = resolveLazyComponentTag(workInProgress, Component);\n    var resolvedProps = resolveDefaultProps(Component, props);\n    switch (resolvedTag) {\n      case FunctionalComponentLazy:\n        {\n          return updateFunctionalComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n        }\n      case ClassComponentLazy:\n        {\n          return updateClassComponent(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n        }\n      case ForwardRefLazy:\n        {\n          return updateForwardRef(current$$1, workInProgress, Component, resolvedProps, renderExpirationTime);\n        }\n      default:\n        {\n          // This message intentionally doesn't metion ForwardRef because the\n          // fact that it's a separate type of work is an implementation detail.\n          invariant(false, 'Element type is invalid. Received a promise that resolves to: %s. Promise elements must resolve to a class or function.', Component);\n        }\n    }\n  }\n\n  var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n  var context = getMaskedContext(workInProgress, unmaskedContext);\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n\n  var value = void 0;\n\n  {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      var componentName = getComponentName(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        warningWithoutStack$1(false, \"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    ReactCurrentOwner$3.current = workInProgress;\n    value = Component(props, context);\n  }\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n\n  if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    // Proceed under the assumption that this is a class instance\n    workInProgress.tag = ClassComponent;\n\n    // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n    var hasContext = false;\n    if (isContextProvider(Component)) {\n      hasContext = true;\n      pushContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    if (typeof getDerivedStateFromProps === 'function') {\n      applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props);\n    }\n\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderExpirationTime);\n    return finishClassComponent(current$$1, workInProgress, Component, true, hasContext, renderExpirationTime);\n  } else {\n    // Proceed under the assumption that this is a functional component\n    workInProgress.tag = FunctionalComponent;\n    {\n      if (Component) {\n        !!Component.childContextTypes ? warningWithoutStack$1(false, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;\n      }\n      if (workInProgress.ref !== null) {\n        var info = '';\n        var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n        if (ownerName) {\n          info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n        }\n\n        var warningKey = ownerName || workInProgress._debugID || '';\n        var debugSource = workInProgress._debugSource;\n        if (debugSource) {\n          warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n        }\n        if (!didWarnAboutStatelessRefs[warningKey]) {\n          didWarnAboutStatelessRefs[warningKey] = true;\n          warning$1(false, 'Stateless function components cannot be given refs. ' + 'Attempts to access this ref will fail.%s', info);\n        }\n      }\n\n      if (typeof Component.getDerivedStateFromProps === 'function') {\n        var _componentName = getComponentName(Component) || 'Unknown';\n\n        if (!didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName]) {\n          warningWithoutStack$1(false, '%s: Stateless functional components do not support getDerivedStateFromProps.', _componentName);\n          didWarnAboutGetDerivedStateOnFunctionalComponent[_componentName] = true;\n        }\n      }\n    }\n    reconcileChildren(current$$1, workInProgress, value, renderExpirationTime);\n    memoizeProps(workInProgress, props);\n    return workInProgress.child;\n  }\n}\n\nfunction updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime) {\n  if (enableSuspense) {\n    var nextProps = workInProgress.pendingProps;\n\n    // Check if we already attempted to render the normal state. If we did,\n    // and we timed out, render the placeholder state.\n    var alreadyCaptured = (workInProgress.effectTag & DidCapture) === NoEffect;\n\n    var nextDidTimeout = void 0;\n    if (current$$1 !== null && workInProgress.updateQueue !== null) {\n      // We're outside strict mode. Something inside this Placeholder boundary\n      // suspended during the last commit. Switch to the placholder.\n      workInProgress.updateQueue = null;\n      nextDidTimeout = true;\n      // If we're recovering from an error, reconcile twice: first to delete\n      // all the existing children.\n      reconcileChildren(current$$1, workInProgress, null, renderExpirationTime);\n      current$$1.child = null;\n      // Now we can continue reconciling like normal. This has the effect of\n      // remounting all children regardless of whether their their\n      // identity matches.\n    } else {\n      nextDidTimeout = !alreadyCaptured;\n    }\n\n    if ((workInProgress.mode & StrictMode) !== NoEffect) {\n      if (nextDidTimeout) {\n        // If the timed-out view commits, schedule an update effect to record\n        // the committed time.\n        workInProgress.effectTag |= Update;\n      } else {\n        // The state node points to the time at which placeholder timed out.\n        // We can clear it once we switch back to the normal children.\n        workInProgress.stateNode = null;\n      }\n    }\n\n    // If the `children` prop is a function, treat it like a render prop.\n    // TODO: This is temporary until we finalize a lower level API.\n    var children = nextProps.children;\n    var nextChildren = void 0;\n    if (typeof children === 'function') {\n      nextChildren = children(nextDidTimeout);\n    } else {\n      nextChildren = nextDidTimeout ? nextProps.fallback : children;\n    }\n\n    workInProgress.memoizedProps = nextProps;\n    workInProgress.memoizedState = nextDidTimeout;\n    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n    return workInProgress.child;\n  } else {\n    return null;\n  }\n}\n\nfunction updatePortalComponent(current$$1, workInProgress, renderExpirationTime) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n  if (current$$1 === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderExpirationTime);\n    memoizeProps(workInProgress, nextChildren);\n  } else {\n    reconcileChildren(current$$1, workInProgress, nextChildren, renderExpirationTime);\n    memoizeProps(workInProgress, nextChildren);\n  }\n  return workInProgress.child;\n}\n\nfunction updateContextProvider(current$$1, workInProgress, renderExpirationTime) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n\n  var newValue = newProps.value;\n  workInProgress.memoizedProps = newProps;\n\n  {\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider', getCurrentFiberStackInDev);\n    }\n  }\n\n  pushProvider(workInProgress, newValue);\n\n  if (oldProps !== null) {\n    var oldValue = oldProps.value;\n    var changedBits = calculateChangedBits(context, newValue, oldValue);\n    if (changedBits === 0) {\n      // No change. Bailout early if children are the same.\n      if (oldProps.children === newProps.children && !hasContextChanged()) {\n        return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n      }\n    } else {\n      // The context value changed. Search for matching consumers and schedule\n      // them to update.\n      propagateContextChange(workInProgress, context, changedBits, renderExpirationTime);\n    }\n  }\n\n  var newChildren = newProps.children;\n  reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);\n  return workInProgress.child;\n}\n\nfunction updateContextConsumer(current$$1, workInProgress, renderExpirationTime) {\n  var context = workInProgress.type;\n  var newProps = workInProgress.pendingProps;\n  var render = newProps.children;\n\n  {\n    !(typeof render === 'function') ? warningWithoutStack$1(false, 'A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.') : void 0;\n  }\n\n  prepareToReadContext(workInProgress, renderExpirationTime);\n  var newValue = readContext(context, newProps.unstable_observedBits);\n  var newChildren = void 0;\n  {\n    ReactCurrentOwner$3.current = workInProgress;\n    setCurrentPhase('render');\n    newChildren = render(newValue);\n    setCurrentPhase(null);\n  }\n\n  // React DevTools reads this flag.\n  workInProgress.effectTag |= PerformedWork;\n  reconcileChildren(current$$1, workInProgress, newChildren, renderExpirationTime);\n  workInProgress.memoizedProps = newProps;\n  return workInProgress.child;\n}\n\n/*\n  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {\n    let child = firstChild;\n    do {\n      // Ensure that the first and last effect of the parent corresponds\n      // to the children's first and last effect.\n      if (!returnFiber.firstEffect) {\n        returnFiber.firstEffect = child.firstEffect;\n      }\n      if (child.lastEffect) {\n        if (returnFiber.lastEffect) {\n          returnFiber.lastEffect.nextEffect = child.firstEffect;\n        }\n        returnFiber.lastEffect = child.lastEffect;\n      }\n    } while (child = child.sibling);\n  }\n  */\n\nfunction bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime) {\n  cancelWorkTimer(workInProgress);\n\n  if (current$$1 !== null) {\n    // Reuse previous context list\n    workInProgress.firstContextDependency = current$$1.firstContextDependency;\n  }\n\n  if (enableProfilerTimer) {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning(workInProgress);\n  }\n\n  // Check if the children have any pending work.\n  var childExpirationTime = workInProgress.childExpirationTime;\n  if (childExpirationTime === NoWork || childExpirationTime > renderExpirationTime) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    return null;\n  } else {\n    // This fiber doesn't have work, but its subtree does. Clone the child\n    // fibers and continue.\n    cloneChildFibers(current$$1, workInProgress);\n    return workInProgress.child;\n  }\n}\n\n// TODO: Delete memoizeProps/State and move to reconcile/bailout instead\nfunction memoizeProps(workInProgress, nextProps) {\n  workInProgress.memoizedProps = nextProps;\n}\n\nfunction memoizeState(workInProgress, nextState) {\n  workInProgress.memoizedState = nextState;\n  // Don't reset the updateQueue, in case there are pending updates. Resetting\n  // is handled by processUpdateQueue.\n}\n\nfunction beginWork(current$$1, workInProgress, renderExpirationTime) {\n  var updateExpirationTime = workInProgress.expirationTime;\n  if (!hasContextChanged() && (updateExpirationTime === NoWork || updateExpirationTime > renderExpirationTime)) {\n    // This fiber does not have any pending work. Bailout without entering\n    // the begin phase. There's still some bookkeeping we that needs to be done\n    // in this optimized path, mostly pushing stuff onto the stack.\n    switch (workInProgress.tag) {\n      case HostRoot:\n        pushHostRootContext(workInProgress);\n        resetHydrationState();\n        break;\n      case HostComponent:\n        pushHostContext(workInProgress);\n        break;\n      case ClassComponent:\n        {\n          var Component = workInProgress.type;\n          if (isContextProvider(Component)) {\n            pushContextProvider(workInProgress);\n          }\n          break;\n        }\n      case ClassComponentLazy:\n        {\n          var thenable = workInProgress.type;\n          var _Component = getResultFromResolvedThenable(thenable);\n          if (isContextProvider(_Component)) {\n            pushContextProvider(workInProgress);\n          }\n          break;\n        }\n      case HostPortal:\n        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n        break;\n      case ContextProvider:\n        {\n          var newValue = workInProgress.memoizedProps.value;\n          pushProvider(workInProgress, newValue);\n          break;\n        }\n      case Profiler:\n        if (enableProfilerTimer) {\n          workInProgress.effectTag |= Update;\n        }\n        break;\n    }\n    return bailoutOnAlreadyFinishedWork(current$$1, workInProgress, renderExpirationTime);\n  }\n\n  // Before entering the begin phase, clear the expiration time.\n  workInProgress.expirationTime = NoWork;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        var _Component3 = workInProgress.type;\n        return mountIndeterminateComponent(current$$1, workInProgress, _Component3, renderExpirationTime);\n      }\n    case FunctionalComponent:\n      {\n        var _Component4 = workInProgress.type;\n        var _unresolvedProps = workInProgress.pendingProps;\n        return updateFunctionalComponent(current$$1, workInProgress, _Component4, _unresolvedProps, renderExpirationTime);\n      }\n    case FunctionalComponentLazy:\n      {\n        var _thenable2 = workInProgress.type;\n        var _Component5 = getResultFromResolvedThenable(_thenable2);\n        var _unresolvedProps2 = workInProgress.pendingProps;\n        var _child = updateFunctionalComponent(current$$1, workInProgress, _Component5, resolveDefaultProps(_Component5, _unresolvedProps2), renderExpirationTime);\n        workInProgress.memoizedProps = _unresolvedProps2;\n        return _child;\n      }\n    case ClassComponent:\n      {\n        var _Component6 = workInProgress.type;\n        var _unresolvedProps3 = workInProgress.pendingProps;\n        return updateClassComponent(current$$1, workInProgress, _Component6, _unresolvedProps3, renderExpirationTime);\n      }\n    case ClassComponentLazy:\n      {\n        var _thenable3 = workInProgress.type;\n        var _Component7 = getResultFromResolvedThenable(_thenable3);\n        var _unresolvedProps4 = workInProgress.pendingProps;\n        var _child2 = updateClassComponent(current$$1, workInProgress, _Component7, resolveDefaultProps(_Component7, _unresolvedProps4), renderExpirationTime);\n        workInProgress.memoizedProps = _unresolvedProps4;\n        return _child2;\n      }\n    case HostRoot:\n      return updateHostRoot(current$$1, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(current$$1, workInProgress, renderExpirationTime);\n    case HostText:\n      return updateHostText(current$$1, workInProgress);\n    case PlaceholderComponent:\n      return updatePlaceholderComponent(current$$1, workInProgress, renderExpirationTime);\n    case HostPortal:\n      return updatePortalComponent(current$$1, workInProgress, renderExpirationTime);\n    case ForwardRef:\n      {\n        var type = workInProgress.type;\n        return updateForwardRef(current$$1, workInProgress, type, workInProgress.pendingProps, renderExpirationTime);\n      }\n    case ForwardRefLazy:\n      var _thenable = workInProgress.type;\n      var _Component2 = getResultFromResolvedThenable(_thenable);\n      var unresolvedProps = workInProgress.pendingProps;\n      var child = updateForwardRef(current$$1, workInProgress, _Component2, resolveDefaultProps(_Component2, unresolvedProps), renderExpirationTime);\n      workInProgress.memoizedProps = unresolvedProps;\n      return child;\n    case Fragment:\n      return updateFragment(current$$1, workInProgress, renderExpirationTime);\n    case Mode:\n      return updateMode(current$$1, workInProgress, renderExpirationTime);\n    case Profiler:\n      return updateProfiler(current$$1, workInProgress, renderExpirationTime);\n    case ContextProvider:\n      return updateContextProvider(current$$1, workInProgress, renderExpirationTime);\n    case ContextConsumer:\n      return updateContextConsumer(current$$1, workInProgress, renderExpirationTime);\n    default:\n      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.effectTag |= Update;\n}\n\nfunction markRef$1(workInProgress) {\n  workInProgress.effectTag |= Ref;\n}\n\nfunction appendAllChildren(parent, workInProgress) {\n  // We only have the top Fiber that was created but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = workInProgress.child;\n  while (node !== null) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      appendInitialChild(parent, node.stateNode);\n    } else if (node.tag === HostPortal) {\n      // If we have a portal child, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === workInProgress) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nvar updateHostContainer = void 0;\nvar updateHostComponent$1 = void 0;\nvar updateHostText$1 = void 0;\nif (supportsMutation) {\n  // Mutation mode\n\n  updateHostContainer = function (workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    var oldProps = current.memoizedProps;\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    }\n\n    // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n    var instance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    // TODO: Type this specific to this type of component.\n    workInProgress.updateQueue = updatePayload;\n    // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n\n  // An unfortunate fork of appendAllChildren because we have two different parent types.\n  var appendAllChildrenToContainer = function (containerChildSet, workInProgress) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendChildToContainerChildSet(containerChildSet, node.stateNode);\n      } else if (node.tag === HostPortal) {\n        // If we have a portal child, then we don't want to traverse\n        // down its children. Instead, we'll get insertions from each child in\n        // the portal directly.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      if (node === workInProgress) {\n        return;\n      }\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n  updateHostContainer = function (workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged) {\n      // No changes, just reuse the existing instance.\n    } else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container);\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildrenToContainer(newChildSet, workInProgress);\n      portalOrRoot.pendingChildren = newChildSet;\n      // Schedule an update on the container to swap out the container.\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    var currentInstance = current.stateNode;\n    var oldProps = current.memoizedProps;\n    // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n    var childrenUnchanged = workInProgress.firstEffect === null;\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    var recyclableInstance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    var updatePayload = null;\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    }\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n    var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n    workInProgress.stateNode = newInstance;\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress);\n    }\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress);\n      // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n      markUpdate(workInProgress);\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (workInProgress) {\n    // Noop\n  };\n  updateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // Noop\n  };\n  updateHostText$1 = function (current, workInProgress, oldText, newText) {\n    // Noop\n  };\n}\n\nfunction completeWork(current, workInProgress, renderExpirationTime) {\n  var newProps = workInProgress.pendingProps;\n\n  switch (workInProgress.tag) {\n    case FunctionalComponent:\n    case FunctionalComponentLazy:\n      break;\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n        break;\n      }\n    case ClassComponentLazy:\n      {\n        var _Component = getResultFromResolvedThenable(workInProgress.type);\n        if (isContextProvider(_Component)) {\n          popContext(workInProgress);\n        }\n        break;\n      }\n    case HostRoot:\n      {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var fiberRoot = workInProgress.stateNode;\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          popHydrationState(workInProgress);\n          // This resets the hacky state to fix isMounted before committing.\n          // TODO: Delete this when we delete isMounted and findDOMNode.\n          workInProgress.effectTag &= ~Placement;\n        }\n        updateHostContainer(workInProgress);\n        break;\n      }\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef$1(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            // This can happen when we abort work.\n            break;\n          }\n\n          var currentHostContext = getHostContext();\n          // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on we want to add then top->down or\n          // bottom->up. Top->down is faster in IE11.\n          var wasHydrated = popHydrationState(workInProgress);\n          if (wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              // If changes to the hydrated node needs to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n\n            appendAllChildren(instance, workInProgress);\n\n            // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n            workInProgress.stateNode = instance;\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef$1(workInProgress);\n          }\n        }\n        break;\n      }\n    case HostText:\n      {\n        var newText = newProps;\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps;\n          // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n          updateHostText$1(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            !(workInProgress.stateNode !== null) ? invariant(false, 'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n            // This can happen when we abort work.\n          }\n          var _rootContainerInstance = getRootHostContainer();\n          var _currentHostContext = getHostContext();\n          var _wasHydrated = popHydrationState(workInProgress);\n          if (_wasHydrated) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n          }\n        }\n        break;\n      }\n    case ForwardRef:\n    case ForwardRefLazy:\n      break;\n    case PlaceholderComponent:\n      break;\n    case Fragment:\n      break;\n    case Mode:\n      break;\n    case Profiler:\n      break;\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(workInProgress);\n      break;\n    case ContextProvider:\n      // Pop provider fiber\n      popProvider(workInProgress);\n      break;\n    case ContextConsumer:\n      break;\n    // Error cases\n    case IndeterminateComponent:\n      invariant(false, 'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');\n    // eslint-disable-next-line no-fallthrough\n    default:\n      invariant(false, 'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  return null;\n}\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(capturedError) {\n  return true;\n}\n\nfunction logCapturedError(capturedError) {\n  var logError = showErrorDialog(capturedError);\n\n  // Allow injected showErrorDialog() to prevent default console.error logging.\n  // This enables renderers like ReactNative to better manage redbox behavior.\n  if (logError === false) {\n    return;\n  }\n\n  var error = capturedError.error;\n  {\n    var componentName = capturedError.componentName,\n        componentStack = capturedError.componentStack,\n        errorBoundaryName = capturedError.errorBoundaryName,\n        errorBoundaryFound = capturedError.errorBoundaryFound,\n        willRetry = capturedError.willRetry;\n\n    // Browsers support silencing uncaught errors by calling\n    // `preventDefault()` in window `error` handler.\n    // We record this information as an expando on the error.\n\n    if (error != null && error._suppressLogging) {\n      if (errorBoundaryFound && willRetry) {\n        // The error is recoverable and was silenced.\n        // Ignore it and don't print the stack addendum.\n        // This is handy for testing error boundaries without noise.\n        return;\n      }\n      // The error is fatal. Since the silencing might have\n      // been accidental, we'll surface it anyway.\n      // However, the browser would have silenced the original error\n      // so we'll print it first, and then print the stack addendum.\n      console.error(error);\n      // For a more detailed description of this block, see:\n      // https://github.com/facebook/react/pull/13384\n    }\n\n    var componentNameMessage = componentName ? 'The above error occurred in the <' + componentName + '> component:' : 'The above error occurred in one of your React components:';\n\n    var errorBoundaryMessage = void 0;\n    // errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.\n    if (errorBoundaryFound && errorBoundaryName) {\n      if (willRetry) {\n        errorBoundaryMessage = 'React will try to recreate this component tree from scratch ' + ('using the error boundary you provided, ' + errorBoundaryName + '.');\n      } else {\n        errorBoundaryMessage = 'This error was initially handled by the error boundary ' + errorBoundaryName + '.\\n' + 'Recreating the tree from scratch failed so React will unmount the tree.';\n      }\n    } else {\n      errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';\n    }\n    var combinedMessage = '' + componentNameMessage + componentStack + '\\n\\n' + ('' + errorBoundaryMessage);\n\n    // In development, we provide our own message with just the component stack.\n    // We don't include the original error message and JS stack because the browser\n    // has already printed it. Even if the application swallows the error, it is still\n    // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n    console.error(combinedMessage);\n  }\n}\n\nvar emptyObject = {};\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n}\n\nfunction logError(boundary, errorInfo) {\n  var source = errorInfo.source;\n  var stack = errorInfo.stack;\n  if (stack === null && source !== null) {\n    stack = getStackByFiberInDevAndProd(source);\n  }\n\n  var capturedError = {\n    componentName: source !== null ? getComponentName(source.type) : null,\n    componentStack: stack !== null ? stack : '',\n    error: errorInfo.value,\n    errorBoundary: null,\n    errorBoundaryName: null,\n    errorBoundaryFound: false,\n    willRetry: false\n  };\n\n  if (boundary !== null && boundary.tag === ClassComponent) {\n    capturedError.errorBoundary = boundary.stateNode;\n    capturedError.errorBoundaryName = getComponentName(boundary.type);\n    capturedError.errorBoundaryFound = true;\n    capturedError.willRetry = true;\n  }\n\n  try {\n    logCapturedError(capturedError);\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function (current$$1, instance) {\n  startPhaseTimer(current$$1, 'componentWillUnmount');\n  instance.props = current$$1.memoizedProps;\n  instance.state = current$$1.memoizedState;\n  instance.componentWillUnmount();\n  stopPhaseTimer();\n};\n\n// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current$$1, instance) {\n  {\n    invokeGuardedCallback(null, callComponentWillUnmountWithTimer, null, current$$1, instance);\n    if (hasCaughtError()) {\n      var unmountError = clearCaughtError();\n      captureCommitPhaseError(current$$1, unmountError);\n    }\n  }\n}\n\nfunction safelyDetachRef(current$$1) {\n  var ref = current$$1.ref;\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      {\n        invokeGuardedCallback(null, ref, null, null);\n        if (hasCaughtError()) {\n          var refError = clearCaughtError();\n          captureCommitPhaseError(current$$1, refError);\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction commitBeforeMutationLifeCycles(current$$1, finishedWork) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        if (finishedWork.effectTag & Snapshot) {\n          if (current$$1 !== null) {\n            var prevProps = current$$1.memoizedProps;\n            var prevState = current$$1.memoizedState;\n            startPhaseTimer(finishedWork, 'getSnapshotBeforeUpdate');\n            var instance = finishedWork.stateNode;\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n            {\n              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n                warningWithoutStack$1(false, '%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentName(finishedWork.type));\n              }\n            }\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n            stopPhaseTimer();\n          }\n        }\n        return;\n      }\n    case HostRoot:\n    case HostComponent:\n    case HostText:\n    case HostPortal:\n      // Nothing to do for these component types\n      return;\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitLifeCycles(finishedRoot, current$$1, finishedWork, committedExpirationTime) {\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        var instance = finishedWork.stateNode;\n        if (finishedWork.effectTag & Update) {\n          if (current$$1 === null) {\n            startPhaseTimer(finishedWork, 'componentDidMount');\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidMount();\n            stopPhaseTimer();\n          } else {\n            var prevProps = current$$1.memoizedProps;\n            var prevState = current$$1.memoizedState;\n            startPhaseTimer(finishedWork, 'componentDidUpdate');\n            instance.props = finishedWork.memoizedProps;\n            instance.state = finishedWork.memoizedState;\n            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n            stopPhaseTimer();\n          }\n        }\n        var updateQueue = finishedWork.updateQueue;\n        if (updateQueue !== null) {\n          instance.props = finishedWork.memoizedProps;\n          instance.state = finishedWork.memoizedState;\n          commitUpdateQueue(finishedWork, updateQueue, instance, committedExpirationTime);\n        }\n        return;\n      }\n    case HostRoot:\n      {\n        var _updateQueue = finishedWork.updateQueue;\n        if (_updateQueue !== null) {\n          var _instance = null;\n          if (finishedWork.child !== null) {\n            switch (finishedWork.child.tag) {\n              case HostComponent:\n                _instance = getPublicInstance(finishedWork.child.stateNode);\n                break;\n              case ClassComponent:\n              case ClassComponentLazy:\n                _instance = finishedWork.child.stateNode;\n                break;\n            }\n          }\n          commitUpdateQueue(finishedWork, _updateQueue, _instance, committedExpirationTime);\n        }\n        return;\n      }\n    case HostComponent:\n      {\n        var _instance2 = finishedWork.stateNode;\n\n        // Renderers may schedule work to be done after host components are mounted\n        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n        // These effects should only be committed when components are first mounted,\n        // aka when there is no current/alternate.\n        if (current$$1 === null && finishedWork.effectTag & Update) {\n          var type = finishedWork.type;\n          var props = finishedWork.memoizedProps;\n          commitMount(_instance2, type, props, finishedWork);\n        }\n\n        return;\n      }\n    case HostText:\n      {\n        // We have no life-cycles associated with text.\n        return;\n      }\n    case HostPortal:\n      {\n        // We have no life-cycles associated with portals.\n        return;\n      }\n    case Profiler:\n      {\n        if (enableProfilerTimer) {\n          var onRender = finishedWork.memoizedProps.onRender;\n\n          if (enableSchedulerTracing) {\n            onRender(finishedWork.memoizedProps.id, current$$1 === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime(), finishedRoot.memoizedInteractions);\n          } else {\n            onRender(finishedWork.memoizedProps.id, current$$1 === null ? 'mount' : 'update', finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, getCommitTime());\n          }\n        }\n        return;\n      }\n    case PlaceholderComponent:\n      {\n        if (enableSuspense) {\n          if ((finishedWork.mode & StrictMode) === NoEffect) {\n            // In loose mode, a placeholder times out by scheduling a synchronous\n            // update in the commit phase. Use `updateQueue` field to signal that\n            // the Timeout needs to switch to the placeholder. We don't need an\n            // entire queue. Any non-null value works.\n            // $FlowFixMe - Intentionally using a value other than an UpdateQueue.\n            finishedWork.updateQueue = emptyObject;\n            scheduleWork(finishedWork, Sync);\n          } else {\n            // In strict mode, the Update effect is used to record the time at\n            // which the placeholder timed out.\n            var currentTime = requestCurrentTime();\n            finishedWork.stateNode = { timedOutAt: currentTime };\n          }\n        }\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse = void 0;\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n      default:\n        instanceToUse = instance;\n    }\n    if (typeof ref === 'function') {\n      ref(instanceToUse);\n    } else {\n      {\n        if (!ref.hasOwnProperty('current')) {\n          warningWithoutStack$1(false, 'Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().%s', getComponentName(finishedWork.type), getStackByFiberInDevAndProd(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current$$1) {\n  var currentRef = current$$1.ref;\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      currentRef(null);\n    } else {\n      currentRef.current = null;\n    }\n  }\n}\n\n// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(current$$1) {\n  onCommitUnmount(current$$1);\n\n  switch (current$$1.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        safelyDetachRef(current$$1);\n        var instance = current$$1.stateNode;\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(current$$1, instance);\n        }\n        return;\n      }\n    case HostComponent:\n      {\n        safelyDetachRef(current$$1);\n        return;\n      }\n    case HostPortal:\n      {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (supportsMutation) {\n          unmountHostComponents(current$$1);\n        } else if (supportsPersistence) {\n          emptyPortalContainer(current$$1);\n        }\n        return;\n      }\n  }\n}\n\nfunction commitNestedUnmounts(root) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  var node = root;\n  while (true) {\n    commitUnmount(node);\n    // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n    if (node.child !== null && (\n    // If we use mutation we drill down into portals using commitUnmount above.\n    // If we don't use mutation we drill down into portals here instead.\n    !supportsMutation || node.tag !== HostPortal)) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === root) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiber(current$$1) {\n  // Cut off the return pointers to disconnect it from the tree. Ideally, we\n  // should clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child. This child\n  // itself will be GC:ed when the parent updates the next time.\n  current$$1.return = null;\n  current$$1.child = null;\n  if (current$$1.alternate) {\n    current$$1.alternate.child = null;\n    current$$1.alternate.return = null;\n  }\n}\n\nfunction emptyPortalContainer(current$$1) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current$$1.stateNode;\n  var containerInfo = portal.containerInfo;\n\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        return;\n      }\n    case HostComponent:\n      {\n        return;\n      }\n    case HostText:\n      {\n        return;\n      }\n    case HostRoot:\n    case HostPortal:\n      {\n        var portalOrRoot = finishedWork.stateNode;\n        var containerInfo = portalOrRoot.containerInfo,\n            _pendingChildren = portalOrRoot.pendingChildren;\n\n        replaceContainerChildren(containerInfo, _pendingChildren);\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n    parent = parent.return;\n  }\n  invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  var node = fiber;\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n    while (node.tag !== HostComponent && node.tag !== HostText) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.effectTag & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      }\n      // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    }\n    // Check if this host node is stable or about to be placed.\n    if (!(node.effectTag & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  // Recursively insert all host nodes into the parent.\n  var parentFiber = getHostParentFiber(finishedWork);\n\n  // Note: these two variables *must* always be updated together.\n  var parent = void 0;\n  var isContainer = void 0;\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      parent = parentFiber.stateNode;\n      isContainer = false;\n      break;\n    case HostRoot:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    case HostPortal:\n      parent = parentFiber.stateNode.containerInfo;\n      isContainer = true;\n      break;\n    default:\n      invariant(false, 'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');\n  }\n  if (parentFiber.effectTag & ContentReset) {\n    // Reset the text content of the parent before doing any insertions\n    resetTextContent(parent);\n    // Clear ContentReset from the effect tag\n    parentFiber.effectTag &= ~ContentReset;\n  }\n\n  var before = getHostSibling(finishedWork);\n  // We only have the top Fiber that was inserted but we need recurse down its\n  // children to find all the terminal nodes.\n  var node = finishedWork;\n  while (true) {\n    if (node.tag === HostComponent || node.tag === HostText) {\n      if (before) {\n        if (isContainer) {\n          insertInContainerBefore(parent, node.stateNode, before);\n        } else {\n          insertBefore(parent, node.stateNode, before);\n        }\n      } else {\n        if (isContainer) {\n          appendChildToContainer(parent, node.stateNode);\n        } else {\n          appendChild(parent, node.stateNode);\n        }\n      }\n    } else if (node.tag === HostPortal) {\n      // If the insertion itself is a portal, then we don't want to traverse\n      // down its children. Instead, we'll get insertions from each child in\n      // the portal directly.\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === finishedWork) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return;\n      }\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction unmountHostComponents(current$$1) {\n  // We only have the top Fiber that was deleted but we need recurse down its\n  var node = current$$1;\n\n  // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n  var currentParentIsValid = false;\n\n  // Note: these two variables *must* always be updated together.\n  var currentParent = void 0;\n  var currentParentIsContainer = void 0;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      var parent = node.return;\n      findParent: while (true) {\n        !(parent !== null) ? invariant(false, 'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parent.stateNode;\n            currentParentIsContainer = false;\n            break findParent;\n          case HostRoot:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n          case HostPortal:\n            currentParent = parent.stateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n        parent = parent.return;\n      }\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(node);\n      // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      }\n      // Don't visit children because we already visited them.\n    } else if (node.tag === HostPortal) {\n      // When we go into a portal, it becomes the parent to remove from.\n      // We will reassign it back when we pop the portal on the way up.\n      currentParent = node.stateNode.containerInfo;\n      currentParentIsContainer = true;\n      // Visit children because portals might contain host components.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(node);\n      // Visit children because we may find more host components below.\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n    if (node === current$$1) {\n      return;\n    }\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current$$1) {\n        return;\n      }\n      node = node.return;\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(current$$1) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(current$$1);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(current$$1);\n  }\n  detachFiber(current$$1);\n}\n\nfunction commitWork(current$$1, finishedWork) {\n  if (!supportsMutation) {\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case ClassComponentLazy:\n      {\n        return;\n      }\n    case HostComponent:\n      {\n        var instance = finishedWork.stateNode;\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          var newProps = finishedWork.memoizedProps;\n          // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n          var oldProps = current$$1 !== null ? current$$1.memoizedProps : newProps;\n          var type = finishedWork.type;\n          // TODO: Type the updateQueue to be specific to host components.\n          var updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n          if (updatePayload !== null) {\n            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n          }\n        }\n        return;\n      }\n    case HostText:\n      {\n        !(finishedWork.stateNode !== null) ? invariant(false, 'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        var textInstance = finishedWork.stateNode;\n        var newText = finishedWork.memoizedProps;\n        // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n        var oldText = current$$1 !== null ? current$$1.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n    case HostRoot:\n      {\n        return;\n      }\n    case Profiler:\n      {\n        return;\n      }\n    case PlaceholderComponent:\n      {\n        return;\n      }\n    default:\n      {\n        invariant(false, 'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');\n      }\n  }\n}\n\nfunction commitResetTextContent(current$$1) {\n  if (!supportsMutation) {\n    return;\n  }\n  resetTextContent(current$$1.stateNode);\n}\n\nfunction NoopComponent() {\n  return null;\n}\n\nfunction createRootErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  // Unmount the root by rendering null.\n  update.tag = CaptureUpdate;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: null };\n  var error = errorInfo.value;\n  update.callback = function () {\n    onUncaughtError(error);\n    logError(fiber, errorInfo);\n  };\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, expirationTime) {\n  var update = createUpdate(expirationTime);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromCatch = fiber.type.getDerivedStateFromCatch;\n  if (enableGetDerivedStateFromCatch && typeof getDerivedStateFromCatch === 'function') {\n    var error = errorInfo.value;\n    update.payload = function () {\n      return getDerivedStateFromCatch(error);\n    };\n  }\n\n  var inst = fiber.stateNode;\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      if (!enableGetDerivedStateFromCatch || getDerivedStateFromCatch !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromCatch is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n      var error = errorInfo.value;\n      var stack = errorInfo.stack;\n      logError(fiber, errorInfo);\n      this.componentDidCatch(error, {\n        componentStack: stack !== null ? stack : ''\n      });\n    };\n  }\n  return update;\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, renderExpirationTime) {\n  // The source fiber did not complete.\n  sourceFiber.effectTag |= Incomplete;\n  // Its effect list is no longer valid.\n  sourceFiber.firstEffect = sourceFiber.lastEffect = null;\n\n  if (enableSuspense && value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a thenable.\n    var thenable = value;\n\n    // Find the earliest timeout threshold of all the placeholders in the\n    // ancestor path. We could avoid this traversal by storing the thresholds on\n    // the stack, but we choose not to because we only hit this path if we're\n    // IO-bound (i.e. if something suspends). Whereas the stack is used even in\n    // the non-IO- bound case.\n    var _workInProgress = returnFiber;\n    var earliestTimeoutMs = -1;\n    var startTimeMs = -1;\n    do {\n      if (_workInProgress.tag === PlaceholderComponent) {\n        var current = _workInProgress.alternate;\n        if (current !== null && current.memoizedState === true && current.stateNode !== null) {\n          // Reached a placeholder that already timed out. Each timed out\n          // placeholder acts as the root of a new suspense boundary.\n\n          // Use the time at which the placeholder timed out as the start time\n          // for the current render.\n          var timedOutAt = current.stateNode.timedOutAt;\n          startTimeMs = expirationTimeToMs(timedOutAt);\n\n          // Do not search any further.\n          break;\n        }\n        var timeoutPropMs = _workInProgress.pendingProps.delayMs;\n        if (typeof timeoutPropMs === 'number') {\n          if (timeoutPropMs <= 0) {\n            earliestTimeoutMs = 0;\n          } else if (earliestTimeoutMs === -1 || timeoutPropMs < earliestTimeoutMs) {\n            earliestTimeoutMs = timeoutPropMs;\n          }\n        }\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n\n    // Schedule the nearest Placeholder to re-render the timed out view.\n    _workInProgress = returnFiber;\n    do {\n      if (_workInProgress.tag === PlaceholderComponent) {\n        var didTimeout = _workInProgress.memoizedState;\n        if (!didTimeout) {\n          // Found the nearest boundary.\n\n          // If the boundary is not in async mode, we should not suspend, and\n          // likewise, when the promise resolves, we should ping synchronously.\n          var pingTime = (_workInProgress.mode & AsyncMode) === NoEffect ? Sync : renderExpirationTime;\n\n          // Attach a listener to the promise to \"ping\" the root and retry.\n          var onResolveOrReject = retrySuspendedRoot.bind(null, root, _workInProgress, pingTime);\n          thenable.then(onResolveOrReject, onResolveOrReject);\n\n          // If the boundary is outside of strict mode, we should *not* suspend\n          // the commit. Pretend as if the suspended component rendered null and\n          // keep rendering. In the commit phase, we'll schedule a subsequent\n          // synchronous update to re-render the Placeholder.\n          //\n          // Note: It doesn't matter whether the component that suspended was\n          // inside a strict mode tree. If the Placeholder is outside of it, we\n          // should *not* suspend the commit.\n          if ((_workInProgress.mode & StrictMode) === NoEffect) {\n            _workInProgress.effectTag |= Update;\n\n            // Unmount the source fiber's children\n            var nextChildren = null;\n            reconcileChildren(sourceFiber.alternate, sourceFiber, nextChildren, renderExpirationTime);\n            sourceFiber.effectTag &= ~Incomplete;\n            if (sourceFiber.tag === IndeterminateComponent) {\n              // Let's just assume it's a functional component. This fiber will\n              // be unmounted in the immediate next commit, anyway.\n              sourceFiber.tag = FunctionalComponent;\n            }\n\n            if (sourceFiber.tag === ClassComponent || sourceFiber.tag === ClassComponentLazy) {\n              // We're going to commit this fiber even though it didn't\n              // complete. But we shouldn't call any lifecycle methods or\n              // callbacks. Remove all lifecycle effect tags.\n              sourceFiber.effectTag &= ~LifecycleEffectMask;\n              if (sourceFiber.alternate === null) {\n                // We're about to mount a class component that doesn't have an\n                // instance. Turn this into a dummy functional component instead,\n                // to prevent type errors. This is a bit weird but it's an edge\n                // case and we're about to synchronously delete this\n                // component, anyway.\n                sourceFiber.tag = FunctionalComponent;\n                sourceFiber.type = NoopComponent;\n              }\n            }\n\n            // Exit without suspending.\n            return;\n          }\n\n          // Confirmed that the boundary is in a strict mode tree. Continue with\n          // the normal suspend path.\n\n          var absoluteTimeoutMs = void 0;\n          if (earliestTimeoutMs === -1) {\n            // If no explicit threshold is given, default to an abitrarily large\n            // value. The actual size doesn't matter because the threshold for the\n            // whole tree will be clamped to the expiration time.\n            absoluteTimeoutMs = maxSigned31BitInt;\n          } else {\n            if (startTimeMs === -1) {\n              // This suspend happened outside of any already timed-out\n              // placeholders. We don't know exactly when the update was scheduled,\n              // but we can infer an approximate start time from the expiration\n              // time. First, find the earliest uncommitted expiration time in the\n              // tree, including work that is suspended. Then subtract the offset\n              // used to compute an async update's expiration time. This will cause\n              // high priority (interactive) work to expire earlier than necessary,\n              // but we can account for this by adjusting for the Just Noticeable\n              // Difference.\n              var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, renderExpirationTime);\n              var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n              startTimeMs = earliestExpirationTimeMs - LOW_PRIORITY_EXPIRATION;\n            }\n            absoluteTimeoutMs = startTimeMs + earliestTimeoutMs;\n          }\n\n          // Mark the earliest timeout in the suspended fiber's ancestor path.\n          // After completing the root, we'll take the largest of all the\n          // suspended fiber's timeouts and use it to compute a timeout for the\n          // whole tree.\n          renderDidSuspend(root, absoluteTimeoutMs, renderExpirationTime);\n\n          _workInProgress.effectTag |= ShouldCapture;\n          _workInProgress.expirationTime = renderExpirationTime;\n          return;\n        }\n        // This boundary already captured during this render. Continue to the\n        // next boundary.\n      }\n      _workInProgress = _workInProgress.return;\n    } while (_workInProgress !== null);\n    // No boundary was found. Fallthrough to error mode.\n    value = new Error('An update was suspended, but no placeholder UI was provided.');\n  }\n\n  // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n  renderDidError();\n  value = createCapturedValue(value, sourceFiber);\n  var workInProgress = returnFiber;\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          var _errorInfo = value;\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          var update = createRootErrorUpdate(workInProgress, _errorInfo, renderExpirationTime);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n      case ClassComponent:\n      case ClassComponentLazy:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n        if ((workInProgress.effectTag & DidCapture) === NoEffect && (typeof ctor.getDerivedStateFromCatch === 'function' && enableGetDerivedStateFromCatch || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.effectTag |= ShouldCapture;\n          workInProgress.expirationTime = renderExpirationTime;\n          // Schedule the error boundary to re-render using updated state\n          var _update = createClassErrorUpdate(workInProgress, errorInfo, renderExpirationTime);\n          enqueueCapturedUpdate(workInProgress, _update);\n          return;\n        }\n        break;\n      default:\n        break;\n    }\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction unwindWork(workInProgress, renderExpirationTime) {\n  switch (workInProgress.tag) {\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n        var effectTag = workInProgress.effectTag;\n        if (effectTag & ShouldCapture) {\n          workInProgress.effectTag = effectTag & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case ClassComponentLazy:\n      {\n        var _Component = workInProgress.type._reactResult;\n        if (isContextProvider(_Component)) {\n          popContext(workInProgress);\n        }\n        var _effectTag = workInProgress.effectTag;\n        if (_effectTag & ShouldCapture) {\n          workInProgress.effectTag = _effectTag & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case HostRoot:\n      {\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        var _effectTag2 = workInProgress.effectTag;\n        !((_effectTag2 & DidCapture) === NoEffect) ? invariant(false, 'The root failed to unmount after an error. This is likely a bug in React. Please file an issue.') : void 0;\n        workInProgress.effectTag = _effectTag2 & ~ShouldCapture | DidCapture;\n        return workInProgress;\n      }\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        return null;\n      }\n    case PlaceholderComponent:\n      {\n        var _effectTag3 = workInProgress.effectTag;\n        if (_effectTag3 & ShouldCapture) {\n          workInProgress.effectTag = _effectTag3 & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        }\n        return null;\n      }\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n    case ContextProvider:\n      popProvider(workInProgress);\n      return null;\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(interruptedWork) {\n  switch (interruptedWork.tag) {\n    case ClassComponent:\n      {\n        var childContextTypes = interruptedWork.type.childContextTypes;\n        if (childContextTypes !== null && childContextTypes !== undefined) {\n          popContext(interruptedWork);\n        }\n        break;\n      }\n    case ClassComponentLazy:\n      {\n        var _childContextTypes = interruptedWork.type._reactResult.childContextTypes;\n        if (_childContextTypes !== null && _childContextTypes !== undefined) {\n          popContext(interruptedWork);\n        }\n        break;\n      }\n    case HostRoot:\n      {\n        popHostContainer(interruptedWork);\n        popTopLevelContextObject(interruptedWork);\n        break;\n      }\n    case HostComponent:\n      {\n        popHostContext(interruptedWork);\n        break;\n      }\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n    case ContextProvider:\n      popProvider(interruptedWork);\n      break;\n    default:\n      break;\n  }\n}\n\nvar Dispatcher = {\n  readContext: readContext\n};\n\nvar ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;\n\n\nvar didWarnAboutStateTransition = void 0;\nvar didWarnSetStateChildContext = void 0;\nvar warnAboutUpdateOnUnmounted = void 0;\nvar warnAboutInvalidUpdates = void 0;\n\nif (enableSchedulerTracing) {\n  // Provide explicit error message when production+profiling bundle of e.g. react-dom\n  // is used with production (non-profiling) bundle of schedule/tracing\n  !(tracing.__interactionsRef != null && tracing.__interactionsRef.current != null) ? invariant(false, 'It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `schedule/tracing` module with `schedule/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling') : void 0;\n}\n\n{\n  didWarnAboutStateTransition = false;\n  didWarnSetStateChildContext = false;\n  var didWarnStateUpdateForUnmountedComponent = {};\n\n  warnAboutUpdateOnUnmounted = function (fiber) {\n    // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n    var componentName = getComponentName(fiber.type) || 'ReactClass';\n    if (didWarnStateUpdateForUnmountedComponent[componentName]) {\n      return;\n    }\n    warningWithoutStack$1(false, \"Can't call setState (or forceUpdate) on an unmounted component. This \" + 'is a no-op, but it indicates a memory leak in your application. To ' + 'fix, cancel all subscriptions and asynchronous tasks in the ' + 'componentWillUnmount method.%s', getStackByFiberInDevAndProd(fiber));\n    didWarnStateUpdateForUnmountedComponent[componentName] = true;\n  };\n\n  warnAboutInvalidUpdates = function (instance) {\n    switch (phase) {\n      case 'getChildContext':\n        if (didWarnSetStateChildContext) {\n          return;\n        }\n        warningWithoutStack$1(false, 'setState(...): Cannot call setState() inside getChildContext()');\n        didWarnSetStateChildContext = true;\n        break;\n      case 'render':\n        if (didWarnAboutStateTransition) {\n          return;\n        }\n        warningWithoutStack$1(false, 'Cannot update during an existing state transition (such as within ' + '`render`). Render methods should be a pure function of props and state.');\n        didWarnAboutStateTransition = true;\n        break;\n    }\n  };\n}\n\n// Used to ensure computeUniqueAsyncExpiration is monotonically increasing.\nvar lastUniqueAsyncExpiration = 0;\n\n// Represents the expiration time that incoming updates should use. (If this\n// is NoWork, use the default strategy: async updates in async mode, sync\n// updates in sync mode.)\nvar expirationContext = NoWork;\n\nvar isWorking = false;\n\n// The next work in progress fiber that we're currently working on.\nvar nextUnitOfWork = null;\nvar nextRoot = null;\n// The time at which we're currently rendering work.\nvar nextRenderExpirationTime = NoWork;\nvar nextLatestAbsoluteTimeoutMs = -1;\nvar nextRenderDidError = false;\n\n// The next fiber with an effect that we're currently committing.\nvar nextEffect = null;\n\nvar isCommitting$1 = false;\n\nvar legacyErrorBoundariesThatAlreadyFailed = null;\n\n// Used for performance tracking.\nvar interruptedBy = null;\n\n// Do not decrement interaction counts in the event of suspense timeouts.\n// This would lead to prematurely calling the interaction-complete hook.\nvar suspenseDidTimeout = false;\n\nvar stashedWorkInProgressProperties = void 0;\nvar replayUnitOfWork = void 0;\nvar isReplayingFailedUnitOfWork = void 0;\nvar originalReplayError = void 0;\nvar rethrowOriginalError = void 0;\nif (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n  stashedWorkInProgressProperties = null;\n  isReplayingFailedUnitOfWork = false;\n  originalReplayError = null;\n  replayUnitOfWork = function (failedUnitOfWork, thrownValue, isYieldy) {\n    if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n      // Don't replay promises. Treat everything else like an error.\n      // TODO: Need to figure out a different strategy if/when we add\n      // support for catching other types.\n      return;\n    }\n\n    // Restore the original state of the work-in-progress\n    if (stashedWorkInProgressProperties === null) {\n      // This should never happen. Don't throw because this code is DEV-only.\n      warningWithoutStack$1(false, 'Could not replay rendering after an error. This is likely a bug in React. ' + 'Please file an issue.');\n      return;\n    }\n    assignFiberPropertiesInDEV(failedUnitOfWork, stashedWorkInProgressProperties);\n\n    switch (failedUnitOfWork.tag) {\n      case HostRoot:\n        popHostContainer(failedUnitOfWork);\n        popTopLevelContextObject(failedUnitOfWork);\n        break;\n      case HostComponent:\n        popHostContext(failedUnitOfWork);\n        break;\n      case ClassComponent:\n        {\n          var Component = failedUnitOfWork.type;\n          if (isContextProvider(Component)) {\n            popContext(failedUnitOfWork);\n          }\n          break;\n        }\n      case ClassComponentLazy:\n        {\n          var _Component = getResultFromResolvedThenable(failedUnitOfWork.type);\n          if (isContextProvider(_Component)) {\n            popContext(failedUnitOfWork);\n          }\n          break;\n        }\n      case HostPortal:\n        popHostContainer(failedUnitOfWork);\n        break;\n      case ContextProvider:\n        popProvider(failedUnitOfWork);\n        break;\n    }\n    // Replay the begin phase.\n    isReplayingFailedUnitOfWork = true;\n    originalReplayError = thrownValue;\n    invokeGuardedCallback(null, workLoop, null, isYieldy);\n    isReplayingFailedUnitOfWork = false;\n    originalReplayError = null;\n    if (hasCaughtError()) {\n      var replayError = clearCaughtError();\n      if (replayError != null && thrownValue != null) {\n        try {\n          // Reading the expando property is intentionally\n          // inside `try` because it might be a getter or Proxy.\n          if (replayError._suppressLogging) {\n            // Also suppress logging for the original error.\n            thrownValue._suppressLogging = true;\n          }\n        } catch (inner) {\n          // Ignore.\n        }\n      }\n    } else {\n      // If the begin phase did not fail the second time, set this pointer\n      // back to the original value.\n      nextUnitOfWork = failedUnitOfWork;\n    }\n  };\n  rethrowOriginalError = function () {\n    throw originalReplayError;\n  };\n}\n\nfunction resetStack() {\n  if (nextUnitOfWork !== null) {\n    var interruptedWork = nextUnitOfWork.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n    checkThatStackIsEmpty();\n  }\n\n  nextRoot = null;\n  nextRenderExpirationTime = NoWork;\n  nextLatestAbsoluteTimeoutMs = -1;\n  nextRenderDidError = false;\n  nextUnitOfWork = null;\n}\n\nfunction commitAllHostEffects() {\n  while (nextEffect !== null) {\n    {\n      setCurrentFiber(nextEffect);\n    }\n    recordEffect();\n\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & ContentReset) {\n      commitResetTextContent(nextEffect);\n    }\n\n    if (effectTag & Ref) {\n      var current$$1 = nextEffect.alternate;\n      if (current$$1 !== null) {\n        commitDetachRef(current$$1);\n      }\n    }\n\n    // The following switch statement is only concerned about placement,\n    // updates, and deletions. To avoid needing to add a case for every\n    // possible bitmap value, we remove the secondary effects from the\n    // effect tag and switch on that value.\n    var primaryEffectTag = effectTag & (Placement | Update | Deletion);\n    switch (primaryEffectTag) {\n      case Placement:\n        {\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          // TODO: findDOMNode doesn't rely on this any more but isMounted\n          // does and isMounted is deprecated anyway so we should be able\n          // to kill this.\n          nextEffect.effectTag &= ~Placement;\n          break;\n        }\n      case PlacementAndUpdate:\n        {\n          // Placement\n          commitPlacement(nextEffect);\n          // Clear the \"placement\" from effect tag so that we know that this is inserted, before\n          // any life-cycles like componentDidMount gets called.\n          nextEffect.effectTag &= ~Placement;\n\n          // Update\n          var _current = nextEffect.alternate;\n          commitWork(_current, nextEffect);\n          break;\n        }\n      case Update:\n        {\n          var _current2 = nextEffect.alternate;\n          commitWork(_current2, nextEffect);\n          break;\n        }\n      case Deletion:\n        {\n          commitDeletion(nextEffect);\n          break;\n        }\n    }\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitBeforeMutationLifecycles() {\n  while (nextEffect !== null) {\n    {\n      setCurrentFiber(nextEffect);\n    }\n\n    var effectTag = nextEffect.effectTag;\n    if (effectTag & Snapshot) {\n      recordEffect();\n      var current$$1 = nextEffect.alternate;\n      commitBeforeMutationLifeCycles(current$$1, nextEffect);\n    }\n\n    // Don't cleanup effects yet;\n    // This will be done by commitAllLifeCycles()\n    nextEffect = nextEffect.nextEffect;\n  }\n\n  {\n    resetCurrentFiber();\n  }\n}\n\nfunction commitAllLifeCycles(finishedRoot, committedExpirationTime) {\n  {\n    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n\n    if (warnAboutDeprecatedLifecycles) {\n      ReactStrictModeWarnings.flushPendingDeprecationWarnings();\n    }\n\n    if (warnAboutLegacyContextAPI) {\n      ReactStrictModeWarnings.flushLegacyContextWarning();\n    }\n  }\n  while (nextEffect !== null) {\n    var effectTag = nextEffect.effectTag;\n\n    if (effectTag & (Update | Callback)) {\n      recordEffect();\n      var current$$1 = nextEffect.alternate;\n      commitLifeCycles(finishedRoot, current$$1, nextEffect, committedExpirationTime);\n    }\n\n    if (effectTag & Ref) {\n      recordEffect();\n      commitAttachRef(nextEffect);\n    }\n\n    var next = nextEffect.nextEffect;\n    // Ensure that we clean these up so that we don't accidentally keep them.\n    // I'm not actually sure this matters because we can't reset firstEffect\n    // and lastEffect since they're on every node, not just the effectful\n    // ones. So we have to clean everything as we reuse nodes anyway.\n    nextEffect.nextEffect = null;\n    // Ensure that we reset the effectTag here so that we can rely on effect\n    // tags to reason about the current life-cycle.\n    nextEffect = next;\n  }\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\n\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction commitRoot(root, finishedWork) {\n  isWorking = true;\n  isCommitting$1 = true;\n  startCommitTimer();\n\n  !(root.current !== finishedWork) ? invariant(false, 'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  var committedExpirationTime = root.pendingCommitExpirationTime;\n  !(committedExpirationTime !== NoWork) ? invariant(false, 'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  root.pendingCommitExpirationTime = NoWork;\n\n  // Update the pending priority levels to account for the work that we are\n  // about to commit. This needs to happen before calling the lifecycles, since\n  // they may schedule additional updates.\n  var updateExpirationTimeBeforeCommit = finishedWork.expirationTime;\n  var childExpirationTimeBeforeCommit = finishedWork.childExpirationTime;\n  var earliestRemainingTimeBeforeCommit = updateExpirationTimeBeforeCommit === NoWork || childExpirationTimeBeforeCommit !== NoWork && childExpirationTimeBeforeCommit < updateExpirationTimeBeforeCommit ? childExpirationTimeBeforeCommit : updateExpirationTimeBeforeCommit;\n  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);\n\n  var prevInteractions = null;\n  var committedInteractions = enableSchedulerTracing ? [] : null;\n  if (enableSchedulerTracing) {\n    // Restore any pending interactions at this point,\n    // So that cascading work triggered during the render phase will be accounted for.\n    prevInteractions = tracing.__interactionsRef.current;\n    tracing.__interactionsRef.current = root.memoizedInteractions;\n\n    // We are potentially finished with the current batch of interactions.\n    // So we should clear them out of the pending interaction map.\n    // We do this at the start of commit in case cascading work is scheduled by commit phase lifecycles.\n    // In that event, interaction data may be added back into the pending map for a future commit.\n    // We also store the interactions we are about to commit so that we can notify subscribers after we're done.\n    // These are stored as an Array rather than a Set,\n    // Because the same interaction may be pending for multiple expiration times,\n    // In which case it's important that we decrement the count the right number of times after finishing.\n    root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {\n      if (scheduledExpirationTime <= committedExpirationTime) {\n        committedInteractions.push.apply(committedInteractions, Array.from(scheduledInteractions));\n        root.pendingInteractionMap.delete(scheduledExpirationTime);\n      }\n    });\n  }\n\n  // Reset this to null before calling lifecycles\n  ReactCurrentOwner$2.current = null;\n\n  var firstEffect = void 0;\n  if (finishedWork.effectTag > PerformedWork) {\n    // A fiber's effect list consists only of its children, not itself. So if\n    // the root has an effect, we need to add it to the end of the list. The\n    // resulting list is the set that would belong to the root's parent, if\n    // it had one; that is, all the effects in the tree including the root.\n    if (finishedWork.lastEffect !== null) {\n      finishedWork.lastEffect.nextEffect = finishedWork;\n      firstEffect = finishedWork.firstEffect;\n    } else {\n      firstEffect = finishedWork;\n    }\n  } else {\n    // There is no effect on the root.\n    firstEffect = finishedWork.firstEffect;\n  }\n\n  prepareForCommit(root.containerInfo);\n\n  // Invoke instances of getSnapshotBeforeUpdate before mutation.\n  nextEffect = firstEffect;\n  startCommitSnapshotEffectsTimer();\n  while (nextEffect !== null) {\n    var didError = false;\n    var error = void 0;\n    {\n      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);\n      if (hasCaughtError()) {\n        didError = true;\n        error = clearCaughtError();\n      }\n    }\n    if (didError) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitSnapshotEffectsTimer();\n\n  if (enableProfilerTimer) {\n    // Mark the current commit time to be shared by all Profilers in this batch.\n    // This enables them to be grouped later.\n    recordCommitTime();\n  }\n\n  // Commit all the side-effects within a tree. We'll do this in two passes.\n  // The first pass performs all the host insertions, updates, deletions and\n  // ref unmounts.\n  nextEffect = firstEffect;\n  startCommitHostEffectsTimer();\n  while (nextEffect !== null) {\n    var _didError = false;\n    var _error = void 0;\n    {\n      invokeGuardedCallback(null, commitAllHostEffects, null);\n      if (hasCaughtError()) {\n        _didError = true;\n        _error = clearCaughtError();\n      }\n    }\n    if (_didError) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, _error);\n      // Clean-up\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n  stopCommitHostEffectsTimer();\n\n  resetAfterCommit(root.containerInfo);\n\n  // The work-in-progress tree is now the current tree. This must come after\n  // the first pass of the commit phase, so that the previous tree is still\n  // current during componentWillUnmount, but before the second pass, so that\n  // the finished work is current during componentDidMount/Update.\n  root.current = finishedWork;\n\n  // In the second pass we'll perform all life-cycles and ref callbacks.\n  // Life-cycles happen as a separate pass so that all placements, updates,\n  // and deletions in the entire tree have already been invoked.\n  // This pass also triggers any renderer-specific initial effects.\n  nextEffect = firstEffect;\n  startCommitLifeCyclesTimer();\n  while (nextEffect !== null) {\n    var _didError2 = false;\n    var _error2 = void 0;\n    {\n      invokeGuardedCallback(null, commitAllLifeCycles, null, root, committedExpirationTime);\n      if (hasCaughtError()) {\n        _didError2 = true;\n        _error2 = clearCaughtError();\n      }\n    }\n    if (_didError2) {\n      !(nextEffect !== null) ? invariant(false, 'Should have next effect. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n      captureCommitPhaseError(nextEffect, _error2);\n      if (nextEffect !== null) {\n        nextEffect = nextEffect.nextEffect;\n      }\n    }\n  }\n\n  isCommitting$1 = false;\n  isWorking = false;\n  stopCommitLifeCyclesTimer();\n  stopCommitTimer();\n  onCommitRoot(finishedWork.stateNode);\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);\n  }\n\n  var updateExpirationTimeAfterCommit = finishedWork.expirationTime;\n  var childExpirationTimeAfterCommit = finishedWork.childExpirationTime;\n  var earliestRemainingTimeAfterCommit = updateExpirationTimeAfterCommit === NoWork || childExpirationTimeAfterCommit !== NoWork && childExpirationTimeAfterCommit < updateExpirationTimeAfterCommit ? childExpirationTimeAfterCommit : updateExpirationTimeAfterCommit;\n  if (earliestRemainingTimeAfterCommit === NoWork) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n  onCommit(root, earliestRemainingTimeAfterCommit);\n\n  if (enableSchedulerTracing) {\n    tracing.__interactionsRef.current = prevInteractions;\n\n    var subscriber = void 0;\n\n    try {\n      subscriber = tracing.__subscriberRef.current;\n      if (subscriber !== null && root.memoizedInteractions.size > 0) {\n        var threadID = computeThreadID(committedExpirationTime, root.interactionThreadID);\n        subscriber.onWorkStopped(root.memoizedInteractions, threadID);\n      }\n    } catch (error) {\n      // It's not safe for commitRoot() to throw.\n      // Store the error for now and we'll re-throw in finishRendering().\n      if (!hasUnhandledError) {\n        hasUnhandledError = true;\n        unhandledError = error;\n      }\n    } finally {\n      // Don't update interaction counts if we're frozen due to suspense.\n      // In this case, we can skip the completed-work check entirely.\n      if (!suspenseDidTimeout) {\n        // Now that we're done, check the completed batch of interactions.\n        // If no more work is outstanding for a given interaction,\n        // We need to notify the subscribers that it's finished.\n        committedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n          if (subscriber !== null && interaction.__count === 0) {\n            try {\n              subscriber.onInteractionScheduledWorkCompleted(interaction);\n            } catch (error) {\n              // It's not safe for commitRoot() to throw.\n              // Store the error for now and we'll re-throw in finishRendering().\n              if (!hasUnhandledError) {\n                hasUnhandledError = true;\n                unhandledError = error;\n              }\n            }\n          }\n        });\n      }\n    }\n  }\n}\n\nfunction resetChildExpirationTime(workInProgress, renderTime) {\n  if (renderTime !== Never && workInProgress.childExpirationTime === Never) {\n    // The children of this component are hidden. Don't bubble their\n    // expiration times.\n    return;\n  }\n\n  var newChildExpirationTime = NoWork;\n\n  // Bubble up the earliest expiration time.\n  if (enableProfilerTimer && workInProgress.mode & ProfileMode) {\n    // We're in profiling mode.\n    // Let's use this same traversal to update the render durations.\n    var actualDuration = workInProgress.actualDuration;\n    var treeBaseDuration = workInProgress.selfBaseDuration;\n\n    // When a fiber is cloned, its actualDuration is reset to 0.\n    // This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).\n    // When work is done, it should bubble to the parent's actualDuration.\n    // If the fiber has not been cloned though, (meaning no work was done),\n    // Then this value will reflect the amount of time spent working on a previous render.\n    // In that case it should not bubble.\n    // We determine whether it was cloned by comparing the child pointer.\n    var shouldBubbleActualDurations = workInProgress.alternate === null || workInProgress.child !== workInProgress.alternate.child;\n\n    var child = workInProgress.child;\n    while (child !== null) {\n      var childUpdateExpirationTime = child.expirationTime;\n      var childChildExpirationTime = child.childExpirationTime;\n      if (newChildExpirationTime === NoWork || childUpdateExpirationTime !== NoWork && childUpdateExpirationTime < newChildExpirationTime) {\n        newChildExpirationTime = childUpdateExpirationTime;\n      }\n      if (newChildExpirationTime === NoWork || childChildExpirationTime !== NoWork && childChildExpirationTime < newChildExpirationTime) {\n        newChildExpirationTime = childChildExpirationTime;\n      }\n      if (shouldBubbleActualDurations) {\n        actualDuration += child.actualDuration;\n      }\n      treeBaseDuration += child.treeBaseDuration;\n      child = child.sibling;\n    }\n    workInProgress.actualDuration = actualDuration;\n    workInProgress.treeBaseDuration = treeBaseDuration;\n  } else {\n    var _child = workInProgress.child;\n    while (_child !== null) {\n      var _childUpdateExpirationTime = _child.expirationTime;\n      var _childChildExpirationTime = _child.childExpirationTime;\n      if (newChildExpirationTime === NoWork || _childUpdateExpirationTime !== NoWork && _childUpdateExpirationTime < newChildExpirationTime) {\n        newChildExpirationTime = _childUpdateExpirationTime;\n      }\n      if (newChildExpirationTime === NoWork || _childChildExpirationTime !== NoWork && _childChildExpirationTime < newChildExpirationTime) {\n        newChildExpirationTime = _childChildExpirationTime;\n      }\n      _child = _child.sibling;\n    }\n  }\n\n  workInProgress.childExpirationTime = newChildExpirationTime;\n}\n\nfunction completeUnitOfWork(workInProgress) {\n  // Attempt to complete the current unit of work, then move to the\n  // next sibling. If there are no more siblings, return to the\n  // parent fiber.\n  while (true) {\n    // The current, flushed, state of this fiber is the alternate.\n    // Ideally nothing should rely on this, but relying on it here\n    // means that we don't need an additional field on the work in\n    // progress.\n    var current$$1 = workInProgress.alternate;\n    {\n      setCurrentFiber(workInProgress);\n    }\n\n    var returnFiber = workInProgress.return;\n    var siblingFiber = workInProgress.sibling;\n\n    if ((workInProgress.effectTag & Incomplete) === NoEffect) {\n      // This fiber completed.\n      if (enableProfilerTimer) {\n        if (workInProgress.mode & ProfileMode) {\n          startProfilerTimer(workInProgress);\n        }\n\n        nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);\n\n        if (workInProgress.mode & ProfileMode) {\n          // Update render duration assuming we didn't error.\n          stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n        }\n      } else {\n        nextUnitOfWork = completeWork(current$$1, workInProgress, nextRenderExpirationTime);\n      }\n      var next = nextUnitOfWork;\n      stopWorkTimer(workInProgress);\n      resetChildExpirationTime(workInProgress, nextRenderExpirationTime);\n      {\n        resetCurrentFiber();\n      }\n\n      if (next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        return next;\n      }\n\n      if (returnFiber !== null &&\n      // Do not append effects to parents if a sibling failed to complete\n      (returnFiber.effectTag & Incomplete) === NoEffect) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = workInProgress.firstEffect;\n        }\n        if (workInProgress.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;\n          }\n          returnFiber.lastEffect = workInProgress.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if\n        // needed, by doing multiple passes over the effect list. We don't want\n        // to schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        var effectTag = workInProgress.effectTag;\n        // Skip both NoWork and PerformedWork tags when creating the effect list.\n        // PerformedWork effect is read by React DevTools but shouldn't be committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = workInProgress;\n          } else {\n            returnFiber.firstEffect = workInProgress;\n          }\n          returnFiber.lastEffect = workInProgress;\n        }\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        // We've reached the root.\n        return null;\n      }\n    } else {\n      if (workInProgress.mode & ProfileMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(workInProgress, false);\n      }\n\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(workInProgress, nextRenderExpirationTime);\n      // Because this fiber did not complete, don't reset its expiration time.\n      if (workInProgress.effectTag & DidCapture) {\n        // Restarting an error boundary\n        stopFailedWorkTimer(workInProgress);\n      } else {\n        stopWorkTimer(workInProgress);\n      }\n\n      {\n        resetCurrentFiber();\n      }\n\n      if (_next !== null) {\n        stopWorkTimer(workInProgress);\n        if (true && ReactFiberInstrumentation_1.debugTool) {\n          ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n        }\n\n        if (enableProfilerTimer) {\n          // Include the time spent working on failed children before continuing.\n          if (_next.mode & ProfileMode) {\n            var actualDuration = _next.actualDuration;\n            var child = _next.child;\n            while (child !== null) {\n              actualDuration += child.actualDuration;\n              child = child.sibling;\n            }\n            _next.actualDuration = actualDuration;\n          }\n        }\n\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.effectTag &= HostEffectMask;\n        return _next;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n\n      if (true && ReactFiberInstrumentation_1.debugTool) {\n        ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);\n      }\n\n      if (siblingFiber !== null) {\n        // If there is more work to do in this returnFiber, do that next.\n        return siblingFiber;\n      } else if (returnFiber !== null) {\n        // If there's no more work in this returnFiber. Complete the returnFiber.\n        workInProgress = returnFiber;\n        continue;\n      } else {\n        return null;\n      }\n    }\n  }\n\n  // Without this explicit null return Flow complains of invalid return type\n  // TODO Remove the above while(true) loop\n  // eslint-disable-next-line no-unreachable\n  return null;\n}\n\nfunction performUnitOfWork(workInProgress) {\n  // The current, flushed, state of this fiber is the alternate.\n  // Ideally nothing should rely on this, but relying on it here\n  // means that we don't need an additional field on the work in\n  // progress.\n  var current$$1 = workInProgress.alternate;\n\n  // See if beginning this work spawns more work.\n  startWorkTimer(workInProgress);\n  {\n    setCurrentFiber(workInProgress);\n  }\n\n  if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n    stashedWorkInProgressProperties = assignFiberPropertiesInDEV(stashedWorkInProgressProperties, workInProgress);\n  }\n\n  var next = void 0;\n  if (enableProfilerTimer) {\n    if (workInProgress.mode & ProfileMode) {\n      startProfilerTimer(workInProgress);\n    }\n\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n\n    if (workInProgress.mode & ProfileMode) {\n      // Record the render duration assuming we didn't bailout (or error).\n      stopProfilerTimerIfRunningAndRecordDelta(workInProgress, true);\n    }\n  } else {\n    next = beginWork(current$$1, workInProgress, nextRenderExpirationTime);\n  }\n\n  {\n    resetCurrentFiber();\n    if (isReplayingFailedUnitOfWork) {\n      // Currently replaying a failed unit of work. This should be unreachable,\n      // because the render phase is meant to be idempotent, and it should\n      // have thrown again. Since it didn't, rethrow the original error, so\n      // React's internal stack is not misaligned.\n      rethrowOriginalError();\n    }\n  }\n  if (true && ReactFiberInstrumentation_1.debugTool) {\n    ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);\n  }\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    next = completeUnitOfWork(workInProgress);\n  }\n\n  ReactCurrentOwner$2.current = null;\n\n  return next;\n}\n\nfunction workLoop(isYieldy) {\n  if (!isYieldy) {\n    // Flush work without yielding\n    while (nextUnitOfWork !== null) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  } else {\n    // Flush asynchronous work until the deadline runs out of time.\n    while (nextUnitOfWork !== null && !shouldYield()) {\n      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    }\n  }\n}\n\nfunction renderRoot(root, isYieldy, isExpired) {\n  !!isWorking ? invariant(false, 'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  isWorking = true;\n  ReactCurrentOwner$2.currentDispatcher = Dispatcher;\n\n  var expirationTime = root.nextExpirationTimeToWorkOn;\n\n  var prevInteractions = null;\n  if (enableSchedulerTracing) {\n    // We're about to start new traced work.\n    // Restore pending interactions so cascading work triggered during the render phase will be accounted for.\n    prevInteractions = tracing.__interactionsRef.current;\n    tracing.__interactionsRef.current = root.memoizedInteractions;\n  }\n\n  // Check if we're starting from a fresh stack, or if we're resuming from\n  // previously yielded work.\n  if (expirationTime !== nextRenderExpirationTime || root !== nextRoot || nextUnitOfWork === null) {\n    // Reset the stack and start working from the root.\n    resetStack();\n    nextRoot = root;\n    nextRenderExpirationTime = expirationTime;\n    nextUnitOfWork = createWorkInProgress(nextRoot.current, null, nextRenderExpirationTime);\n    root.pendingCommitExpirationTime = NoWork;\n\n    if (enableSchedulerTracing) {\n      // Determine which interactions this batch of work currently includes,\n      // So that we can accurately attribute time spent working on it,\n      var interactions = new Set();\n      root.pendingInteractionMap.forEach(function (scheduledInteractions, scheduledExpirationTime) {\n        if (scheduledExpirationTime <= expirationTime) {\n          scheduledInteractions.forEach(function (interaction) {\n            return interactions.add(interaction);\n          });\n        }\n      });\n\n      // Store the current set of interactions on the FiberRoot for a few reasons:\n      // We can re-use it in hot functions like renderRoot() without having to recalculate it.\n      // We will also use it in commitWork() to pass to any Profiler onRender() hooks.\n      // This also provides DevTools with a way to access it when the onCommitRoot() hook is called.\n      root.memoizedInteractions = interactions;\n\n      if (interactions.size > 0) {\n        var subscriber = tracing.__subscriberRef.current;\n        if (subscriber !== null) {\n          var threadID = computeThreadID(expirationTime, root.interactionThreadID);\n          try {\n            subscriber.onWorkStarted(interactions, threadID);\n          } catch (error) {\n            // Work thrown by an interaction tracing subscriber should be rethrown,\n            // But only once it's safe (to avoid leaveing the scheduler in an invalid state).\n            // Store the error for now and we'll re-throw in finishRendering().\n            if (!hasUnhandledError) {\n              hasUnhandledError = true;\n              unhandledError = error;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var didFatal = false;\n\n  startWorkLoopTimer(nextUnitOfWork);\n\n  do {\n    try {\n      workLoop(isYieldy);\n    } catch (thrownValue) {\n      if (nextUnitOfWork === null) {\n        // This is a fatal error.\n        didFatal = true;\n        onUncaughtError(thrownValue);\n      } else {\n        {\n          // Reset global debug state\n          // We assume this is defined in DEV\n          resetCurrentlyProcessingQueue();\n        }\n\n        var failedUnitOfWork = nextUnitOfWork;\n        if (true && replayFailedUnitOfWorkWithInvokeGuardedCallback) {\n          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);\n        }\n\n        // TODO: we already know this isn't true in some cases.\n        // At least this shows a nicer error message until we figure out the cause.\n        // https://github.com/facebook/react/issues/12449#issuecomment-386727431\n        !(nextUnitOfWork !== null) ? invariant(false, 'Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.') : void 0;\n\n        var sourceFiber = nextUnitOfWork;\n        var returnFiber = sourceFiber.return;\n        if (returnFiber === null) {\n          // This is the root. The root could capture its own errors. However,\n          // we don't know if it errors before or after we pushed the host\n          // context. This information is needed to avoid a stack mismatch.\n          // Because we're not sure, treat this as a fatal error. We could track\n          // which phase it fails in, but doesn't seem worth it. At least\n          // for now.\n          didFatal = true;\n          onUncaughtError(thrownValue);\n        } else {\n          throwException(root, returnFiber, sourceFiber, thrownValue, nextRenderExpirationTime);\n          nextUnitOfWork = completeUnitOfWork(sourceFiber);\n          continue;\n        }\n      }\n    }\n    break;\n  } while (true);\n\n  if (enableSchedulerTracing) {\n    // Traced work is done for now; restore the previous interactions.\n    tracing.__interactionsRef.current = prevInteractions;\n  }\n\n  // We're done performing work. Time to clean up.\n  isWorking = false;\n  ReactCurrentOwner$2.currentDispatcher = null;\n  resetContextDependences();\n\n  // Yield back to main thread.\n  if (didFatal) {\n    var _didCompleteRoot = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot);\n    interruptedBy = null;\n    // There was a fatal error.\n    {\n      resetStackAfterFatalErrorInDev();\n    }\n    // `nextRoot` points to the in-progress root. A non-null value indicates\n    // that we're in the middle of an async render. Set it to null to indicate\n    // there's no more work to be done in the current batch.\n    nextRoot = null;\n    onFatal(root);\n    return;\n  }\n\n  if (nextUnitOfWork !== null) {\n    // There's still remaining async work in this tree, but we ran out of time\n    // in the current frame. Yield back to the renderer. Unless we're\n    // interrupted by a higher priority update, we'll continue later from where\n    // we left off.\n    var _didCompleteRoot2 = false;\n    stopWorkLoopTimer(interruptedBy, _didCompleteRoot2);\n    interruptedBy = null;\n    onYield(root);\n    return;\n  }\n\n  // We completed the whole tree.\n  var didCompleteRoot = true;\n  stopWorkLoopTimer(interruptedBy, didCompleteRoot);\n  var rootWorkInProgress = root.current.alternate;\n  !(rootWorkInProgress !== null) ? invariant(false, 'Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  // `nextRoot` points to the in-progress root. A non-null value indicates\n  // that we're in the middle of an async render. Set it to null to indicate\n  // there's no more work to be done in the current batch.\n  nextRoot = null;\n  interruptedBy = null;\n\n  if (nextRenderDidError) {\n    // There was an error\n    if (hasLowerPriorityWork(root, expirationTime)) {\n      // There's lower priority work. If so, it may have the effect of fixing\n      // the exception that was just thrown. Exit without committing. This is\n      // similar to a suspend, but without a timeout because we're not waiting\n      // for a promise to resolve. React will restart at the lower\n      // priority level.\n      markSuspendedPriorityLevel(root, expirationTime);\n      var suspendedExpirationTime = expirationTime;\n      var rootExpirationTime = root.expirationTime;\n      onSuspend(root, rootWorkInProgress, suspendedExpirationTime, rootExpirationTime, -1 // Indicates no timeout\n      );\n      return;\n    } else if (\n    // There's no lower priority work, but we're rendering asynchronously.\n    // Synchronsouly attempt to render the same level one more time. This is\n    // similar to a suspend, but without a timeout because we're not waiting\n    // for a promise to resolve.\n    !root.didError && !isExpired) {\n      root.didError = true;\n      var _suspendedExpirationTime = root.nextExpirationTimeToWorkOn = expirationTime;\n      var _rootExpirationTime = root.expirationTime = Sync;\n      onSuspend(root, rootWorkInProgress, _suspendedExpirationTime, _rootExpirationTime, -1 // Indicates no timeout\n      );\n      return;\n    }\n  }\n\n  if (enableSuspense && !isExpired && nextLatestAbsoluteTimeoutMs !== -1) {\n    // The tree was suspended.\n    var _suspendedExpirationTime2 = expirationTime;\n    markSuspendedPriorityLevel(root, _suspendedExpirationTime2);\n\n    // Find the earliest uncommitted expiration time in the tree, including\n    // work that is suspended. The timeout threshold cannot be longer than\n    // the overall expiration.\n    var earliestExpirationTime = findEarliestOutstandingPriorityLevel(root, expirationTime);\n    var earliestExpirationTimeMs = expirationTimeToMs(earliestExpirationTime);\n    if (earliestExpirationTimeMs < nextLatestAbsoluteTimeoutMs) {\n      nextLatestAbsoluteTimeoutMs = earliestExpirationTimeMs;\n    }\n\n    // Subtract the current time from the absolute timeout to get the number\n    // of milliseconds until the timeout. In other words, convert an absolute\n    // timestamp to a relative time. This is the value that is passed\n    // to `setTimeout`.\n    var currentTimeMs = expirationTimeToMs(requestCurrentTime());\n    var msUntilTimeout = nextLatestAbsoluteTimeoutMs - currentTimeMs;\n    msUntilTimeout = msUntilTimeout < 0 ? 0 : msUntilTimeout;\n\n    // TODO: Account for the Just Noticeable Difference\n\n    var _rootExpirationTime2 = root.expirationTime;\n    onSuspend(root, rootWorkInProgress, _suspendedExpirationTime2, _rootExpirationTime2, msUntilTimeout);\n    return;\n  }\n\n  // Ready to commit.\n  onComplete(root, rootWorkInProgress, expirationTime);\n}\n\nfunction dispatch(sourceFiber, value, expirationTime) {\n  !(!isWorking || isCommitting$1) ? invariant(false, 'dispatch: Cannot dispatch during the render phase.') : void 0;\n\n  var fiber = sourceFiber.return;\n  while (fiber !== null) {\n    switch (fiber.tag) {\n      case ClassComponent:\n      case ClassComponentLazy:\n        var ctor = fiber.type;\n        var instance = fiber.stateNode;\n        if (typeof ctor.getDerivedStateFromCatch === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n          var errorInfo = createCapturedValue(value, sourceFiber);\n          var update = createClassErrorUpdate(fiber, errorInfo, expirationTime);\n          enqueueUpdate(fiber, update);\n          scheduleWork(fiber, expirationTime);\n          return;\n        }\n        break;\n      case HostRoot:\n        {\n          var _errorInfo = createCapturedValue(value, sourceFiber);\n          var _update = createRootErrorUpdate(fiber, _errorInfo, expirationTime);\n          enqueueUpdate(fiber, _update);\n          scheduleWork(fiber, expirationTime);\n          return;\n        }\n    }\n    fiber = fiber.return;\n  }\n\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    var rootFiber = sourceFiber;\n    var _errorInfo2 = createCapturedValue(value, rootFiber);\n    var _update2 = createRootErrorUpdate(rootFiber, _errorInfo2, expirationTime);\n    enqueueUpdate(rootFiber, _update2);\n    scheduleWork(rootFiber, expirationTime);\n  }\n}\n\nfunction captureCommitPhaseError(fiber, error) {\n  return dispatch(fiber, error, Sync);\n}\n\nfunction computeThreadID(expirationTime, interactionThreadID) {\n  // Interaction threads are unique per root and expiration time.\n  return expirationTime * 1000 + interactionThreadID;\n}\n\n// Creates a unique async expiration time.\nfunction computeUniqueAsyncExpiration() {\n  var currentTime = requestCurrentTime();\n  var result = computeAsyncExpiration(currentTime);\n  if (result <= lastUniqueAsyncExpiration) {\n    // Since we assume the current time monotonically increases, we only hit\n    // this branch when computeUniqueAsyncExpiration is fired multiple times\n    // within a 200ms window (or whatever the async bucket size is).\n    result = lastUniqueAsyncExpiration + 1;\n  }\n  lastUniqueAsyncExpiration = result;\n  return lastUniqueAsyncExpiration;\n}\n\nfunction computeExpirationForFiber(currentTime, fiber) {\n  var expirationTime = void 0;\n  if (expirationContext !== NoWork) {\n    // An explicit expiration context was set;\n    expirationTime = expirationContext;\n  } else if (isWorking) {\n    if (isCommitting$1) {\n      // Updates that occur during the commit phase should have sync priority\n      // by default.\n      expirationTime = Sync;\n    } else {\n      // Updates during the render phase should expire at the same time as\n      // the work that is being rendered.\n      expirationTime = nextRenderExpirationTime;\n    }\n  } else {\n    // No explicit expiration context was set, and we're not currently\n    // performing work. Calculate a new expiration time.\n    if (fiber.mode & AsyncMode) {\n      if (isBatchingInteractiveUpdates) {\n        // This is an interactive update\n        expirationTime = computeInteractiveExpiration(currentTime);\n      } else {\n        // This is an async update\n        expirationTime = computeAsyncExpiration(currentTime);\n      }\n      // If we're in the middle of rendering a tree, do not update at the same\n      // expiration time that is already rendering.\n      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {\n        expirationTime += 1;\n      }\n    } else {\n      // This is a sync update\n      expirationTime = Sync;\n    }\n  }\n  if (isBatchingInteractiveUpdates) {\n    // This is an interactive update. Keep track of the lowest pending\n    // interactive expiration time. This allows us to synchronously flush\n    // all interactive updates when needed.\n    if (lowestPriorityPendingInteractiveExpirationTime === NoWork || expirationTime > lowestPriorityPendingInteractiveExpirationTime) {\n      lowestPriorityPendingInteractiveExpirationTime = expirationTime;\n    }\n  }\n  return expirationTime;\n}\n\nfunction renderDidSuspend(root, absoluteTimeoutMs, suspendedTime) {\n  // Schedule the timeout.\n  if (absoluteTimeoutMs >= 0 && nextLatestAbsoluteTimeoutMs < absoluteTimeoutMs) {\n    nextLatestAbsoluteTimeoutMs = absoluteTimeoutMs;\n  }\n}\n\nfunction renderDidError() {\n  nextRenderDidError = true;\n}\n\nfunction retrySuspendedRoot(root, fiber, suspendedTime) {\n  if (enableSuspense) {\n    var retryTime = void 0;\n\n    if (isPriorityLevelSuspended(root, suspendedTime)) {\n      // Ping at the original level\n      retryTime = suspendedTime;\n      markPingedPriorityLevel(root, retryTime);\n    } else {\n      // Placeholder already timed out. Compute a new expiration time\n      var currentTime = requestCurrentTime();\n      retryTime = computeExpirationForFiber(currentTime, fiber);\n      markPendingPriorityLevel(root, retryTime);\n    }\n\n    scheduleWorkToRoot(fiber, retryTime);\n    var rootExpirationTime = root.expirationTime;\n    if (rootExpirationTime !== NoWork) {\n      if (enableSchedulerTracing) {\n        // Restore previous interactions so that new work is associated with them.\n        var prevInteractions = tracing.__interactionsRef.current;\n        tracing.__interactionsRef.current = root.memoizedInteractions;\n        // Because suspense timeouts do not decrement the interaction count,\n        // Continued suspense work should also not increment the count.\n        storeInteractionsForExpirationTime(root, rootExpirationTime, false);\n        requestWork(root, rootExpirationTime);\n        tracing.__interactionsRef.current = prevInteractions;\n      } else {\n        requestWork(root, rootExpirationTime);\n      }\n    }\n  }\n}\n\nfunction scheduleWorkToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  if (fiber.expirationTime === NoWork || fiber.expirationTime > expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  var alternate = fiber.alternate;\n  if (alternate !== null && (alternate.expirationTime === NoWork || alternate.expirationTime > expirationTime)) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  var node = fiber.return;\n  if (node === null && fiber.tag === HostRoot) {\n    return fiber.stateNode;\n  }\n  while (node !== null) {\n    alternate = node.alternate;\n    if (node.childExpirationTime === NoWork || node.childExpirationTime > expirationTime) {\n      node.childExpirationTime = expirationTime;\n      if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {\n        alternate.childExpirationTime = expirationTime;\n      }\n    } else if (alternate !== null && (alternate.childExpirationTime === NoWork || alternate.childExpirationTime > expirationTime)) {\n      alternate.childExpirationTime = expirationTime;\n    }\n    if (node.return === null && node.tag === HostRoot) {\n      return node.stateNode;\n    }\n    node = node.return;\n  }\n  return null;\n}\n\nfunction storeInteractionsForExpirationTime(root, expirationTime, updateInteractionCounts) {\n  if (!enableSchedulerTracing) {\n    return;\n  }\n\n  var interactions = tracing.__interactionsRef.current;\n  if (interactions.size > 0) {\n    var pendingInteractions = root.pendingInteractionMap.get(expirationTime);\n    if (pendingInteractions != null) {\n      interactions.forEach(function (interaction) {\n        if (updateInteractionCounts && !pendingInteractions.has(interaction)) {\n          // Update the pending async work count for previously unscheduled interaction.\n          interaction.__count++;\n        }\n\n        pendingInteractions.add(interaction);\n      });\n    } else {\n      root.pendingInteractionMap.set(expirationTime, new Set(interactions));\n\n      // Update the pending async work count for the current interactions.\n      if (updateInteractionCounts) {\n        interactions.forEach(function (interaction) {\n          interaction.__count++;\n        });\n      }\n    }\n\n    var subscriber = tracing.__subscriberRef.current;\n    if (subscriber !== null) {\n      var threadID = computeThreadID(expirationTime, root.interactionThreadID);\n      subscriber.onWorkScheduled(interactions, threadID);\n    }\n  }\n}\n\nfunction scheduleWork(fiber, expirationTime) {\n  recordScheduleUpdate();\n\n  {\n    if (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy) {\n      var instance = fiber.stateNode;\n      warnAboutInvalidUpdates(instance);\n    }\n  }\n\n  var root = scheduleWorkToRoot(fiber, expirationTime);\n  if (root === null) {\n    if (true && (fiber.tag === ClassComponent || fiber.tag === ClassComponentLazy)) {\n      warnAboutUpdateOnUnmounted(fiber);\n    }\n    return;\n  }\n\n  if (enableSchedulerTracing) {\n    storeInteractionsForExpirationTime(root, expirationTime, true);\n  }\n\n  if (!isWorking && nextRenderExpirationTime !== NoWork && expirationTime < nextRenderExpirationTime) {\n    // This is an interruption. (Used for performance tracking.)\n    interruptedBy = fiber;\n    resetStack();\n  }\n  markPendingPriorityLevel(root, expirationTime);\n  if (\n  // If we're in the render phase, we don't need to schedule this root\n  // for an update, because we'll do it before we exit...\n  !isWorking || isCommitting$1 ||\n  // ...unless this is a different root than the one we're rendering.\n  nextRoot !== root) {\n    var rootExpirationTime = root.expirationTime;\n    requestWork(root, rootExpirationTime);\n  }\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    // Reset this back to zero so subsequent updates don't throw.\n    nestedUpdateCount = 0;\n    invariant(false, 'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');\n  }\n}\n\nfunction syncUpdates(fn, a, b, c, d) {\n  var previousExpirationContext = expirationContext;\n  expirationContext = Sync;\n  try {\n    return fn(a, b, c, d);\n  } finally {\n    expirationContext = previousExpirationContext;\n  }\n}\n\n// TODO: Everything below this is written as if it has been lifted to the\n// renderers. I'll do this in a follow-up.\n\n// Linked-list of roots\nvar firstScheduledRoot = null;\nvar lastScheduledRoot = null;\n\nvar callbackExpirationTime = NoWork;\nvar callbackID = void 0;\nvar isRendering = false;\nvar nextFlushedRoot = null;\nvar nextFlushedExpirationTime = NoWork;\nvar lowestPriorityPendingInteractiveExpirationTime = NoWork;\nvar deadlineDidExpire = false;\nvar hasUnhandledError = false;\nvar unhandledError = null;\nvar deadline = null;\n\nvar isBatchingUpdates = false;\nvar isUnbatchingUpdates = false;\nvar isBatchingInteractiveUpdates = false;\n\nvar completedBatches = null;\n\nvar originalStartTimeMs = schedule.unstable_now();\nvar currentRendererTime = msToExpirationTime(originalStartTimeMs);\nvar currentSchedulerTime = currentRendererTime;\n\n// Use these to prevent an infinite loop of nested updates\nvar NESTED_UPDATE_LIMIT = 50;\nvar nestedUpdateCount = 0;\nvar lastCommittedRootDuringThisBatch = null;\n\nvar timeHeuristicForUnitOfWork = 1;\n\nfunction recomputeCurrentRendererTime() {\n  var currentTimeMs = schedule.unstable_now() - originalStartTimeMs;\n  currentRendererTime = msToExpirationTime(currentTimeMs);\n}\n\nfunction scheduleCallbackWithExpirationTime(root, expirationTime) {\n  if (callbackExpirationTime !== NoWork) {\n    // A callback is already scheduled. Check its expiration time (timeout).\n    if (expirationTime > callbackExpirationTime) {\n      // Existing callback has sufficient timeout. Exit.\n      return;\n    } else {\n      if (callbackID !== null) {\n        // Existing callback has insufficient timeout. Cancel and schedule a\n        // new one.\n        schedule.unstable_cancelScheduledWork(callbackID);\n      }\n    }\n    // The request callback timer is already running. Don't start a new one.\n  } else {\n    startRequestCallbackTimer();\n  }\n\n  callbackExpirationTime = expirationTime;\n  var currentMs = schedule.unstable_now() - originalStartTimeMs;\n  var expirationTimeMs = expirationTimeToMs(expirationTime);\n  var timeout = expirationTimeMs - currentMs;\n  callbackID = schedule.unstable_scheduleWork(performAsyncWork, { timeout: timeout });\n}\n\n// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and\n// onYield is called upon exiting. We use these in lieu of returning a tuple.\n// I've also chosen not to inline them into renderRoot because these will\n// eventually be lifted into the renderer.\nfunction onFatal(root) {\n  root.finishedWork = null;\n}\n\nfunction onComplete(root, finishedWork, expirationTime) {\n  root.pendingCommitExpirationTime = expirationTime;\n  root.finishedWork = finishedWork;\n}\n\nfunction onSuspend(root, finishedWork, suspendedExpirationTime, rootExpirationTime, msUntilTimeout) {\n  root.expirationTime = rootExpirationTime;\n  if (enableSuspense && msUntilTimeout === 0 && !shouldYield()) {\n    // Don't wait an additional tick. Commit the tree immediately.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n  } else if (msUntilTimeout > 0) {\n    // Wait `msUntilTimeout` milliseconds before committing.\n    root.timeoutHandle = scheduleTimeout(onTimeout.bind(null, root, finishedWork, suspendedExpirationTime), msUntilTimeout);\n  }\n}\n\nfunction onYield(root) {\n  root.finishedWork = null;\n}\n\nfunction onTimeout(root, finishedWork, suspendedExpirationTime) {\n  if (enableSuspense) {\n    // The root timed out. Commit it.\n    root.pendingCommitExpirationTime = suspendedExpirationTime;\n    root.finishedWork = finishedWork;\n    // Read the current time before entering the commit phase. We can be\n    // certain this won't cause tearing related to batching of event updates\n    // because we're at the top of a timer event.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableSchedulerTracing) {\n      // Don't update pending interaction counts for suspense timeouts,\n      // Because we know we still need to do more work in this case.\n      suspenseDidTimeout = true;\n      flushRoot(root, suspendedExpirationTime);\n      suspenseDidTimeout = false;\n    } else {\n      flushRoot(root, suspendedExpirationTime);\n    }\n  }\n}\n\nfunction onCommit(root, expirationTime) {\n  root.expirationTime = expirationTime;\n  root.finishedWork = null;\n}\n\nfunction requestCurrentTime() {\n  // requestCurrentTime is called by the scheduler to compute an expiration\n  // time.\n  //\n  // Expiration times are computed by adding to the current time (the start\n  // time). However, if two updates are scheduled within the same event, we\n  // should treat their start times as simultaneous, even if the actual clock\n  // time has advanced between the first and second call.\n\n  // In other words, because expiration times determine how updates are batched,\n  // we want all updates of like priority that occur within the same event to\n  // receive the same expiration time. Otherwise we get tearing.\n  //\n  // We keep track of two separate times: the current \"renderer\" time and the\n  // current \"scheduler\" time. The renderer time can be updated whenever; it\n  // only exists to minimize the calls performance.now.\n  //\n  // But the scheduler time can only be updated if there's no pending work, or\n  // if we know for certain that we're not in the middle of an event.\n\n  if (isRendering) {\n    // We're already rendering. Return the most recently read time.\n    return currentSchedulerTime;\n  }\n  // Check if there's pending work.\n  findHighestPriorityRoot();\n  if (nextFlushedExpirationTime === NoWork || nextFlushedExpirationTime === Never) {\n    // If there's no pending work, or if the pending work is offscreen, we can\n    // read the current time without risk of tearing.\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n    return currentSchedulerTime;\n  }\n  // There's already pending work. We might be in the middle of a browser\n  // event. If we were to read the current time, it could cause multiple updates\n  // within the same event to receive different expiration times, leading to\n  // tearing. Return the last read time. During the next idle callback, the\n  // time will be updated.\n  return currentSchedulerTime;\n}\n\n// requestWork is called by the scheduler whenever a root receives an update.\n// It's up to the renderer to call renderRoot at some point in the future.\nfunction requestWork(root, expirationTime) {\n  addRootToSchedule(root, expirationTime);\n  if (isRendering) {\n    // Prevent reentrancy. Remaining work will be scheduled at the end of\n    // the currently rendering batch.\n    return;\n  }\n\n  if (isBatchingUpdates) {\n    // Flush work at the end of the batch.\n    if (isUnbatchingUpdates) {\n      // ...unless we're inside unbatchedUpdates, in which case we should\n      // flush it now.\n      nextFlushedRoot = root;\n      nextFlushedExpirationTime = Sync;\n      performWorkOnRoot(root, Sync, true);\n    }\n    return;\n  }\n\n  // TODO: Get rid of Sync and use current time?\n  if (expirationTime === Sync) {\n    performSyncWork();\n  } else {\n    scheduleCallbackWithExpirationTime(root, expirationTime);\n  }\n}\n\nfunction addRootToSchedule(root, expirationTime) {\n  // Add the root to the schedule.\n  // Check if this root is already part of the schedule.\n  if (root.nextScheduledRoot === null) {\n    // This root is not already scheduled. Add it.\n    root.expirationTime = expirationTime;\n    if (lastScheduledRoot === null) {\n      firstScheduledRoot = lastScheduledRoot = root;\n      root.nextScheduledRoot = root;\n    } else {\n      lastScheduledRoot.nextScheduledRoot = root;\n      lastScheduledRoot = root;\n      lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n    }\n  } else {\n    // This root is already scheduled, but its priority may have increased.\n    var remainingExpirationTime = root.expirationTime;\n    if (remainingExpirationTime === NoWork || expirationTime < remainingExpirationTime) {\n      // Update the priority.\n      root.expirationTime = expirationTime;\n    }\n  }\n}\n\nfunction findHighestPriorityRoot() {\n  var highestPriorityWork = NoWork;\n  var highestPriorityRoot = null;\n  if (lastScheduledRoot !== null) {\n    var previousScheduledRoot = lastScheduledRoot;\n    var root = firstScheduledRoot;\n    while (root !== null) {\n      var remainingExpirationTime = root.expirationTime;\n      if (remainingExpirationTime === NoWork) {\n        // This root no longer has work. Remove it from the scheduler.\n\n        // TODO: This check is redudant, but Flow is confused by the branch\n        // below where we set lastScheduledRoot to null, even though we break\n        // from the loop right after.\n        !(previousScheduledRoot !== null && lastScheduledRoot !== null) ? invariant(false, 'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n        if (root === root.nextScheduledRoot) {\n          // This is the only root in the list.\n          root.nextScheduledRoot = null;\n          firstScheduledRoot = lastScheduledRoot = null;\n          break;\n        } else if (root === firstScheduledRoot) {\n          // This is the first root in the list.\n          var next = root.nextScheduledRoot;\n          firstScheduledRoot = next;\n          lastScheduledRoot.nextScheduledRoot = next;\n          root.nextScheduledRoot = null;\n        } else if (root === lastScheduledRoot) {\n          // This is the last root in the list.\n          lastScheduledRoot = previousScheduledRoot;\n          lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;\n          root.nextScheduledRoot = null;\n          break;\n        } else {\n          previousScheduledRoot.nextScheduledRoot = root.nextScheduledRoot;\n          root.nextScheduledRoot = null;\n        }\n        root = previousScheduledRoot.nextScheduledRoot;\n      } else {\n        if (highestPriorityWork === NoWork || remainingExpirationTime < highestPriorityWork) {\n          // Update the priority, if it's higher\n          highestPriorityWork = remainingExpirationTime;\n          highestPriorityRoot = root;\n        }\n        if (root === lastScheduledRoot) {\n          break;\n        }\n        if (highestPriorityWork === Sync) {\n          // Sync is highest priority by definition so\n          // we can stop searching.\n          break;\n        }\n        previousScheduledRoot = root;\n        root = root.nextScheduledRoot;\n      }\n    }\n  }\n\n  nextFlushedRoot = highestPriorityRoot;\n  nextFlushedExpirationTime = highestPriorityWork;\n}\n\nfunction performAsyncWork(dl) {\n  if (dl.didTimeout) {\n    // The callback timed out. That means at least one update has expired.\n    // Iterate through the root schedule. If they contain expired work, set\n    // the next render expiration time to the current time. This has the effect\n    // of flushing all expired work in a single batch, instead of flushing each\n    // level one at a time.\n    if (firstScheduledRoot !== null) {\n      recomputeCurrentRendererTime();\n      var root = firstScheduledRoot;\n      do {\n        didExpireAtExpirationTime(root, currentRendererTime);\n        // The root schedule is circular, so this is never null.\n        root = root.nextScheduledRoot;\n      } while (root !== firstScheduledRoot);\n    }\n  }\n  performWork(NoWork, dl);\n}\n\nfunction performSyncWork() {\n  performWork(Sync, null);\n}\n\nfunction performWork(minExpirationTime, dl) {\n  deadline = dl;\n\n  // Keep working on roots until there's no more work, or until we reach\n  // the deadline.\n  findHighestPriorityRoot();\n\n  if (deadline !== null) {\n    recomputeCurrentRendererTime();\n    currentSchedulerTime = currentRendererTime;\n\n    if (enableUserTimingAPI) {\n      var didExpire = nextFlushedExpirationTime < currentRendererTime;\n      var timeout = expirationTimeToMs(nextFlushedExpirationTime);\n      stopRequestCallbackTimer(didExpire, timeout);\n    }\n\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime) && (!deadlineDidExpire || currentRendererTime >= nextFlushedExpirationTime)) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, currentRendererTime >= nextFlushedExpirationTime);\n      findHighestPriorityRoot();\n      recomputeCurrentRendererTime();\n      currentSchedulerTime = currentRendererTime;\n    }\n  } else {\n    while (nextFlushedRoot !== null && nextFlushedExpirationTime !== NoWork && (minExpirationTime === NoWork || minExpirationTime >= nextFlushedExpirationTime)) {\n      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);\n      findHighestPriorityRoot();\n    }\n  }\n\n  // We're done flushing work. Either we ran out of time in this callback,\n  // or there's no more work left with sufficient priority.\n\n  // If we're inside a callback, set this to false since we just completed it.\n  if (deadline !== null) {\n    callbackExpirationTime = NoWork;\n    callbackID = null;\n  }\n  // If there's work left over, schedule a new callback.\n  if (nextFlushedExpirationTime !== NoWork) {\n    scheduleCallbackWithExpirationTime(nextFlushedRoot, nextFlushedExpirationTime);\n  }\n\n  // Clean-up.\n  deadline = null;\n  deadlineDidExpire = false;\n\n  finishRendering();\n}\n\nfunction flushRoot(root, expirationTime) {\n  !!isRendering ? invariant(false, 'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.') : void 0;\n  // Perform work on root as if the given expiration time is the current time.\n  // This has the effect of synchronously flushing all work up to and\n  // including the given time.\n  nextFlushedRoot = root;\n  nextFlushedExpirationTime = expirationTime;\n  performWorkOnRoot(root, expirationTime, true);\n  // Flush any sync work that was scheduled by lifecycles\n  performSyncWork();\n}\n\nfunction finishRendering() {\n  nestedUpdateCount = 0;\n  lastCommittedRootDuringThisBatch = null;\n\n  if (completedBatches !== null) {\n    var batches = completedBatches;\n    completedBatches = null;\n    for (var i = 0; i < batches.length; i++) {\n      var batch = batches[i];\n      try {\n        batch._onComplete();\n      } catch (error) {\n        if (!hasUnhandledError) {\n          hasUnhandledError = true;\n          unhandledError = error;\n        }\n      }\n    }\n  }\n\n  if (hasUnhandledError) {\n    var error = unhandledError;\n    unhandledError = null;\n    hasUnhandledError = false;\n    throw error;\n  }\n}\n\nfunction performWorkOnRoot(root, expirationTime, isExpired) {\n  !!isRendering ? invariant(false, 'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n\n  isRendering = true;\n\n  // Check if this is async work or sync/expired work.\n  if (deadline === null || isExpired) {\n    // Flush work without yielding.\n    // TODO: Non-yieldy work does not necessarily imply expired work. A renderer\n    // may want to perform some work without yielding, but also without\n    // requiring the root to complete (by triggering placeholders).\n\n    var finishedWork = root.finishedWork;\n    if (finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      var timeoutHandle = root.timeoutHandle;\n      if (enableSuspense && timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(timeoutHandle);\n      }\n      var isYieldy = false;\n      renderRoot(root, isYieldy, isExpired);\n      finishedWork = root.finishedWork;\n      if (finishedWork !== null) {\n        // We've completed the root. Commit it.\n        completeRoot(root, finishedWork, expirationTime);\n      }\n    }\n  } else {\n    // Flush async work.\n    var _finishedWork = root.finishedWork;\n    if (_finishedWork !== null) {\n      // This root is already complete. We can commit it.\n      completeRoot(root, _finishedWork, expirationTime);\n    } else {\n      root.finishedWork = null;\n      // If this root previously suspended, clear its existing timeout, since\n      // we're about to try rendering again.\n      var _timeoutHandle = root.timeoutHandle;\n      if (enableSuspense && _timeoutHandle !== noTimeout) {\n        root.timeoutHandle = noTimeout;\n        // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n        cancelTimeout(_timeoutHandle);\n      }\n      var _isYieldy = true;\n      renderRoot(root, _isYieldy, isExpired);\n      _finishedWork = root.finishedWork;\n      if (_finishedWork !== null) {\n        // We've completed the root. Check the deadline one more time\n        // before committing.\n        if (!shouldYield()) {\n          // Still time left. Commit the root.\n          completeRoot(root, _finishedWork, expirationTime);\n        } else {\n          // There's no time left. Mark this root as complete. We'll come\n          // back and commit it later.\n          root.finishedWork = _finishedWork;\n        }\n      }\n    }\n  }\n\n  isRendering = false;\n}\n\nfunction completeRoot(root, finishedWork, expirationTime) {\n  // Check if there's a batch that matches this expiration time.\n  var firstBatch = root.firstBatch;\n  if (firstBatch !== null && firstBatch._expirationTime <= expirationTime) {\n    if (completedBatches === null) {\n      completedBatches = [firstBatch];\n    } else {\n      completedBatches.push(firstBatch);\n    }\n    if (firstBatch._defer) {\n      // This root is blocked from committing by a batch. Unschedule it until\n      // we receive another update.\n      root.finishedWork = finishedWork;\n      root.expirationTime = NoWork;\n      return;\n    }\n  }\n\n  // Commit the root.\n  root.finishedWork = null;\n\n  // Check if this is a nested update (a sync update scheduled during the\n  // commit phase).\n  if (root === lastCommittedRootDuringThisBatch) {\n    // If the next root is the same as the previous root, this is a nested\n    // update. To prevent an infinite loop, increment the nested update count.\n    nestedUpdateCount++;\n  } else {\n    // Reset whenever we switch roots.\n    lastCommittedRootDuringThisBatch = root;\n    nestedUpdateCount = 0;\n  }\n  commitRoot(root, finishedWork);\n}\n\n// When working on async work, the reconciler asks the renderer if it should\n// yield execution. For DOM, we implement this with requestIdleCallback.\nfunction shouldYield() {\n  if (deadlineDidExpire) {\n    return true;\n  }\n  if (deadline === null || deadline.timeRemaining() > timeHeuristicForUnitOfWork) {\n    // Disregard deadline.didTimeout. Only expired work should be flushed\n    // during a timeout. This path is only hit for non-expired work.\n    return false;\n  }\n  deadlineDidExpire = true;\n  return true;\n}\n\nfunction onUncaughtError(error) {\n  !(nextFlushedRoot !== null) ? invariant(false, 'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.') : void 0;\n  // Unschedule this root so we don't work on it again until there's\n  // another update.\n  nextFlushedRoot.expirationTime = NoWork;\n  if (!hasUnhandledError) {\n    hasUnhandledError = true;\n    unhandledError = error;\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction batchedUpdates$1(fn, a) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return fn(a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\n// TODO: Batching should be implemented at the renderer level, not inside\n// the reconciler.\nfunction unbatchedUpdates(fn, a) {\n  if (isBatchingUpdates && !isUnbatchingUpdates) {\n    isUnbatchingUpdates = true;\n    try {\n      return fn(a);\n    } finally {\n      isUnbatchingUpdates = false;\n    }\n  }\n  return fn(a);\n}\n\n// TODO: Batching should be implemented at the renderer level, not within\n// the reconciler.\nfunction flushSync(fn, a) {\n  !!isRendering ? invariant(false, 'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.') : void 0;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    return syncUpdates(fn, a);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    performSyncWork();\n  }\n}\n\nfunction interactiveUpdates$1(fn, a, b) {\n  if (isBatchingInteractiveUpdates) {\n    return fn(a, b);\n  }\n  // If there are any pending interactive updates, synchronously flush them.\n  // This needs to happen before we read any handlers, because the effect of\n  // the previous event may influence which handlers are called during\n  // this event.\n  if (!isBatchingUpdates && !isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingInteractiveUpdates = true;\n  isBatchingUpdates = true;\n  try {\n    return fn(a, b);\n  } finally {\n    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\nfunction flushInteractiveUpdates$1() {\n  if (!isRendering && lowestPriorityPendingInteractiveExpirationTime !== NoWork) {\n    // Synchronously flush pending interactive updates.\n    performWork(lowestPriorityPendingInteractiveExpirationTime, null);\n    lowestPriorityPendingInteractiveExpirationTime = NoWork;\n  }\n}\n\nfunction flushControlled(fn) {\n  var previousIsBatchingUpdates = isBatchingUpdates;\n  isBatchingUpdates = true;\n  try {\n    syncUpdates(fn);\n  } finally {\n    isBatchingUpdates = previousIsBatchingUpdates;\n    if (!isBatchingUpdates && !isRendering) {\n      performSyncWork();\n    }\n  }\n}\n\n// 0 is PROD, 1 is DEV.\n// Might add PROFILE later.\n\n\nvar didWarnAboutNestedUpdates = void 0;\n\n{\n  didWarnAboutNestedUpdates = false;\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    var Component = fiber.type;\n    if (isContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  } else if (fiber.tag === ClassComponentLazy) {\n    var _Component = getResultFromResolvedThenable(fiber.type);\n    if (isContextProvider(_Component)) {\n      return processChildContext(fiber, _Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction scheduleRootUpdate(current$$1, element, expirationTime, callback) {\n  {\n    if (phase === 'render' && current !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n      warningWithoutStack$1(false, 'Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentName(current.type) || 'Unknown');\n    }\n  }\n\n  var update = createUpdate(expirationTime);\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  update.payload = { element: element };\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    !(typeof callback === 'function') ? warningWithoutStack$1(false, 'render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback) : void 0;\n    update.callback = callback;\n  }\n  enqueueUpdate(current$$1, update);\n\n  scheduleWork(current$$1, expirationTime);\n  return expirationTime;\n}\n\nfunction updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback) {\n  // TODO: If this is a nested container, this won't be the root.\n  var current$$1 = container.current;\n\n  {\n    if (ReactFiberInstrumentation_1.debugTool) {\n      if (current$$1.alternate === null) {\n        ReactFiberInstrumentation_1.debugTool.onMountContainer(container);\n      } else if (element === null) {\n        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);\n      } else {\n        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);\n      }\n    }\n  }\n\n  var context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  return scheduleRootUpdate(current$$1, element, expirationTime, callback);\n}\n\nfunction findHostInstance(component) {\n  var fiber = get(component);\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      invariant(false, 'Unable to find node on an unmounted component.');\n    } else {\n      invariant(false, 'Argument appears to not be a ReactComponent. Keys: %s', Object.keys(component));\n    }\n  }\n  var hostFiber = findCurrentHostFiber(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction createContainer(containerInfo, isAsync, hydrate) {\n  return createFiberRoot(containerInfo, isAsync, hydrate);\n}\n\nfunction updateContainer(element, container, parentComponent, callback) {\n  var current$$1 = container.current;\n  var currentTime = requestCurrentTime();\n  var expirationTime = computeExpirationForFiber(currentTime, current$$1);\n  return updateContainerAtExpirationTime(element, container, parentComponent, expirationTime, callback);\n}\n\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n  if (!containerFiber.child) {\n    return null;\n  }\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\n\nfunction findHostInstanceWithNoPortals(fiber) {\n  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n  if (hostFiber === null) {\n    return null;\n  }\n  return hostFiber.stateNode;\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n\n  return injectInternals(_assign({}, devToolsConfig, {\n    findHostInstanceByFiber: function (fiber) {\n      var hostFiber = findCurrentHostFiber(fiber);\n      if (hostFiber === null) {\n        return null;\n      }\n      return hostFiber.stateNode;\n    },\n    findFiberByHostInstance: function (instance) {\n      if (!findFiberByHostInstance) {\n        // Might not be implemented by the renderer.\n        return null;\n      }\n      return findFiberByHostInstance(instance);\n    }\n  }));\n}\n\n// This file intentionally does *not* have the Flow annotation.\n// Don't add it. See `./inline-typed.js` for an explanation.\n\nfunction createPortal$1(children, containerInfo,\n// TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.5.2';\n\n// TODO: This type is shared between the reconciler and ReactDOM, but will\n// eventually be lifted out to the renderer.\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n\nvar topLevelUpdateWarnings = void 0;\nvar warnOnInvalidCallback = void 0;\nvar didWarnAboutUnstableCreatePortal = false;\n\n{\n  if (typeof Map !== 'function' ||\n  // $FlowIssue Flow incorrectly thinks Map has no prototype\n  Map.prototype == null || typeof Map.prototype.forEach !== 'function' || typeof Set !== 'function' ||\n  // $FlowIssue Flow incorrectly thinks Set has no prototype\n  Set.prototype == null || typeof Set.prototype.clear !== 'function' || typeof Set.prototype.forEach !== 'function') {\n    warningWithoutStack$1(false, 'React depends on Map and Set built-in types. Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n  }\n\n  topLevelUpdateWarnings = function (container) {\n    if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n      var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);\n      if (hostInstance) {\n        !(hostInstance.parentNode === container) ? warningWithoutStack$1(false, 'render(...): It looks like the React-rendered content of this ' + 'container was removed without using React. This is not ' + 'supported and will cause errors. Instead, call ' + 'ReactDOM.unmountComponentAtNode to empty a container.') : void 0;\n      }\n    }\n\n    var isRootRenderedBySomeReact = !!container._reactRootContainer;\n    var rootEl = getReactRootElementInContainer(container);\n    var hasNonRootReactChild = !!(rootEl && getInstanceFromNode$1(rootEl));\n\n    !(!hasNonRootReactChild || isRootRenderedBySomeReact) ? warningWithoutStack$1(false, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;\n\n    !(container.nodeType !== ELEMENT_NODE || !container.tagName || container.tagName.toUpperCase() !== 'BODY') ? warningWithoutStack$1(false, 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;\n  };\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    !(callback === null || typeof callback === 'function') ? warningWithoutStack$1(false, '%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback) : void 0;\n  };\n}\n\nsetRestoreImplementation(restoreControlledState$1);\n\n/* eslint-disable no-use-before-define */\n\n/* eslint-enable no-use-before-define */\n\nfunction ReactBatch(root) {\n  var expirationTime = computeUniqueAsyncExpiration();\n  this._expirationTime = expirationTime;\n  this._root = root;\n  this._next = null;\n  this._callbacks = null;\n  this._didComplete = false;\n  this._hasChildren = false;\n  this._children = null;\n  this._defer = true;\n}\nReactBatch.prototype.render = function (children) {\n  !this._defer ? invariant(false, 'batch.render: Cannot render a batch that already committed.') : void 0;\n  this._hasChildren = true;\n  this._children = children;\n  var internalRoot = this._root._internalRoot;\n  var expirationTime = this._expirationTime;\n  var work = new ReactWork();\n  updateContainerAtExpirationTime(children, internalRoot, null, expirationTime, work._onCommit);\n  return work;\n};\nReactBatch.prototype.then = function (onComplete) {\n  if (this._didComplete) {\n    onComplete();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onComplete);\n};\nReactBatch.prototype.commit = function () {\n  var internalRoot = this._root._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  !(this._defer && firstBatch !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n\n  if (!this._hasChildren) {\n    // This batch is empty. Return.\n    this._next = null;\n    this._defer = false;\n    return;\n  }\n\n  var expirationTime = this._expirationTime;\n\n  // Ensure this is the first batch in the list.\n  if (firstBatch !== this) {\n    // This batch is not the earliest batch. We need to move it to the front.\n    // Update its expiration time to be the expiration time of the earliest\n    // batch, so that we can flush it without flushing the other batches.\n    if (this._hasChildren) {\n      expirationTime = this._expirationTime = firstBatch._expirationTime;\n      // Rendering this batch again ensures its children will be the final state\n      // when we flush (updates are processed in insertion order: last\n      // update wins).\n      // TODO: This forces a restart. Should we print a warning?\n      this.render(this._children);\n    }\n\n    // Remove the batch from the list.\n    var previous = null;\n    var batch = firstBatch;\n    while (batch !== this) {\n      previous = batch;\n      batch = batch._next;\n    }\n    !(previous !== null) ? invariant(false, 'batch.commit: Cannot commit a batch multiple times.') : void 0;\n    previous._next = batch._next;\n\n    // Add it to the front.\n    this._next = firstBatch;\n    firstBatch = internalRoot.firstBatch = this;\n  }\n\n  // Synchronously flush all the work up to this batch's expiration time.\n  this._defer = false;\n  flushRoot(internalRoot, expirationTime);\n\n  // Pop the batch from the list.\n  var next = this._next;\n  this._next = null;\n  firstBatch = internalRoot.firstBatch = next;\n\n  // Append the next earliest batch's children to the update queue.\n  if (firstBatch !== null && firstBatch._hasChildren) {\n    firstBatch.render(firstBatch._children);\n  }\n};\nReactBatch.prototype._onComplete = function () {\n  if (this._didComplete) {\n    return;\n  }\n  this._didComplete = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback = callbacks[i];\n    _callback();\n  }\n};\n\nfunction ReactWork() {\n  this._callbacks = null;\n  this._didCommit = false;\n  // TODO: Avoid need to bind by replacing callbacks in the update queue with\n  // list of Work objects.\n  this._onCommit = this._onCommit.bind(this);\n}\nReactWork.prototype.then = function (onCommit) {\n  if (this._didCommit) {\n    onCommit();\n    return;\n  }\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    callbacks = this._callbacks = [];\n  }\n  callbacks.push(onCommit);\n};\nReactWork.prototype._onCommit = function () {\n  if (this._didCommit) {\n    return;\n  }\n  this._didCommit = true;\n  var callbacks = this._callbacks;\n  if (callbacks === null) {\n    return;\n  }\n  // TODO: Error handling.\n  for (var i = 0; i < callbacks.length; i++) {\n    var _callback2 = callbacks[i];\n    !(typeof _callback2 === 'function') ? invariant(false, 'Invalid argument passed as callback. Expected a function. Instead received: %s', _callback2) : void 0;\n    _callback2();\n  }\n};\n\nfunction ReactRoot(container, isAsync, hydrate) {\n  var root = createContainer(container, isAsync, hydrate);\n  this._internalRoot = root;\n}\nReactRoot.prototype.render = function (children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(children, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.unmount = function (callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(null, root, null, work._onCommit);\n  return work;\n};\nReactRoot.prototype.legacy_renderSubtreeIntoContainer = function (parentComponent, children, callback) {\n  var root = this._internalRoot;\n  var work = new ReactWork();\n  callback = callback === undefined ? null : callback;\n  {\n    warnOnInvalidCallback(callback, 'render');\n  }\n  if (callback !== null) {\n    work.then(callback);\n  }\n  updateContainer(children, root, parentComponent, work._onCommit);\n  return work;\n};\nReactRoot.prototype.createBatch = function () {\n  var batch = new ReactBatch(this);\n  var expirationTime = batch._expirationTime;\n\n  var internalRoot = this._internalRoot;\n  var firstBatch = internalRoot.firstBatch;\n  if (firstBatch === null) {\n    internalRoot.firstBatch = batch;\n    batch._next = null;\n  } else {\n    // Insert sorted by expiration time then insertion order\n    var insertAfter = null;\n    var insertBefore = firstBatch;\n    while (insertBefore !== null && insertBefore._expirationTime <= expirationTime) {\n      insertAfter = insertBefore;\n      insertBefore = insertBefore._next;\n    }\n    batch._next = insertBefore;\n    if (insertAfter !== null) {\n      insertAfter._next = batch;\n    }\n  }\n\n  return batch;\n};\n\n/**\n * True if the supplied DOM node is a valid node element.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @return {boolean} True if the DOM is a valid DOM node.\n * @internal\n */\nfunction isValidContainer(node) {\n  return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === ' react-mount-point-unstable '));\n}\n\nfunction getReactRootElementInContainer(container) {\n  if (!container) {\n    return null;\n  }\n\n  if (container.nodeType === DOCUMENT_NODE) {\n    return container.documentElement;\n  } else {\n    return container.firstChild;\n  }\n}\n\nfunction shouldHydrateDueToLegacyHeuristic(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return !!(rootElement && rootElement.nodeType === ELEMENT_NODE && rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));\n}\n\nsetBatchingImplementation(batchedUpdates$1, interactiveUpdates$1, flushInteractiveUpdates$1);\n\nvar warnedAboutHydrateAPI = false;\n\nfunction legacyCreateRootFromDOMContainer(container, forceHydrate) {\n  var shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  if (!shouldHydrate) {\n    var warned = false;\n    var rootSibling = void 0;\n    while (rootSibling = container.lastChild) {\n      {\n        if (!warned && rootSibling.nodeType === ELEMENT_NODE && rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)) {\n          warned = true;\n          warningWithoutStack$1(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.');\n        }\n      }\n      container.removeChild(rootSibling);\n    }\n  }\n  {\n    if (shouldHydrate && !forceHydrate && !warnedAboutHydrateAPI) {\n      warnedAboutHydrateAPI = true;\n      lowPriorityWarning$1(false, 'render(): Calling ReactDOM.render() to hydrate server-rendered markup ' + 'will stop working in React v17. Replace the ReactDOM.render() call ' + 'with ReactDOM.hydrate() if you want React to attach to the server HTML.');\n    }\n  }\n  // Legacy roots are not async by default.\n  var isAsync = false;\n  return new ReactRoot(container, isAsync, shouldHydrate);\n}\n\nfunction legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n  // TODO: Ensure all entry points contain this check\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n\n  {\n    topLevelUpdateWarnings(container);\n  }\n\n  // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n  // member of intersection type.\" Whyyyyyy.\n  var root = container._reactRootContainer;\n  if (!root) {\n    // Initial mount\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(container, forceHydrate);\n    if (typeof callback === 'function') {\n      var originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(root._internalRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(function () {\n      if (parentComponent != null) {\n        root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n      } else {\n        root.render(children, callback);\n      }\n    });\n  } else {\n    if (typeof callback === 'function') {\n      var _originalCallback = callback;\n      callback = function () {\n        var instance = getPublicRootInstance(root._internalRoot);\n        _originalCallback.call(instance);\n      };\n    }\n    // Update\n    if (parentComponent != null) {\n      root.legacy_renderSubtreeIntoContainer(parentComponent, children, callback);\n    } else {\n      root.render(children, callback);\n    }\n  }\n  return getPublicRootInstance(root._internalRoot);\n}\n\nfunction createPortal(children, container) {\n  var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n  !isValidContainer(container) ? invariant(false, 'Target container is not a DOM element.') : void 0;\n  // TODO: pass ReactDOM portal implementation as third argument\n  return createPortal$1(children, container, null, key);\n}\n\nvar ReactDOM = {\n  createPortal: createPortal,\n\n  findDOMNode: function (componentOrElement) {\n    {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null && owner.stateNode !== null) {\n        var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n        !warnedAboutRefsInRender ? warningWithoutStack$1(false, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentName(owner.type) || 'A component') : void 0;\n        owner.stateNode._warnedAboutRefsInRender = true;\n      }\n    }\n    if (componentOrElement == null) {\n      return null;\n    }\n    if (componentOrElement.nodeType === ELEMENT_NODE) {\n      return componentOrElement;\n    }\n\n    return findHostInstance(componentOrElement);\n  },\n  hydrate: function (element, container, callback) {\n    // TODO: throw or warn if we couldn't hydrate?\n    return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n  },\n  render: function (element, container, callback) {\n    return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n  },\n  unstable_renderSubtreeIntoContainer: function (parentComponent, element, containerNode, callback) {\n    !(parentComponent != null && has(parentComponent)) ? invariant(false, 'parentComponent must be a valid React Component') : void 0;\n    return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n  },\n  unmountComponentAtNode: function (container) {\n    !isValidContainer(container) ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : void 0;\n\n    if (container._reactRootContainer) {\n      {\n        var rootEl = getReactRootElementInContainer(container);\n        var renderedByDifferentReact = rootEl && !getInstanceFromNode$1(rootEl);\n        !!renderedByDifferentReact ? warningWithoutStack$1(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by another copy of React.') : void 0;\n      }\n\n      // Unmount should not be batched.\n      unbatchedUpdates(function () {\n        legacyRenderSubtreeIntoContainer(null, null, container, false, function () {\n          container._reactRootContainer = null;\n        });\n      });\n      // If you call unmountComponentAtNode twice in quick succession, you'll\n      // get `true` twice. That's probably fine?\n      return true;\n    } else {\n      {\n        var _rootEl = getReactRootElementInContainer(container);\n        var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode$1(_rootEl));\n\n        // Check if the container itself is a React root node.\n        var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainer(container.parentNode) && !!container.parentNode._reactRootContainer;\n\n        !!hasNonRootReactChild ? warningWithoutStack$1(false, \"unmountComponentAtNode(): The node you're attempting to unmount \" + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;\n      }\n\n      return false;\n    }\n  },\n\n\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal: function () {\n    if (!didWarnAboutUnstableCreatePortal) {\n      didWarnAboutUnstableCreatePortal = true;\n      lowPriorityWarning$1(false, 'The ReactDOM.unstable_createPortal() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactDOM.createPortal() instead. It has the exact same API, ' + 'but without the \"unstable_\" prefix.');\n    }\n    return createPortal.apply(undefined, arguments);\n  },\n\n\n  unstable_batchedUpdates: batchedUpdates$1,\n\n  unstable_interactiveUpdates: interactiveUpdates$1,\n\n  flushSync: flushSync,\n\n  unstable_flushControlled: flushControlled,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    // Keep in sync with ReactDOMUnstableNativeDependencies.js\n    // and ReactTestUtils.js. This is an array for better minification.\n    Events: [getInstanceFromNode$1, getNodeFromInstance$1, getFiberCurrentPropsFromNode$1, injection.injectEventPluginsByName, eventNameDispatchConfigs, accumulateTwoPhaseDispatches, accumulateDirectDispatches, enqueueStateRestore, restoreStateIfNeeded, dispatchEvent, runEventsInBatch]\n  }\n};\n\nReactDOM.unstable_createRoot = function createRoot(container, options) {\n  !isValidContainer(container) ? invariant(false, 'unstable_createRoot(...): Target container is not a DOM element.') : void 0;\n  var hydrate = options != null && options.hydrate === true;\n  return new ReactRoot(container, true, hydrate);\n};\n\nvar foundDevTools = injectIntoDevTools({\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  bundleType: 1,\n  version: ReactVersion,\n  rendererPackageName: 'react-dom'\n});\n\n{\n  if (!foundDevTools && canUseDOM && window.top === window.self) {\n    // If we're in Chrome or Firefox, provide a download link if not installed.\n    if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {\n      var protocol = window.location.protocol;\n      // Don't warn in exotic cases like chrome-extension://.\n      if (/^(https?|file):$/.test(protocol)) {\n        console.info('%cDownload the React DevTools ' + 'for a better development experience: ' + 'https://fb.me/react-devtools' + (protocol === 'file:' ? '\\nYou might need to use a local HTTP server (instead of file://): ' + 'https://fb.me/react-devtools-faq' : ''), 'font-weight:bold');\n      }\n    }\n  }\n}\n\n\n\nvar ReactDOM$2 = Object.freeze({\n\tdefault: ReactDOM\n});\n\nvar ReactDOM$3 = ( ReactDOM$2 && ReactDOM ) || ReactDOM$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar reactDom = ReactDOM$3.default || ReactDOM$3;\n\nmodule.exports = reactDom;\n  })();\n}\n","'use strict';\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (process.env.NODE_ENV === 'production') {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = require('./cjs/react-dom.production.min.js');\n} else {\n  module.exports = require('./cjs/react-dom.development.js');\n}\n","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport warning from \"warning\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createBrowserHistory as createHistory } from \"history\";\nimport Router from \"./Router\";\n\n/**\n * The public API for a <Router> that uses HTML5 history.\n */\n\nvar BrowserRouter = function (_React$Component) {\n  _inherits(BrowserRouter, _React$Component);\n\n  function BrowserRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, BrowserRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createHistory(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  BrowserRouter.prototype.componentWillMount = function componentWillMount() {\n    warning(!this.props.history, \"<BrowserRouter> ignores the history prop. To use a custom history, \" + \"use `import { Router }` instead of `import { BrowserRouter as Router }`.\");\n  };\n\n  BrowserRouter.prototype.render = function render() {\n    return React.createElement(Router, { history: this.history, children: this.props.children });\n  };\n\n  return BrowserRouter;\n}(React.Component);\n\nBrowserRouter.propTypes = {\n  basename: PropTypes.string,\n  forceRefresh: PropTypes.bool,\n  getUserConfirmation: PropTypes.func,\n  keyLength: PropTypes.number,\n  children: PropTypes.node\n};\n\n\nexport default BrowserRouter;","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport warning from \"warning\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createHashHistory as createHistory } from \"history\";\nimport Router from \"./Router\";\n\n/**\n * The public API for a <Router> that uses window.location.hash.\n */\n\nvar HashRouter = function (_React$Component) {\n  _inherits(HashRouter, _React$Component);\n\n  function HashRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, HashRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createHistory(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  HashRouter.prototype.componentWillMount = function componentWillMount() {\n    warning(!this.props.history, \"<HashRouter> ignores the history prop. To use a custom history, \" + \"use `import { Router }` instead of `import { HashRouter as Router }`.\");\n  };\n\n  HashRouter.prototype.render = function render() {\n    return React.createElement(Router, { history: this.history, children: this.props.children });\n  };\n\n  return HashRouter;\n}(React.Component);\n\nHashRouter.propTypes = {\n  basename: PropTypes.string,\n  getUserConfirmation: PropTypes.func,\n  hashType: PropTypes.oneOf([\"hashbang\", \"noslash\", \"slash\"]),\n  children: PropTypes.node\n};\n\n\nexport default HashRouter;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"invariant\";\nimport { createLocation } from \"history\";\n\nvar isModifiedEvent = function isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n};\n\n/**\n * The public API for rendering a history-aware <a>.\n */\n\nvar Link = function (_React$Component) {\n  _inherits(Link, _React$Component);\n\n  function Link() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Link);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {\n      if (_this.props.onClick) _this.props.onClick(event);\n\n      if (!event.defaultPrevented && // onClick prevented default\n      event.button === 0 && // ignore everything but left clicks\n      !_this.props.target && // let browser handle \"target=_blank\" etc.\n      !isModifiedEvent(event) // ignore clicks with modifier keys\n      ) {\n          event.preventDefault();\n\n          var history = _this.context.router.history;\n          var _this$props = _this.props,\n              replace = _this$props.replace,\n              to = _this$props.to;\n\n\n          if (replace) {\n            history.replace(to);\n          } else {\n            history.push(to);\n          }\n        }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Link.prototype.render = function render() {\n    var _props = this.props,\n        replace = _props.replace,\n        to = _props.to,\n        innerRef = _props.innerRef,\n        props = _objectWithoutProperties(_props, [\"replace\", \"to\", \"innerRef\"]); // eslint-disable-line no-unused-vars\n\n    invariant(this.context.router, \"You should not use <Link> outside a <Router>\");\n\n    invariant(to !== undefined, 'You must specify the \"to\" property');\n\n    var history = this.context.router.history;\n\n    var location = typeof to === \"string\" ? createLocation(to, null, null, history.location) : to;\n\n    var href = history.createHref(location);\n    return React.createElement(\"a\", _extends({}, props, { onClick: this.handleClick, href: href, ref: innerRef }));\n  };\n\n  return Link;\n}(React.Component);\n\nLink.propTypes = {\n  onClick: PropTypes.func,\n  target: PropTypes.string,\n  replace: PropTypes.bool,\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,\n  innerRef: PropTypes.oneOfType([PropTypes.string, PropTypes.func])\n};\nLink.defaultProps = {\n  replace: false\n};\nLink.contextTypes = {\n  router: PropTypes.shape({\n    history: PropTypes.shape({\n      push: PropTypes.func.isRequired,\n      replace: PropTypes.func.isRequired,\n      createHref: PropTypes.func.isRequired\n    }).isRequired\n  }).isRequired\n};\n\n\nexport default Link;","// Written in this round about way for babel-transform-imports\nimport MemoryRouter from \"react-router/es/MemoryRouter\";\n\nexport default MemoryRouter;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport Route from \"./Route\";\nimport Link from \"./Link\";\n\n/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */\nvar NavLink = function NavLink(_ref) {\n  var to = _ref.to,\n      exact = _ref.exact,\n      strict = _ref.strict,\n      location = _ref.location,\n      activeClassName = _ref.activeClassName,\n      className = _ref.className,\n      activeStyle = _ref.activeStyle,\n      style = _ref.style,\n      getIsActive = _ref.isActive,\n      ariaCurrent = _ref[\"aria-current\"],\n      rest = _objectWithoutProperties(_ref, [\"to\", \"exact\", \"strict\", \"location\", \"activeClassName\", \"className\", \"activeStyle\", \"style\", \"isActive\", \"aria-current\"]);\n\n  var path = (typeof to === \"undefined\" ? \"undefined\" : _typeof(to)) === \"object\" ? to.pathname : to;\n\n  // Regex taken from: https://github.com/pillarjs/path-to-regexp/blob/master/index.js#L202\n  var escapedPath = path && path.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n\n  return React.createElement(Route, {\n    path: escapedPath,\n    exact: exact,\n    strict: strict,\n    location: location,\n    children: function children(_ref2) {\n      var location = _ref2.location,\n          match = _ref2.match;\n\n      var isActive = !!(getIsActive ? getIsActive(match, location) : match);\n\n      return React.createElement(Link, _extends({\n        to: to,\n        className: isActive ? [className, activeClassName].filter(function (i) {\n          return i;\n        }).join(\" \") : className,\n        style: isActive ? _extends({}, style, activeStyle) : style,\n        \"aria-current\": isActive && ariaCurrent || null\n      }, rest));\n    }\n  });\n};\n\nNavLink.propTypes = {\n  to: Link.propTypes.to,\n  exact: PropTypes.bool,\n  strict: PropTypes.bool,\n  location: PropTypes.object,\n  activeClassName: PropTypes.string,\n  className: PropTypes.string,\n  activeStyle: PropTypes.object,\n  style: PropTypes.object,\n  isActive: PropTypes.func,\n  \"aria-current\": PropTypes.oneOf([\"page\", \"step\", \"location\", \"date\", \"time\", \"true\"])\n};\n\nNavLink.defaultProps = {\n  activeClassName: \"active\",\n  \"aria-current\": \"page\"\n};\n\nexport default NavLink;","// Written in this round about way for babel-transform-imports\nimport Prompt from \"react-router/es/Prompt\";\n\nexport default Prompt;","// Written in this round about way for babel-transform-imports\nimport Redirect from \"react-router/es/Redirect\";\n\nexport default Redirect;","// Written in this round about way for babel-transform-imports\nimport Route from \"react-router/es/Route\";\n\nexport default Route;","// Written in this round about way for babel-transform-imports\nimport Router from \"react-router/es/Router\";\n\nexport default Router;","// Written in this round about way for babel-transform-imports\nimport StaticRouter from \"react-router/es/StaticRouter\";\n\nexport default StaticRouter;","// Written in this round about way for babel-transform-imports\nimport Switch from \"react-router/es/Switch\";\n\nexport default Switch;","// Written in this round about way for babel-transform-imports\nimport generatePath from \"react-router/es/generatePath\";\n\nexport default generatePath;","import _BrowserRouter from \"./BrowserRouter\";\nexport { _BrowserRouter as BrowserRouter };\nimport _HashRouter from \"./HashRouter\";\nexport { _HashRouter as HashRouter };\nimport _Link from \"./Link\";\nexport { _Link as Link };\nimport _MemoryRouter from \"./MemoryRouter\";\nexport { _MemoryRouter as MemoryRouter };\nimport _NavLink from \"./NavLink\";\nexport { _NavLink as NavLink };\nimport _Prompt from \"./Prompt\";\nexport { _Prompt as Prompt };\nimport _Redirect from \"./Redirect\";\nexport { _Redirect as Redirect };\nimport _Route from \"./Route\";\nexport { _Route as Route };\nimport _Router from \"./Router\";\nexport { _Router as Router };\nimport _StaticRouter from \"./StaticRouter\";\nexport { _StaticRouter as StaticRouter };\nimport _Switch from \"./Switch\";\nexport { _Switch as Switch };\nimport _generatePath from \"./generatePath\";\nexport { _generatePath as generatePath };\nimport _matchPath from \"./matchPath\";\nexport { _matchPath as matchPath };\nimport _withRouter from \"./withRouter\";\nexport { _withRouter as withRouter };","// Written in this round about way for babel-transform-imports\nimport matchPath from \"react-router/es/matchPath\";\n\nexport default matchPath;","// Written in this round about way for babel-transform-imports\nimport withRouter from \"react-router/es/withRouter\";\n\nexport default withRouter;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport warning from \"warning\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createMemoryHistory as createHistory } from \"history\";\nimport Router from \"./Router\";\n\n/**\n * The public API for a <Router> that stores location in memory.\n */\n\nvar MemoryRouter = function (_React$Component) {\n  _inherits(MemoryRouter, _React$Component);\n\n  function MemoryRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, MemoryRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = createHistory(_this.props), _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  MemoryRouter.prototype.componentWillMount = function componentWillMount() {\n    warning(!this.props.history, \"<MemoryRouter> ignores the history prop. To use a custom history, \" + \"use `import { Router }` instead of `import { MemoryRouter as Router }`.\");\n  };\n\n  MemoryRouter.prototype.render = function render() {\n    return React.createElement(Router, { history: this.history, children: this.props.children });\n  };\n\n  return MemoryRouter;\n}(React.Component);\n\nMemoryRouter.propTypes = {\n  initialEntries: PropTypes.array,\n  initialIndex: PropTypes.number,\n  getUserConfirmation: PropTypes.func,\n  keyLength: PropTypes.number,\n  children: PropTypes.node\n};\n\n\nexport default MemoryRouter;","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport invariant from \"invariant\";\n\n/**\n * The public API for prompting the user before navigating away\n * from a screen with a component.\n */\n\nvar Prompt = function (_React$Component) {\n  _inherits(Prompt, _React$Component);\n\n  function Prompt() {\n    _classCallCheck(this, Prompt);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Prompt.prototype.enable = function enable(message) {\n    if (this.unblock) this.unblock();\n\n    this.unblock = this.context.router.history.block(message);\n  };\n\n  Prompt.prototype.disable = function disable() {\n    if (this.unblock) {\n      this.unblock();\n      this.unblock = null;\n    }\n  };\n\n  Prompt.prototype.componentWillMount = function componentWillMount() {\n    invariant(this.context.router, \"You should not use <Prompt> outside a <Router>\");\n\n    if (this.props.when) this.enable(this.props.message);\n  };\n\n  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (nextProps.when) {\n      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);\n    } else {\n      this.disable();\n    }\n  };\n\n  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.disable();\n  };\n\n  Prompt.prototype.render = function render() {\n    return null;\n  };\n\n  return Prompt;\n}(React.Component);\n\nPrompt.propTypes = {\n  when: PropTypes.bool,\n  message: PropTypes.oneOfType([PropTypes.func, PropTypes.string]).isRequired\n};\nPrompt.defaultProps = {\n  when: true\n};\nPrompt.contextTypes = {\n  router: PropTypes.shape({\n    history: PropTypes.shape({\n      block: PropTypes.func.isRequired\n    }).isRequired\n  }).isRequired\n};\n\n\nexport default Prompt;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"warning\";\nimport invariant from \"invariant\";\nimport { createLocation, locationsAreEqual } from \"history\";\nimport generatePath from \"./generatePath\";\n\n/**\n * The public API for updating the location programmatically\n * with a component.\n */\n\nvar Redirect = function (_React$Component) {\n  _inherits(Redirect, _React$Component);\n\n  function Redirect() {\n    _classCallCheck(this, Redirect);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Redirect.prototype.isStatic = function isStatic() {\n    return this.context.router && this.context.router.staticContext;\n  };\n\n  Redirect.prototype.componentWillMount = function componentWillMount() {\n    invariant(this.context.router, \"You should not use <Redirect> outside a <Router>\");\n\n    if (this.isStatic()) this.perform();\n  };\n\n  Redirect.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isStatic()) this.perform();\n  };\n\n  Redirect.prototype.componentDidUpdate = function componentDidUpdate(prevProps) {\n    var prevTo = createLocation(prevProps.to);\n    var nextTo = createLocation(this.props.to);\n\n    if (locationsAreEqual(prevTo, nextTo)) {\n      warning(false, \"You tried to redirect to the same route you're currently on: \" + (\"\\\"\" + nextTo.pathname + nextTo.search + \"\\\"\"));\n      return;\n    }\n\n    this.perform();\n  };\n\n  Redirect.prototype.computeTo = function computeTo(_ref) {\n    var computedMatch = _ref.computedMatch,\n        to = _ref.to;\n\n    if (computedMatch) {\n      if (typeof to === \"string\") {\n        return generatePath(to, computedMatch.params);\n      } else {\n        return _extends({}, to, {\n          pathname: generatePath(to.pathname, computedMatch.params)\n        });\n      }\n    }\n\n    return to;\n  };\n\n  Redirect.prototype.perform = function perform() {\n    var history = this.context.router.history;\n    var push = this.props.push;\n\n    var to = this.computeTo(this.props);\n\n    if (push) {\n      history.push(to);\n    } else {\n      history.replace(to);\n    }\n  };\n\n  Redirect.prototype.render = function render() {\n    return null;\n  };\n\n  return Redirect;\n}(React.Component);\n\nRedirect.propTypes = {\n  computedMatch: PropTypes.object, // private, from <Switch>\n  push: PropTypes.bool,\n  from: PropTypes.string,\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired\n};\nRedirect.defaultProps = {\n  push: false\n};\nRedirect.contextTypes = {\n  router: PropTypes.shape({\n    history: PropTypes.shape({\n      push: PropTypes.func.isRequired,\n      replace: PropTypes.func.isRequired\n    }).isRequired,\n    staticContext: PropTypes.object\n  }).isRequired\n};\n\n\nexport default Redirect;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport warning from \"warning\";\nimport invariant from \"invariant\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport matchPath from \"./matchPath\";\n\nvar isEmptyChildren = function isEmptyChildren(children) {\n  return React.Children.count(children) === 0;\n};\n\n/**\n * The public API for matching a single path and rendering.\n */\n\nvar Route = function (_React$Component) {\n  _inherits(Route, _React$Component);\n\n  function Route() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Route);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      match: _this.computeMatch(_this.props, _this.context.router)\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Route.prototype.getChildContext = function getChildContext() {\n    return {\n      router: _extends({}, this.context.router, {\n        route: {\n          location: this.props.location || this.context.router.route.location,\n          match: this.state.match\n        }\n      })\n    };\n  };\n\n  Route.prototype.computeMatch = function computeMatch(_ref, router) {\n    var computedMatch = _ref.computedMatch,\n        location = _ref.location,\n        path = _ref.path,\n        strict = _ref.strict,\n        exact = _ref.exact,\n        sensitive = _ref.sensitive;\n\n    if (computedMatch) return computedMatch; // <Switch> already computed the match for us\n\n    invariant(router, \"You should not use <Route> or withRouter() outside a <Router>\");\n\n    var route = router.route;\n\n    var pathname = (location || route.location).pathname;\n\n    return matchPath(pathname, { path: path, strict: strict, exact: exact, sensitive: sensitive }, route.match);\n  };\n\n  Route.prototype.componentWillMount = function componentWillMount() {\n    warning(!(this.props.component && this.props.render), \"You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored\");\n\n    warning(!(this.props.component && this.props.children && !isEmptyChildren(this.props.children)), \"You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored\");\n\n    warning(!(this.props.render && this.props.children && !isEmptyChildren(this.props.children)), \"You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored\");\n  };\n\n  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {\n    warning(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.');\n\n    warning(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.');\n\n    this.setState({\n      match: this.computeMatch(nextProps, nextContext.router)\n    });\n  };\n\n  Route.prototype.render = function render() {\n    var match = this.state.match;\n    var _props = this.props,\n        children = _props.children,\n        component = _props.component,\n        render = _props.render;\n    var _context$router = this.context.router,\n        history = _context$router.history,\n        route = _context$router.route,\n        staticContext = _context$router.staticContext;\n\n    var location = this.props.location || route.location;\n    var props = { match: match, location: location, history: history, staticContext: staticContext };\n\n    if (component) return match ? React.createElement(component, props) : null;\n\n    if (render) return match ? render(props) : null;\n\n    if (typeof children === \"function\") return children(props);\n\n    if (children && !isEmptyChildren(children)) return React.Children.only(children);\n\n    return null;\n  };\n\n  return Route;\n}(React.Component);\n\nRoute.propTypes = {\n  computedMatch: PropTypes.object, // private, from <Switch>\n  path: PropTypes.string,\n  exact: PropTypes.bool,\n  strict: PropTypes.bool,\n  sensitive: PropTypes.bool,\n  component: PropTypes.func,\n  render: PropTypes.func,\n  children: PropTypes.oneOfType([PropTypes.func, PropTypes.node]),\n  location: PropTypes.object\n};\nRoute.contextTypes = {\n  router: PropTypes.shape({\n    history: PropTypes.object.isRequired,\n    route: PropTypes.object.isRequired,\n    staticContext: PropTypes.object\n  })\n};\nRoute.childContextTypes = {\n  router: PropTypes.object.isRequired\n};\n\n\nexport default Route;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport warning from \"warning\";\nimport invariant from \"invariant\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\n\n/**\n * The public API for putting history on context.\n */\n\nvar Router = function (_React$Component) {\n  _inherits(Router, _React$Component);\n\n  function Router() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Router);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {\n      match: _this.computeMatch(_this.props.history.location.pathname)\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  Router.prototype.getChildContext = function getChildContext() {\n    return {\n      router: _extends({}, this.context.router, {\n        history: this.props.history,\n        route: {\n          location: this.props.history.location,\n          match: this.state.match\n        }\n      })\n    };\n  };\n\n  Router.prototype.computeMatch = function computeMatch(pathname) {\n    return {\n      path: \"/\",\n      url: \"/\",\n      params: {},\n      isExact: pathname === \"/\"\n    };\n  };\n\n  Router.prototype.componentWillMount = function componentWillMount() {\n    var _this2 = this;\n\n    var _props = this.props,\n        children = _props.children,\n        history = _props.history;\n\n\n    invariant(children == null || React.Children.count(children) === 1, \"A <Router> may have only one child element\");\n\n    // Do this here so we can setState when a <Redirect> changes the\n    // location in componentWillMount. This happens e.g. when doing\n    // server rendering using a <StaticRouter>.\n    this.unlisten = history.listen(function () {\n      _this2.setState({\n        match: _this2.computeMatch(history.location.pathname)\n      });\n    });\n  };\n\n  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    warning(this.props.history === nextProps.history, \"You cannot change <Router history>\");\n  };\n\n  Router.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.unlisten();\n  };\n\n  Router.prototype.render = function render() {\n    var children = this.props.children;\n\n    return children ? React.Children.only(children) : null;\n  };\n\n  return Router;\n}(React.Component);\n\nRouter.propTypes = {\n  history: PropTypes.object.isRequired,\n  children: PropTypes.node\n};\nRouter.contextTypes = {\n  router: PropTypes.object\n};\nRouter.childContextTypes = {\n  router: PropTypes.object.isRequired\n};\n\n\nexport default Router;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport warning from \"warning\";\nimport invariant from \"invariant\";\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { createLocation, createPath } from \"history\";\nimport Router from \"./Router\";\n\nvar addLeadingSlash = function addLeadingSlash(path) {\n  return path.charAt(0) === \"/\" ? path : \"/\" + path;\n};\n\nvar addBasename = function addBasename(basename, location) {\n  if (!basename) return location;\n\n  return _extends({}, location, {\n    pathname: addLeadingSlash(basename) + location.pathname\n  });\n};\n\nvar stripBasename = function stripBasename(basename, location) {\n  if (!basename) return location;\n\n  var base = addLeadingSlash(basename);\n\n  if (location.pathname.indexOf(base) !== 0) return location;\n\n  return _extends({}, location, {\n    pathname: location.pathname.substr(base.length)\n  });\n};\n\nvar createURL = function createURL(location) {\n  return typeof location === \"string\" ? location : createPath(location);\n};\n\nvar staticHandler = function staticHandler(methodName) {\n  return function () {\n    invariant(false, \"You cannot %s with <StaticRouter>\", methodName);\n  };\n};\n\nvar noop = function noop() {};\n\n/**\n * The public top-level API for a \"static\" <Router>, so-called because it\n * can't actually change the current location. Instead, it just records\n * location changes in a context object. Useful mainly in testing and\n * server-rendering scenarios.\n */\n\nvar StaticRouter = function (_React$Component) {\n  _inherits(StaticRouter, _React$Component);\n\n  function StaticRouter() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, StaticRouter);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {\n      return addLeadingSlash(_this.props.basename + createURL(path));\n    }, _this.handlePush = function (location) {\n      var _this$props = _this.props,\n          basename = _this$props.basename,\n          context = _this$props.context;\n\n      context.action = \"PUSH\";\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }, _this.handleReplace = function (location) {\n      var _this$props2 = _this.props,\n          basename = _this$props2.basename,\n          context = _this$props2.context;\n\n      context.action = \"REPLACE\";\n      context.location = addBasename(basename, createLocation(location));\n      context.url = createURL(context.location);\n    }, _this.handleListen = function () {\n      return noop;\n    }, _this.handleBlock = function () {\n      return noop;\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  StaticRouter.prototype.getChildContext = function getChildContext() {\n    return {\n      router: {\n        staticContext: this.props.context\n      }\n    };\n  };\n\n  StaticRouter.prototype.componentWillMount = function componentWillMount() {\n    warning(!this.props.history, \"<StaticRouter> ignores the history prop. To use a custom history, \" + \"use `import { Router }` instead of `import { StaticRouter as Router }`.\");\n  };\n\n  StaticRouter.prototype.render = function render() {\n    var _props = this.props,\n        basename = _props.basename,\n        context = _props.context,\n        location = _props.location,\n        props = _objectWithoutProperties(_props, [\"basename\", \"context\", \"location\"]);\n\n    var history = {\n      createHref: this.createHref,\n      action: \"POP\",\n      location: stripBasename(basename, createLocation(location)),\n      push: this.handlePush,\n      replace: this.handleReplace,\n      go: staticHandler(\"go\"),\n      goBack: staticHandler(\"goBack\"),\n      goForward: staticHandler(\"goForward\"),\n      listen: this.handleListen,\n      block: this.handleBlock\n    };\n\n    return React.createElement(Router, _extends({}, props, { history: history }));\n  };\n\n  return StaticRouter;\n}(React.Component);\n\nStaticRouter.propTypes = {\n  basename: PropTypes.string,\n  context: PropTypes.object.isRequired,\n  location: PropTypes.oneOfType([PropTypes.string, PropTypes.object])\n};\nStaticRouter.defaultProps = {\n  basename: \"\",\n  location: \"/\"\n};\nStaticRouter.childContextTypes = {\n  router: PropTypes.object.isRequired\n};\n\n\nexport default StaticRouter;","function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"warning\";\nimport invariant from \"invariant\";\nimport matchPath from \"./matchPath\";\n\n/**\n * The public API for rendering the first <Route> that matches.\n */\n\nvar Switch = function (_React$Component) {\n  _inherits(Switch, _React$Component);\n\n  function Switch() {\n    _classCallCheck(this, Switch);\n\n    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));\n  }\n\n  Switch.prototype.componentWillMount = function componentWillMount() {\n    invariant(this.context.router, \"You should not use <Switch> outside a <Router>\");\n  };\n\n  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    warning(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no \"location\" prop and then provided one on a subsequent render.');\n\n    warning(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a \"location\" prop initially but omitted it on a subsequent render.');\n  };\n\n  Switch.prototype.render = function render() {\n    var route = this.context.router.route;\n    var children = this.props.children;\n\n    var location = this.props.location || route.location;\n\n    var match = void 0,\n        child = void 0;\n    React.Children.forEach(children, function (element) {\n      if (match == null && React.isValidElement(element)) {\n        var _element$props = element.props,\n            pathProp = _element$props.path,\n            exact = _element$props.exact,\n            strict = _element$props.strict,\n            sensitive = _element$props.sensitive,\n            from = _element$props.from;\n\n        var path = pathProp || from;\n\n        child = element;\n        match = matchPath(location.pathname, { path: path, exact: exact, strict: strict, sensitive: sensitive }, route.match);\n      }\n    });\n\n    return match ? React.cloneElement(child, { location: location, computedMatch: match }) : null;\n  };\n\n  return Switch;\n}(React.Component);\n\nSwitch.contextTypes = {\n  router: PropTypes.shape({\n    route: PropTypes.object.isRequired\n  }).isRequired\n};\nSwitch.propTypes = {\n  children: PropTypes.node,\n  location: PropTypes.object\n};\n\n\nexport default Switch;","import pathToRegexp from \"path-to-regexp\";\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compileGenerator = function compileGenerator(pattern) {\n  var cacheKey = pattern;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) return cache[pattern];\n\n  var compiledGenerator = pathToRegexp.compile(pattern);\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledGenerator;\n    cacheCount++;\n  }\n\n  return compiledGenerator;\n};\n\n/**\n * Public API for generating a URL pathname from a pattern and parameters.\n */\nvar generatePath = function generatePath() {\n  var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"/\";\n  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (pattern === \"/\") {\n    return pattern;\n  }\n  var generator = compileGenerator(pattern);\n  return generator(params, { pretty: true });\n};\n\nexport default generatePath;","import pathToRegexp from \"path-to-regexp\";\n\nvar patternCache = {};\nvar cacheLimit = 10000;\nvar cacheCount = 0;\n\nvar compilePath = function compilePath(pattern, options) {\n  var cacheKey = \"\" + options.end + options.strict + options.sensitive;\n  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});\n\n  if (cache[pattern]) return cache[pattern];\n\n  var keys = [];\n  var re = pathToRegexp(pattern, keys, options);\n  var compiledPattern = { re: re, keys: keys };\n\n  if (cacheCount < cacheLimit) {\n    cache[pattern] = compiledPattern;\n    cacheCount++;\n  }\n\n  return compiledPattern;\n};\n\n/**\n * Public API for matching a URL pathname to a path pattern.\n */\nvar matchPath = function matchPath(pathname) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var parent = arguments[2];\n\n  if (typeof options === \"string\") options = { path: options };\n\n  var _options = options,\n      path = _options.path,\n      _options$exact = _options.exact,\n      exact = _options$exact === undefined ? false : _options$exact,\n      _options$strict = _options.strict,\n      strict = _options$strict === undefined ? false : _options$strict,\n      _options$sensitive = _options.sensitive,\n      sensitive = _options$sensitive === undefined ? false : _options$sensitive;\n\n\n  if (path == null) return parent;\n\n  var _compilePath = compilePath(path, { end: exact, strict: strict, sensitive: sensitive }),\n      re = _compilePath.re,\n      keys = _compilePath.keys;\n\n  var match = re.exec(pathname);\n\n  if (!match) return null;\n\n  var url = match[0],\n      values = match.slice(1);\n\n  var isExact = pathname === url;\n\n  if (exact && !isExact) return null;\n\n  return {\n    path: path, // the path pattern used to match\n    url: path === \"/\" && url === \"\" ? \"/\" : url, // the matched portion of the URL\n    isExact: isExact, // whether or not we matched exactly\n    params: keys.reduce(function (memo, key, index) {\n      memo[key.name] = values[index];\n      return memo;\n    }, {})\n  };\n};\n\nexport default matchPath;","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport hoistStatics from \"hoist-non-react-statics\";\nimport Route from \"./Route\";\n\n/**\n * A public higher-order component to access the imperative API\n */\nvar withRouter = function withRouter(Component) {\n  var C = function C(props) {\n    var wrappedComponentRef = props.wrappedComponentRef,\n        remainingProps = _objectWithoutProperties(props, [\"wrappedComponentRef\"]);\n\n    return React.createElement(Route, {\n      children: function children(routeComponentProps) {\n        return React.createElement(Component, _extends({}, remainingProps, routeComponentProps, {\n          ref: wrappedComponentRef\n        }));\n      }\n    });\n  };\n\n  C.displayName = \"withRouter(\" + (Component.displayName || Component.name) + \")\";\n  C.WrappedComponent = Component;\n  C.propTypes = {\n    wrappedComponentRef: PropTypes.func\n  };\n\n  return hoistStatics(C, Component);\n};\n\nexport default withRouter;","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = function() {};\n\nif (__DEV__) {\n  var printWarning = function printWarning(format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    var argIndex = 0;\n    var message = 'Warning: ' +\n      format.replace(/%s/g, function() {\n        return args[argIndex++];\n      });\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  }\n\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n          'message argument'\n      );\n    }\n    if (!condition) {\n      printWarning.apply(null, [format].concat(args));\n    }\n  };\n}\n\nmodule.exports = warning;\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"react\"),require(\"vega-lite\"),require(\"react-vega\")):\"function\"==typeof define&&define.amd?define([\"react\",\"vega-lite\",\"react-vega\"],t):\"object\"==typeof exports?exports.ReactVegaLite=t(require(\"react\"),require(\"vega-lite\"),require(\"react-vega\")):e.ReactVegaLite=t(e.React,e.vl,e.ReactVega)}(\"undefined\"!=typeof self?self:this,function(e,t,r){return function(e){function t(n){if(r[n])return r[n].exports;var a=r[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,\"a\",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=\"\",t(t.s=2)}([function(e,t,r){\"use strict\";var n=r(1),a=r.n(n),o=r(4),c=(r.n(o),r(5)),u=r.n(c),i=function(e){var t=Object.assign({},e),r=Object.assign({},e.spec);return e.data&&(r.data=e.data,delete t.data),t.spec=o.compile(r).spec,a.a.createElement(u.a,t)};i.propTypes=u.a.propTypes,t.a=i},function(t,r){t.exports=e},function(e,t,r){e.exports=r(3)},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),r.d(t,\"createClassFromLiteSpec\",function(){return o});var n=r(0),a=r(6);t.default=n.a;var o=a.a},function(e,r){e.exports=t},function(e,t){e.exports=r},function(e,t,r){\"use strict\";function n(){function e(e){return o.a.createElement(c.a,u({spec:t},e))}var t=1===arguments.length?arguments.length<=0?void 0:arguments[0]:arguments.length<=1?void 0:arguments[1],r=Object.assign({},c.a.propTypes);return delete r.spec,e.getSpec=function(){return t},e.propTypes=r,e}t.a=n;var a=r(1),o=r.n(a),c=r(0),u=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}}]).default});","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"prop-types\"),require(\"react\"),require(\"vega-lib\")):\"function\"==typeof define&&define.amd?define([\"prop-types\",\"react\",\"vega-lib\"],t):\"object\"==typeof exports?exports.ReactVega=t(require(\"prop-types\"),require(\"react\"),require(\"vega-lib\")):e.ReactVega=t(e.PropTypes,e.React,e.vega)}(this,function(e,t,n){return function(e){function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,\"a\",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=\"\",t(t.s=7)}([function(e,t,n){\"use strict\";function r(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}function i(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!=typeof t&&\"function\"!=typeof t?e:t}function a(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}var o=n(6),u=(n.n(o),n(5)),c=n(1),s=n.n(c),p=n(2),f=n.n(p),l=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),d={className:s.a.string,style:s.a.object,spec:s.a.object.isRequired,logLevel:s.a.number,width:s.a.number,height:s.a.number,tooltip:s.a.func,background:s.a.string,padding:s.a.object,renderer:s.a.string,enableHover:s.a.bool,data:s.a.object,onNewView:s.a.func,onParseError:s.a.func},h={className:\"\",renderer:\"svg\",enableHover:!0,onNewView:function(){},onParseError:function(){}},v=function(e){function t(){return r(this,t),i(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return a(t,e),l(t,[{key:\"componentDidMount\",value:function(){this.createView(this.props.spec)}},{key:\"componentDidUpdate\",value:function(e){var n=this;if(this.props.spec!==e.spec)this.clearView(),this.createView(this.props.spec);else if(this.view){var r=this.props,i=this.props.spec,a=!1;[\"width\",\"height\",\"renderer\",\"logLevel\",\"background\"].filter(function(t){return r[t]!==e[t]}).forEach(function(e){n.view[e](r[e]),a=!0}),t.isSamePadding(r.padding,e.padding)||(this.view.padding(r.padding||i.padding),a=!0),i.data&&r.data&&i.data.forEach(function(i){var o=e.data[i.name],u=r.data[i.name];t.isSameData(o,u)||(n.updateData(i.name,u),a=!0)}),r.enableHover!==e.enableHover&&(a=!0),a&&(r.enableHover&&this.view.hover(),this.view.run())}}},{key:\"componentWillUnmount\",value:function(){this.clearView()}},{key:\"createView\",value:function(e){var r=this;if(e){var i=this.props;try{var a=o.parse(e),c=new o.View(a).initialize(this.element);e.signals&&e.signals.forEach(function(e){c.addSignalListener(e.name,function(){for(var n=arguments.length,i=Array(n),a=0;a<n;a++)i[a]=arguments[a];var o=r.props[t.listenerName(e.name)];o&&o.apply(r,i)})}),this.view=c,[\"logLevel\",\"renderer\",\"tooltip\",\"background\",\"width\",\"height\",\"padding\"].filter(function(e){return n.i(u.a)(i[e])}).forEach(function(e){c[e](i[e])}),e.data&&i.data&&e.data.filter(function(e){return i.data[e.name]}).forEach(function(e){r.updateData(e.name,i.data[e.name])}),i.enableHover&&c.hover(),c.run(),i.onNewView(c)}catch(e){this.clearView(),i.onParseError(e)}}else this.clearView();return this}},{key:\"updateData\",value:function(e,t){t&&(n.i(u.b)(t)?t(this.view.data(e)):this.view.change(e,o.changeset().remove(function(){return!0}).insert(t)))}},{key:\"clearView\",value:function(){return this.view&&(this.view.finalize(),this.view=null),this}},{key:\"render\",value:function(){var e=this;return f.a.createElement(\"div\",{ref:function(t){e.element=t},className:this.props.className,style:this.props.style})}}],[{key:\"isSamePadding\",value:function(e,t){return n.i(u.a)(e)&&n.i(u.a)(t)?e.top===t.top&&e.left===t.left&&e.right===t.right&&e.bottom===t.bottom:e===t}},{key:\"isSameData\",value:function(e,t){return e===t&&!n.i(u.b)(e)}},{key:\"isSameSpec\",value:function(e,t){return e===t||JSON.stringify(e)===JSON.stringify(t)}},{key:\"listenerName\",value:function(e){return\"onSignal\"+n.i(u.c)(e)}}]),t}(f.a.Component);v.propTypes=d,v.defaultProps=h,t.a=v},function(t,n){t.exports=e},function(e,n){e.exports=t},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),n.d(t,\"createClassFromSpec\",function(){return a});var r=n(0),i=n(4);t.default=r.a;var a=i.a},function(e,t,n){\"use strict\";function r(){function e(e){return a.a.createElement(c.a,s({spec:t},e))}var t=1===arguments.length?arguments.length<=0?void 0:arguments[0]:arguments.length<=1?void 0:arguments[1],n=Object.assign({},c.a.propTypes);return delete n.spec,t.signals&&t.signals.forEach(function(e){n[c.a.listenerName(e.name)]=u.a.func}),e.getSpec=function(){return t},e.propTypes=n,e}t.a=r;var i=n(2),a=n.n(i),o=n(1),u=n.n(o),c=n(0),s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}},function(e,t,n){\"use strict\";function r(e){return e.charAt(0).toUpperCase()+e.slice(1)}function i(e){return null!==e&&void 0!==e}function a(e){var t={};return!!e&&\"[object Function]\"===t.toString.call(e)}t.c=r,t.a=i,t.b=a},function(e,t){e.exports=n},function(e,t,n){e.exports=n(3)}])});","/** @license React v16.5.2\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar _assign = require('object-assign');\nvar checkPropTypes = require('prop-types/checkPropTypes');\n\n// TODO: this is special because it gets imported during build.\n\nvar ReactVersion = '16.5.2';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\n\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_PLACEHOLDER_TYPE = hasSymbol ? Symbol.for('react.placeholder') : 0xead1;\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n  return null;\n}\n\n// Exports ReactDOM.createRoot\n\n\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\n\n// Suspense\nvar enableSuspense = false;\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\n\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n\n// Warn about legacy context API\n\n\n// Gather advanced timing metrics for Profiler subtrees.\n\n\n// Trace which interactions trigger each commit.\n\n\n// Only used in www builds.\n\n\n// Only used in www builds.\n\n\n// React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function () {};\n\n{\n  validateFormat = function (format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error = void 0;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\n// Relying on the `invariant()` implementation lets us\n// preserve the format and params in the www builds.\n\n/**\n * Forked from fbjs/warning:\n * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js\n *\n * Only change is we use console.warn instead of console.error,\n * and do nothing when 'console' is not supported.\n * This really simplifies the code.\n * ---\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar lowPriorityWarning = function () {};\n\n{\n  var printWarning = function (format) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var argIndex = 0;\n    var message = 'Warning: ' + format.replace(/%s/g, function () {\n      return args[argIndex++];\n    });\n    if (typeof console !== 'undefined') {\n      console.warn(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n\n  lowPriorityWarning = function (condition, format) {\n    if (format === undefined) {\n      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (!condition) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n\n      printWarning.apply(undefined, [format].concat(args));\n    }\n  };\n}\n\nvar lowPriorityWarning$1 = lowPriorityWarning;\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warningWithoutStack = function () {};\n\n{\n  warningWithoutStack = function (condition, format) {\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    if (format === undefined) {\n      throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');\n    }\n    if (args.length > 8) {\n      // Check before the condition to catch violations early.\n      throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n    }\n    if (condition) {\n      return;\n    }\n    if (typeof console !== 'undefined') {\n      var _args$map = args.map(function (item) {\n        return '' + item;\n      }),\n          a = _args$map[0],\n          b = _args$map[1],\n          c = _args$map[2],\n          d = _args$map[3],\n          e = _args$map[4],\n          f = _args$map[5],\n          g = _args$map[6],\n          h = _args$map[7];\n\n      var message = 'Warning: ' + format;\n\n      // We intentionally don't use spread (or .apply) because it breaks IE9:\n      // https://github.com/facebook/react/issues/13610\n      switch (args.length) {\n        case 0:\n          console.error(message);\n          break;\n        case 1:\n          console.error(message, a);\n          break;\n        case 2:\n          console.error(message, a, b);\n          break;\n        case 3:\n          console.error(message, a, b, c);\n          break;\n        case 4:\n          console.error(message, a, b, c, d);\n          break;\n        case 5:\n          console.error(message, a, b, c, d, e);\n          break;\n        case 6:\n          console.error(message, a, b, c, d, e, f);\n          break;\n        case 7:\n          console.error(message, a, b, c, d, e, f, g);\n          break;\n        case 8:\n          console.error(message, a, b, c, d, e, f, g, h);\n          break;\n        default:\n          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');\n      }\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      var argIndex = 0;\n      var _message = 'Warning: ' + format.replace(/%s/g, function () {\n        return args[argIndex++];\n      });\n      throw new Error(_message);\n    } catch (x) {}\n  };\n}\n\nvar warningWithoutStack$1 = warningWithoutStack;\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + '.' + callerName;\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n    warningWithoutStack$1(false, \"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n\n/**\n * This is the abstract API for an update queue.\n */\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar emptyObject = {};\n{\n  Object.freeze(emptyObject);\n}\n\n/**\n * Base class helpers for the updating state of a component.\n */\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  // We initialize the default updater but the real one gets injected by the\n  // renderer.\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\nComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n        return undefined;\n      }\n    });\n  };\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\n\n/**\n * Convenience component with default shallow equality check for sCU.\n */\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  // If a component has string refs, we will assign a different object later.\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent;\n// Avoid an extra prototype jump for these methods.\n_assign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n  {\n    Object.seal(refObject);\n  }\n  return refObject;\n}\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null,\n  currentDispatcher: null\n};\n\nvar BEFORE_SLASH_RE = /^(.*)[\\\\\\/]/;\n\nvar describeComponentFrame = function (name, source, ownerName) {\n  var sourceInfo = '';\n  if (source) {\n    var path = source.fileName;\n    var fileName = path.replace(BEFORE_SLASH_RE, '');\n    {\n      // In DEV, include code for a common special case:\n      // prefer \"folder/index.js\" instead of just \"index.js\".\n      if (/^index\\./.test(fileName)) {\n        var match = path.match(BEFORE_SLASH_RE);\n        if (match) {\n          var pathBeforeSlash = match[1];\n          if (pathBeforeSlash) {\n            var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');\n            fileName = folderName + '/' + fileName;\n          }\n        }\n      }\n    }\n    sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';\n  } else if (ownerName) {\n    sourceInfo = ' (created by ' + ownerName + ')';\n  }\n  return '\\n    in ' + (name || 'Unknown') + sourceInfo;\n};\n\nvar Resolved = 1;\n\n\n\n\nfunction refineResolvedThenable(thenable) {\n  return thenable._reactStatus === Resolved ? thenable._reactResult : null;\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n  {\n    if (typeof type.tag === 'number') {\n      warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n  if (typeof type === 'string') {\n    return type;\n  }\n  switch (type) {\n    case REACT_ASYNC_MODE_TYPE:\n      return 'AsyncMode';\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n    case REACT_PLACEHOLDER_TYPE:\n      return 'Placeholder';\n  }\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return 'Context.Consumer';\n      case REACT_PROVIDER_TYPE:\n        return 'Context.Provider';\n      case REACT_FORWARD_REF_TYPE:\n        var renderFn = type.render;\n        var functionName = renderFn.displayName || renderFn.name || '';\n        return type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');\n    }\n    if (typeof type.then === 'function') {\n      var thenable = type;\n      var resolvedThenable = refineResolvedThenable(thenable);\n      if (resolvedThenable) {\n        return getComponentName(resolvedThenable);\n      }\n    }\n  }\n  return null;\n}\n\nvar ReactDebugCurrentFrame = {};\n\nvar currentlyValidatingElement = null;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    currentlyValidatingElement = element;\n  }\n}\n\n{\n  // Stack implementation injected by the current renderer.\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = '';\n\n    // Add an extra top frame while an element is being validated\n    if (currentlyValidatingElement) {\n      var name = getComponentName(currentlyValidatingElement.type);\n      var owner = currentlyValidatingElement._owner;\n      stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));\n    }\n\n    // Delegate to the injected renderer-specific implementation\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\nvar ReactSharedInternals = {\n  ReactCurrentOwner: ReactCurrentOwner,\n  // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n  assign: _assign\n};\n\n{\n  _assign(ReactSharedInternals, {\n    // These should not be included in production.\n    ReactDebugCurrentFrame: ReactDebugCurrentFrame,\n    // Shim for React DOM 16.0.0 which still destructured (but not used) this.\n    // TODO: remove in React 17.0.\n    ReactComponentTreeHook: {}\n  });\n}\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = warningWithoutStack$1;\n\n{\n  warning = function (condition, format) {\n    if (condition) {\n      return;\n    }\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n    // eslint-disable-next-line react-internal/warning-and-invariant-args\n\n    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));\n  };\n}\n\nvar warning$1 = warning;\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\n\nvar specialPropKeyWarningShown = void 0;\nvar specialPropRefWarningShown = void 0;\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    if (!specialPropKeyWarningShown) {\n      specialPropKeyWarningShown = true;\n      warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    if (!specialPropRefWarningShown) {\n      specialPropRefWarningShown = true;\n      warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);\n    }\n  };\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, no instanceof check\n * will work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} key\n * @param {string|object} ref\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @param {*} owner\n * @param {*} props\n * @internal\n */\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {};\n\n    // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    });\n    // self and source are DEV only properties.\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    });\n    // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\nfunction createElement(type, config, children) {\n  var propName = void 0;\n\n  // Reserved names are extracted\n  var props = {};\n\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source;\n    // Remaining properties are added to a new props object\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n    props.children = childArray;\n  }\n\n  // Resolve default props\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\n\n/**\n * Return a function that produces ReactElements of a given type.\n * See https://reactjs.org/docs/react-api.html#createfactory\n */\n\n\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\n  return newElement;\n}\n\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\nfunction cloneElement(element, config, children) {\n  !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;\n\n  var propName = void 0;\n\n  // Original props are copied\n  var props = _assign({}, element.props);\n\n  // Reserved names are extracted\n  var key = element.key;\n  var ref = element.ref;\n  // Self is preserved since the owner is preserved.\n  var self = element._self;\n  // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n  var source = element._source;\n\n  // Owner will be preserved, unless ref is overridden\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    // Remaining properties override existing props\n    var defaultProps = void 0;\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  }\n\n  // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n  var childrenLength = arguments.length - 2;\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar didWarnAboutMaps = false;\n\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');\n}\n\nvar POOL_SIZE = 10;\nvar traverseContextPool = [];\nfunction getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {\n  if (traverseContextPool.length) {\n    var traverseContext = traverseContextPool.pop();\n    traverseContext.result = mapResult;\n    traverseContext.keyPrefix = keyPrefix;\n    traverseContext.func = mapFunction;\n    traverseContext.context = mapContext;\n    traverseContext.count = 0;\n    return traverseContext;\n  } else {\n    return {\n      result: mapResult,\n      keyPrefix: keyPrefix,\n      func: mapFunction,\n      context: mapContext,\n      count: 0\n    };\n  }\n}\n\nfunction releaseTraverseContext(traverseContext) {\n  traverseContext.result = null;\n  traverseContext.keyPrefix = null;\n  traverseContext.func = null;\n  traverseContext.context = null;\n  traverseContext.count = 0;\n  if (traverseContextPool.length < POOL_SIZE) {\n    traverseContextPool.push(traverseContext);\n  }\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n    }\n  }\n\n  if (invokeCallback) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child = void 0;\n  var nextName = void 0;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (typeof iteratorFn === 'function') {\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === children.entries) {\n          !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(children);\n      var step = void 0;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = '';\n      {\n        addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();\n      }\n      var childrenString = '' + children;\n      invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', callback, traverseContext);\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof component === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\nfunction forEachSingleChild(bookKeeping, child, name) {\n  var func = bookKeeping.func,\n      context = bookKeeping.context;\n\n  func.call(context, child, bookKeeping.count++);\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  if (children == null) {\n    return children;\n  }\n  var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);\n  traverseAllChildren(children, forEachSingleChild, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\nfunction mapSingleChildIntoContext(bookKeeping, child, childKey) {\n  var result = bookKeeping.result,\n      keyPrefix = bookKeeping.keyPrefix,\n      func = bookKeeping.func,\n      context = bookKeeping.context;\n\n\n  var mappedChild = func.call(context, child, bookKeeping.count++);\n  if (Array.isArray(mappedChild)) {\n    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {\n      return c;\n    });\n  } else if (mappedChild != null) {\n    if (isValidElement(mappedChild)) {\n      mappedChild = cloneAndReplaceKey(mappedChild,\n      // Keep both the (mapped) and old keys if they differ, just as\n      // traverseAllChildren used to do for objects as children\n      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);\n    }\n    result.push(mappedChild);\n  }\n}\n\nfunction mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {\n  var escapedPrefix = '';\n  if (prefix != null) {\n    escapedPrefix = escapeUserProvidedKey(prefix) + '/';\n  }\n  var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);\n  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);\n  releaseTraverseContext(traverseContext);\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, key, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, func, context);\n  return result;\n}\n\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\nfunction countChildren(children) {\n  return traverseAllChildren(children, function () {\n    return null;\n  }, null);\n}\n\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\nfunction toArray(children) {\n  var result = [];\n  mapIntoWithKeyPrefixInternal(children, result, null, function (child) {\n    return child;\n  });\n  return result;\n}\n\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\nfunction onlyChild(children) {\n  !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;\n  return children;\n}\n\nfunction readContext(context, observedBits) {\n  var dispatcher = ReactCurrentOwner.currentDispatcher;\n  !(dispatcher !== null) ? invariant(false, 'Context.unstable_read(): Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps.') : void 0;\n  return dispatcher.readContext(context, observedBits);\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // These are circular\n    Provider: null,\n    Consumer: null,\n    unstable_read: null\n  };\n\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  context.Consumer = context;\n  context.unstable_read = readContext.bind(null, context);\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nfunction lazy(ctor) {\n  var thenable = null;\n  return {\n    then: function (resolve, reject) {\n      if (thenable === null) {\n        // Lazily create thenable by wrapping in an extra thenable.\n        thenable = ctor();\n        ctor = null;\n      }\n      return thenable.then(resolve, reject);\n    },\n\n    // React uses these fields to store the result.\n    _reactStatus: -1,\n    _reactResult: null\n  };\n}\n\nfunction forwardRef(render) {\n  {\n    if (typeof render !== 'function') {\n      warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      !(\n      // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object\n      render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;\n    }\n\n    if (render != null) {\n      !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;\n    }\n  }\n\n  return {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n}\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' ||\n  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_ASYNC_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_PLACEHOLDER_TYPE || typeof type === 'object' && type !== null && (typeof type.then === 'function' || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);\n}\n\n/**\n * ReactElementValidator provides a wrapper around a element factory\n * which validates the props passed to the element. This is intended to be\n * used only in DEV and could be replaced by a static type checker for languages\n * that support it.\n */\n\nvar propTypesMisspellWarningShown = void 0;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current.type);\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(elementProps) {\n  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {\n    var source = elementProps.__source;\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n  return '';\n}\n\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n    if (parentName) {\n      info = '\\n\\nCheck the top-level render call using <' + parentName + '>.';\n    }\n  }\n  return info;\n}\n\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n  element._store.validated = true;\n\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n\n  // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n  var childOwner = '';\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.';\n  }\n\n  setCurrentlyValidatingElement(element);\n  {\n    warning$1(false, 'Each child in an array or iterator should have a unique \"key\" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);\n  }\n  setCurrentlyValidatingElement(null);\n}\n\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step = void 0;\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\nfunction validatePropTypes(element) {\n  var type = element.type;\n  var name = void 0,\n      propTypes = void 0;\n  if (typeof type === 'function') {\n    // Class or functional component\n    name = type.displayName || type.name;\n    propTypes = type.propTypes;\n  } else if (typeof type === 'object' && type !== null && type.$$typeof === REACT_FORWARD_REF_TYPE) {\n    // ForwardRef\n    var functionName = type.render.displayName || type.render.name || '';\n    name = type.displayName || (functionName !== '' ? 'ForwardRef(' + functionName + ')' : 'ForwardRef');\n    propTypes = type.propTypes;\n  } else {\n    return;\n  }\n  if (propTypes) {\n    setCurrentlyValidatingElement(element);\n    checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);\n    setCurrentlyValidatingElement(null);\n  } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n    propTypesMisspellWarningShown = true;\n    warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');\n  }\n  if (typeof type.getDefaultProps === 'function') {\n    !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;\n  }\n}\n\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\nfunction validateFragmentProps(fragment) {\n  setCurrentlyValidatingElement(fragment);\n\n  var keys = Object.keys(fragment.props);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== 'children' && key !== 'key') {\n      warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n      break;\n    }\n  }\n\n  if (fragment.ref !== null) {\n    warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');\n  }\n\n  setCurrentlyValidatingElement(null);\n}\n\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type);\n\n  // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n  if (!validType) {\n    var info = '';\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendum(props);\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString = void 0;\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />';\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n  }\n\n  var element = createElement.apply(this, arguments);\n\n  // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n  if (element == null) {\n    return element;\n  }\n\n  // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === REACT_FRAGMENT_TYPE) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\n\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n  // Legacy hook: remove it\n  {\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\n\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n  validatePropTypes(newElement);\n  return newElement;\n}\n\nvar React = {\n  Children: {\n    map: mapChildren,\n    forEach: forEachChildren,\n    count: countChildren,\n    toArray: toArray,\n    only: onlyChild\n  },\n\n  createRef: createRef,\n  Component: Component,\n  PureComponent: PureComponent,\n\n  createContext: createContext,\n  forwardRef: forwardRef,\n\n  Fragment: REACT_FRAGMENT_TYPE,\n  StrictMode: REACT_STRICT_MODE_TYPE,\n  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,\n  unstable_Profiler: REACT_PROFILER_TYPE,\n\n  createElement: createElementWithValidation,\n  cloneElement: cloneElementWithValidation,\n  createFactory: createFactoryWithValidation,\n  isValidElement: isValidElement,\n\n  version: ReactVersion,\n\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals\n};\n\nif (enableSuspense) {\n  React.Placeholder = REACT_PLACEHOLDER_TYPE;\n  React.lazy = lazy;\n}\n\n\n\nvar React$2 = Object.freeze({\n\tdefault: React\n});\n\nvar React$3 = ( React$2 && React ) || React$2;\n\n// TODO: decide on the top-level export form.\n// This is hacky but makes it work with both Rollup and Jest.\nvar react = React$3.default || React$3;\n\nmodule.exports = react;\n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","function isAbsolute(pathname) {\n  return pathname.charAt(0) === '/';\n}\n\n// About 1.5x faster than the two-arg version of Array#splice()\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {\n    list[i] = list[k];\n  }\n\n  list.pop();\n}\n\n// This implementation is based heavily on node's url.parse\nfunction resolvePathname(to) {\n  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  var toParts = to && to.split('/') || [];\n  var fromParts = from && from.split('/') || [];\n\n  var isToAbs = to && isAbsolute(to);\n  var isFromAbs = from && isAbsolute(from);\n  var mustEndAbs = isToAbs || isFromAbs;\n\n  if (to && isAbsolute(to)) {\n    // to is absolute\n    fromParts = toParts;\n  } else if (toParts.length) {\n    // to is relative, drop the filename\n    fromParts.pop();\n    fromParts = fromParts.concat(toParts);\n  }\n\n  if (!fromParts.length) return '/';\n\n  var hasTrailingSlash = void 0;\n  if (fromParts.length) {\n    var last = fromParts[fromParts.length - 1];\n    hasTrailingSlash = last === '.' || last === '..' || last === '';\n  } else {\n    hasTrailingSlash = false;\n  }\n\n  var up = 0;\n  for (var i = fromParts.length; i >= 0; i--) {\n    var part = fromParts[i];\n\n    if (part === '.') {\n      spliceOne(fromParts, i);\n    } else if (part === '..') {\n      spliceOne(fromParts, i);\n      up++;\n    } else if (up) {\n      spliceOne(fromParts, i);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs) for (; up--; up) {\n    fromParts.unshift('..');\n  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');\n\n  var result = fromParts.join('/');\n\n  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';\n\n  return result;\n}\n\nexport default resolvePathname;","/** @license React v16.5.2\n * schedule-tracing.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n// Exports ReactDOM.createRoot\n\n\n// Experimental error-boundary API that can recover from errors within a single\n// render phase\n\n// Suspense\n\n// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:\n\n\n// In some cases, StrictMode should also double-render lifecycles.\n// This can be confusing for tests though,\n// And it can be bad for performance in production.\n// This feature flag can be used to control the behavior:\n\n\n// To preserve the \"Pause on caught exceptions\" behavior of the debugger, we\n// replay the begin phase of a failed component inside invokeGuardedCallback.\n\n\n// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:\n\n\n// Warn about legacy context API\n\n\n// Gather advanced timing metrics for Profiler subtrees.\n\n\n// Trace which interactions trigger each commit.\nvar enableSchedulerTracing = true;\n\n// Only used in www builds.\n\n\n// Only used in www builds.\n\n\n// React Fire: prevent the value and checked attributes from syncing\n// with their related DOM properties\n\nvar DEFAULT_THREAD_ID = 0;\n\n// Counters used to generate unique IDs.\nvar interactionIDCounter = 0;\nvar threadIDCounter = 0;\n\n// Set of currently traced interactions.\n// Interactions \"stack\"\n// Meaning that newly traced interactions are appended to the previously active set.\n// When an interaction goes out of scope, the previous set (if any) is restored.\nexports.__interactionsRef = null;\n\n// Listener(s) to notify when interactions begin and end.\nexports.__subscriberRef = null;\n\nif (enableSchedulerTracing) {\n  exports.__interactionsRef = {\n    current: new Set()\n  };\n  exports.__subscriberRef = {\n    current: null\n  };\n}\n\nfunction unstable_clear(callback) {\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  var prevInteractions = exports.__interactionsRef.current;\n  exports.__interactionsRef.current = new Set();\n\n  try {\n    return callback();\n  } finally {\n    exports.__interactionsRef.current = prevInteractions;\n  }\n}\n\nfunction unstable_getCurrent() {\n  if (!enableSchedulerTracing) {\n    return null;\n  } else {\n    return exports.__interactionsRef.current;\n  }\n}\n\nfunction unstable_getThreadID() {\n  return ++threadIDCounter;\n}\n\nfunction unstable_trace(name, timestamp, callback) {\n  var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracing) {\n    return callback();\n  }\n\n  var interaction = {\n    __count: 1,\n    id: interactionIDCounter++,\n    name: name,\n    timestamp: timestamp\n  };\n\n  var prevInteractions = exports.__interactionsRef.current;\n\n  // Traced interactions should stack/accumulate.\n  // To do that, clone the current interactions.\n  // The previous set will be restored upon completion.\n  var interactions = new Set(prevInteractions);\n  interactions.add(interaction);\n  exports.__interactionsRef.current = interactions;\n\n  var subscriber = exports.__subscriberRef.current;\n  var returnValue = void 0;\n\n  try {\n    if (subscriber !== null) {\n      subscriber.onInteractionTraced(interaction);\n    }\n  } finally {\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkStarted(interactions, threadID);\n      }\n    } finally {\n      try {\n        returnValue = callback();\n      } finally {\n        exports.__interactionsRef.current = prevInteractions;\n\n        try {\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(interactions, threadID);\n          }\n        } finally {\n          interaction.__count--;\n\n          // If no async work was scheduled for this interaction,\n          // Notify subscribers that it's completed.\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        }\n      }\n    }\n  }\n\n  return returnValue;\n}\n\nfunction unstable_wrap(callback) {\n  var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;\n\n  if (!enableSchedulerTracing) {\n    return callback;\n  }\n\n  var wrappedInteractions = exports.__interactionsRef.current;\n\n  var subscriber = exports.__subscriberRef.current;\n  if (subscriber !== null) {\n    subscriber.onWorkScheduled(wrappedInteractions, threadID);\n  }\n\n  // Update the pending async work count for the current interactions.\n  // Update after calling subscribers in case of error.\n  wrappedInteractions.forEach(function (interaction) {\n    interaction.__count++;\n  });\n\n  var hasRun = false;\n\n  function wrapped() {\n    var prevInteractions = exports.__interactionsRef.current;\n    exports.__interactionsRef.current = wrappedInteractions;\n\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      var returnValue = void 0;\n\n      try {\n        if (subscriber !== null) {\n          subscriber.onWorkStarted(wrappedInteractions, threadID);\n        }\n      } finally {\n        try {\n          returnValue = callback.apply(undefined, arguments);\n        } finally {\n          exports.__interactionsRef.current = prevInteractions;\n\n          if (subscriber !== null) {\n            subscriber.onWorkStopped(wrappedInteractions, threadID);\n          }\n        }\n      }\n\n      return returnValue;\n    } finally {\n      if (!hasRun) {\n        // We only expect a wrapped function to be executed once,\n        // But in the event that it's executed more than once\n        // Only decrement the outstanding interaction counts once.\n        hasRun = true;\n\n        // Update pending async counts for all wrapped interactions.\n        // If this was the last scheduled async work for any of them,\n        // Mark them as completed.\n        wrappedInteractions.forEach(function (interaction) {\n          interaction.__count--;\n\n          if (subscriber !== null && interaction.__count === 0) {\n            subscriber.onInteractionScheduledWorkCompleted(interaction);\n          }\n        });\n      }\n    }\n  }\n\n  wrapped.cancel = function cancel() {\n    subscriber = exports.__subscriberRef.current;\n\n    try {\n      if (subscriber !== null) {\n        subscriber.onWorkCanceled(wrappedInteractions, threadID);\n      }\n    } finally {\n      // Update pending async counts for all wrapped interactions.\n      // If this was the last scheduled async work for any of them,\n      // Mark them as completed.\n      wrappedInteractions.forEach(function (interaction) {\n        interaction.__count--;\n\n        if (subscriber && interaction.__count === 0) {\n          subscriber.onInteractionScheduledWorkCompleted(interaction);\n        }\n      });\n    }\n  };\n\n  return wrapped;\n}\n\nvar subscribers = null;\nif (enableSchedulerTracing) {\n  subscribers = new Set();\n}\n\nfunction unstable_subscribe(subscriber) {\n  if (enableSchedulerTracing) {\n    subscribers.add(subscriber);\n\n    if (subscribers.size === 1) {\n      exports.__subscriberRef.current = {\n        onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,\n        onInteractionTraced: onInteractionTraced,\n        onWorkCanceled: onWorkCanceled,\n        onWorkScheduled: onWorkScheduled,\n        onWorkStarted: onWorkStarted,\n        onWorkStopped: onWorkStopped\n      };\n    }\n  }\n}\n\nfunction unstable_unsubscribe(subscriber) {\n  if (enableSchedulerTracing) {\n    subscribers.delete(subscriber);\n\n    if (subscribers.size === 0) {\n      exports.__subscriberRef.current = null;\n    }\n  }\n}\n\nfunction onInteractionTraced(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionTraced(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onInteractionScheduledWorkCompleted(interaction) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onInteractionScheduledWorkCompleted(interaction);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkScheduled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkScheduled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStarted(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStarted(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkStopped(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkStopped(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nfunction onWorkCanceled(interactions, threadID) {\n  var didCatchError = false;\n  var caughtError = null;\n\n  subscribers.forEach(function (subscriber) {\n    try {\n      subscriber.onWorkCanceled(interactions, threadID);\n    } catch (error) {\n      if (!didCatchError) {\n        didCatchError = true;\n        caughtError = error;\n      }\n    }\n  });\n\n  if (didCatchError) {\n    throw caughtError;\n  }\n}\n\nexports.unstable_clear = unstable_clear;\nexports.unstable_getCurrent = unstable_getCurrent;\nexports.unstable_getThreadID = unstable_getThreadID;\nexports.unstable_trace = unstable_trace;\nexports.unstable_wrap = unstable_wrap;\nexports.unstable_subscribe = unstable_subscribe;\nexports.unstable_unsubscribe = unstable_unsubscribe;\n  })();\n}\n","/** @license React v16.5.2\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable no-var */\n\n// TODO: Currently there's only a single priority level, Deferred. Will add\n// additional priorities.\nvar DEFERRED_TIMEOUT = 5000;\n\n// Callbacks are stored as a circular, doubly linked list.\nvar firstCallbackNode = null;\n\nvar isPerformingWork = false;\n\nvar isHostCallbackScheduled = false;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nvar timeRemaining;\nif (hasNativePerformanceNow) {\n  timeRemaining = function () {\n    // We assume that if we have a performance timer that the rAF callback\n    // gets a performance timer value. Not sure if this is always true.\n    var remaining = getFrameDeadline() - performance.now();\n    return remaining > 0 ? remaining : 0;\n  };\n} else {\n  timeRemaining = function () {\n    // Fallback to Date.now()\n    var remaining = getFrameDeadline() - Date.now();\n    return remaining > 0 ? remaining : 0;\n  };\n}\n\nvar deadlineObject = {\n  timeRemaining: timeRemaining,\n  didTimeout: false\n};\n\nfunction ensureHostCallbackIsScheduled() {\n  if (isPerformingWork) {\n    // Don't schedule work yet; wait until the next time we yield.\n    return;\n  }\n  // Schedule the host callback using the earliest timeout in the list.\n  var timesOutAt = firstCallbackNode.timesOutAt;\n  if (!isHostCallbackScheduled) {\n    isHostCallbackScheduled = true;\n  } else {\n    // Cancel the existing host callback.\n    cancelCallback();\n  }\n  requestCallback(flushWork, timesOutAt);\n}\n\nfunction flushFirstCallback(node) {\n  var flushedNode = firstCallbackNode;\n\n  // Remove the node from the list before calling the callback. That way the\n  // list is in a consistent state even if the callback throws.\n  var next = firstCallbackNode.next;\n  if (firstCallbackNode === next) {\n    // This is the last callback in the list.\n    firstCallbackNode = null;\n    next = null;\n  } else {\n    var previous = firstCallbackNode.previous;\n    firstCallbackNode = previous.next = next;\n    next.previous = previous;\n  }\n\n  flushedNode.next = flushedNode.previous = null;\n\n  // Now it's safe to call the callback.\n  var callback = flushedNode.callback;\n  callback(deadlineObject);\n}\n\nfunction flushWork(didTimeout) {\n  isPerformingWork = true;\n  deadlineObject.didTimeout = didTimeout;\n  try {\n    if (didTimeout) {\n      // Flush all the timed out callbacks without yielding.\n      while (firstCallbackNode !== null) {\n        // Read the current time. Flush all the callbacks that expire at or\n        // earlier than that time. Then read the current time again and repeat.\n        // This optimizes for as few performance.now calls as possible.\n        var currentTime = exports.unstable_now();\n        if (firstCallbackNode.timesOutAt <= currentTime) {\n          do {\n            flushFirstCallback();\n          } while (firstCallbackNode !== null && firstCallbackNode.timesOutAt <= currentTime);\n          continue;\n        }\n        break;\n      }\n    } else {\n      // Keep flushing callbacks until we run out of time in the frame.\n      if (firstCallbackNode !== null) {\n        do {\n          flushFirstCallback();\n        } while (firstCallbackNode !== null && getFrameDeadline() - exports.unstable_now() > 0);\n      }\n    }\n  } finally {\n    isPerformingWork = false;\n    if (firstCallbackNode !== null) {\n      // There's still work remaining. Request another callback.\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    } else {\n      isHostCallbackScheduled = false;\n    }\n  }\n}\n\nfunction unstable_scheduleWork(callback, options) {\n  var currentTime = exports.unstable_now();\n\n  var timesOutAt;\n  if (options !== undefined && options !== null && options.timeout !== null && options.timeout !== undefined) {\n    // Check for an explicit timeout\n    timesOutAt = currentTime + options.timeout;\n  } else {\n    // Compute an absolute timeout using the default constant.\n    timesOutAt = currentTime + DEFERRED_TIMEOUT;\n  }\n\n  var newNode = {\n    callback: callback,\n    timesOutAt: timesOutAt,\n    next: null,\n    previous: null\n  };\n\n  // Insert the new callback into the list, sorted by its timeout.\n  if (firstCallbackNode === null) {\n    // This is the first callback in the list.\n    firstCallbackNode = newNode.next = newNode.previous = newNode;\n    ensureHostCallbackIsScheduled(firstCallbackNode);\n  } else {\n    var next = null;\n    var node = firstCallbackNode;\n    do {\n      if (node.timesOutAt > timesOutAt) {\n        // The new callback times out before this one.\n        next = node;\n        break;\n      }\n      node = node.next;\n    } while (node !== firstCallbackNode);\n\n    if (next === null) {\n      // No callback with a later timeout was found, which means the new\n      // callback has the latest timeout in the list.\n      next = firstCallbackNode;\n    } else if (next === firstCallbackNode) {\n      // The new callback has the earliest timeout in the entire list.\n      firstCallbackNode = newNode;\n      ensureHostCallbackIsScheduled(firstCallbackNode);\n    }\n\n    var previous = next.previous;\n    previous.next = next.previous = newNode;\n    newNode.next = next;\n    newNode.previous = previous;\n  }\n\n  return newNode;\n}\n\nfunction unstable_cancelScheduledWork(callbackNode) {\n  var next = callbackNode.next;\n  if (next === null) {\n    // Already cancelled.\n    return;\n  }\n\n  if (next === callbackNode) {\n    // This is the only scheduled callback. Clear the list.\n    firstCallbackNode = null;\n  } else {\n    // Remove the callback from its position in the list.\n    if (callbackNode === firstCallbackNode) {\n      firstCallbackNode = next;\n    }\n    var previous = callbackNode.previous;\n    previous.next = next;\n    next.previous = previous;\n  }\n\n  callbackNode.next = callbackNode.previous = null;\n}\n\n// The remaining code is essentially a polyfill for requestIdleCallback. It\n// works by scheduling a requestAnimationFrame, storing the time for the start\n// of the frame, then scheduling a postMessage which gets scheduled after paint.\n// Within the postMessage handler do as much work as possible until time + frame\n// rate. By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated. We want to be using a\n// consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments if a component\n// just imports ReactDOM (e.g. for findDOMNode). Some environments might not\n// have setTimeout or clearTimeout. However, we always expect them to be defined\n// on the client. https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined, but we will error\n// later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\n// requestAnimationFrame does not run when the tab is in the background. If\n// we're backgrounded we prefer for that work to happen so that the page\n// continues to load in the background. So we also schedule a 'setTimeout' as\n// a fallback.\n// TODO: Need a better heuristic for backgrounded work.\nvar ANIMATION_FRAME_TIMEOUT = 100;\nvar rAFID;\nvar rAFTimeoutID;\nvar requestAnimationFrameWithTimeout = function (callback) {\n  // schedule rAF and also a setTimeout\n  rAFID = localRequestAnimationFrame(function (timestamp) {\n    // cancel the setTimeout\n    localClearTimeout(rAFTimeoutID);\n    callback(timestamp);\n  });\n  rAFTimeoutID = localSetTimeout(function () {\n    // cancel the requestAnimationFrame\n    localCancelAnimationFrame(rAFID);\n    callback(exports.unstable_now());\n  }, ANIMATION_FRAME_TIMEOUT);\n};\n\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nvar requestCallback;\nvar cancelCallback;\nvar getFrameDeadline;\n\nif (typeof window === 'undefined') {\n  // If this accidentally gets imported in a non-browser environment, fallback\n  // to a naive implementation.\n  var timeoutID = -1;\n  requestCallback = function (callback, absoluteTimeout) {\n    timeoutID = setTimeout(callback, 0, true);\n  };\n  cancelCallback = function () {\n    clearTimeout(timeoutID);\n  };\n  getFrameDeadline = function () {\n    return 0;\n  };\n} else if (window._schedMock) {\n  // Dynamic injection, only for testing purposes.\n  var impl = window._schedMock;\n  requestCallback = impl[0];\n  cancelCallback = impl[1];\n  getFrameDeadline = impl[2];\n} else {\n  if (typeof console !== 'undefined') {\n    if (typeof localRequestAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n    if (typeof localCancelAnimationFrame !== 'function') {\n      console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n    }\n  }\n\n  var scheduledCallback = null;\n  var isIdleScheduled = false;\n  var timeoutTime = -1;\n\n  var isAnimationFrameScheduled = false;\n\n  var isPerformingIdleWork = false;\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  getFrameDeadline = function () {\n    return frameDeadline;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n\n    isIdleScheduled = false;\n\n    var currentTime = exports.unstable_now();\n\n    var didTimeout = false;\n    if (frameDeadline - currentTime <= 0) {\n      // There's no time left in this idle period. Check if the callback has\n      // a timeout and whether it's been exceeded.\n      if (timeoutTime !== -1 && timeoutTime <= currentTime) {\n        // Exceeded the timeout. Invoke the callback even though there's no\n        // time left.\n        didTimeout = true;\n      } else {\n        // No timeout.\n        if (!isAnimationFrameScheduled) {\n          // Schedule another animation callback so we retry later.\n          isAnimationFrameScheduled = true;\n          requestAnimationFrameWithTimeout(animationTick);\n        }\n        // Exit without invoking the callback.\n        return;\n      }\n    }\n\n    timeoutTime = -1;\n    var callback = scheduledCallback;\n    scheduledCallback = null;\n    if (callback !== null) {\n      isPerformingIdleWork = true;\n      try {\n        callback(didTimeout);\n      } finally {\n        isPerformingIdleWork = false;\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  requestCallback = function (callback, absoluteTimeout) {\n    scheduledCallback = callback;\n    timeoutTime = absoluteTimeout;\n    if (isPerformingIdleWork) {\n      // If we're already performing idle work, an error must have been thrown.\n      // Don't wait for the next frame. Continue working ASAP, in a new event.\n      window.postMessage(messageKey, '*');\n    } else if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger rIC as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      requestAnimationFrameWithTimeout(animationTick);\n    }\n  };\n\n  cancelCallback = function () {\n    scheduledCallback = null;\n    isIdleScheduled = false;\n    timeoutTime = -1;\n  };\n}\n\nexports.unstable_scheduleWork = unstable_scheduleWork;\nexports.unstable_cancelScheduledWork = unstable_cancelScheduledWork;\n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/schedule.production.min.js');\n} else {\n  module.exports = require('./cjs/schedule.development.js');\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/schedule-tracing.production.min.js');\n} else {\n  module.exports = require('./cjs/schedule-tracing.development.js');\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tvar styleTarget = fn.call(this, selector);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[selector] = styleTarget;\n\t\t}\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","export {default as bbox} from \"./src/bbox\";\nexport {default as feature} from \"./src/feature\";\nexport {default as mesh, meshArcs} from \"./src/mesh\";\nexport {default as merge, mergeArcs} from \"./src/merge\";\nexport {default as neighbors} from \"./src/neighbors\";\nexport {default as quantize} from \"./src/quantize\";\nexport {default as transform} from \"./src/transform\";\nexport {default as untransform} from \"./src/untransform\";\n","import transform from \"./transform\";\n\nexport default function(topology) {\n  var t = transform(topology.transform), key,\n      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;\n\n  function bboxPoint(p) {\n    p = t(p);\n    if (p[0] < x0) x0 = p[0];\n    if (p[0] > x1) x1 = p[0];\n    if (p[1] < y0) y0 = p[1];\n    if (p[1] > y1) y1 = p[1];\n  }\n\n  function bboxGeometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(bboxGeometry); break;\n      case \"Point\": bboxPoint(o.coordinates); break;\n      case \"MultiPoint\": o.coordinates.forEach(bboxPoint); break;\n    }\n  }\n\n  topology.arcs.forEach(function(arc) {\n    var i = -1, n = arc.length, p;\n    while (++i < n) {\n      p = t(arc[i], i);\n      if (p[0] < x0) x0 = p[0];\n      if (p[0] > x1) x1 = p[0];\n      if (p[1] < y0) y0 = p[1];\n      if (p[1] > y1) y1 = p[1];\n    }\n  });\n\n  for (key in topology.objects) {\n    bboxGeometry(topology.objects[key]);\n  }\n\n  return [x0, y0, x1, y1];\n}\n","export default function(a, x) {\n  var lo = 0, hi = a.length;\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (a[mid] < x) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n","import reverse from \"./reverse\";\nimport transform from \"./transform\";\n\nexport default function(topology, o) {\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nexport function feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","export default function(x) {\n  return x;\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nfunction planarRingArea(ring) {\n  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;\n  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];\n  return Math.abs(area); // Note: doubled area!\n}\n\nexport default function(topology) {\n  return object(topology, mergeArcs.apply(this, arguments));\n}\n\nexport function mergeArcs(topology, objects) {\n  var polygonsByArc = {},\n      polygons = [],\n      groups = [];\n\n  objects.forEach(geometry);\n\n  function geometry(o) {\n    switch (o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"Polygon\": extract(o.arcs); break;\n      case \"MultiPolygon\": o.arcs.forEach(extract); break;\n    }\n  }\n\n  function extract(polygon) {\n    polygon.forEach(function(ring) {\n      ring.forEach(function(arc) {\n        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);\n      });\n    });\n    polygons.push(polygon);\n  }\n\n  function area(ring) {\n    return planarRingArea(object(topology, {type: \"Polygon\", arcs: [ring]}).coordinates[0]);\n  }\n\n  polygons.forEach(function(polygon) {\n    if (!polygon._) {\n      var group = [],\n          neighbors = [polygon];\n      polygon._ = 1;\n      groups.push(group);\n      while (polygon = neighbors.pop()) {\n        group.push(polygon);\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {\n              if (!polygon._) {\n                polygon._ = 1;\n                neighbors.push(polygon);\n              }\n            });\n          });\n        });\n      }\n    }\n  });\n\n  polygons.forEach(function(polygon) {\n    delete polygon._;\n  });\n\n  return {\n    type: \"MultiPolygon\",\n    arcs: groups.map(function(polygons) {\n      var arcs = [], n;\n\n      // Extract the exterior (unique) arcs.\n      polygons.forEach(function(polygon) {\n        polygon.forEach(function(ring) {\n          ring.forEach(function(arc) {\n            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {\n              arcs.push(arc);\n            }\n          });\n        });\n      });\n\n      // Stitch the arcs into one or more rings.\n      arcs = stitch(topology, arcs);\n\n      // If more than one ring is returned,\n      // at most one of these rings can be the exterior;\n      // choose the one with the greatest absolute area.\n      if ((n = arcs.length) > 1) {\n        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {\n          if ((ki = area(arcs[i])) > k) {\n            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;\n          }\n        }\n      }\n\n      return arcs;\n    })\n  };\n}\n","import {object} from \"./feature\";\nimport stitch from \"./stitch\";\n\nexport default function(topology) {\n  return object(topology, meshArcs.apply(this, arguments));\n}\n\nexport function meshArcs(topology, object, filter) {\n  var arcs, i, n;\n  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);\n  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;\n  return {type: \"MultiLineString\", arcs: stitch(topology, arcs)};\n}\n\nfunction extractArcs(topology, object, filter) {\n  var arcs = [],\n      geomsByArc = [],\n      geom;\n\n  function extract0(i) {\n    var j = i < 0 ? ~i : i;\n    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});\n  }\n\n  function extract1(arcs) {\n    arcs.forEach(extract0);\n  }\n\n  function extract2(arcs) {\n    arcs.forEach(extract1);\n  }\n\n  function extract3(arcs) {\n    arcs.forEach(extract2);\n  }\n\n  function geometry(o) {\n    switch (geom = o, o.type) {\n      case \"GeometryCollection\": o.geometries.forEach(geometry); break;\n      case \"LineString\": extract1(o.arcs); break;\n      case \"MultiLineString\": case \"Polygon\": extract2(o.arcs); break;\n      case \"MultiPolygon\": extract3(o.arcs); break;\n    }\n  }\n\n  geometry(object);\n\n  geomsByArc.forEach(filter == null\n      ? function(geoms) { arcs.push(geoms[0].i); }\n      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });\n\n  return arcs;\n}\n","import bisect from \"./bisect\";\n\nexport default function(objects) {\n  var indexesByArc = {}, // arc index -> array of object indexes\n      neighbors = objects.map(function() { return []; });\n\n  function line(arcs, i) {\n    arcs.forEach(function(a) {\n      if (a < 0) a = ~a;\n      var o = indexesByArc[a];\n      if (o) o.push(i);\n      else indexesByArc[a] = [i];\n    });\n  }\n\n  function polygon(arcs, i) {\n    arcs.forEach(function(arc) { line(arc, i); });\n  }\n\n  function geometry(o, i) {\n    if (o.type === \"GeometryCollection\") o.geometries.forEach(function(o) { geometry(o, i); });\n    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);\n  }\n\n  var geometryType = {\n    LineString: line,\n    MultiLineString: polygon,\n    Polygon: polygon,\n    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }\n  };\n\n  objects.forEach(geometry);\n\n  for (var i in indexesByArc) {\n    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {\n      for (var k = j + 1; k < m; ++k) {\n        var ij = indexes[j], ik = indexes[k], n;\n        if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);\n        if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);\n      }\n    }\n  }\n\n  return neighbors;\n}\n","import bbox from \"./bbox\";\nimport untransform from \"./untransform\";\n\nexport default function(topology, transform) {\n  if (topology.transform) throw new Error(\"already quantized\");\n\n  if (!transform || !transform.scale) {\n    if (!((n = Math.floor(transform)) >= 2)) throw new Error(\"n must be 2\");\n    box = topology.bbox || bbox(topology);\n    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;\n    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};\n  } else {\n    box = topology.bbox;\n  }\n\n  var t = untransform(transform), box, key, inputs = topology.objects, outputs = {};\n\n  function quantizePoint(point) {\n    return t(point);\n  }\n\n  function quantizeGeometry(input) {\n    var output;\n    switch (input.type) {\n      case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(quantizeGeometry)}; break;\n      case \"Point\": output = {type: \"Point\", coordinates: quantizePoint(input.coordinates)}; break;\n      case \"MultiPoint\": output = {type: \"MultiPoint\", coordinates: input.coordinates.map(quantizePoint)}; break;\n      default: return input;\n    }\n    if (input.id != null) output.id = input.id;\n    if (input.bbox != null) output.bbox = input.bbox;\n    if (input.properties != null) output.properties = input.properties;\n    return output;\n  }\n\n  function quantizeArc(input) {\n    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic\n    output[0] = t(input[0], 0);\n    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points\n    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points\n    output.length = j;\n    return output;\n  }\n\n  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);\n\n  return {\n    type: \"Topology\",\n    bbox: box,\n    transform: transform,\n    objects: outputs,\n    arcs: topology.arcs.map(quantizeArc)\n  };\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","export default function(topology, arcs) {\n  var stitchedArcs = {},\n      fragmentByStart = {},\n      fragmentByEnd = {},\n      fragments = [],\n      emptyIndex = -1;\n\n  // Stitch empty arcs first, since they may be subsumed by other arcs.\n  arcs.forEach(function(i, j) {\n    var arc = topology.arcs[i < 0 ? ~i : i], t;\n    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {\n      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;\n    }\n  });\n\n  arcs.forEach(function(i) {\n    var e = ends(i),\n        start = e[0],\n        end = e[1],\n        f, g;\n\n    if (f = fragmentByEnd[start]) {\n      delete fragmentByEnd[f.end];\n      f.push(i);\n      f.end = end;\n      if (g = fragmentByStart[end]) {\n        delete fragmentByStart[g.start];\n        var fg = g === f ? f : f.concat(g);\n        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else if (f = fragmentByStart[end]) {\n      delete fragmentByStart[f.start];\n      f.unshift(i);\n      f.start = start;\n      if (g = fragmentByEnd[start]) {\n        delete fragmentByEnd[g.end];\n        var gf = g === f ? f : g.concat(f);\n        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;\n      } else {\n        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;\n      }\n    } else {\n      f = [i];\n      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;\n    }\n  });\n\n  function ends(i) {\n    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;\n    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });\n    else p1 = arc[arc.length - 1];\n    return i < 0 ? [p1, p0] : [p0, p1];\n  }\n\n  function flush(fragmentByEnd, fragmentByStart) {\n    for (var k in fragmentByEnd) {\n      var f = fragmentByEnd[k];\n      delete fragmentByStart[f.start];\n      delete f.start;\n      delete f.end;\n      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });\n      fragments.push(f);\n    }\n  }\n\n  flush(fragmentByEnd, fragmentByStart);\n  flush(fragmentByStart, fragmentByEnd);\n  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });\n\n  return fragments;\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import identity from \"./identity\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2,\n        n = input.length,\n        output = new Array(n),\n        x1 = Math.round((input[0] - dx) / kx),\n        y1 = Math.round((input[1] - dy) / ky);\n    output[0] = x1 - x0, x0 = x1;\n    output[1] = y1 - y0, y0 = y1;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction valueEqual(a, b) {\n  if (a === b) return true;\n\n  if (a == null || b == null) return false;\n\n  if (Array.isArray(a)) {\n    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {\n      return valueEqual(item, b[index]);\n    });\n  }\n\n  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);\n  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);\n\n  if (aType !== bType) return false;\n\n  if (aType === 'object') {\n    var aValue = a.valueOf();\n    var bValue = b.valueOf();\n\n    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);\n\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) return false;\n\n    return aKeys.every(function (key) {\n      return valueEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n\nexport default valueEqual;","export {\n  domCanvas as canvas,\n  domImage as image\n} from './src/domCanvas';\n","export function domCanvas(w, h) {\n  if (typeof document !== 'undefined' && document.createElement) {\n    var c = document.createElement('canvas');\n    if (c && c.getContext) {\n      c.width = w;\n      c.height = h;\n      return c;\n    }\n  }\n  return null;\n}\n\nexport function domImage() {\n  return typeof Image !== 'undefined' ? Image : null;\n}\n","export {default as crossfilter} from './src/CrossFilter';\nexport {default as resolvefilter} from './src/ResolveFilter';\n","import {array8, array16, array32} from './arrays';\n\n/**\n * Maintains CrossFilter state.\n */\nexport default function Bitmaps() {\n\n  var width = 8,\n      data = [],\n      seen = array32(0),\n      curr = array(0, width),\n      prev = array(0, width);\n\n  return {\n\n    data: function() { return data; },\n\n    seen: function() {\n      return (seen = lengthen(seen, data.length));\n    },\n\n    add: function(array) {\n      for (var i=0, j=data.length, n=array.length, t; i<n; ++i) {\n        t = array[i];\n        t._index = j++;\n        data.push(t);\n      }\n    },\n\n    remove: function(num, map) { // map: index -> boolean (true => remove)\n      var n = data.length,\n          copy = Array(n - num),\n          reindex = data, // reuse old data array for index map\n          t, i, j;\n\n      // seek forward to first removal\n      for (i=0; !map[i] && i<n; ++i) {\n        copy[i] = data[i];\n        reindex[i] = i;\n      }\n\n      // condense arrays\n      for (j=i; i<n; ++i) {\n        t = data[i];\n        if (!map[i]) {\n          reindex[i] = j;\n          curr[j] = curr[i];\n          prev[j] = prev[i];\n          copy[j] = t;\n          t._index = j++;\n        } else {\n          reindex[i] = -1;\n        }\n        curr[i] = 0; // clear unused bits\n      }\n\n      data = copy;\n      return reindex;\n    },\n\n    size: function() { return data.length; },\n\n    curr: function() { return curr; },\n\n    prev: function() { return prev; },\n\n    reset: function(k) { prev[k] = curr[k]; },\n\n    all: function() {\n      return width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff;\n    },\n\n    set: function(k, one) { curr[k] |= one; },\n\n    clear: function(k, one) { curr[k] &= ~one; },\n\n    resize: function(n, m) {\n      var k = curr.length;\n      if (n > k || m > width) {\n        width = Math.max(m, width);\n        curr = array(n, width, curr);\n        prev = array(n, width);\n      }\n    }\n  };\n}\n\nfunction lengthen(array, length, copy) {\n  if (array.length >= length) return array;\n  copy = copy || new array.constructor(length);\n  copy.set(array);\n  return copy;\n}\n\nfunction array(n, m, array) {\n  var copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);\n  if (array) copy.set(array);\n  return copy;\n}\n","import Bitmaps from './Bitmaps';\nimport Dimension from './Dimension';\nimport SortedIndex from './SortedIndex';\nimport {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * An indexed multi-dimensional filter.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.\n * @param {Array} params.query - An array of per-dimension range queries.\n */\nexport default function CrossFilter(params) {\n  Transform.call(this, Bitmaps(), params);\n  this._indices = null;\n  this._dims = null;\n}\n\nCrossFilter.Definition = {\n  \"type\": \"CrossFilter\",\n  \"metadata\": {},\n  \"params\": [\n    { \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"required\": true },\n    { \"name\": \"query\", \"type\": \"array\", \"array\": true, \"required\": true,\n      \"content\": {\"type\": \"number\", \"array\": true, \"length\": 2} }\n  ]\n};\n\nvar prototype = inherits(CrossFilter, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (!this._dims) {\n    return this.init(_, pulse);\n  } else {\n    var init = _.modified('fields')\n          || _.fields.some(function(f) { return pulse.modified(f.fields); });\n\n    return init\n      ? this.reinit(_, pulse)\n      : this.eval(_, pulse);\n  }\n};\n\nprototype.init = function(_, pulse) {\n  var fields = _.fields,\n      query = _.query,\n      indices = this._indices = {},\n      dims = this._dims = [],\n      m = query.length,\n      i = 0, key, index;\n\n  // instantiate indices and dimensions\n  for (; i<m; ++i) {\n    key = fields[i].fname;\n    index = indices[key] || (indices[key] = SortedIndex());\n    dims.push(Dimension(index, i, query[i]));\n  }\n\n  return this.eval(_, pulse);\n};\n\nprototype.reinit = function(_, pulse) {\n  var output = pulse.materialize().fork(),\n      fields = _.fields,\n      query = _.query,\n      indices = this._indices,\n      dims = this._dims,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all = bits.all(),\n      out = (output.rem = output.add),\n      mod = output.mod,\n      m = query.length,\n      adds = {}, add, index, key,\n      mods, remMap, modMap, i, n, f;\n\n  // set prev to current state\n  prev.set(curr);\n\n  // if pulse has remove tuples, process them first\n  if (pulse.rem.length) {\n    remMap = this.remove(_, pulse, output);\n  }\n\n  // if pulse has added tuples, add them to state\n  if (pulse.add.length) {\n    bits.add(pulse.add);\n  }\n\n  // if pulse has modified tuples, create an index map\n  if (pulse.mod.length) {\n    modMap = {};\n    for (mods=pulse.mod, i=0, n=mods.length; i<n; ++i) {\n      modMap[mods[i]._index] = 1;\n    }\n  }\n\n  // re-initialize indices as needed, update curr bitmap\n  for (i=0; i<m; ++i) {\n    f = fields[i];\n    if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {\n      key = f.fname;\n      if (!(add = adds[key])) {\n        indices[key] = index = SortedIndex();\n        adds[key] = add = index.insert(f, pulse.source, 0);\n      }\n      dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);\n    }\n  }\n\n  // visit each tuple\n  // if filter state changed, push index to add/rem\n  // else if in mod and passes a filter, push index to mod\n  for (i=0, n=bits.data().length; i<n; ++i) {\n    if (remMap[i]) { // skip if removed tuple\n      continue;\n    } else if (prev[i] !== curr[i]) { // add if state changed\n      out.push(i);\n    } else if (modMap[i] && curr[i] !== all) { // otherwise, pass mods through\n      mod.push(i);\n    }\n  }\n\n  bits.mask = (1 << m) - 1;\n  return output;\n};\n\nprototype.eval = function(_, pulse) {\n  var output = pulse.materialize().fork(),\n      m = this._dims.length,\n      mask = 0;\n\n  if (pulse.rem.length) {\n    this.remove(_, pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  if (_.modified('query') && !_.modified('fields')) {\n    mask |= this.update(_, pulse, output);\n  }\n\n  if (pulse.add.length) {\n    this.insert(_, pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  if (pulse.mod.length) {\n    this.modify(pulse, output);\n    mask |= (1 << m) - 1;\n  }\n\n  this.value.mask = mask;\n  return output;\n};\n\nprototype.insert = function(_, pulse, output) {\n  var tuples = pulse.add,\n      bits = this.value,\n      dims = this._dims,\n      indices = this._indices,\n      fields = _.fields,\n      adds = {},\n      out = output.add,\n      k = bits.size(),\n      n = k + tuples.length,\n      m = dims.length, j, key, add;\n\n  // resize bitmaps and add tuples as needed\n  bits.resize(n, m);\n  bits.add(tuples);\n\n  var curr = bits.curr(),\n      prev = bits.prev(),\n      all  = bits.all();\n\n  // add to dimensional indices\n  for (j=0; j<m; ++j) {\n    key = fields[j].fname;\n    add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));\n    dims[j].onAdd(add, curr);\n  }\n\n  // set previous filters, output if passes at least one filter\n  for (; k<n; ++k) {\n    prev[k] = all;\n    if (curr[k] !== all) out.push(k);\n  }\n};\n\nprototype.modify = function(pulse, output) {\n  var out = output.mod,\n      bits = this.value,\n      curr = bits.curr(),\n      all  = bits.all(),\n      tuples = pulse.mod,\n      i, n, k;\n\n  for (i=0, n=tuples.length; i<n; ++i) {\n    k = tuples[i]._index;\n    if (curr[k] !== all) out.push(k);\n  }\n};\n\nprototype.remove = function(_, pulse, output) {\n  var indices = this._indices,\n      bits = this.value,\n      curr = bits.curr(),\n      prev = bits.prev(),\n      all  = bits.all(),\n      map = {},\n      out = output.rem,\n      tuples = pulse.rem,\n      i, n, k, f;\n\n  // process tuples, output if passes at least one filter\n  for (i=0, n=tuples.length; i<n; ++i) {\n    k = tuples[i]._index;\n    map[k] = 1; // build index map\n    prev[k] = (f = curr[k]);\n    curr[k] = all;\n    if (f !== all) out.push(k);\n  }\n\n  // remove from dimensional indices\n  for (k in indices) {\n    indices[k].remove(n, map);\n  }\n\n  this.reindex(pulse, n, map);\n  return map;\n};\n\n// reindex filters and indices after propagation completes\nprototype.reindex = function(pulse, num, map) {\n  var indices = this._indices,\n      bits = this.value;\n\n  pulse.runAfter(function() {\n    var indexMap = bits.remove(num, map);\n    for (var key in indices) indices[key].reindex(indexMap);\n  });\n};\n\nprototype.update = function(_, pulse, output) {\n  var dims = this._dims,\n      query = _.query,\n      stamp = pulse.stamp,\n      m = dims.length,\n      mask = 0, i, q;\n\n  // survey how many queries have changed\n  output.filters = 0;\n  for (q=0; q<m; ++q) {\n    if (_.modified('query', q)) { i = q; ++mask; }\n  }\n\n  if (mask === 1) {\n    // only one query changed, use more efficient update\n    mask = dims[i].one;\n    this.incrementOne(dims[i], query[i], output.add, output.rem);\n  } else {\n    // multiple queries changed, perform full record keeping\n    for (q=0, mask=0; q<m; ++q) {\n      if (!_.modified('query', q)) continue;\n      mask |= dims[q].one;\n      this.incrementAll(dims[q], query[q], stamp, output.add);\n      output.rem = output.add; // duplicate add/rem for downstream resolve\n    }\n  }\n\n  return mask;\n};\n\nprototype.incrementAll = function(dim, query, stamp, out) {\n  var bits = this.value,\n      seen = bits.seen(),\n      curr = bits.curr(),\n      prev = bits.prev(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one,\n      i, j, k;\n\n  // Fast incremental update based on previous lo index.\n  if (lo1 < lo0) {\n    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  } else if (lo1 > lo0) {\n    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  }\n\n  // Fast incremental update based on previous hi index.\n  if (hi1 > hi0) {\n    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  } else if (hi1 < hi0) {\n    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n      k = index[i];\n      if (seen[k] !== stamp) {\n        prev[k] = curr[k];\n        seen[k] = stamp;\n        out.push(k);\n      }\n      curr[k] ^= one;\n    }\n  }\n\n  dim.range = query.slice();\n};\n\nprototype.incrementOne = function(dim, query, add, rem) {\n  var bits = this.value,\n      curr = bits.curr(),\n      index = dim.index(),\n      old = dim.bisect(dim.range),\n      range = dim.bisect(query),\n      lo1 = range[0],\n      hi1 = range[1],\n      lo0 = old[0],\n      hi0 = old[1],\n      one = dim.one,\n      i, j, k;\n\n  // Fast incremental update based on previous lo index.\n  if (lo1 < lo0) {\n    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      add.push(k);\n    }\n  } else if (lo1 > lo0) {\n    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      rem.push(k);\n    }\n  }\n\n  // Fast incremental update based on previous hi index.\n  if (hi1 > hi0) {\n    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      add.push(k);\n    }\n  } else if (hi1 < hi0) {\n    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {\n      k = index[i];\n      curr[k] ^= one;\n      rem.push(k);\n    }\n  }\n\n  dim.range = query.slice();\n};\n","export default function(index, i, query) {\n  var bit = (1 << i);\n\n  return {\n    one:     bit,\n    zero:    ~bit,\n    range:   query.slice(),\n    bisect:  index.bisect,\n    index:   index.index,\n    size:    index.size,\n\n    onAdd: function(added, curr) {\n      var dim = this,\n          range = dim.bisect(dim.range, added.value),\n          idx = added.index,\n          lo = range[0],\n          hi = range[1],\n          n1 = idx.length, i;\n\n      for (i=0;  i<lo; ++i) curr[idx[i]] |= bit;\n      for (i=hi; i<n1; ++i) curr[idx[i]] |= bit;\n      return dim;\n    }\n  };\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Selectively filters tuples by resolving against a filter bitmap.\n * Useful for processing the output of a cross-filter transform.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.ignore - A bit mask indicating which filters to ignore.\n * @param {object} params.filter - The per-tuple filter bitmaps. Typically this\n *   parameter value is a reference to a {@link CrossFilter} transform.\n */\nexport default function ResolveFilter(params) {\n  Transform.call(this, null, params);\n}\n\nResolveFilter.Definition = {\n  \"type\": \"ResolveFilter\",\n  \"metadata\": {},\n  \"params\": [\n    { \"name\": \"ignore\", \"type\": \"number\", \"required\": true,\n      \"description\": \"A bit mask indicating which filters to ignore.\" },\n    { \"name\": \"filter\", \"type\": \"object\", \"required\": true,\n      \"description\": \"Per-tuple filter bitmaps from a CrossFilter transform.\" }\n  ]\n};\n\nvar prototype = inherits(ResolveFilter, Transform);\n\nprototype.transform = function(_, pulse) {\n  var ignore = ~(_.ignore || 0), // bit mask where zeros -> dims to ignore\n      bitmap = _.filter,\n      mask = bitmap.mask;\n\n  // exit early if no relevant filter changes\n  if ((mask & ignore) === 0) return pulse.StopPropagation;\n\n  var output = pulse.fork(pulse.ALL),\n      data = bitmap.data(),\n      curr = bitmap.curr(),\n      prev = bitmap.prev(),\n      pass = function(k) {\n        return !(curr[k] & ignore) ? data[k] : null;\n      };\n\n  // propagate all mod tuples that pass the filter\n  output.filter(output.MOD, pass);\n\n  // determine add & rem tuples via filter functions\n  // for efficiency, we do *not* populate new arrays,\n  // instead we add filter functions applied downstream\n\n  if (!(mask & (mask-1))) { // only one filter changed\n    output.filter(output.ADD, pass);\n    output.filter(output.REM, function(k) {\n      return (curr[k] & ignore) === mask ? data[k] : null;\n    });\n\n  } else { // multiple filters changed\n    output.filter(output.ADD, function(k) {\n      var c = curr[k] & ignore,\n          f = !c && (c ^ (prev[k] & ignore));\n      return f ? data[k] : null;\n    });\n    output.filter(output.REM, function(k) {\n      var c = curr[k] & ignore,\n          f = c && !(c ^ (c ^ (prev[k] & ignore)));\n      return f ? data[k] : null;\n    });\n  }\n\n  // add filter to source data in case of reflow...\n  return output.filter(output.SOURCE, function(t) { return pass(t._index); });\n};\n","import {array32} from './arrays';\nimport {bisectLeft, bisectRight, permute} from 'd3-array';\n\n/**\n * Maintains a list of values, sorted by key.\n */\nexport default function SortedIndex() {\n  var index = array32(0),\n      value = [],\n      size = 0;\n\n  function insert(key, data, base) {\n    if (!data.length) return [];\n\n    var n0 = size,\n        n1 = data.length,\n        addv = Array(n1),\n        addi = array32(n1),\n        oldv, oldi, i;\n\n    for (i=0; i<n1; ++i) {\n      addv[i] = key(data[i]);\n      addi[i] = i;\n    }\n    addv = sort(addv, addi);\n\n    if (n0) {\n      oldv = value;\n      oldi = index;\n      value = Array(n0 + n1);\n      index = array32(n0 + n1);\n      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);\n    } else {\n      if (base > 0) for (i=0; i<n1; ++i) {\n        addi[i] += base;\n      }\n      value = addv;\n      index = addi;\n    }\n    size = n0 + n1;\n\n    return {index: addi, value: addv};\n  }\n\n  function remove(num, map) {\n    // map: index -> remove\n    var n = size,\n        idx, i, j;\n\n    // seek forward to first removal\n    for (i=0; !map[index[i]] && i<n; ++i);\n\n    // condense index and value arrays\n    for (j=i; i<n; ++i) {\n      if (!map[idx=index[i]]) {\n        index[j] = idx;\n        value[j] = value[i];\n        ++j;\n      }\n    }\n\n    size = n - num;\n  }\n\n  function reindex(map) {\n    for (var i=0, n=size; i<n; ++i) {\n      index[i] = map[index[i]];\n    }\n  }\n\n  function bisect(range, array) {\n    var n;\n    if (array) {\n      n = array.length;\n    } else {\n      array = value;\n      n = size;\n    }\n    return [\n      bisectLeft(array, range[0], 0, n),\n      bisectRight(array, range[1], 0, n)\n    ];\n  }\n\n  return {\n    insert:  insert,\n    remove:  remove,\n    bisect:  bisect,\n    reindex: reindex,\n    index:   function() { return index; },\n    size:    function() { return size; }\n  };\n}\n\nfunction sort(values, index) {\n  values.sort.call(index, function(a, b) {\n    var x = values[a],\n        y = values[b];\n    return x < y ? -1 : x > y ? 1 : 0;\n  });\n  return permute(values, index);\n}\n\nfunction merge(base, value0, index0, n0, value1, index1, n1, value, index) {\n  var i0 = 0, i1 = 0, i;\n\n  for (i=0; i0 < n0 && i1 < n1; ++i) {\n    if (value0[i0] < value1[i1]) {\n      value[i] = value0[i0];\n      index[i] = index0[i0++];\n    } else {\n      value[i] = value1[i1];\n      index[i] = index1[i1++] + base;\n    }\n  }\n\n  for (; i0 < n0; ++i0, ++i) {\n    value[i] = value0[i0];\n    index[i] = index0[i0];\n  }\n\n  for (; i1 < n1; ++i1, ++i) {\n    value[i] = value1[i1];\n    index[i] = index1[i1] + base;\n  }\n}\n","export function array8(n) { return new Uint8Array(n); }\n\nexport function array16(n) { return new Uint16Array(n); }\n\nexport function array32(n) { return new Uint32Array(n); }\n","// Utilities\nexport {default as UniqueList} from './src/util/UniqueList';\n\n// Core Runtime\nexport {default as changeset, isChangeSet} from './src/ChangeSet';\nexport {default as Dataflow} from './src/dataflow/Dataflow';\nexport {default as EventStream} from './src/EventStream';\nexport {default as Parameters} from './src/Parameters';\nexport {default as Pulse} from './src/Pulse';\nexport {default as MultiPulse} from './src/MultiPulse';\nexport {default as Operator} from './src/Operator';\nexport {default as Transform} from './src/Transform';\nexport {derive, rederive, ingest, isTuple, replace, tupleid} from './src/Tuple';\n\n// Transform Registry\nexport {\n  definition,\n  transform,\n  transforms\n} from './src/register';\n","import {ingest, tupleid} from './Tuple';\nimport {array, constant, isFunction} from 'vega-util';\n\nexport function isChangeSet(v) {\n  return v && v.constructor === changeset;\n}\n\nexport default function changeset() {\n  var add = [],  // insert tuples\n      rem = [],  // remove tuples\n      mod = [],  // modify tuples\n      remp = [], // remove by predicate\n      modp = [], // modify by predicate\n      reflow = false;\n\n  return {\n    constructor: changeset,\n    insert: function(t) {\n      var d = array(t), i = 0, n = d.length;\n      for (; i<n; ++i) add.push(d[i]);\n      return this;\n    },\n    remove: function(t) {\n      var a = isFunction(t) ? remp : rem,\n          d = array(t), i = 0, n = d.length;\n      for (; i<n; ++i) a.push(d[i]);\n      return this;\n    },\n    modify: function(t, field, value) {\n      var m = {field: field, value: constant(value)};\n      if (isFunction(t)) {\n        m.filter = t;\n        modp.push(m);\n      } else {\n        m.tuple = t;\n        mod.push(m);\n      }\n      return this;\n    },\n    encode: function(t, set) {\n      if (isFunction(t)) modp.push({filter: t, field: set});\n      else mod.push({tuple: t, field: set});\n      return this;\n    },\n    reflow: function() {\n      reflow = true;\n      return this;\n    },\n    pulse: function(pulse, tuples) {\n      var cur = {}, out = {}, i, n, m, f, t, id;\n\n      // build lookup table of current tuples\n      for (i=0, n=tuples.length; i<n; ++i) {\n        cur[tupleid(tuples[i])] = 1;\n      }\n\n      // process individual tuples to remove\n      for (i=0, n=rem.length; i<n; ++i) {\n        t = rem[i];\n        cur[tupleid(t)] = -1;\n      }\n\n      // process predicate-based removals\n      for (i=0, n=remp.length; i<n; ++i) {\n        f = remp[i];\n        tuples.forEach(function(t) {\n          if (f(t)) cur[tupleid(t)] = -1;\n        });\n      }\n\n      // process all add tuples\n      for (i=0, n=add.length; i<n; ++i) {\n        t = add[i];\n        id = tupleid(t);\n        if (cur[id]) {\n          // tuple already resides in dataset\n          // if flagged for both add and remove, cancel\n          cur[id] = 1;\n        } else {\n          // tuple does not reside in dataset, add\n          pulse.add.push(ingest(add[i]));\n        }\n      }\n\n      // populate pulse rem list\n      for (i=0, n=tuples.length; i<n; ++i) {\n        t = tuples[i];\n        if (cur[tupleid(t)] < 0) pulse.rem.push(t);\n      }\n\n      // modify helper method\n      function modify(t, f, v) {\n        if (v) {\n          t[f] = v(t);\n        } else {\n          pulse.encode = f;\n        }\n        if (!reflow) out[tupleid(t)] = t;\n      }\n\n      // process individual tuples to modify\n      for (i=0, n=mod.length; i<n; ++i) {\n        m = mod[i];\n        t = m.tuple;\n        f = m.field;\n        id = cur[tupleid(t)];\n        if (id > 0) {\n          modify(t, f, m.value);\n          pulse.modifies(f);\n        }\n      }\n\n      // process predicate-based modifications\n      for (i=0, n=modp.length; i<n; ++i) {\n        m = modp[i];\n        f = m.filter;\n        tuples.forEach(function(t) {\n          if (f(t) && cur[tupleid(t)] > 0) {\n            modify(t, m.field, m.value);\n          }\n        });\n        pulse.modifies(m.field);\n      }\n\n      // upon reflow request, populate mod with all non-removed tuples\n      // otherwise, populate mod with modified tuples only\n      if (reflow) {\n        pulse.mod = rem.length || remp.length\n          ? tuples.filter(function(t) { return cur[tupleid(t)] > 0; })\n          : tuples.slice();\n      } else {\n        for (id in out) pulse.mod.push(out[id]);\n      }\n\n      return pulse;\n    }\n  };\n}\n","import UniqueList from './util/UniqueList';\nimport {debounce, id, identity, truthy} from 'vega-util';\n\nvar STREAM_ID = 0;\n\n/**\n * Models an event stream.\n * @constructor\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\n *   Events pass through when truthy, events are suppressed when falsy.\n * @param {function(Object): *} [apply] - Applied to input events to produce\n *   new event values.\n * @param {function(Object)} [receive] - Event callback function to invoke\n *   upon receipt of a new event. Use to override standard event processing.\n */\nexport default function EventStream(filter, apply, receive) {\n  this.id = ++STREAM_ID;\n  this.value = null;\n  if (receive) this.receive = receive;\n  if (filter) this._filter = filter;\n  if (apply) this._apply = apply;\n}\n\n/**\n * Creates a new event stream instance with the provided\n * (optional) filter, apply and receive functions.\n * @param {function(Object, number): boolean} [filter] - Filter predicate.\n *   Events pass through when truthy, events are suppressed when falsy.\n * @param {function(Object): *} [apply] - Applied to input events to produce\n *   new event values.\n * @see EventStream\n */\nexport function stream(filter, apply, receive) {\n  return new EventStream(filter, apply, receive);\n}\n\nvar prototype = EventStream.prototype;\n\nprototype._filter = truthy;\n\nprototype._apply = identity;\n\nprototype.targets = function() {\n  return this._targets || (this._targets = UniqueList(id));\n};\n\nprototype.consume = function(_) {\n  if (!arguments.length) return !!this._consume;\n  this._consume = !!_;\n  return this;\n};\n\nprototype.receive = function(evt) {\n  if (this._filter(evt)) {\n    var val = (this.value = this._apply(evt)),\n        trg = this._targets,\n        n = trg ? trg.length : 0,\n        i = 0;\n\n    for (; i<n; ++i) trg[i].receive(val);\n\n    if (this._consume) {\n      evt.preventDefault();\n      evt.stopPropagation();\n    }\n  }\n};\n\nprototype.filter = function(filter) {\n  var s = stream(filter);\n  this.targets().add(s);\n  return s;\n};\n\nprototype.apply = function(apply) {\n  var s = stream(null, apply);\n  this.targets().add(s);\n  return s;\n};\n\nprototype.merge = function() {\n  var s = stream();\n\n  this.targets().add(s);\n  for (var i=0, n=arguments.length; i<n; ++i) {\n    arguments[i].targets().add(s);\n  }\n\n  return s;\n};\n\nprototype.throttle = function(pause) {\n  var t = -1;\n  return this.filter(function() {\n    var now = Date.now();\n    if ((now - t) > pause) {\n      t = now;\n      return 1;\n    } else {\n      return 0;\n    }\n  });\n};\n\nprototype.debounce = function(delay) {\n  var s = stream();\n\n  this.targets().add(stream(null, null,\n    debounce(delay, function(e) {\n      var df = e.dataflow;\n      s.receive(e);\n      if (df && df.run) df.run();\n    })\n  ));\n\n  return s;\n};\n\nprototype.between = function(a, b) {\n  var active = false;\n  a.targets().add(stream(null, null, function() { active = true; }));\n  b.targets().add(stream(null, null, function() { active = false; }));\n  return this.filter(function() { return active; });\n};\n","import Pulse from './Pulse';\nimport {error, inherits, isArray} from 'vega-util';\n\n/**\n * Represents a set of multiple pulses. Used as input for operators\n * that accept multiple pulses at a time. Contained pulses are\n * accessible via the public \"pulses\" array property. This pulse doe\n * not carry added, removed or modified tuples directly. However,\n * the visit method can be used to traverse all such tuples contained\n * in sub-pulses with a timestamp matching this parent multi-pulse.\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The timestamp.\n * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.\n */\nexport default function MultiPulse(dataflow, stamp, pulses, encode) {\n  var p = this,\n      c = 0,\n      pulse, hash, i, n, f;\n\n  this.dataflow = dataflow;\n  this.stamp = stamp;\n  this.fields = null;\n  this.encode = encode || null;\n  this.pulses = pulses;\n\n  for (i=0, n=pulses.length; i<n; ++i) {\n    pulse = pulses[i];\n    if (pulse.stamp !== stamp) continue;\n\n    if (pulse.fields) {\n      hash = p.fields || (p.fields = {});\n      for (f in pulse.fields) { hash[f] = 1; }\n    }\n\n    if (pulse.changed(p.ADD)) c |= p.ADD;\n    if (pulse.changed(p.REM)) c |= p.REM;\n    if (pulse.changed(p.MOD)) c |= p.MOD;\n  }\n\n  this.changes = c;\n}\n\nvar prototype = inherits(MultiPulse, Pulse);\n\n/**\n * Creates a new pulse based on the values of this pulse.\n * The dataflow, time stamp and field modification values are copied over.\n * @return {Pulse}\n */\nprototype.fork = function(flags) {\n  var p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);\n  if (flags !== undefined) {\n    if (flags & p.ADD) {\n      this.visit(p.ADD, function(t) { return p.add.push(t); });\n    }\n    if (flags & p.REM) {\n      this.visit(p.REM, function(t) { return p.rem.push(t); });\n    }\n    if (flags & p.MOD) {\n      this.visit(p.MOD, function(t) { return p.mod.push(t); });\n    }\n  }\n  return p;\n};\n\nprototype.changed = function(flags) {\n  return this.changes & flags;\n};\n\nprototype.modified = function(_) {\n  var p = this, fields = p.fields;\n  return !(fields && (p.changes & p.MOD)) ? 0\n    : isArray(_) ? _.some(function(f) { return fields[f]; })\n    : fields[_];\n};\n\nprototype.filter = function() {\n  error('MultiPulse does not support filtering.');\n};\n\nprototype.materialize = function() {\n  error('MultiPulse does not support materialization.');\n};\n\nprototype.visit = function(flags, visitor) {\n  var p = this,\n      pulses = p.pulses,\n      n = pulses.length,\n      i = 0;\n\n  if (flags & p.SOURCE) {\n    for (; i<n; ++i) {\n      pulses[i].visit(flags, visitor);\n    }\n  } else {\n    for (; i<n; ++i) {\n      if (pulses[i].stamp === p.stamp) {\n        pulses[i].visit(flags, visitor);\n      }\n    }\n  }\n\n  return p;\n};\n","import Parameters from './Parameters';\nimport UniqueList from './util/UniqueList';\nimport {array, error, id, isArray} from 'vega-util';\n\nvar OP_ID = 0;\nvar PULSE = 'pulse';\nvar NO_PARAMS = new Parameters();\n\n// Boolean Flags\nvar SKIP     = 1,\n    MODIFIED = 2;\n\n/**\n * An Operator is a processing node in a dataflow graph.\n * Each operator stores a value and an optional value update function.\n * Operators can accept a hash of named parameters. Parameter values can\n * either be direct (JavaScript literals, arrays, objects) or indirect\n * (other operators whose values will be pulled dynamically). Operators\n * included as parameters will have this operator added as a dependency.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {function(object, Pulse)} [update] - An update function. Upon\n *   evaluation of this operator, the update function will be invoked and the\n *   return value will be used as the new value of this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @see parameters\n */\nexport default function Operator(init, update, params, react) {\n  this.id = ++OP_ID;\n  this.value = init;\n  this.stamp = -1;\n  this.rank = -1;\n  this.qrank = -1;\n  this.flags = 0;\n\n  if (update) {\n    this._update = update;\n  }\n  if (params) this.parameters(params, react);\n}\n\nvar prototype = Operator.prototype;\n\n/**\n * Returns a list of target operators dependent on this operator.\n * If this list does not exist, it is created and then returned.\n * @return {UniqueList}\n */\nprototype.targets = function() {\n  return this._targets || (this._targets = UniqueList(id));\n};\n\n/**\n * Sets the value of this operator.\n * @param {*} value - the value to set.\n * @return {Number} Returns 1 if the operator value has changed\n *   according to strict equality, returns 0 otherwise.\n */\nprototype.set = function(value) {\n  if (this.value !== value) {\n    this.value = value;\n    return 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction flag(bit) {\n  return function(state) {\n    var f = this.flags;\n    if (arguments.length === 0) return !!(f & bit);\n    this.flags = state ? (f | bit) : (f & ~bit);\n    return this;\n  };\n}\n\n/**\n * Indicates that operator evaluation should be skipped on the next pulse.\n * This operator will still propagate incoming pulses, but its update function\n * will not be invoked. The skip flag is reset after every pulse, so calling\n * this method will affect processing of the next pulse only.\n */\nprototype.skip = flag(SKIP);\n\n/**\n * Indicates that this operator's value has been modified on its most recent\n * pulse. Normally modification is checked via strict equality; however, in\n * some cases it is more efficient to update the internal state of an object.\n * In those cases, the modified flag can be used to trigger propagation. Once\n * set, the modification flag persists across pulses until unset. The flag can\n * be used with the last timestamp to test if a modification is recent.\n */\nprototype.modified = flag(MODIFIED);\n\n/**\n * Sets the parameters for this operator. The parameter values are analyzed for\n * operator instances. If found, this operator will be added as a dependency\n * of the parameterizing operator. Operator values are dynamically marshalled\n * from each operator parameter prior to evaluation. If a parameter value is\n * an array, the array will also be searched for Operator instances. However,\n * the search does not recurse into sub-arrays or object properties.\n * @param {object} params - A hash of operator parameters.\n * @param {boolean} [react=true] - A flag indicating if this operator should\n *   automatically update (react) when parameter values change. In other words,\n *   this flag determines if the operator registers itself as a listener on\n *   any upstream operators included in the parameters.\n * @return {Operator[]} - An array of upstream dependencies.\n */\nprototype.parameters = function(params, react) {\n  react = react !== false;\n  var self = this,\n      argval = (self._argval = self._argval || new Parameters()),\n      argops = (self._argops = self._argops || []),\n      deps = [],\n      name, value, n, i;\n\n  function add(name, index, value) {\n    if (value instanceof Operator) {\n      if (value !== self) {\n        if (react) value.targets().add(self);\n        deps.push(value);\n      }\n      argops.push({op:value, name:name, index:index});\n    } else {\n      argval.set(name, index, value);\n    }\n  }\n\n  for (name in params) {\n    value = params[name];\n\n    if (name === PULSE) {\n      array(value).forEach(function(op) {\n        if (!(op instanceof Operator)) {\n          error('Pulse parameters must be operator instances.');\n        } else if (op !== self) {\n          op.targets().add(self);\n          deps.push(op);\n        }\n      });\n      self.source = value;\n    } else if (isArray(value)) {\n      argval.set(name, -1, Array(n = value.length));\n      for (i=0; i<n; ++i) add(name, i, value[i]);\n    } else {\n      add(name, -1, value);\n    }\n  }\n\n  this.marshall().clear(); // initialize values\n  return deps;\n};\n\n/**\n * Internal method for marshalling parameter values.\n * Visits each operator dependency to pull the latest value.\n * @return {Parameters} A Parameters object to pass to the update function.\n */\nprototype.marshall = function(stamp) {\n  var argval = this._argval || NO_PARAMS,\n      argops = this._argops, item, i, n, op, mod;\n\n  if (argops && (n = argops.length)) {\n    for (i=0; i<n; ++i) {\n      item = argops[i];\n      op = item.op;\n      mod = op.modified() && op.stamp === stamp;\n      argval.set(item.name, item.index, op.value, mod);\n    }\n  }\n  return argval;\n};\n\n/**\n * Delegate method to perform operator processing.\n * Subclasses can override this method to perform custom processing.\n * By default, it marshalls parameters and calls the update function\n * if that function is defined. If the update function does not\n * change the operator value then StopPropagation is returned.\n * If no update function is defined, this method does nothing.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return The output pulse or StopPropagation. A falsy return value\n *   (including undefined) will let the input pulse pass through.\n */\nprototype.evaluate = function(pulse) {\n  if (this._update) {\n    var params = this.marshall(pulse.stamp),\n        v = this._update(params, pulse);\n\n    params.clear();\n    if (v !== this.value) {\n      this.value = v;\n    } else if (!this.modified()) {\n      return pulse.StopPropagation;\n    }\n  }\n};\n\n/**\n * Run this operator for the current pulse. If this operator has already\n * been run at (or after) the pulse timestamp, returns StopPropagation.\n * Internally, this method calls {@link evaluate} to perform processing.\n * If {@link evaluate} returns a falsy value, the input pulse is returned.\n * This method should NOT be overridden, instead overrride {@link evaluate}.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return the output pulse for this operator (or StopPropagation)\n */\nprototype.run = function(pulse) {\n  if (pulse.stamp <= this.stamp) return pulse.StopPropagation;\n  var rv;\n  if (this.skip()) {\n    this.skip(false);\n    rv = 0;\n  } else {\n    rv = this.evaluate(pulse);\n  }\n  this.stamp = pulse.stamp;\n  return (this.pulse = rv || pulse);\n};\n","import {isArray} from 'vega-util';\n\nvar CACHE = '_:mod:_';\n\n/**\n * Hash that tracks modifications to assigned values.\n * Callers *must* use the set method to update values.\n */\nexport default function Parameters() {\n  Object.defineProperty(this, CACHE, {writable:true, value: {}});\n}\n\nvar prototype = Parameters.prototype;\n\n/**\n * Set a parameter value. If the parameter value changes, the parameter\n * will be recorded as modified.\n * @param {string} name - The parameter name.\n * @param {number} index - The index into an array-value parameter. Ignored if\n *   the argument is undefined, null or less than zero.\n * @param {*} value - The parameter value to set.\n * @param {boolean} [force=false] - If true, records the parameter as modified\n *   even if the value is unchanged.\n * @return {Parameters} - This parameter object.\n */\nprototype.set = function(name, index, value, force) {\n  var o = this,\n      v = o[name],\n      mod = o[CACHE];\n\n  if (index != null && index >= 0) {\n    if (v[index] !== value || force) {\n      v[index] = value;\n      mod[index + ':' + name] = -1;\n      mod[name] = -1;\n    }\n  } else if (v !== value || force) {\n    o[name] = value;\n    mod[name] = isArray(value) ? 1 + value.length : -1;\n  }\n\n  return o;\n};\n\n/**\n * Tests if one or more parameters has been modified. If invoked with no\n * arguments, returns true if any parameter value has changed. If the first\n * argument is array, returns trues if any parameter name in the array has\n * changed. Otherwise, tests if the given name and optional array index has\n * changed.\n * @param {string} name - The parameter name to test.\n * @param {number} [index=undefined] - The parameter array index to test.\n * @return {boolean} - Returns true if a queried parameter was modified.\n */\nprototype.modified = function(name, index) {\n  var mod = this[CACHE], k;\n  if (!arguments.length) {\n    for (k in mod) { if (mod[k]) return true; }\n    return false;\n  } else if (isArray(name)) {\n    for (k=0; k<name.length; ++k) {\n      if (mod[name[k]]) return true;\n    }\n    return false;\n  }\n  return (index != null && index >= 0)\n    ? (index + 1 < mod[name] || !!mod[index + ':' + name])\n    : !!mod[name];\n};\n\n/**\n * Clears the modification records. After calling this method,\n * all parameters are considered unmodified.\n */\nprototype.clear = function() {\n  this[CACHE] = {};\n  return this;\n};\n","import {tupleid} from './Tuple';\nimport {array, isArray, visitArray} from 'vega-util';\n\n/**\n * Sentinel value indicating pulse propagation should stop.\n */\nexport var StopPropagation = {};\n\n// Pulse visit type flags\nvar ADD       = (1 << 0),\n    REM       = (1 << 1),\n    MOD       = (1 << 2),\n    ADD_REM   = ADD | REM,\n    ADD_MOD   = ADD | MOD,\n    ALL       = ADD | REM | MOD,\n    REFLOW    = (1 << 3),\n    SOURCE    = (1 << 4),\n    NO_SOURCE = (1 << 5),\n    NO_FIELDS = (1 << 6);\n\n/**\n * A Pulse enables inter-operator communication during a run of the\n * dataflow graph. In addition to the current timestamp, a pulse may also\n * contain a change-set of added, removed or modified data tuples, as well as\n * a pointer to a full backing data source. Tuple change sets may not\n * be fully materialized; for example, to prevent needless array creation\n * a change set may include larger arrays and corresponding filter functions.\n * The pulse provides a {@link visit} method to enable proper and efficient\n * iteration over requested data tuples.\n *\n * In addition, each pulse can track modification flags for data tuple fields.\n * Responsible transform operators should call the {@link modifies} method to\n * indicate changes to data fields. The {@link modified} method enables\n * querying of this modification state.\n *\n * @constructor\n * @param {Dataflow} dataflow - The backing dataflow instance.\n * @param {number} stamp - The current propagation timestamp.\n * @param {string} [encode] - An optional encoding set name, which is then\n *   accessible as Pulse.encode. Operators can respond to (or ignore) this\n *   setting as appropriate. This parameter can be used in conjunction with\n *   the Encode transform in the vega-encode module.\n */\nexport default function Pulse(dataflow, stamp, encode) {\n  this.dataflow = dataflow;\n  this.stamp = stamp == null ? -1 : stamp;\n  this.add = [];\n  this.rem = [];\n  this.mod = [];\n  this.fields = null;\n  this.encode = encode || null;\n}\n\nvar prototype = Pulse.prototype;\n\n/**\n * Sentinel value indicating pulse propagation should stop.\n */\nprototype.StopPropagation = StopPropagation;\n\n/**\n * Boolean flag indicating ADD (added) tuples.\n */\nprototype.ADD = ADD;\n\n/**\n * Boolean flag indicating REM (removed) tuples.\n */\nprototype.REM = REM;\n\n/**\n * Boolean flag indicating MOD (modified) tuples.\n */\nprototype.MOD = MOD;\n\n/**\n * Boolean flag indicating ADD (added) and REM (removed) tuples.\n */\nprototype.ADD_REM = ADD_REM;\n\n/**\n * Boolean flag indicating ADD (added) and MOD (modified) tuples.\n */\nprototype.ADD_MOD = ADD_MOD;\n\n/**\n * Boolean flag indicating ADD, REM and MOD tuples.\n */\nprototype.ALL = ALL;\n\n/**\n * Boolean flag indicating all tuples in a data source\n * except for the ADD, REM and MOD tuples.\n */\nprototype.REFLOW = REFLOW;\n\n/**\n * Boolean flag indicating a 'pass-through' to a\n * backing data source, ignoring ADD, REM and MOD tuples.\n */\nprototype.SOURCE = SOURCE;\n\n/**\n * Boolean flag indicating that source data should be\n * suppressed when creating a forked pulse.\n */\nprototype.NO_SOURCE = NO_SOURCE;\n\n/**\n * Boolean flag indicating that field modifications should be\n * suppressed when creating a forked pulse.\n */\nprototype.NO_FIELDS = NO_FIELDS;\n\n/**\n * Creates a new pulse based on the values of this pulse.\n * The dataflow, time stamp and field modification values are copied over.\n * By default, new empty ADD, REM and MOD arrays are created.\n * @param {number} flags - Integer of boolean flags indicating which (if any)\n *   tuple arrays should be copied to the new pulse. The supported flag values\n *   are ADD, REM and MOD. Array references are copied directly: new array\n *   instances are not created.\n * @return {Pulse} - The forked pulse instance.\n * @see init\n */\nprototype.fork = function(flags) {\n  return new Pulse(this.dataflow).init(this, flags);\n};\n\n/**\n * Creates a copy of this pulse with new materialized array\n * instances for the ADD, REM, MOD, and SOURCE arrays.\n * The dataflow, time stamp and field modification values are copied over.\n * @return {Pulse} - The cloned pulse instance.\n * @see init\n */\nprototype.clone = function() {\n  var p = this.fork(ALL);\n  p.add = p.add.slice();\n  p.rem = p.rem.slice();\n  p.mod = p.mod.slice();\n  if (p.source) p.source = p.source.slice();\n  return p.materialize(ALL | SOURCE);\n};\n\n/**\n * Returns a pulse that adds all tuples from a backing source. This is\n * useful for cases where operators are added to a dataflow after an\n * upstream data pipeline has already been processed, ensuring that\n * new operators can observe all tuples within a stream.\n * @return {Pulse} - A pulse instance with all source tuples included\n *   in the add array. If the current pulse already has all source\n *   tuples in its add array, it is returned directly. If the current\n *   pulse does not have a backing source, it is returned directly.\n */\nprototype.addAll = function() {\n  var p = this;\n  if (!this.source || this.source.length === this.add.length) {\n    return p;\n  } else {\n    p = new Pulse(this.dataflow).init(this);\n    p.add = p.source;\n    return p;\n  }\n};\n\n/**\n * Initialize this pulse based on the values of another pulse. This method\n * is used internally by {@link fork} to initialize a new forked tuple.\n * The dataflow, time stamp and field modification values are copied over.\n * By default, new empty ADD, REM and MOD arrays are created.\n * @param {Pulse} src - The source pulse to copy from.\n * @param {number} flags - Integer of boolean flags indicating which (if any)\n *   tuple arrays should be copied to the new pulse. The supported flag values\n *   are ADD, REM and MOD. Array references are copied directly: new array\n *   instances are not created. By default, source data arrays are copied\n *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.\n * @return {Pulse} - Returns this Pulse instance.\n */\nprototype.init = function(src, flags) {\n  var p = this;\n  p.stamp = src.stamp;\n  p.encode = src.encode;\n\n  if (src.fields && !(flags & NO_FIELDS)) {\n    p.fields = src.fields;\n  }\n\n  if (flags & ADD) {\n    p.addF = src.addF;\n    p.add = src.add;\n  } else {\n    p.addF = null;\n    p.add = [];\n  }\n\n  if (flags & REM) {\n    p.remF = src.remF;\n    p.rem = src.rem;\n  } else {\n    p.remF = null;\n    p.rem = [];\n  }\n\n  if (flags & MOD) {\n    p.modF = src.modF;\n    p.mod = src.mod;\n  } else {\n    p.modF = null;\n    p.mod = [];\n  }\n\n  if (flags & NO_SOURCE) {\n    p.srcF = null;\n    p.source = null;\n  } else {\n    p.srcF = src.srcF;\n    p.source = src.source;\n  }\n\n  return p;\n};\n\n/**\n * Schedules a function to run after pulse propagation completes.\n * @param {function} func - The function to run.\n */\nprototype.runAfter = function(func) {\n  this.dataflow.runAfter(func);\n};\n\n/**\n * Indicates if tuples have been added, removed or modified.\n * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.\n *   Defaults to ALL, returning true if any tuple type has changed.\n * @return {boolean} - Returns true if one or more queried tuple types have\n *   changed, false otherwise.\n */\nprototype.changed = function(flags) {\n  var f = flags || ALL;\n  return ((f & ADD) && this.add.length)\n      || ((f & REM) && this.rem.length)\n      || ((f & MOD) && this.mod.length);\n};\n\n/**\n * Forces a \"reflow\" of tuple values, such that all tuples in the backing\n * source are added to the MOD set, unless already present in the ADD set.\n * @param {boolean} [fork=false] - If true, returns a forked copy of this\n *   pulse, and invokes reflow on that derived pulse.\n * @return {Pulse} - The reflowed pulse instance.\n */\nprototype.reflow = function(fork) {\n  if (fork) return this.fork(ALL).reflow();\n\n  var len = this.add.length,\n      src = this.source && this.source.length;\n  if (src && src !== len) {\n    this.mod = this.source;\n    if (len) this.filter(MOD, filter(this, ADD));\n  }\n  return this;\n};\n\n/**\n * Marks one or more data field names as modified to assist dependency\n * tracking and incremental processing by transform operators.\n * @param {string|Array<string>} _ - The field(s) to mark as modified.\n * @return {Pulse} - This pulse instance.\n */\nprototype.modifies = function(_) {\n  var fields = array(_),\n      hash = this.fields || (this.fields = {});\n  fields.forEach(function(f) { hash[f] = true; });\n  return this;\n};\n\n/**\n * Checks if one or more data fields have been modified during this pulse\n * propagation timestamp.\n * @param {string|Array<string>} _ - The field(s) to check for modified.\n * @return {boolean} - Returns true if any of the provided fields has been\n *   marked as modified, false otherwise.\n */\nprototype.modified = function(_) {\n  var fields = this.fields;\n  return !(this.mod.length && fields) ? false\n    : !arguments.length ? !!fields\n    : isArray(_) ? _.some(function(f) { return fields[f]; })\n    : fields[_];\n};\n\n/**\n * Adds a filter function to one more tuple sets. Filters are applied to\n * backing tuple arrays, to determine the actual set of tuples considered\n * added, removed or modified. They can be used to delay materialization of\n * a tuple set in order to avoid expensive array copies. In addition, the\n * filter functions can serve as value transformers: unlike standard predicate\n * function (which return boolean values), Pulse filters should return the\n * actual tuple value to process. If a tuple set is already filtered, the\n * new filter function will be appended into a conjuntive ('and') query.\n * @param {number} flags - Flags indicating the tuple set(s) to filter.\n * @param {function(*):object} filter - Filter function that will be applied\n *   to the tuple set array, and should return a data tuple if the value\n *   should be included in the tuple set, and falsy (or null) otherwise.\n * @return {Pulse} - Returns this pulse instance.\n */\nprototype.filter = function(flags, filter) {\n  var p = this;\n  if (flags & ADD) p.addF = addFilter(p.addF, filter);\n  if (flags & REM) p.remF = addFilter(p.remF, filter);\n  if (flags & MOD) p.modF = addFilter(p.modF, filter);\n  if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);\n  return p;\n};\n\nfunction addFilter(a, b) {\n  return a ? function(t,i) { return a(t,i) && b(t,i); } : b;\n}\n\n/**\n * Materialize one or more tuple sets in this pulse. If the tuple set(s) have\n * a registered filter function, it will be applied and the tuple set(s) will\n * be replaced with materialized tuple arrays.\n * @param {number} flags - Flags indicating the tuple set(s) to materialize.\n * @return {Pulse} - Returns this pulse instance.\n */\nprototype.materialize = function(flags) {\n  flags = flags || ALL;\n  var p = this;\n  if ((flags & ADD) && p.addF) {\n    p.add = materialize(p.add, p.addF);\n    p.addF = null;\n  }\n  if ((flags & REM) && p.remF) {\n    p.rem = materialize(p.rem, p.remF);\n    p.remF = null;\n  }\n  if ((flags & MOD) && p.modF) {\n    p.mod = materialize(p.mod, p.modF);\n    p.modF = null;\n  }\n  if ((flags & SOURCE) && p.srcF) {\n    p.source = p.source.filter(p.srcF);\n    p.srcF = null;\n  }\n  return p;\n};\n\nfunction materialize(data, filter) {\n  var out = [];\n  visitArray(data, filter, function(_) { out.push(_); });\n  return out;\n}\n\nfunction filter(pulse, flags) {\n  var map = {};\n  pulse.visit(flags, function(t) { map[tupleid(t)] = 1; });\n  return function(t) { return map[tupleid(t)] ? null : t; };\n}\n\n/**\n * Visit one or more tuple sets in this pulse.\n * @param {number} flags - Flags indicating the tuple set(s) to visit.\n *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source\n *   has been set).\n * @param {function(object):*} - Visitor function invoked per-tuple.\n * @return {Pulse} - Returns this pulse instance.\n */\nprototype.visit = function(flags, visitor) {\n  var p = this, v = visitor, src, sum;\n\n  if (flags & SOURCE) {\n    visitArray(p.source, p.srcF, v);\n    return p;\n  }\n\n  if (flags & ADD) visitArray(p.add, p.addF, v);\n  if (flags & REM) visitArray(p.rem, p.remF, v);\n  if (flags & MOD) visitArray(p.mod, p.modF, v);\n\n  if ((flags & REFLOW) && (src = p.source)) {\n    sum = p.add.length + p.mod.length;\n    if (sum === src.length) {\n      // do nothing\n    } else if (sum) {\n      visitArray(src, filter(p, ADD_MOD), v);\n    } else {\n      // if no add/rem/mod tuples, visit source\n      visitArray(src, p.srcF, v);\n    }\n  }\n\n  return p;\n};\n","import Operator from './Operator';\nimport {inherits} from 'vega-util';\n\n/**\n * Abstract class for operators that process data tuples.\n * Subclasses must provide a {@link transform} method for operator processing.\n * @constructor\n * @param {*} [init] - The initial value for this operator.\n * @param {object} [params] - The parameters for this operator.\n * @param {Operator} [source] - The operator from which to receive pulses.\n */\nexport default function Transform(init, params) {\n  Operator.call(this, init, null, params);\n}\n\nvar prototype = inherits(Transform, Operator);\n\n/**\n * Overrides {@link Operator.evaluate} for transform operators.\n * Internally, this method calls {@link evaluate} to perform processing.\n * If {@link evaluate} returns a falsy value, the input pulse is returned.\n * This method should NOT be overridden, instead overrride {@link evaluate}.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return the output pulse for this operator (or StopPropagation)\n */\nprototype.run = function(pulse) {\n  if (pulse.stamp <= this.stamp) return pulse.StopPropagation;\n\n  var rv;\n  if (this.skip()) {\n    this.skip(false);\n  } else {\n    rv = this.evaluate(pulse);\n  }\n  rv = rv || pulse;\n\n  if (rv !== pulse.StopPropagation) this.pulse = rv;\n  this.stamp = pulse.stamp;\n\n  return rv;\n};\n\n/**\n * Overrides {@link Operator.evaluate} for transform operators.\n * Marshalls parameter values and then invokes {@link transform}.\n * @param {Pulse} pulse - the current dataflow pulse.\n * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n     value (including undefined) will let the input pulse pass through.\n */\nprototype.evaluate = function(pulse) {\n  var params = this.marshall(pulse.stamp),\n      out = this.transform(params, pulse);\n  params.clear();\n  return out;\n};\n\n/**\n * Process incoming pulses.\n * Subclasses should override this method to implement transforms.\n * @param {Parameters} _ - The operator parameter values.\n * @param {Pulse} pulse - The current dataflow pulse.\n * @return {Pulse} The output pulse (or StopPropagation). A falsy return\n *   value (including undefined) will let the input pulse pass through.\n */\nprototype.transform = function() {};\n","var TUPLE_ID_KEY = Symbol('vega_id'),\n    TUPLE_ID = 1;\n\n/**\n * Resets the internal tuple id counter to one.\n */\nexport function reset() {\n  TUPLE_ID = 1;\n}\n\n/**\n * Checks if an input value is a registered tuple.\n * @param {*} t - The value to check.\n * @return {boolean} True if the input is a tuple, false otherwise.\n */\nexport function isTuple(t) {\n  return !!(t && tupleid(t));\n}\n\n/**\n * Returns the id of a tuple.\n * @param {object} t - The input tuple.\n * @return {*} the tuple id.\n */\nexport function tupleid(t) {\n  return t[TUPLE_ID_KEY];\n}\n\n/**\n * Sets the id of a tuple.\n * @param {object} t - The input tuple.\n * @param {*} id - The id value to set.\n * @return {object} the input tuple.\n */\nfunction setid(t, id) {\n  t[TUPLE_ID_KEY] = id;\n  return t;\n}\n\n/**\n * Ingest an object or value as a data tuple.\n * If the input value is an object, an id field will be added to it. For\n * efficiency, the input object is modified directly. A copy is not made.\n * If the input value is a literal, it will be wrapped in a new object\n * instance, with the value accessible as the 'data' property.\n * @param datum - The value to ingest.\n * @return {object} The ingested data tuple.\n */\nexport function ingest(datum) {\n  var t = (datum === Object(datum)) ? datum : {data: datum};\n  return tupleid(t) ? t : setid(t, TUPLE_ID++);\n}\n\n/**\n * Given a source tuple, return a derived copy.\n * @param {object} t - The source tuple.\n * @return {object} The derived tuple.\n */\nexport function derive(t) {\n  return rederive(t, ingest({}));\n}\n\n/**\n * Rederive a derived tuple by copying values from the source tuple.\n * @param {object} t - The source tuple.\n * @param {object} d - The derived tuple.\n * @return {object} The derived tuple.\n */\nexport function rederive(t, d) {\n  for (var k in t) d[k] = t[k];\n  return d;\n}\n\n/**\n * Replace an existing tuple with a new tuple.\n * @param {object} t - The existing data tuple.\n * @param {object} d - The new tuple that replaces the old.\n * @return {object} The new tuple.\n */\nexport function replace(t, d) {\n  return setid(d, tupleid(t));\n}\n","import add from './add';\nimport connect from './connect';\nimport events from './events';\nimport {ingest, request} from './load';\nimport on from './on';\nimport {rank, rerank} from './rank';\nimport {run, runAsync, runAfter, enqueue, getPulse} from './run';\nimport {pulse, touch, update} from './update';\nimport changeset from '../ChangeSet';\nimport Heap from '../util/Heap';\nimport UniqueList from '../util/UniqueList';\nimport {loader} from 'vega-loader';\nimport {id, logger, Error} from 'vega-util';\n\n/**\n * A dataflow graph for reactive processing of data streams.\n * @constructor\n */\nexport default function Dataflow() {\n  this._log = logger();\n  this.logLevel(Error);\n\n  this._clock = 0;\n  this._rank = 0;\n  try {\n    this._loader = loader();\n  } catch (e) {\n    // do nothing if loader module is unavailable\n  }\n\n  this._touched = UniqueList(id);\n  this._pulses = {};\n  this._pulse = null;\n\n  this._heap = new Heap(function(a, b) { return a.qrank - b.qrank; });\n  this._postrun = [];\n}\n\nvar prototype = Dataflow.prototype;\n\n/**\n * The current timestamp of this dataflow. This value reflects the\n * timestamp of the previous dataflow run. The dataflow is initialized\n * with a stamp value of 0. The initial run of the dataflow will have\n * a timestap of 1, and so on. This value will match the\n * {@link Pulse.stamp} property.\n * @return {number} - The current timestamp value.\n */\nprototype.stamp = function() {\n  return this._clock;\n};\n\n/**\n * Gets or sets the loader instance to use for data file loading. A\n * loader object must provide a \"load\" method for loading files and a\n * \"sanitize\" method for checking URL/filename validity. Both methods\n * should accept a URI and options hash as arguments, and return a Promise\n * that resolves to the loaded file contents (load) or a hash containing\n * sanitized URI data with the sanitized url assigned to the \"href\" property\n * (sanitize).\n * @param {object} _ - The loader instance to use.\n * @return {object|Dataflow} - If no arguments are provided, returns\n *   the current loader instance. Otherwise returns this Dataflow instance.\n */\nprototype.loader = function(_) {\n  if (arguments.length) {\n    this._loader = _;\n    return this;\n  } else {\n    return this._loader;\n  }\n};\n\n/**\n * Empty entry threshold for garbage cleaning. Map data structures will\n * perform cleaning once the number of empty entries exceeds this value.\n */\nprototype.cleanThreshold = 1e4;\n\n// OPERATOR REGISTRATION\nprototype.add = add;\nprototype.connect = connect;\nprototype.rank = rank;\nprototype.rerank = rerank;\n\n// OPERATOR UPDATES\nprototype.pulse = pulse;\nprototype.touch = touch;\nprototype.update = update;\nprototype.changeset = changeset;\n\n// DATA LOADING\nprototype.ingest = ingest;\nprototype.request = request;\n\n// EVENT HANDLING\nprototype.events = events;\nprototype.on = on;\n\n// PULSE PROPAGATION\nprototype.run = run;\nprototype.runAsync = runAsync;\nprototype.runAfter = runAfter;\nprototype._enqueue = enqueue;\nprototype._getPulse = getPulse;\n\n// LOGGING AND ERROR HANDLING\n\nfunction logMethod(method) {\n  return function() {\n    return this._log[method].apply(this, arguments);\n  };\n}\n\n/**\n * Logs an error message. By default, logged messages are written to console\n * output. The message will only be logged if the current log level is high\n * enough to permit error messages.\n */\nprototype.error = logMethod('error');\n\n/**\n * Logs a warning message. By default, logged messages are written to console\n * output. The message will only be logged if the current log level is high\n * enough to permit warning messages.\n */\nprototype.warn = logMethod('warn');\n\n/**\n * Logs a information message. By default, logged messages are written to\n * console output. The message will only be logged if the current log level is\n * high enough to permit information messages.\n */\nprototype.info = logMethod('info');\n\n/**\n * Logs a debug message. By default, logged messages are written to console\n * output. The message will only be logged if the current log level is high\n * enough to permit debug messages.\n */\nprototype.debug = logMethod('debug');\n\n/**\n * Get or set the current log level. If an argument is provided, it\n * will be used as the new log level.\n * @param {number} [level] - Should be one of None, Warn, Info\n * @return {number} - The current log level.\n */\nprototype.logLevel = logMethod('level');\n","import Operator from '../Operator';\nimport {isFunction} from 'vega-util';\n\n/**\n * Add an operator to the dataflow graph. This function accepts a\n * variety of input argument types. The basic signature supports an\n * initial value, update function and parameters. If the first parameter\n * is an Operator instance, it will be added directly. If it is a\n * constructor for an Operator subclass, a new instance will be instantiated.\n * Otherwise, if the first parameter is a function instance, it will be used\n * as the update function and a null initial value is assumed.\n * @param {*} init - One of: the operator to add, the initial value of\n *   the operator, an operator class to instantiate, or an update function.\n * @param {function} [update] - The operator update function.\n * @param {object} [params] - The operator parameters.\n * @param {boolean} [react=true] - Flag indicating if this operator should\n *   listen for changes to upstream operators included as parameters.\n * @return {Operator} - The added operator.\n */\nexport default function(init, update, params, react) {\n  var shift = 1,\n    op;\n\n  if (init instanceof Operator) {\n    op = init;\n  } else if (init && init.prototype instanceof Operator) {\n    op = new init();\n  } else if (isFunction(init)) {\n    op = new Operator(null, init);\n  } else {\n    shift = 0;\n    op = new Operator(init, update);\n  }\n\n  this.rank(op);\n  if (shift) {\n    react = params;\n    params = update;\n  }\n  if (params) this.connect(op, op.parameters(params, react));\n  this.touch(op);\n\n  return op;\n}\n","/**\n * Connect a target operator as a dependent of source operators.\n * If necessary, this method will rerank the target operator and its\n * dependents to ensure propagation proceeds in a topologically sorted order.\n * @param {Operator} target - The target operator.\n * @param {Array<Operator>} - The source operators that should propagate\n *   to the target operator.\n */\nexport default function(target, sources) {\n  var targetRank = target.rank, i, n;\n\n  for (i=0, n=sources.length; i<n; ++i) {\n    if (targetRank < sources[i].rank) {\n      this.rerank(target);\n      return;\n    }\n  }\n}\n","import {stream} from '../EventStream';\nimport {array} from 'vega-util';\n\n/**\n * Create a new event stream from an event source.\n * @param {object} source - The event source to monitor. The input must\n *  support the addEventListener method.\n * @param {string} type - The event type.\n * @param {function(object): boolean} [filter] - Event filter function.\n * @param {function(object): *} [apply] - Event application function.\n *   If provided, this function will be invoked and the result will be\n *   used as the downstream event value.\n * @return {EventStream}\n */\nexport default function(source, type, filter, apply) {\n  var df = this,\n      s = stream(filter, apply),\n      send = function(e) {\n        e.dataflow = df;\n        try {\n          s.receive(e);\n        } catch (error) {\n          df.error(error);\n        } finally {\n          df.run();\n        }\n      },\n      sources;\n\n  if (typeof source === 'string' && typeof document !== 'undefined') {\n    sources = document.querySelectorAll(source);\n  } else {\n    sources = array(source);\n  }\n\n  for (var i=0, n=sources.length; i<n; ++i) {\n    sources[i].addEventListener(type, send);\n  }\n\n  return s;\n}\n","import {read} from 'vega-loader';\nimport {truthy} from 'vega-util';\n\n/**\n * Ingests new data into the dataflow. First parses the data using the\n * vega-loader read method, then pulses a changeset to the target operator.\n * @param {Operator} target - The Operator to target with ingested data,\n *   typically a Collect transform instance.\n * @param {*} data - The input data, prior to parsing. For JSON this may\n *   be a string or an object. For CSV, TSV, etc should be a string.\n * @param {object} format - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @returns {Dataflow}\n */\nexport function ingest(target, data, format) {\n  return this.pulse(target, this.changeset().insert(read(data, format)));\n}\n\nfunction loadPending(df) {\n  var accept, reject,\n      pending = new Promise(function(a, r) {\n        accept = function() { a(df); };\n        reject = r;\n      });\n\n  pending.requests = 0;\n\n  pending.done = function() {\n    if (--pending.requests === 0) {\n      df.runAfter(function() {\n        df._pending = null;\n        try {\n          df.run();\n          if (df._pending) {\n            df._pending.then(accept);\n          } else {\n            accept();\n          }\n        } catch (err) {\n          reject(err);\n        }\n      });\n    }\n  };\n\n  return (df._pending = pending);\n}\n\n/**\n * Request data from an external source, parse it, and pulse a changeset\n * to the specified target operator.\n * @param {Operator} target - The Operator to target with the loaded data,\n *   typically a Collect transform instance.\n * @param {string} url - The URL from which to load the data. This string\n *   is passed to the vega-loader load method.\n * @param {object} [format] - The data format description for parsing\n *   loaded data. This object is passed to the vega-loader read method.\n * @return {Promise} A Promise that resolves upon completion of the request.\n *   Resolves to a status code: 0 success, -1 load fail, -2 parse fail.\n */\nexport function request(target, url, format) {\n  var df = this,\n      status = 0,\n      pending = df._pending || loadPending(df);\n\n  pending.requests += 1;\n\n  return df.loader()\n    .load(url, {context:'dataflow'})\n    .then(\n      function(data) {\n        return read(data, format);\n      },\n      function(error) {\n        status = -1;\n        df.error('Loading failed', url, error);\n      })\n    .catch(\n      function(error) {\n        status = -2;\n        df.error('Data ingestion failed', url, error);\n      })\n    .then(function(data) {\n      df.pulse(target, df.changeset().remove(truthy).insert(data || []));\n      pending.done();\n      return status;\n    });\n}\n","import Operator from '../Operator';\nimport {isChangeSet} from '../ChangeSet';\nimport {constant, extend, isFunction} from 'vega-util';\n\nvar SKIP = {skip: true};\n\n/**\n * Perform operator updates in response to events. Applies an\n * update function to compute a new operator value. If the update function\n * returns a {@link ChangeSet}, the operator will be pulsed with those tuple\n * changes. Otherwise, the operator value will be updated to the return value.\n * @param {EventStream|Operator} source - The event source to react to.\n *   This argument can be either an EventStream or an Operator.\n * @param {Operator|function(object):Operator} target - The operator to update.\n *   This argument can either be an Operator instance or (if the source\n *   argument is an EventStream), a function that accepts an event object as\n *   input and returns an Operator to target.\n * @param {function(Parameters,Event): *} [update] - Optional update function\n *   to compute the new operator value, or a literal value to set. Update\n *   functions expect to receive a parameter object and event as arguments.\n *   This function can either return a new operator value or (if the source\n *   argument is an EventStream) a {@link ChangeSet} instance to pulse\n *   the target operator with tuple changes.\n * @param {object} [params] - The update function parameters.\n * @param {object} [options] - Additional options hash. If not overridden,\n *   updated operators will be skipped by default.\n * @param {boolean} [options.skip] - If true, the operator will\n *  be skipped: it will not be evaluated, but its dependents will be.\n * @param {boolean} [options.force] - If true, the operator will\n *   be re-evaluated even if its value has not changed.\n * @return {Dataflow}\n */\nexport default function(source, target, update, params, options) {\n  var fn = source instanceof Operator ? onOperator : onStream;\n  fn(this, source, target, update, params, options);\n  return this;\n}\n\nfunction onStream(df, stream, target, update, params, options) {\n  var opt = extend({}, options, SKIP), func, op;\n\n  if (!isFunction(target)) target = constant(target);\n\n  if (update === undefined) {\n    func = function(e) {\n      df.touch(target(e));\n    };\n  } else if (isFunction(update)) {\n    op = new Operator(null, update, params, false);\n    func = function(e) {\n      var v, t = target(e);\n      op.evaluate(e);\n      isChangeSet(v = op.value) ? df.pulse(t, v, options) : df.update(t, v, opt);\n    };\n  } else {\n    func = function(e) {\n      df.update(target(e), update, opt);\n    };\n  }\n\n  stream.apply(func);\n}\n\nfunction onOperator(df, source, target, update, params, options) {\n  var func, op;\n\n  if (update === undefined) {\n    op = target;\n  } else {\n    func = isFunction(update) ? update : constant(update);\n    update = !target ? func : function(_, pulse) {\n      var value = func(_, pulse);\n      if (!target.skip()) {\n        target.skip(value !== this.value).value = value;\n      }\n      return value;\n    };\n\n    op = new Operator(null, update, params, false);\n    op.modified(options && options.force);\n    op.rank = 0;\n\n    if (target) {\n      op.skip(true); // skip first invocation\n      op.value = target.value;\n      op.targets().add(target);\n    }\n  }\n\n  source.targets().add(op);\n}\n","import {error} from 'vega-util';\n\n/**\n * Assigns a rank to an operator. Ranks are assigned in increasing order\n * by incrementing an internal rank counter.\n * @param {Operator} op - The operator to assign a rank.\n */\nexport function rank(op) {\n  op.rank = ++this._rank;\n}\n\n/**\n * Re-ranks an operator and all downstream target dependencies. This\n * is necessary when upstream depencies of higher rank are added to\n * a target operator.\n * @param {Operator} op - The operator to re-rank.\n */\nexport function rerank(op) {\n  var queue = [op],\n      cur, list, i;\n\n  while (queue.length) {\n    this.rank(cur = queue.pop());\n    if (list = cur._targets) {\n      for (i=list.length; --i >= 0;) {\n        queue.push(cur = list[i]);\n        if (cur === op) error('Cycle detected in dataflow graph.');\n      }\n    }\n  }\n}\n","import {default as Pulse, StopPropagation} from '../Pulse';\nimport MultiPulse from '../MultiPulse';\nimport UniqueList from '../util/UniqueList';\nimport {id, isArray, Info, Debug} from 'vega-util';\n\n/**\n * Runs the dataflow. This method will increment the current timestamp\n * and process all updated, pulsed and touched operators. When run for\n * the first time, all registered operators will be processed. If there\n * are pending data loading operations, this method will return immediately\n * without evaluating the dataflow. Instead, the dataflow will be\n * asynchronously invoked when data loading completes. To track when dataflow\n * evaluation completes, use the {@link runAsync} method instead.\n * @param {string} [encode] - The name of an encoding set to invoke during\n *   propagation. This value is added to generated Pulse instances;\n *   operators can then respond to (or ignore) this setting as appropriate.\n *   This parameter can be used in conjunction with the Encode transform in\n *   the vega-encode module.\n */\nexport function run(encode) {\n  var df = this,\n      count = 0,\n      level = df.logLevel(),\n      op, next, dt, error;\n\n  if (df._pending) {\n    df.info('Awaiting requests, delaying dataflow run.');\n    return 0;\n  }\n\n  if (df._pulse) {\n    df.error('Dataflow invoked recursively. Use the runAfter method to queue invocation.');\n    return 0;\n  }\n\n  if (!df._touched.length) {\n    df.info('Dataflow invoked, but nothing to do.');\n    return 0;\n  }\n\n  df._pulse = new Pulse(df, ++df._clock, encode);\n\n  if (level >= Info) {\n    dt = Date.now();\n    df.debug('-- START PROPAGATION (' + df._clock + ') -----');\n  }\n\n  // initialize queue, reset touched operators\n  df._touched.forEach(function(op) { df._enqueue(op, true); });\n  df._touched = UniqueList(id);\n\n  try {\n    while (df._heap.size() > 0) {\n      op = df._heap.pop();\n\n      // re-queue if rank changes\n      if (op.rank !== op.qrank) { df._enqueue(op, true); continue; }\n\n      // otherwise, evaluate the operator\n      next = op.run(df._getPulse(op, encode));\n\n      if (level >= Debug) {\n        df.debug(op.id, next === StopPropagation ? 'STOP' : next, op);\n      }\n\n      // propagate the pulse\n      if (next !== StopPropagation) {\n        df._pulse = next;\n        if (op._targets) op._targets.forEach(function(op) { df._enqueue(op); });\n      }\n\n      // increment visit counter\n      ++count;\n    }\n  } catch (err) {\n    error = err;\n  }\n\n  // reset pulse map\n  df._pulses = {};\n  df._pulse = null;\n\n  if (level >= Info) {\n    dt = Date.now() - dt;\n    df.info('> Pulse ' + df._clock + ': ' + count + ' operators; ' + dt + 'ms');\n  }\n\n  if (error) {\n    df._postrun = [];\n    df.error(error);\n  }\n\n  if (df._onrun) {\n    try { df._onrun(df, count, error); } catch (err) { df.error(err); }\n  }\n\n  // invoke callbacks queued via runAfter\n  if (df._postrun.length) {\n    var postrun = df._postrun;\n    df._postrun = [];\n    postrun\n      .sort(function(a, b) { return b.priority - a.priority; })\n      .forEach(function(_) { invokeCallback(df, _.callback); });\n  }\n\n  return this;\n}\n\nfunction invokeCallback(df, callback) {\n  try { callback(df); } catch (err) { df.error(err); }\n}\n\n/**\n * Runs the dataflow and returns a Promise that resolves when the\n * propagation cycle completes. The standard run method may exit early\n * if there are pending data loading operations. In contrast, this\n * method returns a Promise to allow callers to receive notification\n * when dataflow evaluation completes.\n * @return {Promise} - A promise that resolves to this dataflow.\n */\nexport function runAsync() {\n  // return this._pending || Promise.resolve(this.run());\n  return this._pending\n    || (this.run() && this._pending)\n    || Promise.resolve(this);\n}\n\n/**\n * Schedules a callback function to be invoked after the current pulse\n * propagation completes. If no propagation is currently occurring,\n * the function is invoked immediately.\n * @param {function(Dataflow)} callback - The callback function to run.\n *   The callback will be invoked with this Dataflow instance as its\n *   sole argument.\n * @param {boolean} enqueue - A boolean flag indicating that the\n *   callback should be queued up to run after the next propagation\n *   cycle, suppressing immediate invocation when propagation is not\n *   currently occurring.\n */\nexport function runAfter(callback, enqueue, priority) {\n  if (this._pulse || enqueue) {\n    // pulse propagation is currently running, queue to run after\n    this._postrun.push({\n      priority: priority || 0,\n      callback: callback\n    });\n  } else {\n    // pulse propagation already complete, invoke immediately\n    invokeCallback(this, callback);\n  }\n}\n\n/**\n * Enqueue an operator into the priority queue for evaluation. The operator\n * will be enqueued if it has no registered pulse for the current cycle, or if\n * the force argument is true. Upon enqueue, this method also sets the\n * operator's qrank to the current rank value.\n * @param {Operator} op - The operator to enqueue.\n * @param {boolean} [force] - A flag indicating if the operator should be\n *   forceably added to the queue, even if it has already been previously\n *   enqueued during the current pulse propagation. This is useful when the\n *   dataflow graph is dynamically modified and the operator rank changes.\n */\nexport function enqueue(op, force) {\n  var p = !this._pulses[op.id];\n  if (p) this._pulses[op.id] = this._pulse;\n  if (p || force) {\n    op.qrank = op.rank;\n    this._heap.push(op);\n  }\n}\n\n/**\n * Provide a correct pulse for evaluating an operator. If the operator has an\n * explicit source operator, we will try to pull the pulse(s) from it.\n * If there is an array of source operators, we build a multi-pulse.\n * Otherwise, we return a current pulse with correct source data.\n * If the pulse is the pulse map has an explicit target set, we use that.\n * Else if the pulse on the upstream source operator is current, we use that.\n * Else we use the pulse from the pulse map, but copy the source tuple array.\n * @param {Operator} op - The operator for which to get an input pulse.\n * @param {string} [encode] - An (optional) encoding set name with which to\n *   annotate the returned pulse. See {@link run} for more information.\n */\nexport function getPulse(op, encode) {\n  var s = op.source,\n      stamp = this._clock,\n      p;\n\n  if (s && isArray(s)) {\n    p = s.map(function(_) { return _.pulse; });\n    return new MultiPulse(this, stamp, p, encode);\n  }\n\n  p = this._pulses[op.id];\n  if (s) {\n    s = s.pulse;\n    if (!s || s === StopPropagation) {\n      p.source = [];\n    } else if (s.stamp === stamp && p.target !== op) {\n      p = s;\n    } else {\n      p.source = s.source;\n    }\n  }\n\n  return p;\n}\n","import Pulse from '../Pulse';\n\nvar NO_OPT = {skip: false, force: false};\n\n/**\n * Touches an operator, scheduling it to be evaluated. If invoked outside of\n * a pulse propagation, the operator will be evaluated the next time this\n * dataflow is run. If invoked in the midst of pulse propagation, the operator\n * will be queued for evaluation if and only if the operator has not yet been\n * evaluated on the current propagation timestamp.\n * @param {Operator} op - The operator to touch.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\nexport function touch(op, options) {\n  var opt = options || NO_OPT;\n  if (this._pulse) {\n    // if in midst of propagation, add to priority queue\n    this._enqueue(op);\n  } else {\n    // otherwise, queue for next propagation\n    this._touched.add(op);\n  }\n  if (opt.skip) op.skip(true);\n  return this;\n}\n\n/**\n * Updates the value of the given operator.\n * @param {Operator} op - The operator to update.\n * @param {*} value - The value to set.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.force] - If true, the operator will\n *   be re-evaluated even if its value has not changed.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\nexport function update(op, value, options) {\n  var opt = options || NO_OPT;\n  if (op.set(value) || opt.force) {\n    this.touch(op, opt);\n  }\n  return this;\n}\n\n/**\n * Pulses an operator with a changeset of tuples. If invoked outside of\n * a pulse propagation, the pulse will be applied the next time this\n * dataflow is run. If invoked in the midst of pulse propagation, the pulse\n * will be added to the set of active pulses and will be applied if and\n * only if the target operator has not yet been evaluated on the current\n * propagation timestamp.\n * @param {Operator} op - The operator to pulse.\n * @param {ChangeSet} value - The tuple changeset to apply.\n * @param {object} [options] - Additional options hash.\n * @param {boolean} [options.skip] - If true, the operator will\n *   be skipped: it will not be evaluated, but its dependents will be.\n * @return {Dataflow}\n */\nexport function pulse(op, changeset, options) {\n  this.touch(op, options || NO_OPT);\n\n  var p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),\n      t = op.pulse && op.pulse.source || [];\n  p.target = op;\n  this._pulses[op.id] = changeset.pulse(p, t);\n\n  return this;\n}\n","export var transforms = {};\n\nexport function definition(type) {\n  var t = transform(type);\n  return t && t.Definition || null;\n}\n\nexport function transform(type) {\n  type = type && type.toLowerCase();\n  return transforms.hasOwnProperty(type) ? transforms[type] : null;\n}\n","export default function Heap(comparator) {\n  this.cmp = comparator;\n  this.nodes = [];\n}\n\nvar prototype = Heap.prototype;\n\nprototype.size = function() {\n  return this.nodes.length;\n};\n\nprototype.clear = function() {\n  this.nodes = [];\n  return this;\n};\n\nprototype.peek = function() {\n  return this.nodes[0];\n};\n\nprototype.push = function(x) {\n  var array = this.nodes;\n  array.push(x);\n  return siftdown(array, 0, array.length-1, this.cmp);\n};\n\nprototype.pop = function() {\n  var array = this.nodes,\n      last = array.pop(),\n      item;\n\n  if (array.length) {\n    item = array[0];\n    array[0] = last;\n    siftup(array, 0, this.cmp);\n  } else {\n    item = last;\n  }\n  return item;\n};\n\nprototype.replace = function(item) {\n  var array = this.nodes,\n      retval = array[0];\n  array[0] = item;\n  siftup(array, 0, this.cmp);\n  return retval;\n};\n\nprototype.pushpop = function(item) {\n  var array = this.nodes, ref = array[0];\n  if (array.length && this.cmp(ref, item) < 0) {\n    array[0] = item;\n    item = ref;\n    siftup(array, 0, this.cmp);\n  }\n  return item;\n};\n\nfunction siftdown(array, start, idx, cmp) {\n  var item, parent, pidx;\n\n  item = array[idx];\n  while (idx > start) {\n    pidx = (idx - 1) >> 1;\n    parent = array[pidx];\n    if (cmp(item, parent) < 0) {\n      array[idx] = parent;\n      idx = pidx;\n      continue;\n    }\n    break;\n  }\n  return (array[idx] = item);\n}\n\nfunction siftup(array, idx, cmp) {\n  var start = idx,\n      end = array.length,\n      item = array[idx],\n      cidx = 2 * idx + 1, ridx;\n\n  while (cidx < end) {\n    ridx = cidx + 1;\n    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {\n      cidx = ridx;\n    }\n    array[idx] = array[cidx];\n    idx = cidx;\n    cidx = 2 * idx + 1;\n  }\n  array[idx] = item;\n  return siftdown(array, start, idx, cmp);\n}\n","import {identity} from 'vega-util';\n\nexport default function UniqueList(idFunc) {\n  var $ = idFunc || identity,\n      list = [],\n      ids = {};\n\n  list.add = function(_) {\n    var id = $(_);\n    if (!ids[id]) {\n      ids[id] = 1;\n      list.push(_);\n    }\n    return list;\n  };\n\n  list.remove = function(_) {\n    var id = $(_), idx;\n    if (ids[id]) {\n      ids[id] = 0;\n      if ((idx = list.indexOf(_)) >= 0) {\n        list.splice(idx, 1);\n      }\n    }\n    return list;\n  };\n\n  return list;\n}\n","export {default as axisticks} from './src/AxisTicks';\nexport {default as datajoin} from './src/DataJoin';\nexport {default as encode} from './src/Encode';\nexport {default as legendentries} from './src/LegendEntries';\nexport {default as linkpath} from './src/LinkPath';\nexport {default as pie} from './src/Pie';\nexport {default as scale} from './src/Scale';\nexport {default as sortitems} from './src/SortItems';\nexport {default as stack} from './src/Stack';\nexport {validTicks} from './src/ticks';\n","import {tickCount, tickFormat, tickValues, validTicks} from './ticks';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Generates axis ticks for visualizing a spatial scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate ticks for.\n * @param {*} [params.count=10] - The approximate number of ticks, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {function(*):string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid d3 4.0 format specifier.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\nexport default function AxisTicks(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(AxisTicks, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (this.value && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      ticks = this.value,\n      scale = _.scale,\n      count = _.count == null ? (_.values ? _.values.length : 10) : tickCount(scale, _.count),\n      format = _.format || tickFormat(scale, count, _.formatSpecifier),\n      values = _.values ? validTicks(scale, _.values, count) : tickValues(scale, count);\n\n  if (ticks) out.rem = ticks;\n\n  ticks = values.map(function(value, i) {\n    return ingest({\n      index: i / (values.length - 1),\n      value: value,\n      label: format(value)\n    });\n  });\n\n  if (_.extra && ticks.length) {\n    // add an extra tick pegged to the initial domain value\n    // this is used to generate axes with 'binned' domains\n    ticks.push(ingest({\n      index: -1,\n      extra: {value: ticks[0].value},\n      label: ''\n    }));\n  }\n\n  out.source = ticks;\n  out.add = ticks;\n  this.value = ticks;\n\n  return out;\n};\n","import {Transform, ingest, tupleid} from 'vega-dataflow';\nimport {error, fastmap, inherits, isArray} from 'vega-util';\n\n/**\n * Joins a set of data elements against a set of visual items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): object} [params.item] - An item generator function.\n * @param {function(object): *} [params.key] - The key field associating data and visual items.\n */\nexport default function DataJoin(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(DataJoin, Transform);\n\nfunction defaultItemCreate() {\n  return ingest({});\n}\n\nfunction isExit(t) {\n  return t.exit;\n}\n\nprototype.transform = function(_, pulse) {\n  var df = pulse.dataflow,\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      item = _.item || defaultItemCreate,\n      key = _.key || tupleid,\n      map = this.value;\n\n  // prevent transient (e.g., hover) requests from\n  // cascading across marks derived from marks\n  if (isArray(out.encode)) {\n    out.encode = null;\n  }\n\n  if (map && (_.modified('key') || pulse.modified(key))) {\n    error('DataJoin does not support modified key function or fields.');\n  }\n\n  if (!map) {\n    pulse = pulse.addAll();\n    this.value = map = fastmap().test(isExit);\n    map.lookup = function(t) { return map.get(key(t)); };\n  }\n\n  pulse.visit(pulse.ADD, function(t) {\n    var k = key(t),\n        x = map.get(k);\n\n    if (x) {\n      if (x.exit) {\n        map.empty--;\n        out.add.push(x);\n      } else {\n        out.mod.push(x);\n      }\n    } else {\n      map.set(k, (x = item(t)));\n      out.add.push(x);\n    }\n\n    x.datum = t;\n    x.exit = false;\n  });\n\n  pulse.visit(pulse.MOD, function(t) {\n    var k = key(t),\n        x = map.get(k);\n\n    if (x) {\n      x.datum = t;\n      out.mod.push(x);\n    }\n  });\n\n  pulse.visit(pulse.REM, function(t) {\n    var k = key(t),\n        x = map.get(k);\n\n    if (t === x.datum && !x.exit) {\n      out.rem.push(x);\n      x.exit = true;\n      ++map.empty;\n    }\n  });\n\n  if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');\n\n  if (_.clean && map.empty > df.cleanThreshold) df.runAfter(map.clean);\n\n  return out;\n};\n","import {Transform} from 'vega-dataflow';\nimport {falsy, inherits, isArray} from 'vega-util';\n\n/**\n * Invokes encoding functions for visual items.\n * @constructor\n * @param {object} params - The parameters to the encoding functions. This\n *   parameter object will be passed through to all invoked encoding functions.\n * @param {object} param.encoders - The encoding functions\n * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set\n * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set\n * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set\n */\nexport default function Encode(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Encode, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.ADD_REM),\n      encoders = _.encoders,\n      encode = pulse.encode;\n\n  // if an array, the encode directive includes additional sets\n  // that must be defined in order for the primary set to be invoked\n  // e.g., only run the update set if the hover set is defined\n  if (isArray(encode)) {\n    if (out.changed() || encode.every(function(e) { return encoders[e]; })) {\n      encode = encode[0];\n      out.encode = null; // consume targeted encode directive\n    } else {\n      return pulse.StopPropagation;\n    }\n  }\n\n  // marshall encoder functions\n  var reenter = encode === 'enter',\n      update = encoders.update || falsy,\n      enter = encoders.enter || falsy,\n      exit = encoders.exit || falsy,\n      set = (encode && !reenter ? encoders[encode] : update) || falsy;\n\n  if (pulse.changed(pulse.ADD)) {\n    pulse.visit(pulse.ADD, function(t) {\n      enter(t, _);\n      update(t, _);\n      if (set !== falsy && set !== update) set(t, _);\n    });\n    out.modifies(enter.output);\n    out.modifies(update.output);\n    if (set !== falsy && set !== update) out.modifies(set.output);\n  }\n\n  if (pulse.changed(pulse.REM) && exit !== falsy) {\n    pulse.visit(pulse.REM, function(t) { exit(t, _); });\n    out.modifies(exit.output);\n  }\n\n  if (reenter || set !== falsy) {\n    var flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);\n    if (reenter) {\n      pulse.visit(flag, function(t) {\n        var mod = enter(t, _);\n        if (set(t, _) || mod) out.mod.push(t);\n      });\n      if (out.mod.length) out.modifies(enter.output);\n    } else {\n      pulse.visit(flag, function(t) {\n        if (set(t, _)) out.mod.push(t);\n      });\n    }\n    if (out.mod.length) out.modifies(set.output);\n  }\n\n  return out.changed() ? out : pulse.StopPropagation;\n};\n","import {labelFormat, labelFraction, labelValues} from './labels';\nimport {Symbols, Gradient} from './legend-types';\nimport {tickCount, tickFormat} from './ticks';\nimport {Transform, ingest} from 'vega-dataflow';\nimport {scaleFraction} from 'vega-scale';\nimport {constant, inherits, isFunction, peek} from 'vega-util';\n\n/**\n * Generates legend entries for visualizing a scale.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Scale} params.scale - The scale to generate items for.\n * @param {*} [params.count=5] - The approximate number of items, or\n *   desired tick interval, to use.\n * @param {Array<*>} [params.values] - The exact tick values to use.\n *   These must be legal domain values for the provided scale.\n *   If provided, the count argument is ignored.\n * @param {string} [params.formatSpecifier] - A format specifier\n *   to use in conjunction with scale.tickFormat. Legal values are\n *   any valid D3 format specifier string.\n * @param {function(*):string} [params.format] - The format function to use.\n *   If provided, the formatSpecifier argument is ignored.\n */\nexport default function LegendEntries(params) {\n  Transform.call(this, [], params);\n}\n\nvar prototype = inherits(LegendEntries, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (this.value != null && !_.modified()) {\n    return pulse.StopPropagation;\n  }\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      items = this.value,\n      type  = _.type || Symbols,\n      scale = _.scale,\n      count = _.count == null ? 5 : tickCount(scale, _.count),\n      format = _.format || tickFormat(scale, count, _.formatSpecifier),\n      values = _.values || labelValues(scale, count, type),\n      domain, fraction, size, offset;\n\n  format = labelFormat(scale, format, type);\n  if (items) out.rem = items;\n\n  if (type === Symbols) {\n    if (isFunction(size = _.size)) {\n      // if first value maps to size zero, remove from list (vega#717)\n      if (!_.values && scale(values[0]) === 0) {\n        values = values.slice(1);\n      }\n      // compute size offset for legend entries\n      offset = values.reduce(function(max, value) {\n        return Math.max(max, size(value, _));\n      }, 0);\n    } else {\n      size = constant(offset = size || 8);\n    }\n\n    items = values.map(function(value, index) {\n      return ingest({\n        index:  index,\n        label:  format(value, index, values),\n        value:  value,\n        offset: offset,\n        size:   size(value, _)\n      });\n    });\n  }\n\n  else if (type === Gradient) {\n    domain = scale.domain(),\n    fraction = scaleFraction(scale, domain[0], peek(domain));\n\n    // if automatic label generation produces 2 or fewer values,\n    // use the domain end points instead (fixes vega/vega#1364)\n    if (values.length < 3 && !_.values && domain[0] !== peek(domain)) {\n      values = [domain[0], peek(domain)];\n    }\n\n    items = values.map(function(value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc:  fraction(value)\n      });\n    });\n  }\n\n  else {\n    size = values.length - 1;\n    fraction = labelFraction(scale);\n\n    items = values.map(function(value, index) {\n      return ingest({\n        index: index,\n        label: format(value, index, values),\n        value: value,\n        perc:  index ? fraction(value) : 0,\n        perc2: index === size ? 1 : fraction(values[index+1])\n      });\n    });\n  }\n\n  out.source = items;\n  out.add = items;\n  this.value = items;\n\n  return out;\n};\n","import {Transform} from 'vega-dataflow';\nimport {error, fastmap, inherits} from 'vega-util';\n\nvar Paths = fastmap({\n  'line': line,\n  'line-radial': lineR,\n  'arc': arc,\n  'arc-radial': arcR,\n  'curve': curve,\n  'curve-radial': curveR,\n  'orthogonal-horizontal': orthoX,\n  'orthogonal-vertical': orthoY,\n  'orthogonal-radial': orthoR,\n  'diagonal-horizontal': diagonalX,\n  'diagonal-vertical': diagonalY,\n  'diagonal-radial': diagonalR\n});\n\nfunction sourceX(t) { return t.source.x; }\nfunction sourceY(t) { return t.source.y; }\nfunction targetX(t) { return t.target.x; }\nfunction targetY(t) { return t.target.y; }\n\n /**\n  * Layout paths linking source and target elements.\n  * @constructor\n  * @param {object} params - The parameters for this operator.\n  */\nexport default function LinkPath(params) {\n  Transform.call(this, {}, params);\n}\n\nLinkPath.Definition = {\n  \"type\": \"LinkPath\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"sourceX\", \"type\": \"field\", \"default\": \"source.x\" },\n    { \"name\": \"sourceY\", \"type\": \"field\", \"default\": \"source.y\" },\n    { \"name\": \"targetX\", \"type\": \"field\", \"default\": \"target.x\" },\n    { \"name\": \"targetY\", \"type\": \"field\", \"default\": \"target.y\" },\n    { \"name\": \"orient\", \"type\": \"enum\", \"default\": \"vertical\",\n      \"values\": [\"horizontal\", \"vertical\", \"radial\"] },\n    { \"name\": \"shape\", \"type\": \"enum\", \"default\": \"line\",\n      \"values\": [\"line\", \"arc\", \"curve\", \"diagonal\", \"orthogonal\"] },\n    { \"name\": \"require\", \"type\": \"signal\" },\n    { \"name\": \"as\", \"type\": \"string\", \"default\": \"path\" }\n  ]\n};\n\nvar prototype = inherits(LinkPath, Transform);\n\nprototype.transform = function(_, pulse) {\n  var sx = _.sourceX || sourceX,\n      sy = _.sourceY || sourceY,\n      tx = _.targetX || targetX,\n      ty = _.targetY || targetY,\n      as = _.as || 'path',\n      orient = _.orient || 'vertical',\n      shape = _.shape || 'line',\n      path = Paths.get(shape + '-' + orient) || Paths.get(shape);\n\n  if (!path) {\n    error('LinkPath unsupported type: ' + _.shape\n      + (_.orient ? '-' + _.orient : ''));\n  }\n\n  pulse.visit(pulse.SOURCE, function(t) {\n    t[as] = path(sx(t), sy(t), tx(t), ty(t));\n  });\n\n  return pulse.reflow(_.modified()).modifies(as);\n};\n\n// -- Link Path Generation Methods -----\n\nfunction line(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'L' + tx + ',' + ty;\n}\n\nfunction lineR(sa, sr, ta, tr) {\n  return line(\n    sr * Math.cos(sa), sr * Math.sin(sa),\n    tr * Math.cos(ta), tr * Math.sin(ta)\n  );\n}\n\nfunction arc(sx, sy, tx, ty) {\n  var dx = tx - sx,\n      dy = ty - sy,\n      rr = Math.sqrt(dx * dx + dy * dy) / 2,\n      ra = 180 * Math.atan2(dy, dx) / Math.PI;\n  return 'M' + sx + ',' + sy +\n         'A' + rr + ',' + rr +\n         ' ' + ra + ' 0 1' +\n         ' ' + tx + ',' + ty;\n}\n\nfunction arcR(sa, sr, ta, tr) {\n  return arc(\n    sr * Math.cos(sa), sr * Math.sin(sa),\n    tr * Math.cos(ta), tr * Math.sin(ta)\n  );\n}\n\nfunction curve(sx, sy, tx, ty) {\n  var dx = tx - sx,\n      dy = ty - sy,\n      ix = 0.2 * (dx + dy),\n      iy = 0.2 * (dy - dx);\n  return 'M' + sx + ',' + sy +\n         'C' + (sx+ix) + ',' + (sy+iy) +\n         ' ' + (tx+iy) + ',' + (ty-ix) +\n         ' ' + tx + ',' + ty;\n}\n\nfunction curveR(sa, sr, ta, tr) {\n  return curve(\n    sr * Math.cos(sa), sr * Math.sin(sa),\n    tr * Math.cos(ta), tr * Math.sin(ta)\n  );\n}\n\nfunction orthoX(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'V' + ty + 'H' + tx;\n}\n\nfunction orthoY(sx, sy, tx, ty) {\n  return 'M' + sx + ',' + sy +\n         'H' + tx + 'V' + ty;\n}\n\nfunction orthoR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n      ss = Math.sin(sa),\n      tc = Math.cos(ta),\n      ts = Math.sin(ta),\n      sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;\n  return 'M' + (sr*sc) + ',' + (sr*ss) +\n         'A' + sr + ',' + sr + ' 0 0,' + (sf?1:0) +\n         ' ' + (sr*tc) + ',' + (sr*ts) +\n         'L' + (tr*tc) + ',' + (tr*ts);\n}\n\nfunction diagonalX(sx, sy, tx, ty) {\n  var m = (sx + tx) / 2;\n  return 'M' + sx + ',' + sy +\n         'C' + m  + ',' + sy +\n         ' ' + m  + ',' + ty +\n         ' ' + tx + ',' + ty;\n}\n\nfunction diagonalY(sx, sy, tx, ty) {\n  var m = (sy + ty) / 2;\n  return 'M' + sx + ',' + sy +\n         'C' + sx + ',' + m +\n         ' ' + tx + ',' + m +\n         ' ' + tx + ',' + ty;\n}\n\nfunction diagonalR(sa, sr, ta, tr) {\n  var sc = Math.cos(sa),\n      ss = Math.sin(sa),\n      tc = Math.cos(ta),\n      ts = Math.sin(ta),\n      mr = (sr + tr) / 2;\n  return 'M' + (sr*sc) + ',' + (sr*ss) +\n         'C' + (mr*sc) + ',' + (mr*ss) +\n         ' ' + (mr*tc) + ',' + (mr*ts) +\n         ' ' + (tr*tc) + ',' + (tr*ts);\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits, one} from 'vega-util';\nimport {range, sum} from 'd3-array';\n\n/**\n * Pie and donut chart layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size pie segments.\n * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.\n * @param {number} [params.endAngle=2] - The end angle (in radians) of the layout.\n * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.\n */\nexport default function Pie(params) {\n  Transform.call(this, null, params);\n}\n\nPie.Definition = {\n  \"type\": \"Pie\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\" },\n    { \"name\": \"startAngle\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"endAngle\", \"type\": \"number\", \"default\": 6.283185307179586 },\n    { \"name\": \"sort\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"startAngle\", \"endAngle\"] }\n  ]\n};\n\nvar prototype = inherits(Pie, Transform);\n\nprototype.transform = function(_, pulse) {\n  var as = _.as || ['startAngle', 'endAngle'],\n      startAngle = as[0],\n      endAngle = as[1],\n      field = _.field || one,\n      start = _.startAngle || 0,\n      stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,\n      data = pulse.source,\n      values = data.map(field),\n      n = values.length,\n      a = start,\n      k = (stop - start) / sum(values),\n      index = range(n),\n      i, t, v;\n\n  if (_.sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<n; ++i) {\n    v = values[index[i]];\n    t = data[index[i]];\n    t[startAngle] = a;\n    t[endAngle] = (a += v * k);\n  }\n\n  this.value = values;\n  return pulse.reflow(_.modified()).modifies(as);\n};\n","import {tickCount} from './ticks';\nimport {Transform} from 'vega-dataflow';\nimport {\n  error, inherits, isFunction, peek, stringValue,\n  toSet, zoomLinear, zoomLog, zoomPow\n} from 'vega-util';\n\nimport {\n  Ordinal, Band, Point,\n  Linear, Log, Pow, Sqrt, Sequential,\n  Quantile, Quantize, Threshold, BinOrdinal,\n  Time, Utc\n} from './scale-types';\n\nimport {\n  bandSpace,\n  interpolateRange,\n  interpolate as getInterpolate,\n  scale as getScale,\n  scheme as getScheme,\n  scaleImplicit\n} from 'vega-scale';\n\nimport {\n  interpolate,\n  interpolateRgbBasis,\n  interpolateRound\n} from 'd3-interpolate';\n\nvar DEFAULT_COUNT = 5;\n\nvar INCLUDE_ZERO = toSet([Linear, Pow, Sqrt]);\n\nvar INCLUDE_PAD = toSet([Linear, Log, Pow, Sqrt, Time, Utc]);\n\nvar SKIP = toSet([\n  'set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount',\n  'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero',\n  'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma'\n]);\n\n/**\n * Maintains a scale function mapping data values to visual channels.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nexport default function Scale(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\nvar prototype = inherits(Scale, Transform);\n\nprototype.transform = function(_, pulse) {\n  var df = pulse.dataflow,\n      scale = this.value,\n      prop;\n\n  if (!scale || _.modified('type')) {\n    this.value = scale = getScale((_.type || Linear).toLowerCase())();\n  }\n\n  for (prop in _) if (!SKIP[prop]) {\n    // padding is a scale property for band/point but not others\n    if (prop === 'padding' && INCLUDE_PAD[scale.type]) continue;\n    // invoke scale property setter, raise warning if not found\n    isFunction(scale[prop])\n      ? scale[prop](_[prop])\n      : df.warn('Unsupported scale property: ' + prop);\n  }\n\n  configureRange(scale, _, configureDomain(scale, _, df));\n\n  return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n};\n\nfunction configureDomain(scale, _, df) {\n  // check raw domain, if provided use that and exit early\n  var raw = rawDomain(scale, _.domainRaw, df);\n  if (raw > -1) return raw;\n\n  var domain = _.domain,\n      type = scale.type,\n      zero = _.zero || (_.zero === undefined && INCLUDE_ZERO[type]),\n      n, mid;\n\n  if (!domain) return 0;\n\n  // adjust continuous domain for minimum pixel padding\n  if (INCLUDE_PAD[type] && _.padding && domain[0] !== peek(domain)) {\n    domain = padDomain(type, domain, _.range, _.padding, _.exponent);\n  }\n\n  // adjust domain based on zero, min, max settings\n  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {\n    n = ((domain = domain.slice()).length - 1) || 1;\n    if (zero) {\n      if (domain[0] > 0) domain[0] = 0;\n      if (domain[n] < 0) domain[n] = 0;\n    }\n    if (_.domainMin != null) domain[0] = _.domainMin;\n    if (_.domainMax != null) domain[n] = _.domainMax;\n\n    if (_.domainMid != null) {\n      mid = _.domainMid;\n      if (mid < domain[0] || mid > domain[n]) {\n        df.warn('Scale domainMid exceeds domain min or max.', mid);\n      }\n      domain.splice(n, 0, mid);\n    }\n  }\n\n  // set the scale domain\n  scale.domain(domainCheck(type, domain, df));\n\n  // if ordinal scale domain is defined, prevent implicit\n  // domain construction as side-effect of scale lookup\n  if (type === Ordinal) {\n    scale.unknown(_.domainImplicit ? scaleImplicit : undefined);\n  }\n\n  // perform 'nice' adjustment as requested\n  if (_.nice && scale.nice) {\n    scale.nice((_.nice !== true && tickCount(scale, _.nice)) || null);\n  }\n\n  // return the cardinality of the domain\n  return domain.length;\n}\n\nfunction rawDomain(scale, raw, df) {\n  if (raw) {\n    scale.domain(domainCheck(scale.type, raw, df));\n    return raw.length;\n  } else {\n    return -1;\n  }\n}\n\nfunction padDomain(type, domain, range, pad, exponent) {\n  var span = Math.abs(peek(range) - range[0]),\n      frac = span / (span - 2 * pad),\n      d = type === Log  ? zoomLog(domain, null, frac)\n        : type === Sqrt ? zoomPow(domain, null, frac, 0.5)\n        : type === Pow  ? zoomPow(domain, null, frac, exponent)\n        : zoomLinear(domain, null, frac);\n\n  domain = domain.slice();\n  domain[0] = d[0];\n  domain[domain.length-1] = d[1];\n  return domain;\n}\n\nfunction domainCheck(type, domain, df) {\n  if (type === Log) {\n    // sum signs of domain values\n    // if all pos or all neg, abs(sum) === domain.length\n    var s = Math.abs(domain.reduce(function(s, v) {\n      return s + (v < 0 ? -1 : v > 0 ? 1 : 0);\n    }, 0));\n\n    if (s !== domain.length) {\n      df.warn('Log scale domain includes zero: ' + stringValue(domain));\n    }\n  }\n  return domain;\n}\n\nfunction configureRange(scale, _, count) {\n  var round = _.round || false,\n      range = _.range;\n\n  // if range step specified, calculate full range extent\n  if (_.rangeStep != null) {\n    range = configureRangeStep(scale.type, _, count);\n  }\n\n  // else if a range scheme is defined, use that\n  else if (_.scheme) {\n    range = configureScheme(scale.type, _, count);\n    if (isFunction(range)) return scale.interpolator(range);\n  }\n\n  // given a range array for a sequential scale, convert to interpolator\n  else if (range && scale.type === Sequential) {\n    return scale.interpolator(interpolateRgbBasis(flip(range, _.reverse)));\n  }\n\n  // configure rounding / interpolation\n  if (range && _.interpolate && scale.interpolate) {\n    scale.interpolate(getInterpolate(_.interpolate, _.interpolateGamma));\n  } else if (isFunction(scale.round)) {\n    scale.round(round);\n  } else if (isFunction(scale.rangeRound)) {\n    scale.interpolate(round ? interpolateRound : interpolate);\n  }\n\n  if (range) scale.range(flip(range, _.reverse));\n}\n\nfunction configureRangeStep(type, _, count) {\n  if (type !== Band && type !== Point) {\n    error('Only band and point scales support rangeStep.');\n  }\n\n  // calculate full range based on requested step size and padding\n  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,\n      inner = type === Point ? 1\n            : ((_.paddingInner != null ? _.paddingInner : _.padding) || 0);\n  return [0, _.rangeStep * bandSpace(count, inner, outer)];\n}\n\nfunction configureScheme(type, _, count) {\n  var name = _.scheme.toLowerCase(),\n      scheme = getScheme(name),\n      extent = _.schemeExtent,\n      discrete;\n\n  if (!scheme) {\n    error('Unrecognized scheme name: ' + _.scheme);\n  }\n\n  // determine size for potential discrete range\n  count = (type === Threshold) ? count + 1\n    : (type === BinOrdinal) ? count - 1\n    : (type === Quantile || type === Quantize) ? (+_.schemeCount || DEFAULT_COUNT)\n    : count;\n\n  // adjust and/or quantize scheme as appropriate\n  return type === Sequential ? adjustScheme(scheme, extent, _.reverse)\n    : !extent && (discrete = getScheme(name + '-' + count)) ? discrete\n    : isFunction(scheme) ? quantize(adjustScheme(scheme, extent), count)\n    : type === Ordinal ? scheme : scheme.slice(0, count);\n}\n\nfunction adjustScheme(scheme, extent, reverse) {\n  return (isFunction(scheme) && (extent || reverse))\n    ? interpolateRange(scheme, flip(extent || [0, 1], reverse))\n    : scheme;\n}\n\nfunction flip(array, reverse) {\n  return reverse ? array.slice().reverse() : array;\n}\n\nfunction quantize(interpolator, count) {\n  var samples = new Array(count),\n      n = count + 1;\n  for (var i = 0; i < count;) samples[i] = interpolator(++i / n);\n  return samples;\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Sorts scenegraph items in the pulse source array.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting tuples.\n */\nexport default function SortItems(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(SortItems, Transform);\n\nprototype.transform = function(_, pulse) {\n  var mod = _.modified('sort')\n         || pulse.changed(pulse.ADD)\n         || pulse.modified(_.sort.fields)\n         || pulse.modified('datum');\n\n  if (mod) pulse.source.sort(_.sort);\n\n  this.modified(mod);\n  return pulse;\n};\n","import {Transform} from 'vega-dataflow';\nimport {inherits, one} from 'vega-util';\n\nvar Center = 'center',\n    Normalize = 'normalize';\n\n/**\n * Stack layout for visualization elements.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to stack.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.\n * @param {string} [offset='zero'] - One of 'zero', 'center', 'normalize'.\n */\nexport default function Stack(params) {\n  Transform.call(this, null, params);\n}\n\nStack.Definition = {\n  \"type\": \"Stack\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\" },\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"sort\", \"type\": \"compare\" },\n    { \"name\": \"offset\", \"type\": \"enum\", \"default\": \"zero\", \"values\": [\"zero\", \"center\", \"normalize\"] },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"y0\", \"y1\"] }\n  ]\n};\n\nvar prototype = inherits(Stack, Transform);\n\nprototype.transform = function(_, pulse) {\n  var as = _.as || ['y0', 'y1'],\n      y0 = as[0],\n      y1 = as[1],\n      field = _.field || one,\n      stack = _.offset === Center ? stackCenter\n            : _.offset === Normalize ? stackNormalize\n            : stackZero,\n      groups, i, n, max;\n\n  // partition, sum, and sort the stack groups\n  groups = partition(pulse.source, _.groupby, _.sort, field);\n\n  // compute stack layouts per group\n  for (i=0, n=groups.length, max=groups.max; i<n; ++i) {\n    stack(groups[i], max, field, y0, y1);\n  }\n\n  return pulse.reflow(_.modified()).modifies(as);\n};\n\nfunction stackCenter(group, max, field, y0, y1) {\n  var last = (max - group.sum) / 2,\n      m = group.length,\n      j = 0, t;\n\n  for (; j<m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = (last += Math.abs(field(t)));\n  }\n}\n\nfunction stackNormalize(group, max, field, y0, y1) {\n  var scale = 1 / group.sum,\n      last = 0,\n      m = group.length,\n      j = 0, v = 0, t;\n\n  for (; j<m; ++j) {\n    t = group[j];\n    t[y0] = last;\n    t[y1] = last = scale * (v += Math.abs(field(t)));\n  }\n}\n\nfunction stackZero(group, max, field, y0, y1) {\n  var lastPos = 0,\n      lastNeg = 0,\n      m = group.length,\n      j = 0, v, t;\n\n  for (; j<m; ++j) {\n    t = group[j];\n    v = field(t);\n    if (v < 0) {\n      t[y0] = lastNeg;\n      t[y1] = (lastNeg += v);\n    } else {\n      t[y0] = lastPos;\n      t[y1] = (lastPos += v);\n    }\n  }\n}\n\nfunction partition(data, groupby, sort, field) {\n  var groups = [],\n      get = function(f) { return f(t); },\n      map, i, n, m, t, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0, n=data.length; i<n; ++i) {\n      t = data[i];\n      k = groupby.map(get);\n      g = map[k];\n      if (!g) {\n        map[k] = (g = []);\n        groups.push(g);\n      }\n      g.push(t);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0, m=groups.length; k<m; ++k) {\n    g = groups[k];\n    for (i=0, s=0, n=g.length; i<n; ++i) {\n      s += Math.abs(field(g[i]));\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sort) g.sort(sort);\n  }\n  groups.max = max;\n\n  return groups;\n}\n","import {Symbols, Discrete} from './legend-types';\nimport {Quantile, Quantize, Threshold, BinLinear, BinOrdinal} from './scale-types';\nimport {tickValues} from './ticks';\nimport {peek} from 'vega-util';\n\nvar symbols = {};\nsymbols[Quantile] = quantileSymbols;\nsymbols[Quantize] = quantizeSymbols;\nsymbols[Threshold] = thresholdSymbols;\nsymbols[BinLinear] = symbols[BinOrdinal] = binSymbols;\n\nexport function labelValues(scale, count) {\n  var values = symbols[scale.type];\n  return values ? values(scale) : tickValues(scale, count);\n}\n\nfunction quantizeSymbols(scale) {\n  var domain = scale.domain(),\n      x0 = domain[0],\n      x1 = peek(domain),\n      n = scale.range().length,\n      values = new Array(n),\n      i = 0;\n\n  values[0] = -Infinity;\n  while (++i < n) values[i] = (i * x1 - (i - n) * x0) / n;\n  values.max = +Infinity;\n\n  return values;\n}\n\nfunction quantileSymbols(scale) {\n  var values = [-Infinity].concat(scale.quantiles());\n  values.max = +Infinity;\n\n  return values;\n}\n\nfunction thresholdSymbols(scale) {\n  var values = [-Infinity].concat(scale.domain());\n  values.max = +Infinity;\n\n  return values;\n}\n\nfunction binSymbols(scale) {\n  var values = scale.domain();\n  values.max = values.pop();\n\n  return values;\n}\n\nexport function labelFormat(scale, format, type) {\n  return type === Symbols && symbols[scale.type] ? formatRange(format)\n    : type === Discrete ? formatDiscrete(format)\n    : formatPoint(format);\n}\n\nfunction formatRange(format) {\n  return function(value, index, array) {\n    var limit = array[index + 1] || array.max || +Infinity,\n        lo = formatValue(value, format),\n        hi = formatValue(limit, format);\n    return lo && hi ? lo + '\\u2013' + hi : hi ? '< ' + hi : '\\u2265 ' + lo;\n  };\n}\n\nfunction formatDiscrete(format) {\n  return function(value, index) {\n    return index ? format(value) : null;\n  }\n}\n\nfunction formatPoint(format) {\n  return function(value) {\n    return format(value);\n  };\n}\n\nfunction formatValue(value, format) {\n  return isFinite(value) ? format(value) : null;\n}\n\nexport function labelFraction(scale) {\n  var domain = scale.domain(),\n      count = domain.length - 1,\n      lo = +domain[0],\n      hi = +peek(domain),\n      span = hi - lo;\n\n  if (scale.type === Threshold) {\n    var adjust = count ? span / count : 0.1;\n    lo -= adjust;\n    hi += adjust;\n    span = hi - lo;\n  }\n\n  return function(value) {\n    return (value - lo) / span;\n  };\n}\n","export var Symbols  = 'symbol';\nexport var Discrete = 'discrete';\nexport var Gradient = 'gradient';\n","export var Log = 'log';\nexport var Pow = 'pow';\nexport var Utc = 'utc';\nexport var Sqrt = 'sqrt';\nexport var Band = 'band';\nexport var Time = 'time';\nexport var Point = 'point';\nexport var Linear = 'linear';\nexport var Ordinal = 'ordinal';\nexport var Quantile = 'quantile';\nexport var Quantize = 'quantize';\nexport var Threshold = 'threshold';\nexport var BinLinear = 'bin-linear';\nexport var BinOrdinal = 'bin-ordinal';\nexport var Sequential = 'sequential';\n","import {Log} from './scale-types';\nimport {timeInterval, utcInterval} from 'vega-scale';\nimport {error, isObject, isString, peek} from 'vega-util';\nimport {\n  format as numberFormat,\n  formatSpecifier\n} from 'd3-format';\n\n/**\n * Determine the tick count or interval function.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} count - The desired tick count or interval specifier.\n * @return {*} - The tick count or interval function.\n */\nexport function tickCount(scale, count) {\n  var step;\n\n  if (isObject(count)) {\n    step = count.step;\n    count = count.interval;\n  }\n\n  if (isString(count)) {\n    count = scale.type === 'time' ? timeInterval(count)\n      : scale.type === 'utc' ? utcInterval(count)\n      : error('Only time and utc scales accept interval strings.');\n    if (step) count = count.every(step);\n  }\n\n  return count;\n}\n\n/**\n * Filter a set of candidate tick values, ensuring that only tick values\n * that lie within the scale range are included.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {Array<*>} ticks - The candidate tick values.\n * @param {*} count - The tick count or interval function.\n * @return {Array<*>} - The filtered tick values.\n */\nexport function validTicks(scale, ticks, count) {\n  var range = scale.range(),\n      lo = range[0],\n      hi = peek(range);\n  if (lo > hi) {\n    range = hi;\n    hi = lo;\n    lo = range;\n  }\n\n  ticks = ticks.filter(function(v) {\n    v = scale(v);\n    return !(v < lo || v > hi)\n  });\n\n  if (count > 0 && ticks.length > 1) {\n    var endpoints = [ticks[0], peek(ticks)];\n    while (ticks.length > count && ticks.length >= 3) {\n      ticks = ticks.filter(function(_, i) { return !(i % 2); });\n    }\n    if (ticks.length < 3) {\n      ticks = endpoints;\n    }\n  }\n\n  return ticks;\n}\n\n/**\n * Generate tick values for the given scale and approximate tick count or\n * interval value. If the scale has a 'ticks' method, it will be used to\n * generate the ticks, with the count argument passed as a parameter. If the\n * scale lacks a 'ticks' method, the full scale domain will be returned.\n * @param {Scale} scale - The scale for which to generate tick values.\n * @param {*} [count] - The approximate number of desired ticks.\n * @return {Array<*>} - The generated tick values.\n */\nexport function tickValues(scale, count) {\n  return scale.ticks ? scale.ticks(count) : scale.domain();\n}\n\n/**\n * Generate a label format function for a scale. If the scale has a\n * 'tickFormat' method, it will be used to generate the formatter, with the\n * count and specifier arguments passed as parameters. If the scale lacks a\n * 'tickFormat' method, the returned formatter performs simple string coercion.\n * If the input scale is a logarithmic scale and the format specifier does not\n * indicate a desired decimal precision, a special variable precision formatter\n * that automatically trims trailing zeroes will be generated.\n * @param {Scale} scale - The scale for which to generate the label formatter.\n * @param {*} [count] - The approximate number of desired ticks.\n * @param {string} [specifier] - The format specifier. Must be a legal d3 4.0\n *   specifier string (see https://github.com/d3/d3-format#formatSpecifier).\n * @return {function(*):string} - The generated label formatter.\n */\nexport function tickFormat(scale, count, specifier) {\n  var format = scale.tickFormat ? scale.tickFormat(count, specifier)\n    : specifier ? numberFormat(specifier)\n    : String;\n\n  return (scale.type === Log)\n    ? filter(format, variablePrecision(specifier))\n    : format;\n}\n\nfunction filter(sourceFormat, targetFormat) {\n  return function(_) {\n    return sourceFormat(_) ? targetFormat(_) : '';\n  };\n}\n\nfunction variablePrecision(specifier) {\n  var s = formatSpecifier(specifier || ',');\n\n  if (s.precision == null) {\n    s.precision = 12;\n    switch (s.type) {\n      case '%': s.precision -= 2; break;\n      case 'e': s.precision -= 1; break;\n    }\n    return trimZeroes(\n      numberFormat(s),          // number format\n      numberFormat('.1f')(1)[1] // decimal point character\n    );\n  } else {\n    return numberFormat(s);\n  }\n}\n\nfunction trimZeroes(format, decimalChar) {\n  return function(x) {\n    var str = format(x),\n        dec = str.indexOf(decimalChar),\n        idx, end;\n\n    if (dec < 0) return str;\n\n    idx = rightmostDigit(str, dec);\n    end = idx < str.length ? str.slice(idx) : '';\n    while (--idx > dec) if (str[idx] !== '0') { ++idx; break; }\n\n    return str.slice(0, idx) + end;\n  };\n}\n\nfunction rightmostDigit(str, dec) {\n  var i = str.lastIndexOf('e'), c;\n  if (i > 0) return i;\n  for (i=str.length; --i > dec;) {\n    c = str.charCodeAt(i);\n    if (c >= 48 && c <= 57) return i + 1; // is digit\n  }\n}\n","export {default as selector} from './src/event-selector';\n","/**\n * Parse an event selector string.\n * Returns an array of event stream definitions.\n */\nexport default function(selector, source, marks) {\n  DEFAULT_SOURCE = source || VIEW;\n  MARKS = marks || DEFAULT_MARKS;\n  return parseMerge(selector.trim()).map(parseSelector);\n}\n\nvar VIEW    = 'view',\n    LBRACK  = '[',\n    RBRACK  = ']',\n    LBRACE  = '{',\n    RBRACE  = '}',\n    COLON   = ':',\n    COMMA   = ',',\n    NAME    = '@',\n    GT      = '>',\n    ILLEGAL = /[[\\]{}]/,\n    DEFAULT_SOURCE,\n    MARKS,\n    DEFAULT_MARKS = {\n      '*': 1,\n      arc: 1,\n      area: 1,\n      group: 1,\n      image: 1,\n      line: 1,\n      path: 1,\n      rect: 1,\n      rule: 1,\n      shape: 1,\n      symbol: 1,\n      text: 1,\n      trail: 1\n    };\n\nfunction isMarkType(type) {\n  return MARKS.hasOwnProperty(type);\n}\n\nfunction find(s, i, endChar, pushChar, popChar) {\n  var count = 0,\n      n = s.length,\n      c;\n  for (; i<n; ++i) {\n    c = s[i];\n    if (!count && c === endChar) return i;\n    else if (popChar && popChar.indexOf(c) >= 0) --count;\n    else if (pushChar && pushChar.indexOf(c) >= 0) ++count;\n  }\n  return i;\n}\n\nfunction parseMerge(s) {\n  var output = [],\n      start = 0,\n      n = s.length,\n      i = 0;\n\n  while (i < n) {\n    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\n    output.push(s.substring(start, i).trim());\n    start = ++i;\n  }\n\n  if (output.length === 0) {\n    throw 'Empty event selector: ' + s;\n  }\n  return output;\n}\n\nfunction parseSelector(s) {\n  return s[0] === '['\n    ? parseBetween(s)\n    : parseStream(s);\n}\n\nfunction parseBetween(s) {\n  var n = s.length,\n      i = 1,\n      b, stream;\n\n  i = find(s, i, RBRACK, LBRACK, RBRACK);\n  if (i === n) {\n    throw 'Empty between selector: ' + s;\n  }\n\n  b = parseMerge(s.substring(1, i));\n  if (b.length !== 2) {\n    throw 'Between selector must have two elements: ' + s;\n  }\n\n  s = s.slice(i + 1).trim();\n  if (s[0] !== GT) {\n    throw 'Expected \\'>\\' after between selector: ' + s;\n  }\n\n  b = b.map(parseSelector);\n\n  stream = parseSelector(s.slice(1).trim());\n  if (stream.between) {\n    return {\n      between: b,\n      stream: stream\n    };\n  } else {\n    stream.between = b;\n  }\n\n  return stream;\n}\n\nfunction parseStream(s) {\n  var stream = {source: DEFAULT_SOURCE},\n      source = [],\n      throttle = [0, 0],\n      markname = 0,\n      start = 0,\n      n = s.length,\n      i = 0, j,\n      filter;\n\n  // extract throttle from end\n  if (s[n-1] === RBRACE) {\n    i = s.lastIndexOf(LBRACE);\n    if (i >= 0) {\n      try {\n        throttle = parseThrottle(s.substring(i+1, n-1));\n      } catch (e) {\n        throw 'Invalid throttle specification: ' + s;\n      }\n      s = s.slice(0, i).trim();\n      n = s.length;\n    } else throw 'Unmatched right brace: ' + s;\n    i = 0;\n  }\n\n  if (!n) throw s;\n\n  // set name flag based on first char\n  if (s[0] === NAME) markname = ++i;\n\n  // extract first part of multi-part stream selector\n  j = find(s, i, COLON);\n  if (j < n) {\n    source.push(s.substring(start, j).trim());\n    start = i = ++j;\n  }\n\n  // extract remaining part of stream selector\n  i = find(s, i, LBRACK);\n  if (i === n) {\n    source.push(s.substring(start, n).trim());\n  } else {\n    source.push(s.substring(start, i).trim());\n    filter = [];\n    start = ++i;\n    if (start === n) throw 'Unmatched left bracket: ' + s;\n  }\n\n  // extract filters\n  while (i < n) {\n    i = find(s, i, RBRACK);\n    if (i === n) throw 'Unmatched left bracket: ' + s;\n    filter.push(s.substring(start, i).trim());\n    if (i < n-1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;\n    start = ++i;\n  }\n\n  // marshall event stream specification\n  if (!(n = source.length) || ILLEGAL.test(source[n-1])) {\n    throw 'Invalid event selector: ' + s;\n  }\n\n  if (n > 1) {\n    stream.type = source[1];\n    if (markname) {\n      stream.markname = source[0].slice(1);\n    } else if (isMarkType(source[0])) {\n      stream.marktype = source[0];\n    } else {\n      stream.source = source[0];\n    }\n  } else {\n    stream.type = source[0];\n  }\n  if (stream.type.slice(-1) === '!') {\n    stream.consume = true;\n    stream.type = stream.type.slice(0, -1)\n  }\n  if (filter != null) stream.filter = filter;\n  if (throttle[0]) stream.throttle = throttle[0];\n  if (throttle[1]) stream.debounce = throttle[1];\n\n  return stream;\n}\n\nfunction parseThrottle(s) {\n  var a = s.split(COMMA);\n  if (!s.length || a.length > 2) throw s;\n  return a.map(function(_) {\n    var x = +_;\n    if (x !== x) throw s;\n    return x;\n  });\n}\n","export { default as ASTNode } from './src/ast';\nexport { default as parse} from './src/parser';\nexport { default as codegen } from './src/codegen';\nexport { default as functions } from './src/functions';\nexport { default as constants } from './src/constants';\n","export default function ASTNode(type) {\n  this.type = type;\n}\n\nASTNode.prototype.visit = function(visitor) {\n  var node = this, c, i, n;\n\n  if (visitor(node)) return 1;\n\n  for (c=children(node), i=0, n=c.length; i<n; ++i) {\n    if (c[i].visit(visitor)) return 1;\n  }\n};\n\nfunction children(node) {\n  switch (node.type) {\n    case 'ArrayExpression':\n      return node.elements;\n    case 'BinaryExpression':\n    case 'LogicalExpression':\n      return [node.left, node.right];\n    case 'CallExpression':\n      var args = node.arguments.slice();\n      args.unshift(node.callee);\n      return args;\n    case 'ConditionalExpression':\n      return [node.test, node.consequent, node.alternate];\n    case 'MemberExpression':\n      return [node.object, node.property];\n    case 'ObjectExpression':\n      return node.properties;\n    case 'Property':\n      return [node.key, node.value];\n    case 'UnaryExpression':\n      return [node.argument];\n    case 'Identifier':\n    case 'Literal':\n    case 'RawCode':\n    default:\n      return [];\n  }\n}\n","import Constants from './constants';\nimport Functions from './functions';\nimport {error, isFunction, isString, toSet} from 'vega-util';\n\nexport default function(opt) {\n  opt = opt || {};\n\n  var whitelist = opt.whitelist ? toSet(opt.whitelist) : {},\n      blacklist = opt.blacklist ? toSet(opt.blacklist) : {},\n      constants = opt.constants || Constants,\n      functions = (opt.functions || Functions)(visit),\n      globalvar = opt.globalvar,\n      fieldvar = opt.fieldvar,\n      globals = {},\n      fields = {},\n      memberDepth = 0;\n\n  var outputGlobal = isFunction(globalvar)\n    ? globalvar\n    : function (id) { return globalvar + '[\"' + id + '\"]'; };\n\n  function visit(ast) {\n    if (isString(ast)) return ast;\n    var generator = Generators[ast.type];\n    if (generator == null) error('Unsupported type: ' + ast.type);\n    return generator(ast);\n  }\n\n  var Generators = {\n    Literal: function(n) {\n        return n.raw;\n      },\n\n    Identifier: function(n) {\n      var id = n.name;\n      if (memberDepth > 0) {\n        return id;\n      } else if (blacklist.hasOwnProperty(id)) {\n        return error('Illegal identifier: ' + id);\n      } else if (constants.hasOwnProperty(id)) {\n        return constants[id];\n      } else if (whitelist.hasOwnProperty(id)) {\n        return id;\n      } else {\n        globals[id] = 1;\n        return outputGlobal(id);\n      }\n    },\n\n    MemberExpression: function(n) {\n        var d = !n.computed;\n        var o = visit(n.object);\n        if (d) memberDepth += 1;\n        var p = visit(n.property);\n        if (o === fieldvar) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? '.'+p : '['+p+']');\n      },\n\n    CallExpression: function(n) {\n        if (n.callee.type !== 'Identifier') {\n          error('Illegal callee type: ' + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) error('Unrecognized function: ' + callee);\n        return isFunction(fn)\n          ? fn(args)\n          : fn + '(' + args.map(visit).join(',') + ')';\n      },\n\n    ArrayExpression: function(n) {\n        return '[' + n.elements.map(visit).join(',') + ']';\n      },\n\n    BinaryExpression: function(n) {\n        return '(' + visit(n.left) + n.operator + visit(n.right) + ')';\n      },\n\n    UnaryExpression: function(n) {\n        return '(' + n.operator + visit(n.argument) + ')';\n      },\n\n    ConditionalExpression: function(n) {\n        return '(' + visit(n.test) +\n          '?' + visit(n.consequent) +\n          ':' + visit(n.alternate) +\n          ')';\n      },\n\n    LogicalExpression: function(n) {\n        return '(' + visit(n.left) + n.operator + visit(n.right) + ')';\n      },\n\n    ObjectExpression: function(n) {\n        return '{' + n.properties.map(visit).join(',') + '}';\n      },\n\n    Property: function(n) {\n        memberDepth += 1;\n        var k = visit(n.key);\n        memberDepth -= 1;\n        return k + ':' + visit(n.value);\n      }\n  };\n\n  function codegen(ast) {\n    var result = {\n      code:    visit(ast),\n      globals: Object.keys(globals),\n      fields:  Object.keys(fields)\n    };\n    globals = {};\n    fields = {};\n    return result;\n  }\n\n  codegen.functions = functions;\n  codegen.constants = constants;\n\n  return codegen;\n}\n","export default {\n  NaN:       'NaN',\n  E:         'Math.E',\n  LN2:       'Math.LN2',\n  LN10:      'Math.LN10',\n  LOG2E:     'Math.LOG2E',\n  LOG10E:    'Math.LOG10E',\n  PI:        'Math.PI',\n  SQRT1_2:   'Math.SQRT1_2',\n  SQRT2:     'Math.SQRT2',\n  MIN_VALUE: 'Number.MIN_VALUE',\n  MAX_VALUE: 'Number.MAX_VALUE'\n};\n","import {error} from 'vega-util';\n\nexport default function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + '(' + obj + ')';\n      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';\n    }\n    return obj + '.' + name + (type < 0 ? '' : type === 0 ?\n      '()' :\n      '(' + args.slice(1).map(codegen).join(',') + ')');\n  }\n\n  function fn(name, cast, type) {\n    return function(args) {\n      return fncall(name, args, cast, type);\n    };\n  }\n\n  var DATE = 'new Date',\n      STRING = 'String',\n      REGEXP = 'RegExp';\n\n  return {\n    // MATH functions\n    isNaN:    'isNaN',\n    isFinite: 'isFinite',\n    abs:      'Math.abs',\n    acos:     'Math.acos',\n    asin:     'Math.asin',\n    atan:     'Math.atan',\n    atan2:    'Math.atan2',\n    ceil:     'Math.ceil',\n    cos:      'Math.cos',\n    exp:      'Math.exp',\n    floor:    'Math.floor',\n    log:      'Math.log',\n    max:      'Math.max',\n    min:      'Math.min',\n    pow:      'Math.pow',\n    random:   'Math.random',\n    round:    'Math.round',\n    sin:      'Math.sin',\n    sqrt:     'Math.sqrt',\n    tan:      'Math.tan',\n\n    clamp: function(args) {\n      if (args.length < 3) error('Missing arguments to clamp function.');\n      if (args.length > 3) error('Too many arguments to clamp function.');\n      var a = args.map(codegen);\n      return 'Math.max('+a[1]+', Math.min('+a[2]+','+a[0]+'))';\n    },\n\n    // DATE functions\n    now:             'Date.now',\n    utc:             'Date.UTC',\n    datetime:        DATE,\n    date:            fn('getDate', DATE, 0),\n    day:             fn('getDay', DATE, 0),\n    year:            fn('getFullYear', DATE, 0),\n    month:           fn('getMonth', DATE, 0),\n    hours:           fn('getHours', DATE, 0),\n    minutes:         fn('getMinutes', DATE, 0),\n    seconds:         fn('getSeconds', DATE, 0),\n    milliseconds:    fn('getMilliseconds', DATE, 0),\n    time:            fn('getTime', DATE, 0),\n    timezoneoffset:  fn('getTimezoneOffset', DATE, 0),\n    utcdate:         fn('getUTCDate', DATE, 0),\n    utcday:          fn('getUTCDay', DATE, 0),\n    utcyear:         fn('getUTCFullYear', DATE, 0),\n    utcmonth:        fn('getUTCMonth', DATE, 0),\n    utchours:        fn('getUTCHours', DATE, 0),\n    utcminutes:      fn('getUTCMinutes', DATE, 0),\n    utcseconds:      fn('getUTCSeconds', DATE, 0),\n    utcmilliseconds: fn('getUTCMilliseconds', DATE, 0),\n\n    // shared sequence functions\n    length:      fn('length', null, -1),\n    indexof:     fn('indexOf', null),\n    lastindexof: fn('lastIndexOf', null),\n    slice:       fn('slice', null),\n\n    // STRING functions\n    parseFloat:  'parseFloat',\n    parseInt:    'parseInt',\n    upper:       fn('toUpperCase', STRING, 0),\n    lower:       fn('toLowerCase', STRING, 0),\n    substring:   fn('substring', STRING),\n    split:       fn('split', STRING),\n    replace:     fn('replace', STRING),\n\n    // REGEXP functions\n    regexp:  REGEXP,\n    test:    fn('test', REGEXP),\n\n    // Control Flow functions\n    if: function(args) {\n        if (args.length < 3) error('Missing arguments to if function.');\n        if (args.length > 3) error('Too many arguments to if function.');\n        var a = args.map(codegen);\n        return '('+a[0]+'?'+a[1]+':'+a[2]+')';\n      }\n  };\n}\n","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nimport ASTNode from './ast';\n\nvar TokenName,\n    source,\n    index,\n    length,\n    lookahead;\n\nvar TokenBooleanLiteral = 1,\n    TokenEOF = 2,\n    TokenIdentifier = 3,\n    TokenKeyword = 4,\n    TokenNullLiteral = 5,\n    TokenNumericLiteral = 6,\n    TokenPunctuator = 7,\n    TokenStringLiteral = 8,\n    TokenRegularExpression = 9;\n\nTokenName = {};\nTokenName[TokenBooleanLiteral] = 'Boolean';\nTokenName[TokenEOF] = '<end>';\nTokenName[TokenIdentifier] = 'Identifier';\nTokenName[TokenKeyword] = 'Keyword';\nTokenName[TokenNullLiteral] = 'Null';\nTokenName[TokenNumericLiteral] = 'Numeric';\nTokenName[TokenPunctuator] = 'Punctuator';\nTokenName[TokenStringLiteral] = 'String';\nTokenName[TokenRegularExpression] = 'RegularExpression';\n\nvar SyntaxArrayExpression = 'ArrayExpression',\n    SyntaxBinaryExpression = 'BinaryExpression',\n    SyntaxCallExpression = 'CallExpression',\n    SyntaxConditionalExpression = 'ConditionalExpression',\n    SyntaxIdentifier = 'Identifier',\n    SyntaxLiteral = 'Literal',\n    SyntaxLogicalExpression = 'LogicalExpression',\n    SyntaxMemberExpression = 'MemberExpression',\n    SyntaxObjectExpression = 'ObjectExpression',\n    SyntaxProperty = 'Property',\n    SyntaxUnaryExpression = 'UnaryExpression';\n\n// Error messages should be identical to V8.\nvar MessageUnexpectedToken = 'Unexpected token %0',\n    MessageUnexpectedNumber = 'Unexpected number',\n    MessageUnexpectedString = 'Unexpected string',\n    MessageUnexpectedIdentifier = 'Unexpected identifier',\n    MessageUnexpectedReserved = 'Unexpected reserved word',\n    MessageUnexpectedEOS = 'Unexpected end of input',\n    MessageInvalidRegExp = 'Invalid regular expression',\n    MessageUnterminatedRegExp = 'Invalid regular expression: missing /',\n    MessageStrictOctalLiteral = 'Octal literals are not allowed in strict mode.',\n    MessageStrictDuplicateProperty = 'Duplicate data property in object literal not allowed in strict mode';\n\nvar ILLEGAL = 'ILLEGAL',\n    DISABLED = 'Disabled.';\n\n// See also tools/generate-unicode-regex.py.\nvar RegexNonAsciiIdentifierStart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n    RegexNonAsciiIdentifierPart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]');\n\n// Ensure the condition is true, otherwise throw an error.\n// This is only to have a better contract semantic, i.e. another safety net\n// to catch a logic error. The condition shall be fulfilled in normal case.\n// Do NOT use this to enforce a certain condition on any user input.\n\nfunction assert(condition, message) {\n  /* istanbul ignore next */\n  if (!condition) {\n    throw new Error('ASSERT: ' + message);\n  }\n}\n\nfunction isDecimalDigit(ch) {\n  return (ch >= 0x30 && ch <= 0x39); // 0..9\n}\n\nfunction isHexDigit(ch) {\n  return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n}\n\nfunction isOctalDigit(ch) {\n  return '01234567'.indexOf(ch) >= 0;\n}\n\n// 7.2 White Space\n\nfunction isWhiteSpace(ch) {\n  return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n    (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n}\n\n// 7.3 Line Terminators\n\nfunction isLineTerminator(ch) {\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n}\n\n// 7.6 Identifier Names and Identifiers\n\nfunction isIdentifierStart(ch) {\n  return (ch === 0x24) || (ch === 0x5F) || // $ (dollar) and _ (underscore)\n    (ch >= 0x41 && ch <= 0x5A) || // A..Z\n    (ch >= 0x61 && ch <= 0x7A) || // a..z\n    (ch === 0x5C) || // \\ (backslash)\n    ((ch >= 0x80) && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n}\n\nfunction isIdentifierPart(ch) {\n  return (ch === 0x24) || (ch === 0x5F) || // $ (dollar) and _ (underscore)\n    (ch >= 0x41 && ch <= 0x5A) || // A..Z\n    (ch >= 0x61 && ch <= 0x7A) || // a..z\n    (ch >= 0x30 && ch <= 0x39) || // 0..9\n    (ch === 0x5C) || // \\ (backslash)\n    ((ch >= 0x80) && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n}\n\n// 7.6.1.1 Keywords\n\nvar keywords = {\n  'if':1, 'in':1, 'do':1,\n  'var':1, 'for':1, 'new':1, 'try':1, 'let':1,\n  'this':1, 'else':1, 'case':1, 'void':1, 'with':1, 'enum':1,\n  'while':1, 'break':1, 'catch':1, 'throw':1, 'const':1, 'yield':1, 'class':1, 'super':1,\n  'return':1, 'typeof':1, 'delete':1, 'switch':1, 'export':1, 'import':1, 'public':1, 'static':1,\n  'default':1, 'finally':1, 'extends':1, 'package':1, 'private':1,\n  'function':1, 'continue':1, 'debugger':1,\n  'interface':1, 'protected':1,\n  'instanceof':1, 'implements':1\n};\n\nfunction skipComment() {\n  var ch;\n\n  while (index < length) {\n    ch = source.charCodeAt(index);\n\n    if (isWhiteSpace(ch) || isLineTerminator(ch)) {\n      ++index;\n    } else {\n      break;\n    }\n  }\n}\n\nfunction scanHexEscape(prefix) {\n  var i, len, ch, code = 0;\n\n  len = (prefix === 'u') ? 4 : 2;\n  for (i = 0; i < len; ++i) {\n    if (index < length && isHexDigit(source[index])) {\n      ch = source[index++];\n      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n    } else {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    }\n  }\n  return String.fromCharCode(code);\n}\n\nfunction scanUnicodeCodePointEscape() {\n  var ch, code, cu1, cu2;\n\n  ch = source[index];\n  code = 0;\n\n  // At least, one hex digit is required.\n  if (ch === '}') {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  while (index < length) {\n    ch = source[index++];\n    if (!isHexDigit(ch)) {\n      break;\n    }\n    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n  }\n\n  if (code > 0x10FFFF || ch !== '}') {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  // UTF-16 Encoding\n  if (code <= 0xFFFF) {\n    return String.fromCharCode(code);\n  }\n  cu1 = ((code - 0x10000) >> 10) + 0xD800;\n  cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n  return String.fromCharCode(cu1, cu2);\n}\n\nfunction getEscapedIdentifier() {\n  var ch, id;\n\n  ch = source.charCodeAt(index++);\n  id = String.fromCharCode(ch);\n\n  // '\\u' (U+005C, U+0075) denotes an escaped character.\n  if (ch === 0x5C) {\n    if (source.charCodeAt(index) !== 0x75) {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    }\n    ++index;\n    ch = scanHexEscape('u');\n    if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    }\n    id = ch;\n  }\n\n  while (index < length) {\n    ch = source.charCodeAt(index);\n    if (!isIdentifierPart(ch)) {\n      break;\n    }\n    ++index;\n    id += String.fromCharCode(ch);\n\n    // '\\u' (U+005C, U+0075) denotes an escaped character.\n    if (ch === 0x5C) {\n      id = id.substr(0, id.length - 1);\n      if (source.charCodeAt(index) !== 0x75) {\n        throwError({}, MessageUnexpectedToken, ILLEGAL);\n      }\n      ++index;\n      ch = scanHexEscape('u');\n      if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n        throwError({}, MessageUnexpectedToken, ILLEGAL);\n      }\n      id += ch;\n    }\n  }\n\n  return id;\n}\n\nfunction getIdentifier() {\n  var start, ch;\n\n  start = index++;\n  while (index < length) {\n    ch = source.charCodeAt(index);\n    if (ch === 0x5C) {\n      // Blackslash (U+005C) marks Unicode escape sequence.\n      index = start;\n      return getEscapedIdentifier();\n    }\n    if (isIdentifierPart(ch)) {\n      ++index;\n    } else {\n      break;\n    }\n  }\n\n  return source.slice(start, index);\n}\n\nfunction scanIdentifier() {\n  var start, id, type;\n\n  start = index;\n\n  // Backslash (U+005C) starts an escaped character.\n  id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n  // There is no keyword or literal with only one character.\n  // Thus, it must be an identifier.\n  if (id.length === 1) {\n    type = TokenIdentifier;\n  } else if (keywords.hasOwnProperty(id)) {\n    type = TokenKeyword;\n  } else if (id === 'null') {\n    type = TokenNullLiteral;\n  } else if (id === 'true' || id === 'false') {\n    type = TokenBooleanLiteral;\n  } else {\n    type = TokenIdentifier;\n  }\n\n  return {\n    type: type,\n    value: id,\n    start: start,\n    end: index\n  };\n}\n\n// 7.7 Punctuators\n\nfunction scanPunctuator() {\n  var start = index,\n    code = source.charCodeAt(index),\n    code2,\n    ch1 = source[index],\n    ch2,\n    ch3,\n    ch4;\n\n  switch (code) {\n\n    // Check for most common single-character punctuators.\n    case 0x2E: // . dot\n    case 0x28: // ( open bracket\n    case 0x29: // ) close bracket\n    case 0x3B: // ; semicolon\n    case 0x2C: // , comma\n    case 0x7B: // { open curly brace\n    case 0x7D: // } close curly brace\n    case 0x5B: // [\n    case 0x5D: // ]\n    case 0x3A: // :\n    case 0x3F: // ?\n    case 0x7E: // ~\n      ++index;\n      return {\n        type: TokenPunctuator,\n        value: String.fromCharCode(code),\n        start: start,\n        end: index\n      };\n\n    default:\n      code2 = source.charCodeAt(index + 1);\n\n      // '=' (U+003D) marks an assignment or comparison operator.\n      if (code2 === 0x3D) {\n        switch (code) {\n          case 0x2B: // +\n          case 0x2D: // -\n          case 0x2F: // /\n          case 0x3C: // <\n          case 0x3E: // >\n          case 0x5E: // ^\n          case 0x7C: // |\n          case 0x25: // %\n          case 0x26: // &\n          case 0x2A: // *\n            index += 2;\n            return {\n              type: TokenPunctuator,\n              value: String.fromCharCode(code) + String.fromCharCode(code2),\n              start: start,\n              end: index\n            };\n\n          case 0x21: // !\n          case 0x3D: // =\n            index += 2;\n\n            // !== and ===\n            if (source.charCodeAt(index) === 0x3D) {\n              ++index;\n            }\n            return {\n              type: TokenPunctuator,\n              value: source.slice(start, index),\n              start: start,\n              end: index\n            };\n        }\n      }\n  }\n\n  // 4-character punctuator: >>>=\n\n  ch4 = source.substr(index, 4);\n\n  if (ch4 === '>>>=') {\n    index += 4;\n    return {\n      type: TokenPunctuator,\n      value: ch4,\n      start: start,\n      end: index\n    };\n  }\n\n  // 3-character punctuators: === !== >>> <<= >>=\n\n  ch3 = ch4.substr(0, 3);\n\n  if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n    index += 3;\n    return {\n      type: TokenPunctuator,\n      value: ch3,\n      start: start,\n      end: index\n    };\n  }\n\n  // Other 2-character punctuators: ++ -- << >> && ||\n  ch2 = ch3.substr(0, 2);\n\n  if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n    index += 2;\n    return {\n      type: TokenPunctuator,\n      value: ch2,\n      start: start,\n      end: index\n    };\n  }\n\n  // 1-character punctuators: < > = ! + - * % & | ^ /\n\n  if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n    ++index;\n    return {\n      type: TokenPunctuator,\n      value: ch1,\n      start: start,\n      end: index\n    };\n  }\n\n  throwError({}, MessageUnexpectedToken, ILLEGAL);\n}\n\n// 7.8.3 Numeric Literals\n\nfunction scanHexLiteral(start) {\n  var number = '';\n\n  while (index < length) {\n    if (!isHexDigit(source[index])) {\n      break;\n    }\n    number += source[index++];\n  }\n\n  if (number.length === 0) {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  if (isIdentifierStart(source.charCodeAt(index))) {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  return {\n    type: TokenNumericLiteral,\n    value: parseInt('0x' + number, 16),\n    start: start,\n    end: index\n  };\n}\n\nfunction scanOctalLiteral(start) {\n  var number = '0' + source[index++];\n  while (index < length) {\n    if (!isOctalDigit(source[index])) {\n      break;\n    }\n    number += source[index++];\n  }\n\n  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  return {\n    type: TokenNumericLiteral,\n    value: parseInt(number, 8),\n    octal: true,\n    start: start,\n    end: index\n  };\n}\n\nfunction scanNumericLiteral() {\n  var number, start, ch;\n\n  ch = source[index];\n  assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n    'Numeric literal must start with a decimal digit or a decimal point');\n\n  start = index;\n  number = '';\n  if (ch !== '.') {\n    number = source[index++];\n    ch = source[index];\n\n    // Hex number starts with '0x'.\n    // Octal number starts with '0'.\n    if (number === '0') {\n      if (ch === 'x' || ch === 'X') {\n        ++index;\n        return scanHexLiteral(start);\n      }\n      if (isOctalDigit(ch)) {\n        return scanOctalLiteral(start);\n      }\n\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n        throwError({}, MessageUnexpectedToken, ILLEGAL);\n      }\n    }\n\n    while (isDecimalDigit(source.charCodeAt(index))) {\n      number += source[index++];\n    }\n    ch = source[index];\n  }\n\n  if (ch === '.') {\n    number += source[index++];\n    while (isDecimalDigit(source.charCodeAt(index))) {\n      number += source[index++];\n    }\n    ch = source[index];\n  }\n\n  if (ch === 'e' || ch === 'E') {\n    number += source[index++];\n\n    ch = source[index];\n    if (ch === '+' || ch === '-') {\n      number += source[index++];\n    }\n    if (isDecimalDigit(source.charCodeAt(index))) {\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n    } else {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    }\n  }\n\n  if (isIdentifierStart(source.charCodeAt(index))) {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  return {\n    type: TokenNumericLiteral,\n    value: parseFloat(number),\n    start: start,\n    end: index\n  };\n}\n\n// 7.8.4 String Literals\n\nfunction scanStringLiteral() {\n  var str = '',\n    quote, start, ch, code, octal = false;\n\n  quote = source[index];\n  assert((quote === '\\'' || quote === '\"'),\n    'String literal must starts with a quote');\n\n  start = index;\n  ++index;\n\n  while (index < length) {\n    ch = source[index++];\n\n    if (ch === quote) {\n      quote = '';\n      break;\n    } else if (ch === '\\\\') {\n      ch = source[index++];\n      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n        switch (ch) {\n          case 'u':\n          case 'x':\n            if (source[index] === '{') {\n              ++index;\n              str += scanUnicodeCodePointEscape();\n            } else {\n              str += scanHexEscape(ch);\n            }\n            break;\n          case 'n':\n            str += '\\n';\n            break;\n          case 'r':\n            str += '\\r';\n            break;\n          case 't':\n            str += '\\t';\n            break;\n          case 'b':\n            str += '\\b';\n            break;\n          case 'f':\n            str += '\\f';\n            break;\n          case 'v':\n            str += '\\x0B';\n            break;\n\n          default:\n            if (isOctalDigit(ch)) {\n              code = '01234567'.indexOf(ch);\n\n              // \\0 is not octal escape sequence\n              if (code !== 0) {\n                octal = true;\n              }\n\n              if (index < length && isOctalDigit(source[index])) {\n                octal = true;\n                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                // 3 digits are only allowed when string starts\n                // with 0, 1, 2, 3\n                if ('0123'.indexOf(ch) >= 0 &&\n                  index < length &&\n                  isOctalDigit(source[index])) {\n                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                }\n              }\n              str += String.fromCharCode(code);\n            } else {\n              str += ch;\n            }\n            break;\n        }\n      } else {\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n      }\n    } else if (isLineTerminator(ch.charCodeAt(0))) {\n      break;\n    } else {\n      str += ch;\n    }\n  }\n\n  if (quote !== '') {\n    throwError({}, MessageUnexpectedToken, ILLEGAL);\n  }\n\n  return {\n    type: TokenStringLiteral,\n    value: str,\n    octal: octal,\n    start: start,\n    end: index\n  };\n}\n\nfunction testRegExp(pattern, flags) {\n  var tmp = pattern;\n\n  if (flags.indexOf('u') >= 0) {\n    // Replace each astral symbol and every Unicode code point\n    // escape sequence with a single ASCII symbol to avoid throwing on\n    // regular expressions that are only valid in combination with the\n    // `/u` flag.\n    // Note: replacing with the ASCII symbol `x` might cause false\n    // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n    // perfectly valid pattern that is equivalent to `[a-b]`, but it\n    // would be replaced by `[x-b]` which throws an error.\n    tmp = tmp\n      .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function($0, $1) {\n        if (parseInt($1, 16) <= 0x10FFFF) {\n          return 'x';\n        }\n        throwError({}, MessageInvalidRegExp);\n      })\n      .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n  }\n\n  // First, detect invalid regular expressions.\n  try {\n    new RegExp(tmp);\n  } catch (e) {\n    throwError({}, MessageInvalidRegExp);\n  }\n\n  // Return a regular expression object for this pattern-flag pair, or\n  // `null` in case the current environment doesn't support the flags it\n  // uses.\n  try {\n    return new RegExp(pattern, flags);\n  } catch (exception) {\n    return null;\n  }\n}\n\nfunction scanRegExpBody() {\n  var ch, str, classMarker, terminated, body;\n\n  ch = source[index];\n  assert(ch === '/', 'Regular expression literal must start with a slash');\n  str = source[index++];\n\n  classMarker = false;\n  terminated = false;\n  while (index < length) {\n    ch = source[index++];\n    str += ch;\n    if (ch === '\\\\') {\n      ch = source[index++];\n      // ECMA-262 7.8.5\n      if (isLineTerminator(ch.charCodeAt(0))) {\n        throwError({}, MessageUnterminatedRegExp);\n      }\n      str += ch;\n    } else if (isLineTerminator(ch.charCodeAt(0))) {\n      throwError({}, MessageUnterminatedRegExp);\n    } else if (classMarker) {\n      if (ch === ']') {\n        classMarker = false;\n      }\n    } else {\n      if (ch === '/') {\n        terminated = true;\n        break;\n      } else if (ch === '[') {\n        classMarker = true;\n      }\n    }\n  }\n\n  if (!terminated) {\n    throwError({}, MessageUnterminatedRegExp);\n  }\n\n  // Exclude leading and trailing slash.\n  body = str.substr(1, str.length - 2);\n  return {\n    value: body,\n    literal: str\n  };\n}\n\nfunction scanRegExpFlags() {\n  var ch, str, flags;\n\n  str = '';\n  flags = '';\n  while (index < length) {\n    ch = source[index];\n    if (!isIdentifierPart(ch.charCodeAt(0))) {\n      break;\n    }\n\n    ++index;\n    if (ch === '\\\\' && index < length) {\n      throwError({}, MessageUnexpectedToken, ILLEGAL);\n    } else {\n      flags += ch;\n      str += ch;\n    }\n  }\n\n  if (flags.search(/[^gimuy]/g) >= 0) {\n    throwError({}, MessageInvalidRegExp, flags);\n  }\n\n  return {\n    value: flags,\n    literal: str\n  };\n}\n\nfunction scanRegExp() {\n  var start, body, flags, value;\n\n  lookahead = null;\n  skipComment();\n  start = index;\n\n  body = scanRegExpBody();\n  flags = scanRegExpFlags();\n  value = testRegExp(body.value, flags.value);\n\n  return {\n    literal: body.literal + flags.literal,\n    value: value,\n    regex: {\n      pattern: body.value,\n      flags: flags.value\n    },\n    start: start,\n    end: index\n  };\n}\n\nfunction isIdentifierName(token) {\n  return token.type === TokenIdentifier ||\n    token.type === TokenKeyword ||\n    token.type === TokenBooleanLiteral ||\n    token.type === TokenNullLiteral;\n}\n\nfunction advance() {\n  var ch;\n\n  skipComment();\n\n  if (index >= length) {\n    return {\n      type: TokenEOF,\n      start: index,\n      end: index\n    };\n  }\n\n  ch = source.charCodeAt(index);\n\n  if (isIdentifierStart(ch)) {\n    return scanIdentifier();\n  }\n\n  // Very common: ( and ) and ;\n  if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n    return scanPunctuator();\n  }\n\n  // String literal starts with single quote (U+0027) or double quote (U+0022).\n  if (ch === 0x27 || ch === 0x22) {\n    return scanStringLiteral();\n  }\n\n\n  // Dot (.) U+002E can also start a floating-point number, hence the need\n  // to check the next character.\n  if (ch === 0x2E) {\n    if (isDecimalDigit(source.charCodeAt(index + 1))) {\n      return scanNumericLiteral();\n    }\n    return scanPunctuator();\n  }\n\n  if (isDecimalDigit(ch)) {\n    return scanNumericLiteral();\n  }\n\n  return scanPunctuator();\n}\n\nfunction lex() {\n  var token;\n\n  token = lookahead;\n  index = token.end;\n\n  lookahead = advance();\n\n  index = token.end;\n\n  return token;\n}\n\nfunction peek() {\n  var pos;\n\n  pos = index;\n\n  lookahead = advance();\n  index = pos;\n}\n\nfunction finishArrayExpression(elements) {\n  var node = new ASTNode(SyntaxArrayExpression);\n  node.elements = elements;\n  return node;\n}\n\nfunction finishBinaryExpression(operator, left, right) {\n  var node = new ASTNode((operator === '||' || operator === '&&') ? SyntaxLogicalExpression : SyntaxBinaryExpression);\n  node.operator = operator;\n  node.left = left;\n  node.right = right;\n  return node;\n}\n\nfunction finishCallExpression(callee, args) {\n  var node = new ASTNode(SyntaxCallExpression);\n  node.callee = callee;\n  node.arguments = args;\n  return node;\n}\n\nfunction finishConditionalExpression(test, consequent, alternate) {\n  var node = new ASTNode(SyntaxConditionalExpression);\n  node.test = test;\n  node.consequent = consequent;\n  node.alternate = alternate;\n  return node;\n}\n\nfunction finishIdentifier(name) {\n  var node = new ASTNode(SyntaxIdentifier);\n  node.name = name;\n  return node;\n}\n\nfunction finishLiteral(token) {\n  var node = new ASTNode(SyntaxLiteral);\n  node.value = token.value;\n  node.raw = source.slice(token.start, token.end);\n  if (token.regex) {\n    if (node.raw === '//') {\n      node.raw = '/(?:)/';\n    }\n    node.regex = token.regex;\n  }\n  return node;\n}\n\nfunction finishMemberExpression(accessor, object, property) {\n  var node = new ASTNode(SyntaxMemberExpression);\n  node.computed = accessor === '[';\n  node.object = object;\n  node.property = property;\n  if (!node.computed) property.member = true;\n  return node;\n}\n\nfunction finishObjectExpression(properties) {\n  var node = new ASTNode(SyntaxObjectExpression);\n  node.properties = properties;\n  return node;\n}\n\nfunction finishProperty(kind, key, value) {\n  var node = new ASTNode(SyntaxProperty);\n  node.key = key;\n  node.value = value;\n  node.kind = kind;\n  return node;\n}\n\nfunction finishUnaryExpression(operator, argument) {\n  var node = new ASTNode(SyntaxUnaryExpression);\n  node.operator = operator;\n  node.argument = argument;\n  node.prefix = true;\n  return node;\n}\n\n// Throw an exception\n\nfunction throwError(token, messageFormat) {\n  var error,\n    args = Array.prototype.slice.call(arguments, 2),\n    msg = messageFormat.replace(\n      /%(\\d)/g,\n      function(whole, index) {\n        assert(index < args.length, 'Message reference must be in range');\n        return args[index];\n      }\n    );\n\n\n  error = new Error(msg);\n  error.index = index;\n  error.description = msg;\n  throw error;\n}\n\n// Throw an exception because of the token.\n\nfunction throwUnexpected(token) {\n  if (token.type === TokenEOF) {\n    throwError(token, MessageUnexpectedEOS);\n  }\n\n  if (token.type === TokenNumericLiteral) {\n    throwError(token, MessageUnexpectedNumber);\n  }\n\n  if (token.type === TokenStringLiteral) {\n    throwError(token, MessageUnexpectedString);\n  }\n\n  if (token.type === TokenIdentifier) {\n    throwError(token, MessageUnexpectedIdentifier);\n  }\n\n  if (token.type === TokenKeyword) {\n    throwError(token, MessageUnexpectedReserved);\n  }\n\n  // BooleanLiteral, NullLiteral, or Punctuator.\n  throwError(token, MessageUnexpectedToken, token.value);\n}\n\n// Expect the next token to match the specified punctuator.\n// If not, an exception will be thrown.\n\nfunction expect(value) {\n  var token = lex();\n  if (token.type !== TokenPunctuator || token.value !== value) {\n    throwUnexpected(token);\n  }\n}\n\n// Return true if the next token matches the specified punctuator.\n\nfunction match(value) {\n  return lookahead.type === TokenPunctuator && lookahead.value === value;\n}\n\n// Return true if the next token matches the specified keyword\n\nfunction matchKeyword(keyword) {\n  return lookahead.type === TokenKeyword && lookahead.value === keyword;\n}\n\n// 11.1.4 Array Initialiser\n\nfunction parseArrayInitialiser() {\n  var elements = [];\n\n  index = lookahead.start;\n  expect('[');\n\n  while (!match(']')) {\n    if (match(',')) {\n      lex();\n      elements.push(null);\n    } else {\n      elements.push(parseConditionalExpression());\n\n      if (!match(']')) {\n        expect(',');\n      }\n    }\n  }\n\n  lex();\n\n  return finishArrayExpression(elements);\n}\n\n// 11.1.5 Object Initialiser\n\nfunction parseObjectPropertyKey() {\n  var token;\n\n  index = lookahead.start;\n  token = lex();\n\n  // Note: This function is called only from parseObjectProperty(), where\n  // EOF and Punctuator tokens are already filtered out.\n\n  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {\n    if (token.octal) {\n      throwError(token, MessageStrictOctalLiteral);\n    }\n    return finishLiteral(token);\n  }\n\n  return finishIdentifier(token.value);\n}\n\nfunction parseObjectProperty() {\n  var token, key, id, value;\n\n  index = lookahead.start;\n  token = lookahead;\n\n  if (token.type === TokenIdentifier) {\n    id = parseObjectPropertyKey();\n    expect(':');\n    value = parseConditionalExpression();\n    return finishProperty('init', id, value);\n  }\n  if (token.type === TokenEOF || token.type === TokenPunctuator) {\n    throwUnexpected(token);\n  } else {\n    key = parseObjectPropertyKey();\n    expect(':');\n    value = parseConditionalExpression();\n    return finishProperty('init', key, value);\n  }\n}\n\nfunction parseObjectInitialiser() {\n  var properties = [],\n    property, name, key, map = {},\n    toString = String;\n\n  index = lookahead.start;\n  expect('{');\n\n  while (!match('}')) {\n    property = parseObjectProperty();\n\n    if (property.key.type === SyntaxIdentifier) {\n      name = property.key.name;\n    } else {\n      name = toString(property.key.value);\n    }\n\n    key = '$' + name;\n    if (Object.prototype.hasOwnProperty.call(map, key)) {\n      throwError({}, MessageStrictDuplicateProperty);\n    } else {\n      map[key] = true;\n    }\n\n    properties.push(property);\n\n    if (!match('}')) {\n      expect(',');\n    }\n  }\n\n  expect('}');\n\n  return finishObjectExpression(properties);\n}\n\n// 11.1.6 The Grouping Operator\n\nfunction parseGroupExpression() {\n  var expr;\n\n  expect('(');\n\n  expr = parseExpression();\n\n  expect(')');\n\n  return expr;\n}\n\n\n// 11.1 Primary Expressions\n\nvar legalKeywords = {\n  \"if\": 1,\n  \"this\": 1\n};\n\nfunction parsePrimaryExpression() {\n  var type, token, expr;\n\n  if (match('(')) {\n    return parseGroupExpression();\n  }\n\n  if (match('[')) {\n    return parseArrayInitialiser();\n  }\n\n  if (match('{')) {\n    return parseObjectInitialiser();\n  }\n\n  type = lookahead.type;\n  index = lookahead.start;\n\n\n  if (type === TokenIdentifier || legalKeywords[lookahead.value]) {\n    expr = finishIdentifier(lex().value);\n  } else if (type === TokenStringLiteral || type === TokenNumericLiteral) {\n    if (lookahead.octal) {\n      throwError(lookahead, MessageStrictOctalLiteral);\n    }\n    expr = finishLiteral(lex());\n  } else if (type === TokenKeyword) {\n    throw new Error(DISABLED);\n  } else if (type === TokenBooleanLiteral) {\n    token = lex();\n    token.value = (token.value === 'true');\n    expr = finishLiteral(token);\n  } else if (type === TokenNullLiteral) {\n    token = lex();\n    token.value = null;\n    expr = finishLiteral(token);\n  } else if (match('/') || match('/=')) {\n    expr = finishLiteral(scanRegExp());\n    peek();\n  } else {\n    throwUnexpected(lex());\n  }\n\n  return expr;\n}\n\n// 11.2 Left-Hand-Side Expressions\n\nfunction parseArguments() {\n  var args = [];\n\n  expect('(');\n\n  if (!match(')')) {\n    while (index < length) {\n      args.push(parseConditionalExpression());\n      if (match(')')) {\n        break;\n      }\n      expect(',');\n    }\n  }\n\n  expect(')');\n\n  return args;\n}\n\nfunction parseNonComputedProperty() {\n  var token;\n  index = lookahead.start;\n  token = lex();\n\n  if (!isIdentifierName(token)) {\n    throwUnexpected(token);\n  }\n\n  return finishIdentifier(token.value);\n}\n\nfunction parseNonComputedMember() {\n  expect('.');\n\n  return parseNonComputedProperty();\n}\n\nfunction parseComputedMember() {\n  var expr;\n\n  expect('[');\n\n  expr = parseExpression();\n\n  expect(']');\n\n  return expr;\n}\n\nfunction parseLeftHandSideExpressionAllowCall() {\n  var expr, args, property;\n\n  expr = parsePrimaryExpression();\n\n  for (;;) {\n    if (match('.')) {\n      property = parseNonComputedMember();\n      expr = finishMemberExpression('.', expr, property);\n    } else if (match('(')) {\n      args = parseArguments();\n      expr = finishCallExpression(expr, args);\n    } else if (match('[')) {\n      property = parseComputedMember();\n      expr = finishMemberExpression('[', expr, property);\n    } else {\n      break;\n    }\n  }\n\n  return expr;\n}\n\n// 11.3 Postfix Expressions\n\nfunction parsePostfixExpression() {\n  var expr = parseLeftHandSideExpressionAllowCall();\n\n  if (lookahead.type === TokenPunctuator) {\n    if ((match('++') || match('--'))) {\n      throw new Error(DISABLED);\n    }\n  }\n\n  return expr;\n}\n\n// 11.4 Unary Operators\n\nfunction parseUnaryExpression() {\n  var token, expr;\n\n  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {\n    expr = parsePostfixExpression();\n  } else if (match('++') || match('--')) {\n    throw new Error(DISABLED);\n  } else if (match('+') || match('-') || match('~') || match('!')) {\n    token = lex();\n    expr = parseUnaryExpression();\n    expr = finishUnaryExpression(token.value, expr);\n  } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n    throw new Error(DISABLED);\n  } else {\n    expr = parsePostfixExpression();\n  }\n\n  return expr;\n}\n\nfunction binaryPrecedence(token) {\n  var prec = 0;\n\n  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {\n    return 0;\n  }\n\n  switch (token.value) {\n    case '||':\n      prec = 1;\n      break;\n\n    case '&&':\n      prec = 2;\n      break;\n\n    case '|':\n      prec = 3;\n      break;\n\n    case '^':\n      prec = 4;\n      break;\n\n    case '&':\n      prec = 5;\n      break;\n\n    case '==':\n    case '!=':\n    case '===':\n    case '!==':\n      prec = 6;\n      break;\n\n    case '<':\n    case '>':\n    case '<=':\n    case '>=':\n    case 'instanceof':\n    case 'in':\n      prec = 7;\n      break;\n\n    case '<<':\n    case '>>':\n    case '>>>':\n      prec = 8;\n      break;\n\n    case '+':\n    case '-':\n      prec = 9;\n      break;\n\n    case '*':\n    case '/':\n    case '%':\n      prec = 11;\n      break;\n\n    default:\n      break;\n  }\n\n  return prec;\n}\n\n// 11.5 Multiplicative Operators\n// 11.6 Additive Operators\n// 11.7 Bitwise Shift Operators\n// 11.8 Relational Operators\n// 11.9 Equality Operators\n// 11.10 Binary Bitwise Operators\n// 11.11 Binary Logical Operators\n\nfunction parseBinaryExpression() {\n  var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n  marker = lookahead;\n  left = parseUnaryExpression();\n\n  token = lookahead;\n  prec = binaryPrecedence(token);\n  if (prec === 0) {\n    return left;\n  }\n  token.prec = prec;\n  lex();\n\n  markers = [marker, lookahead];\n  right = parseUnaryExpression();\n\n  stack = [left, token, right];\n\n  while ((prec = binaryPrecedence(lookahead)) > 0) {\n\n    // Reduce: make a binary expression from the three topmost entries.\n    while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n      right = stack.pop();\n      operator = stack.pop().value;\n      left = stack.pop();\n      markers.pop();\n      expr = finishBinaryExpression(operator, left, right);\n      stack.push(expr);\n    }\n\n    // Shift.\n    token = lex();\n    token.prec = prec;\n    stack.push(token);\n    markers.push(lookahead);\n    expr = parseUnaryExpression();\n    stack.push(expr);\n  }\n\n  // Final reduce to clean-up the stack.\n  i = stack.length - 1;\n  expr = stack[i];\n  markers.pop();\n  while (i > 1) {\n    markers.pop()\n    expr = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n    i -= 2;\n  }\n\n  return expr;\n}\n\n// 11.12 Conditional Operator\n\nfunction parseConditionalExpression() {\n  var expr, consequent, alternate;\n\n  expr = parseBinaryExpression();\n\n  if (match('?')) {\n    lex();\n    consequent = parseConditionalExpression();\n    expect(':');\n    alternate = parseConditionalExpression();\n\n    expr = finishConditionalExpression(expr, consequent, alternate);\n  }\n\n  return expr;\n}\n\n// 11.14 Comma Operator\n\nfunction parseExpression() {\n  var expr = parseConditionalExpression();\n\n  if (match(',')) {\n    throw new Error(DISABLED); // no sequence expressions\n  }\n\n  return expr;\n}\n\nexport default function(code) {\n  source = code;\n  index = 0;\n  length = source.length;\n  lookahead = null;\n\n  peek();\n\n  var expr = parseExpression();\n\n  if (lookahead.type !== TokenEOF) {\n    throw new Error(\"Unexpect token after expression.\");\n  }\n  return expr;\n}\n","export {default as force} from './src/Force';\n","import {Transform} from 'vega-dataflow';\nimport {accessorFields, array, error, inherits, isFunction} from 'vega-util';\nimport {\n  forceSimulation, forceCenter, forceCollide,\n  forceManyBody, forceLink, forceX, forceY\n} from 'd3-force';\n\nvar ForceMap = {\n  center: forceCenter,\n  collide: forceCollide,\n  nbody: forceManyBody,\n  link: forceLink,\n  x: forceX,\n  y: forceY\n};\n\nvar Forces = 'forces',\n    ForceParams = [\n      'alpha', 'alphaMin', 'alphaTarget',\n      'velocityDecay', 'forces'\n    ],\n    ForceConfig = ['static', 'iterations'],\n    ForceOutput = ['x', 'y', 'vx', 'vy'];\n\n/**\n * Force simulation layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<object>} params.forces - The forces to apply.\n */\nexport default function Force(params) {\n  Transform.call(this, null, params);\n}\n\nForce.Definition = {\n  \"type\": \"Force\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"static\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"restart\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"iterations\", \"type\": \"number\", \"default\": 300 },\n    { \"name\": \"alpha\", \"type\": \"number\", \"default\": 1 },\n    { \"name\": \"alphaMin\", \"type\": \"number\", \"default\": 0.001 },\n    { \"name\": \"alphaTarget\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"velocityDecay\", \"type\": \"number\", \"default\": 0.4 },\n    { \"name\": \"forces\", \"type\": \"param\", \"array\": true,\n      \"params\": [\n        {\n          \"key\": {\"force\": \"center\"},\n          \"params\": [\n            { \"name\": \"x\", \"type\": \"number\", \"default\": 0 },\n            { \"name\": \"y\", \"type\": \"number\", \"default\": 0 }\n          ]\n        },\n        {\n          \"key\": {\"force\": \"collide\"},\n          \"params\": [\n            { \"name\": \"radius\", \"type\": \"number\", \"expr\": true },\n            { \"name\": \"strength\", \"type\": \"number\", \"default\": 0.7 },\n            { \"name\": \"iterations\", \"type\": \"number\", \"default\": 1 }\n          ]\n        },\n        {\n          \"key\": {\"force\": \"nbody\"},\n          \"params\": [\n            { \"name\": \"strength\", \"type\": \"number\", \"default\": -30 },\n            { \"name\": \"theta\", \"type\": \"number\", \"default\": 0.9 },\n            { \"name\": \"distanceMin\", \"type\": \"number\", \"default\": 1 },\n            { \"name\": \"distanceMax\", \"type\": \"number\" }\n          ]\n        },\n        {\n          \"key\": {\"force\": \"link\"},\n          \"params\": [\n            { \"name\": \"links\", \"type\": \"data\" },\n            { \"name\": \"id\", \"type\": \"field\" },\n            { \"name\": \"distance\", \"type\": \"number\", \"default\": 30, \"expr\": true },\n            { \"name\": \"strength\", \"type\": \"number\", \"expr\": true },\n            { \"name\": \"iterations\", \"type\": \"number\", \"default\": 1 }\n          ]\n        },\n        {\n          \"key\": {\"force\": \"x\"},\n          \"params\": [\n            { \"name\": \"strength\", \"type\": \"number\", \"default\": 0.1 },\n            { \"name\": \"x\", \"type\": \"field\" }\n          ]\n        },\n        {\n          \"key\": {\"force\": \"y\"},\n          \"params\": [\n            { \"name\": \"strength\", \"type\": \"number\", \"default\": 0.1 },\n            { \"name\": \"y\", \"type\": \"field\" }\n          ]\n        }\n      ] },\n    {\n      \"name\": \"as\", \"type\": \"string\", \"array\": true, \"modify\": false,\n      \"default\": ForceOutput\n    }\n  ]\n};\n\nvar prototype = inherits(Force, Transform);\n\nprototype.transform = function(_, pulse) {\n  var sim = this.value,\n      change = pulse.changed(pulse.ADD_REM),\n      params = _.modified(ForceParams),\n      iters = _.iterations || 300;\n\n  // configure simulation\n  if (!sim) {\n    this.value = sim = simulation(pulse.source, _);\n    sim.on('tick', rerun(pulse.dataflow, this));\n    if (!_.static) {\n      change = true;\n      sim.tick(); // ensure we run on init\n    }\n    pulse.modifies('index');\n  } else {\n    if (change) {\n      pulse.modifies('index');\n      sim.nodes(pulse.source);\n    }\n    if (params || pulse.changed(pulse.MOD)) {\n      setup(sim, _, 0, pulse);\n    }\n  }\n\n  // run simulation\n  if (params || change || _.modified(ForceConfig)\n      || (pulse.changed() && _.restart))\n  {\n    sim.alpha(Math.max(sim.alpha(), _.alpha || 1))\n       .alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));\n\n    if (_.static) {\n      for (sim.stop(); --iters >= 0;) sim.tick();\n    } else {\n      if (sim.stopped()) sim.restart();\n      if (!change) return pulse.StopPropagation; // defer to sim ticks\n    }\n  }\n\n  return this.finish(_, pulse);\n};\n\nprototype.finish = function(_, pulse) {\n  var dataflow = pulse.dataflow;\n\n  // inspect dependencies, touch link source data\n  for (var args=this._argops, j=0, m=args.length, arg; j<m; ++j) {\n    arg = args[j];\n    if (arg.name !== Forces || arg.op._argval.force !== 'link') {\n      continue;\n    }\n    for (var ops=arg.op._argops, i=0, n=ops.length, op; i<n; ++i) {\n      if (ops[i].name === 'links' && (op = ops[i].op.source)) {\n        dataflow.pulse(op, dataflow.changeset().reflow());\n        break;\n      }\n    }\n  }\n\n  // reflow all nodes\n  return pulse.reflow(_.modified()).modifies(ForceOutput);\n};\n\nfunction rerun(df, op) {\n  return function() { df.touch(op).run(); }\n}\n\nfunction simulation(nodes, _) {\n  var sim = forceSimulation(nodes),\n      stopped = false,\n      stop = sim.stop,\n      restart = sim.restart;\n\n  sim.stopped = function() {\n    return stopped;\n  };\n  sim.restart = function() {\n    stopped = false;\n    return restart();\n  };\n  sim.stop = function() {\n    stopped = true;\n    return stop();\n  };\n\n  return setup(sim, _, true).on('end', function() { stopped = true; });\n}\n\nfunction setup(sim, _, init, pulse) {\n  var f = array(_.forces), i, n, p, name;\n\n  for (i=0, n=ForceParams.length; i<n; ++i) {\n    p = ForceParams[i];\n    if (p !== Forces && _.modified(p)) sim[p](_[p]);\n  }\n\n  for (i=0, n=f.length; i<n; ++i) {\n    name = Forces + i;\n    p = init || _.modified(Forces, i) ? getForce(f[i])\n      : pulse && modified(f[i], pulse) ? sim.force(name)\n      : null;\n    if (p) sim.force(name, p);\n  }\n\n  for (n=(sim.numForces || 0); i<n; ++i) {\n    sim.force(Forces + i, null); // remove\n  }\n\n  sim.numForces = f.length;\n  return sim;\n}\n\nfunction modified(f, pulse) {\n  var k, v;\n  for (k in f) {\n    if (isFunction(v = f[k]) && pulse.modified(accessorFields(v)))\n      return 1;\n  }\n  return 0;\n}\n\nfunction getForce(_) {\n  var f, p;\n\n  if (!ForceMap.hasOwnProperty(_.force)) {\n    error('Unrecognized force: ' + _.force);\n  }\n  f = ForceMap[_.force]();\n\n  for (p in _) {\n    if (isFunction(f[p])) setForceParam(f[p], _[p], _);\n  }\n\n  return f;\n}\n\nfunction setForceParam(f, v, _) {\n  f(isFunction(v) ? function(d) { return v(d, _); } : v);\n}\n","export {default as contour} from './src/Contour';\nexport {default as geojson} from './src/GeoJSON';\nexport {default as geopath} from './src/GeoPath';\nexport {default as geopoint} from './src/GeoPoint';\nexport {default as geoshape} from './src/GeoShape';\nexport {default as graticule} from './src/Graticule';\nexport {default as projection} from './src/Projection';\n","import {ingest, Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\nimport {extent} from 'd3-array';\nimport {contours, contourDensity} from 'd3-contour';\n\nvar CONTOUR_PARAMS = ['size', 'smooth'];\nvar DENSITY_PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];\n\n/**\n * Generate contours based on kernel-density estimation of point data.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.\n *  If the values parameter is provided, this must be the dimensions of the input data.\n *  If density estimation is performed, this is the output view dimensions in pixels.\n * @param {Array<number>} [params.values] - An array of numeric values representing an\n *  width x height grid of values over which to compute contours. If unspecified, this\n *  transform will instead attempt to compute contours for the kernel density estimate\n *  using values drawn from data tuples in the input pulse.\n * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.\n * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.\n * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.\n * @param {number} [params.cellSize] - Contour density calculation cell size.\n * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.\n * @param {Array<number>} [params.thresholds] - Contour threshold array. If\n *   this parameter is set, the count and nice parameters will be ignored.\n * @param {number} [params.count] - The desired number of contours.\n * @param {boolean} [params.nice] - Boolean flag indicating if the contour\n *   threshold values should be automatically aligned to \"nice\"\n *   human-friendly values. Setting this flag may cause the number of\n *   thresholds to deviate from the specified count.\n * @param {boolean} [params.smooth] - Boolean flag indicating if the contour\n *   polygons should be smoothed using linear interpolation. The default is\n *   true. The parameter is ignored when using density estimation.\n */\nexport default function Contour(params) {\n  Transform.call(this, null, params);\n}\n\nContour.Definition = {\n  \"type\": \"Contour\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2, \"required\": true },\n    { \"name\": \"values\", \"type\": \"number\", \"array\": true },\n    { \"name\": \"x\", \"type\": \"field\" },\n    { \"name\": \"y\", \"type\": \"field\" },\n    { \"name\": \"weight\", \"type\": \"field\" },\n    { \"name\": \"cellSize\", \"type\": \"number\" },\n    { \"name\": \"bandwidth\", \"type\": \"number\" },\n    { \"name\": \"count\", \"type\": \"number\" },\n    { \"name\": \"smooth\", \"type\": \"boolean\" },\n    { \"name\": \"nice\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"thresholds\", \"type\": \"number\", \"array\": true }\n  ]\n};\n\nvar prototype = inherits(Contour, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (this.value && !pulse.changed() && !_.modified())\n    return pulse.StopPropagation;\n\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      count = _.count || 10,\n      contour, params, values;\n\n  if (_.values) {\n    contour = contours();\n    params = CONTOUR_PARAMS;\n    values = _.values;\n  } else {\n    contour = contourDensity();\n    params = DENSITY_PARAMS;\n    values = pulse.materialize(pulse.SOURCE).source;\n  }\n\n  // set threshold parameter\n  contour.thresholds(_.thresholds || (_.nice ? count : quantize(count)));\n\n  // set all other parameters\n  params.forEach(function(param) {\n    if (_[param] != null) contour[param](_[param]);\n  });\n\n  if (this.value) out.rem = this.value;\n  values = values && values.length ? contour(values).map(ingest) : [];\n  this.value = out.source = out.add = values;\n\n  return out;\n};\n\nfunction quantize(k) {\n  return function(values) {\n    var ex = extent(values), x0 = ex[0], dx = ex[1] - x0,\n        t = [], i = 1;\n    for (; i<=k; ++i) t.push(x0 + dx * i / (k + 1));\n    return t;\n  };\n}\n","import {Feature, FeatureCollection, MultiPoint} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {accessorFields, inherits} from 'vega-util';\n\n/**\n * Consolidate an array of [longitude, latitude] points or GeoJSON features\n * into a combined GeoJSON object. This transform is particularly useful for\n * combining geo data for a Projection's fit argument. The resulting GeoJSON\n * data is available as this transform's value. Input pulses are unchanged.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.fields] - A two-element array\n *   of field accessors for the longitude and latitude values.\n * @param {function(object): *} params.geojson - A field accessor for\n *   retrieving GeoJSON feature data.\n */\nexport default function GeoJSON(params) {\n  Transform.call(this, null, params);\n}\n\nGeoJSON.Definition = {\n  \"type\": \"GeoJSON\",\n  \"metadata\": {},\n  \"params\": [\n    { \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"length\": 2 },\n    { \"name\": \"geojson\", \"type\": \"field\" },\n  ]\n};\n\nvar prototype = inherits(GeoJSON, Transform);\n\nprototype.transform = function(_, pulse) {\n  var features = this._features,\n      points = this._points,\n      fields = _.fields,\n      lon = fields && fields[0],\n      lat = fields && fields[1],\n      geojson = _.geojson,\n      flag = pulse.ADD,\n      mod;\n\n  mod = _.modified()\n    || pulse.changed(pulse.REM)\n    || pulse.modified(accessorFields(geojson))\n    || (lon && (pulse.modified(accessorFields(lon))))\n    || (lat && (pulse.modified(accessorFields(lat))));\n\n  if (!this.value || mod) {\n    flag = pulse.SOURCE;\n    this._features = (features = []);\n    this._points = (points = []);\n  }\n\n  if (geojson) {\n    pulse.visit(flag, function(t) {\n      features.push(geojson(t));\n    });\n  }\n\n  if (lon && lat) {\n    pulse.visit(flag, function(t) {\n      var x = lon(t),\n          y = lat(t);\n      if (x != null && y != null && (x = +x) === x && (y = +y) === y) {\n        points.push([x, y]);\n      }\n    });\n    features = features.concat({\n      type: Feature,\n      geometry: {\n        type: MultiPoint,\n        coordinates: points\n      }\n    });\n  }\n\n  this.value = {\n    type: FeatureCollection,\n    features: features\n  };\n};\n","import {Transform} from 'vega-dataflow';\nimport {getProjectionPath} from 'vega-projection';\nimport {inherits, identity} from 'vega-util';\n\n/**\n * Map GeoJSON data to an SVG path string.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='path'] - The output field in which to store\n *   the generated path data (default 'path').\n */\nexport default function GeoPath(params) {\n  Transform.call(this, null, params);\n}\n\nGeoPath.Definition = {\n  \"type\": \"GeoPath\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"projection\", \"type\": \"projection\" },\n    { \"name\": \"field\", \"type\": \"field\" },\n    { \"name\": \"pointRadius\", \"type\": \"number\", \"expr\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"default\": \"path\" }\n  ]\n};\n\nvar prototype = inherits(GeoPath, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.ALL),\n      path = this.value,\n      field = _.field || identity,\n      as = _.as || 'path',\n      flag = out.SOURCE;\n\n  function set(t) { t[as] = path(field(t)); }\n\n  if (!path || _.modified()) {\n    // parameters updated, reset and reflow\n    this.value = path = getProjectionPath(_.projection);\n    out.materialize().reflow();\n  } else {\n    flag = field === identity || pulse.modified(field.fields)\n      ? out.ADD_MOD\n      : out.ADD;\n  }\n\n  var prev = initPath(path, _.pointRadius);\n  out.visit(flag, set);\n  path.pointRadius(prev);\n\n  return out.modifies(as);\n};\n\nfunction initPath(path, pointRadius) {\n  var prev = path.pointRadius();\n  path.context(null);\n  if (pointRadius != null) {\n    path.pointRadius(pointRadius);\n  }\n  return prev;\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Geo-code a longitude/latitude point to an x/y coordinate.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {Array<function(object): *>} params.fields - A two-element array of\n *   field accessors for the longitude and latitude values.\n * @param {Array<string>} [params.as] - A two-element array of field names\n *   under which to store the result. Defaults to ['x','y'].\n */\nexport default function GeoPoint(params) {\n  Transform.call(this, null, params);\n}\n\nGeoPoint.Definition = {\n  \"type\": \"GeoPoint\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"projection\", \"type\": \"projection\", \"required\": true },\n    { \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"required\": true, \"length\": 2 },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"x\", \"y\"] }\n  ]\n};\n\nvar prototype = inherits(GeoPoint, Transform);\n\nprototype.transform = function(_, pulse) {\n  var proj = _.projection,\n      lon = _.fields[0],\n      lat = _.fields[1],\n      as = _.as || ['x', 'y'],\n      x = as[0],\n      y = as[1],\n      mod;\n\n  function set(t) {\n    var xy = proj([lon(t), lat(t)]);\n    if (xy) {\n      t[x] = xy[0];\n      t[y] = xy[1];\n    } else {\n      t[x] = undefined;\n      t[y] = undefined;\n    }\n  }\n\n  if (_.modified()) {\n    // parameters updated, reflow\n    pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);\n  } else {\n    mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);\n    pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);\n  }\n\n  return pulse.modifies(as);\n};\n","import {Transform} from 'vega-dataflow';\nimport {getProjectionPath} from 'vega-projection';\nimport {inherits, field} from 'vega-util';\n\n/**\n * Annotate items with a geopath shape generator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(number, number): *} params.projection - The cartographic\n *   projection to apply.\n * @param {function(object): *} [params.field] - The field with GeoJSON data,\n *   or null if the tuple itself is a GeoJSON feature.\n * @param {string} [params.as='shape'] - The output field in which to store\n *   the generated path data (default 'shape').\n */\nexport default function GeoShape(params) {\n  Transform.call(this, null, params);\n}\n\nGeoShape.Definition = {\n  \"type\": \"GeoShape\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"projection\", \"type\": \"projection\" },\n    { \"name\": \"field\", \"type\": \"field\", \"default\": \"datum\" },\n    { \"name\": \"pointRadius\", \"type\": \"number\", \"expr\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"default\": \"shape\" }\n  ]\n};\n\nvar prototype = inherits(GeoShape, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.ALL),\n      shape = this.value,\n      datum = _.field || field('datum'),\n      as = _.as || 'shape',\n      flag = out.ADD_MOD;\n\n  if (!shape || _.modified()) {\n    // parameters updated, reset and reflow\n    this.value = shape = shapeGenerator(\n      getProjectionPath(_.projection),\n      datum,\n      _.pointRadius\n    );\n    out.materialize().reflow();\n    flag = out.SOURCE;\n  }\n\n  out.visit(flag, function(t) { t[as] = shape; });\n\n  return out.modifies(as);\n};\n\nfunction shapeGenerator(path, field, pointRadius) {\n  var shape = pointRadius == null\n    ? function(_) { return path(field(_)); }\n    : function(_) {\n      var prev = path.pointRadius(),\n          value = path.pointRadius(pointRadius)(field(_));\n      path.pointRadius(prev);\n      return value;\n    };\n  shape.context = function(_) {\n    path.context(_);\n    return shape;\n  };\n\n  return shape;\n}\n","import {Transform, ingest, replace} from 'vega-dataflow';\nimport {inherits, isFunction} from 'vega-util';\nimport {geoGraticule} from 'd3-geo';\n\n/**\n * GeoJSON feature generator for creating graticules.\n * @constructor\n */\nexport default function Graticule(params) {\n  Transform.call(this, [], params);\n  this.generator = geoGraticule();\n}\n\nGraticule.Definition = {\n  \"type\": \"Graticule\",\n  \"metadata\": {\"changes\": true},\n  \"params\": [\n    { \"name\": \"extent\", \"type\": \"array\", \"array\": true, \"length\": 2,\n      \"content\": {\"type\": \"number\", \"array\": true, \"length\": 2} },\n    { \"name\": \"extentMajor\", \"type\": \"array\", \"array\": true, \"length\": 2,\n      \"content\": {\"type\": \"number\", \"array\": true, \"length\": 2} },\n    { \"name\": \"extentMinor\", \"type\": \"array\", \"array\": true, \"length\": 2,\n      \"content\": {\"type\": \"number\", \"array\": true, \"length\": 2} },\n    { \"name\": \"step\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"stepMajor\", \"type\": \"number\", \"array\": true, \"length\": 2, \"default\": [90, 360] },\n    { \"name\": \"stepMinor\", \"type\": \"number\", \"array\": true, \"length\": 2, \"default\": [10, 10] },\n    { \"name\": \"precision\", \"type\": \"number\", \"default\": 2.5 }\n  ]\n};\n\nvar prototype = inherits(Graticule, Transform);\n\nprototype.transform = function(_, pulse) {\n  var src = this.value,\n      gen = this.generator, t;\n\n  if (!src.length || _.modified()) {\n    for (var prop in _) {\n      if (isFunction(gen[prop])) {\n        gen[prop](_[prop]);\n      }\n    }\n  }\n\n  t = gen();\n  if (src.length) {\n    pulse.mod.push(replace(src[0], t));\n  } else {\n    pulse.add.push(ingest(t));\n  }\n  src[0] = t;\n\n  return pulse;\n};\n","import {FeatureCollection} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {projection, projectionProperties} from 'vega-projection';\nimport {array, error, inherits, isArray, isFunction} from 'vega-util';\n\n/**\n * Maintains a cartographic projection.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nexport default function Projection(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\nvar prototype = inherits(Projection, Transform);\n\nprototype.transform = function(_, pulse) {\n  var proj = this.value;\n\n  if (!proj || _.modified('type')) {\n    this.value = (proj = create(_.type));\n    projectionProperties.forEach(function(prop) {\n      if (_[prop] != null) set(proj, prop, _[prop]);\n    });\n  } else {\n    projectionProperties.forEach(function(prop) {\n      if (_.modified(prop)) set(proj, prop, _[prop]);\n    });\n  }\n\n  if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);\n  if (_.fit) fit(proj, _);\n\n  return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n};\n\nfunction fit(proj, _) {\n  var data = collectGeoJSON(_.fit);\n  _.extent ? proj.fitExtent(_.extent, data)\n    : _.size ? proj.fitSize(_.size, data) : 0;\n}\n\nfunction create(type) {\n  var constructor = projection((type || 'mercator').toLowerCase());\n  if (!constructor) error('Unrecognized projection type: ' + type);\n  return constructor();\n}\n\nfunction set(proj, key, value) {\n   if (isFunction(proj[key])) proj[key](value);\n}\n\nexport function collectGeoJSON(features) {\n  features = array(features);\n  return features.length === 1\n    ? features[0]\n    : {\n        type: FeatureCollection,\n        features: features.reduce(function(list, f) {\n            (f && f.type === FeatureCollection) ? list.push.apply(list, f.features)\n              : isArray(f) ? list.push.apply(list, f)\n              : list.push(f);\n            return list;\n          }, [])\n      };\n}","export var Feature = 'Feature';\nexport var FeatureCollection = 'FeatureCollection';\nexport var MultiPoint = 'MultiPoint';\n","export {default as nest} from './src/Nest';\nexport {default as pack} from './src/Pack';\nexport {default as partition} from './src/Partition';\nexport {default as stratify} from './src/Stratify';\nexport {default as tree} from './src/Tree';\nexport {default as treelinks} from './src/TreeLinks';\nexport {default as treemap} from './src/Treemap';\n","import {Transform} from 'vega-dataflow';\nimport {error, inherits, one} from 'vega-util';\n\n/**\n * Abstract class for tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nexport default function HierarchyLayout(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(HierarchyLayout, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (!pulse.source || !pulse.source.root) {\n    error(this.constructor.name\n      + ' transform requires a backing tree data source.');\n  }\n\n  var layout = this.layout(_.method),\n      fields = this.fields,\n      root = pulse.source.root,\n      as = _.as || fields;\n\n  if (_.field) root.sum(_.field);\n  if (_.sort) root.sort(_.sort);\n\n  setParams(layout, this.params, _);\n  if (layout.separation) {\n    layout.separation(_.separation !== false ? defaultSeparation : one);\n  }\n\n  try {\n    this.value = layout(root);\n  } catch (err) {\n    error(err);\n  }\n  root.each(function(node) { setFields(node, fields, as); });\n\n  return pulse.reflow(_.modified()).modifies(as).modifies('leaf');\n};\n\nfunction setParams(layout, params, _) {\n  for (var p, i=0, n=params.length; i<n; ++i) {\n    p = params[i];\n    if (p in _) layout[p](_[p]);\n  }\n}\n\nfunction setFields(node, fields, as) {\n  var t = node.data;\n  for (var i=0, n=fields.length-1; i<n; ++i) {\n    t[as[i]] = node[fields[i]];\n  }\n  t[as[n]] = node.children ? node.children.length : 0;\n}\n\nfunction defaultSeparation(a, b) {\n  return a.parent === b.parent ? 1 : 2;\n}\n","import lookup from './lookup';\nimport {ingest, isTuple, Transform, tupleid} from 'vega-dataflow';\nimport {array, error, inherits} from 'vega-util';\nimport {nest} from 'd3-collection';\nimport {hierarchy} from 'd3-hierarchy';\n\n /**\n  * Nest tuples into a tree structure, grouped by key values.\n  * @constructor\n  * @param {object} params - The parameters for this operator.\n  * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.\n  * @param {boolean} [params.generate=false] - A boolean flag indicating if\n  *   non-leaf nodes generated by this transform should be included in the\n  *   output. The default (false) includes only the input data (leaf nodes)\n  *   in the data stream.\n  */\nexport default function Nest(params) {\n  Transform.call(this, null, params);\n}\n\nNest.Definition = {\n  \"type\": \"Nest\",\n  \"metadata\": {\"treesource\": true, \"changes\": true},\n  \"params\": [\n    { \"name\": \"keys\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"generate\", \"type\": \"boolean\" }\n  ]\n};\n\nvar prototype = inherits(Nest, Transform);\n\nfunction children(n) {\n  return n.values;\n}\n\nprototype.transform = function(_, pulse) {\n  if (!pulse.source) {\n    error('Nest transform requires an upstream data source.');\n  }\n\n  var gen = _.generate,\n      mod = _.modified(),\n      out = pulse.clone(),\n      tree = this.value;\n\n  if (!tree || mod || pulse.changed()) {\n    // collect nodes to remove\n    if (tree) {\n      tree.each(function(node) {\n        if (node.children && isTuple(node.data)) {\n          out.rem.push(node.data);\n        }\n      });\n    }\n\n    // generate new tree structure\n    this.value = tree = hierarchy({\n      values: array(_.keys)\n                .reduce(function(n, k) { n.key(k); return n; }, nest())\n                .entries(out.source)\n    }, children);\n\n    // collect nodes to add\n    if (gen) {\n      tree.each(function(node) {\n        if (node.children) {\n          node = ingest(node.data);\n          out.add.push(node);\n          out.source.push(node);\n        }\n      });\n    }\n\n    // build lookup table\n    lookup(tree, tupleid, tupleid);\n  }\n\n  out.source.root = tree;\n  return out;\n};\n","import HierarchyLayout from './HierarchyLayout';\nimport {inherits} from 'vega-util';\nimport {pack} from 'd3-hierarchy';\n\nvar Output = ['x', 'y', 'r', 'depth', 'children'];\n\n/**\n * Packed circle tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\nexport default function Pack(params) {\n  HierarchyLayout.call(this, params);\n}\n\nPack.Definition = {\n  \"type\": \"Pack\",\n  \"metadata\": {\"tree\": true, \"modifies\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\" },\n    { \"name\": \"sort\", \"type\": \"compare\" },\n    { \"name\": \"padding\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"radius\", \"type\": \"field\", \"default\": null },\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": Output.length, \"default\": Output }\n  ]\n};\n\nvar prototype = inherits(Pack, HierarchyLayout);\n\nprototype.layout = pack;\n\nprototype.params = ['size', 'padding'];\n\nprototype.fields = Output;\n","import HierarchyLayout from './HierarchyLayout';\nimport {inherits} from 'vega-util';\nimport {partition} from 'd3-hierarchy';\n\nvar Output = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n\n/**\n * Partition tree layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\nexport default function Partition(params) {\n  HierarchyLayout.call(this, params);\n}\n\nPartition.Definition = {\n  \"type\": \"Partition\",\n  \"metadata\": {\"tree\": true, \"modifies\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\" },\n    { \"name\": \"sort\", \"type\": \"compare\" },\n    { \"name\": \"padding\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"round\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": Output.length, \"default\": Output }\n  ]\n};\n\nvar prototype = inherits(Partition, HierarchyLayout);\n\nprototype.layout = partition;\n\nprototype.params = ['size', 'round', 'padding'];\n\nprototype.fields = Output;\n","import lookup from './lookup';\nimport {Transform} from 'vega-dataflow';\nimport {error, inherits, truthy} from 'vega-util';\nimport {stratify} from 'd3-hierarchy';\n\n /**\n  * Stratify a collection of tuples into a tree structure based on\n  * id and parent id fields.\n  * @constructor\n  * @param {object} params - The parameters for this operator.\n  * @param {function(object): *} params.key - Unique key field for each tuple.\n  * @param {function(object): *} params.parentKey - Field with key for parent tuple.\n  */\nexport default function Stratify(params) {\n  Transform.call(this, null, params);\n}\n\nStratify.Definition = {\n  \"type\": \"Stratify\",\n  \"metadata\": {\"treesource\": true},\n  \"params\": [\n    { \"name\": \"key\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"parentKey\", \"type\": \"field\", \"required\": true  }\n  ]\n};\n\nvar prototype = inherits(Stratify, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (!pulse.source) {\n    error('Stratify transform requires an upstream data source.');\n  }\n\n  var tree = this.value,\n      mod = _.modified(),\n      out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),\n      run = !this.value\n         || mod\n         || pulse.changed(pulse.ADD_REM)\n         || pulse.modified(_.key.fields)\n         || pulse.modified(_.parentKey.fields);\n\n  // prevent upstream source pollution\n  out.source = out.source.slice();\n\n  if (run) {\n    if (out.source.length) {\n      tree = lookup(\n        stratify().id(_.key).parentId(_.parentKey)(out.source)\n        , _.key, truthy);\n    } else {\n      tree = lookup(stratify()([{}]), _.key, _.key);\n    }\n  }\n\n  out.source.root = this.value = tree;\n  return out;\n};\n","import HierarchyLayout from './HierarchyLayout';\nimport {error, inherits} from 'vega-util';\nimport {tree, cluster} from 'd3-hierarchy';\n\nvar Layouts = {\n  tidy: tree,\n  cluster: cluster\n};\n\nvar Output = ['x', 'y', 'depth', 'children'];\n\n/**\n * Tree layout. Depending on the method parameter, performs either\n * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nexport default function Tree(params) {\n  HierarchyLayout.call(this, params);\n}\n\nTree.Definition = {\n  \"type\": \"Tree\",\n  \"metadata\": {\"tree\": true, \"modifies\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\" },\n    { \"name\": \"sort\", \"type\": \"compare\" },\n    { \"name\": \"method\", \"type\": \"enum\", \"default\": \"tidy\", \"values\": [\"tidy\", \"cluster\"] },\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"nodeSize\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"separation\", \"type\": \"boolean\", \"default\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": Output.length, \"default\": Output }\n  ]\n};\n\nvar prototype = inherits(Tree, HierarchyLayout);\n\n/**\n * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.\n */\nprototype.layout = function(method) {\n  var m = method || 'tidy';\n  if (Layouts.hasOwnProperty(m)) return Layouts[m]();\n  else error('Unrecognized Tree layout method: ' + m);\n};\n\nprototype.params = ['size', 'nodeSize'];\n\nprototype.fields = Output;\n","import {ingest, tupleid, Transform} from 'vega-dataflow';\nimport {error, inherits} from 'vega-util';\n\n /**\n  * Generate tuples representing links between tree nodes.\n  * The resulting tuples will contain 'source' and 'target' fields,\n  * which point to parent and child node tuples, respectively.\n  * @constructor\n  * @param {object} params - The parameters for this operator.\n  */\nexport default function TreeLinks(params) {\n  Transform.call(this, [], params);\n}\n\nTreeLinks.Definition = {\n  \"type\": \"TreeLinks\",\n  \"metadata\": {\"tree\": true, \"generates\": true, \"changes\": true},\n  \"params\": []\n};\n\nvar prototype = inherits(TreeLinks, Transform);\n\nprototype.transform = function(_, pulse) {\n  var links = this.value,\n      tree = pulse.source && pulse.source.root,\n      out = pulse.fork(pulse.NO_SOURCE),\n      lut = {};\n\n  if (!tree) error('TreeLinks transform requires a tree data source.');\n\n  if (pulse.changed(pulse.ADD_REM)) {\n    // remove previous links\n    out.rem = links;\n\n    // build lookup table of valid tuples\n    pulse.visit(pulse.SOURCE, function(t) { lut[tupleid(t)] = 1; });\n\n    // generate links for all edges incident on valid tuples\n    tree.each(function(node) {\n      var t = node.data,\n          p = node.parent && node.parent.data;\n      if (p && lut[tupleid(t)] && lut[tupleid(p)]) {\n        out.add.push(ingest({source: p, target: t}));\n      }\n    });\n    this.value = out.add;\n  }\n\n  else if (pulse.changed(pulse.MOD)) {\n    // build lookup table of modified tuples\n    pulse.visit(pulse.MOD, function(t) { lut[tupleid(t)] = 1; });\n\n    // gather links incident on modified tuples\n    links.forEach(function(link) {\n      if (lut[tupleid(link.source)] || lut[tupleid(link.target)]) {\n        out.mod.push(link);\n      }\n    });\n  }\n\n  return out;\n};\n","import HierarchyLayout from './HierarchyLayout';\nimport {error, inherits} from 'vega-util';\nimport {\n  treemap,\n  treemapBinary,\n  treemapDice,\n  treemapSlice,\n  treemapSliceDice,\n  treemapSquarify,\n  treemapResquarify\n} from 'd3-hierarchy';\n\nvar Tiles = {\n  binary: treemapBinary,\n  dice: treemapDice,\n  slice: treemapSlice,\n  slicedice: treemapSliceDice,\n  squarify: treemapSquarify,\n  resquarify: treemapResquarify\n};\n\nvar Output = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];\n\n/**\n * Treemap layout.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to size nodes.\n */\nexport default function Treemap(params) {\n  HierarchyLayout.call(this, params);\n}\n\nTreemap.Definition = {\n  \"type\": \"Treemap\",\n  \"metadata\": {\"tree\": true, \"modifies\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\" },\n    { \"name\": \"sort\", \"type\": \"compare\" },\n    { \"name\": \"method\", \"type\": \"enum\", \"default\": \"squarify\",\n      \"values\": [\"squarify\", \"resquarify\", \"binary\", \"dice\", \"slice\", \"slicedice\"] },\n    { \"name\": \"padding\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"paddingInner\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"paddingOuter\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"paddingTop\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"paddingRight\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"paddingBottom\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"paddingLeft\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"ratio\", \"type\": \"number\", \"default\": 1.618033988749895 },\n    { \"name\": \"round\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": Output.length, \"default\": Output }\n  ]\n};\n\nvar prototype = inherits(Treemap, HierarchyLayout);\n\n/**\n * Treemap layout generator. Adds 'method' and 'ratio' parameters\n * to configure the underlying tile method.\n */\nprototype.layout = function() {\n  var x = treemap();\n  x.ratio = function(_) {\n    var t = x.tile();\n    if (t.ratio) x.tile(t.ratio(_));\n  };\n  x.method = function(_) {\n    if (Tiles.hasOwnProperty(_)) x.tile(Tiles[_]);\n    else error('Unrecognized Treemap layout method: ' + _);\n  };\n  return x;\n};\n\nprototype.params = [\n  'method', 'ratio', 'size', 'round',\n  'padding', 'paddingInner', 'paddingOuter',\n  'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'\n];\n\nprototype.fields = Output;\n","// Build lookup table mapping tuple keys to tree node instances\nexport default function(tree, key, filter) {\n  var map = {};\n  tree.each(function(node) {\n    var t = node.data;\n    if (filter(t)) map[key(t)] = node;\n  });\n  tree.lookup = map;\n  return tree;\n}\n","// -- Transforms -----\n\nimport {extend} from 'vega-util';\nimport {transforms} from 'vega-dataflow';\nimport * as tx from 'vega-transforms';\nimport * as vtx from 'vega-view-transforms';\nimport * as encode from 'vega-encode';\nimport * as geo from 'vega-geo';\nimport * as force from 'vega-force';\nimport * as tree from 'vega-hierarchy';\nimport * as voronoi from 'vega-voronoi';\nimport * as wordcloud from 'vega-wordcloud';\nimport * as xf from 'vega-crossfilter';\nextend(transforms, tx, vtx, encode, geo, force, tree, voronoi, wordcloud, xf);\n\n\n// -- Exports -----\n\nexport {\n  version\n} from './package.json';\n\nexport * from 'vega-statistics';\n\nexport * from 'vega-util';\n\nexport * from 'vega-loader';\n\nexport * from 'vega-scenegraph';\n\nexport {\n  Dataflow,\n  EventStream,\n  Parameters,\n  Pulse,\n  MultiPulse,\n  Operator,\n  Transform,\n  changeset,\n  ingest,\n  isTuple,\n  definition,\n  transform,\n  transforms,\n  tupleid\n} from 'vega-dataflow';\n\nexport {\n  scale,\n  scheme,\n  schemeDiscretized,\n  interpolate,\n  interpolateRange,\n  timeInterval,\n  utcInterval\n} from 'vega-scale';\n\nexport {\n  projection\n} from 'vega-projection';\n\nexport {\n  View\n} from 'vega-view';\n\nexport {\n  parse,\n  expressionFunction,\n  formatLocale,\n  timeFormatLocale\n} from 'vega-parser';\n\nexport {\n  parse as runtime,\n  context as runtimeContext\n} from 'vega-runtime';\n","import {AggregateOp} from 'vega';\nimport {toSet} from 'vega-util';\nimport {contains, Flag, flagKeys} from './util';\n\nconst AGGREGATE_OP_INDEX: Flag<AggregateOp> = {\n  argmax: 1,\n  argmin: 1,\n  average: 1,\n  count: 1,\n  distinct: 1,\n  max: 1,\n  mean: 1,\n  median: 1,\n  min: 1,\n  missing: 1,\n  q1: 1,\n  q3: 1,\n  ci0: 1,\n  ci1: 1,\n  stderr: 1,\n  stdev: 1,\n  stdevp: 1,\n  sum: 1,\n  valid: 1,\n  values: 1,\n  variance: 1,\n  variancep: 1\n};\n\nexport const AGGREGATE_OPS = flagKeys(AGGREGATE_OP_INDEX);\n\nexport function isAggregateOp(a: string): a is AggregateOp {\n  return !!AGGREGATE_OP_INDEX[a];\n}\n\nexport const COUNTING_OPS: AggregateOp[] = ['count', 'valid', 'missing', 'distinct'];\n\nexport function isCountingAggregateOp(aggregate: string): boolean {\n  return aggregate && contains(COUNTING_OPS, aggregate);\n}\n\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexport const SUM_OPS: AggregateOp[] = ['count', 'sum', 'distinct', 'valid', 'missing'];\n\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexport const SHARED_DOMAIN_OPS: AggregateOp[] = ['mean', 'average', 'median', 'q1', 'q3', 'min', 'max'];\n\nexport const SHARED_DOMAIN_OP_INDEX = toSet(SHARED_DOMAIN_OPS);\n","import {Align, Axis as VgAxis, AxisOrient, BaseAxis, FontWeight, LabelOverlap, TextBaseline} from 'vega';\nimport {DateTime} from './datetime';\nimport {Guide, GuideEncodingEntry, VlOnlyGuideConfig} from './guide';\nimport {Flag, flagKeys} from './util';\nimport {Color, VgLayoutAlign} from './vega.schema';\n\ntype BaseAxisNoSignals = AxisMixins &\n  BaseAxis<\n    number,\n    number,\n    boolean,\n    number | boolean,\n    string,\n    Color,\n    FontWeight,\n    Align,\n    TextBaseline,\n    VgLayoutAlign,\n    LabelOverlap,\n    number[]\n  >;\n\n// Vega axis config is the same as vega axis base. If this is not the case, add specific type.\ntype VgAxisConfigNoSignals = BaseAxisNoSignals;\n\n// Change comments to be Vega-Lite specific\ninterface AxisMixins {\n  /**\n   * A boolean flag indicating if grid lines should be included as part of the axis\n   *\n   * __Default value:__ `true` for [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous) that are not binned; otherwise, `false`.\n   */\n  grid?: boolean;\n\n  /**\n   * Indicates if the first and last axis labels should be aligned flush with the scale range. Flush alignment for a horizontal axis will left-align the first label and right-align the last label. For vertical axes, bottom and top text baselines are applied instead. If this property is a number, it also indicates the number of pixels by which to offset the first and last labels; for example, a value of 2 will flush-align the first and last labels and also push them 2 pixels outward from the center of the axis. The additional adjustment can sometimes help the labels better visually group with corresponding axis ticks.\n   *\n   * __Default value:__ `true` for axis of a continuous x-scale. Otherwise, `false`.\n   */\n  labelFlush?: boolean | number;\n\n  /**\n   * The strategy to use for resolving overlap of axis labels. If `false` (the default), no overlap reduction is attempted. If set to `true` or `\"parity\"`, a strategy of removing every other label is used (this works well for standard linear axes). If set to `\"greedy\"`, a linear scan of the labels is performed, removing any labels that overlaps with the last visible label (this often works better for log-scaled axes).\n   *\n   * __Default value:__ `true` for non-nominal fields with non-log scales; `\"greedy\"` for log scales; otherwise `false`.\n   */\n  labelOverlap?: LabelOverlap;\n}\n\nexport type AxisConfig = VgAxisConfigNoSignals & VlOnlyGuideConfig;\n\nexport interface Axis extends BaseAxisNoSignals, Guide {\n  /**\n   * The orientation of the axis. One of `\"top\"`, `\"bottom\"`, `\"left\"` or `\"right\"`. The orientation can be used to further specialize the axis type (e.g., a y axis oriented for the right edge of the chart).\n   *\n   * __Default value:__ `\"bottom\"` for x-axes and `\"left\"` for y-axes.\n   */\n  orient?: AxisOrient;\n\n  /**\n   * The offset, in pixels, by which to displace the axis from the edge of the enclosing group or data rectangle.\n   *\n   * __Default value:__ derived from the [axis config](https://vega.github.io/vega-lite/docs/config.html#facet-scale-config)'s `offset` (`0` by default)\n   */\n  offset?: number;\n\n  /**\n   * The anchor position of the axis in pixels. For x-axes with top or bottom orientation, this sets the axis group x coordinate. For y-axes with left or right orientation, this sets the axis group y coordinate.\n   *\n   * __Default value__: `0`\n   */\n  position?: number;\n\n  /**\n   * A desired number of ticks, for axes visualizing quantitative scales. The resulting number may be different so that values are \"nice\" (multiples of 2, 5, 10) and lie within the underlying scale's range.\n   * @minimum 0\n   *\n   * __Default value__: Determine using a formula `ceil(width/40)` for x and `ceil(height/40)` for y.\n   */\n  tickCount?: number;\n\n  /**\n   * A desired step size for ticks. This property will generate the corresponding `tickCount` and `values`. It can be useful for [data that are binned before importing into Vega-Lite](https://vega.github.io/vega-lite/docs/bin.html#binned).\n   *\n   * __Default value__: `undefined`\n   */\n  tickStep?: number;\n\n  /**\n   * Explicitly set the visible axis tick values.\n   */\n  values?: number[] | string[] | boolean[] | DateTime[];\n\n  /**\n   * A non-positive integer indicating z-index of the axis.\n   * If zindex is 0, axes should be drawn behind all chart elements.\n   * To put them in front, use `\"zindex = 1\"`.\n   *\n   * __Default value:__ `1` (in front of the marks) for actual axis and `0` (behind the marks) for grids.\n   *\n   * @TJS-type integer\n   * @minimum 0\n   */\n  zindex?: number;\n\n  /**\n   * Mark definitions for custom axis encoding.\n   *\n   * @hide\n   */\n  encoding?: AxisEncoding;\n}\n\nexport type AxisPart = keyof AxisEncoding;\nexport const AXIS_PARTS: AxisPart[] = ['domain', 'grid', 'labels', 'ticks', 'title'];\n\n/**\n * A dictionary listing whether a certain axis property is applicable for only main axes or only grid axes.\n * (Properties not listed are applicable for both)\n */\nexport const AXIS_PROPERTY_TYPE: {\n  // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n  [k in keyof VgAxis]: 'main' | 'grid' | 'both'\n} = {\n  grid: 'grid',\n  gridColor: 'grid',\n  gridDash: 'grid',\n  gridOpacity: 'grid',\n  gridScale: 'grid',\n  gridWidth: 'grid',\n\n  orient: 'main',\n\n  bandPosition: 'main',\n  domain: 'main',\n  domainColor: 'main',\n  domainOpacity: 'main',\n  domainWidth: 'main',\n  format: 'main',\n  labelAlign: 'main',\n  labelAngle: 'main',\n  labelBaseline: 'main',\n  labelBound: 'main',\n  labelColor: 'main',\n  labelFlush: 'main',\n  labelFlushOffset: 'main',\n  labelFont: 'main',\n  labelFontSize: 'main',\n  labelFontWeight: 'main',\n  labelLimit: 'main',\n  labelOpacity: 'main',\n  labelOverlap: 'main',\n  labelPadding: 'main',\n  labels: 'main',\n  maxExtent: 'main',\n  minExtent: 'main',\n  offset: 'main',\n  position: 'main',\n  tickColor: 'main',\n  tickExtra: 'main',\n  tickOffset: 'main',\n  tickOpacity: 'main',\n  tickRound: 'main',\n  ticks: 'main',\n  tickSize: 'main',\n  title: 'main',\n  titleAlign: 'main',\n  titleAngle: 'main',\n  titleBaseline: 'main',\n  titleColor: 'main',\n  titleFont: 'main',\n  titleFontSize: 'main',\n  titleFontWeight: 'main',\n  titleLimit: 'main',\n  titleOpacity: 'main',\n  titlePadding: 'main',\n  titleX: 'main',\n  titleY: 'main',\n\n  tickWidth: 'both',\n  tickCount: 'both',\n  values: 'both',\n  scale: 'both',\n  zindex: 'both' // this is actually set afterward, so it doesn't matter\n};\n\nexport interface AxisEncoding {\n  /**\n   * Custom encoding for the axis container.\n   */\n  axis?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for the axis domain rule mark.\n   */\n  domain?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for axis gridline rule marks.\n   */\n  grid?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for axis label text marks.\n   */\n  labels?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for axis tick rule marks.\n   */\n  ticks?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for the axis title text mark.\n   */\n  title?: GuideEncodingEntry;\n}\n\nconst COMMON_AXIS_PROPERTIES_INDEX: Flag<keyof (VgAxis | Axis)> = {\n  orient: 1, // other things can depend on orient\n\n  bandPosition: 1,\n  domain: 1,\n  domainColor: 1,\n  domainOpacity: 1,\n  domainWidth: 1,\n  format: 1,\n  grid: 1,\n  gridColor: 1,\n  gridDash: 1,\n  gridOpacity: 1,\n  gridWidth: 1,\n  labelAlign: 1,\n  labelAngle: 1,\n  labelBaseline: 1,\n  labelBound: 1,\n  labelColor: 1,\n  labelFlush: 1,\n  labelFlushOffset: 1,\n  labelFont: 1,\n  labelFontSize: 1,\n  labelFontWeight: 1,\n  labelLimit: 1,\n  labelOpacity: 1,\n  labelOverlap: 1,\n  labelPadding: 1,\n  labels: 1,\n  maxExtent: 1,\n  minExtent: 1,\n  offset: 1,\n  position: 1,\n  tickColor: 1,\n  tickCount: 1,\n  tickExtra: 1,\n  tickOffset: 1,\n  tickOpacity: 1,\n  tickRound: 1,\n  ticks: 1,\n  tickSize: 1,\n  tickWidth: 1,\n  title: 1,\n  titleAlign: 1,\n  titleAngle: 1,\n  titleBaseline: 1,\n  titleColor: 1,\n  titleFont: 1,\n  titleFontSize: 1,\n  titleFontWeight: 1,\n  titleLimit: 1,\n  titleOpacity: 1,\n  titlePadding: 1,\n  titleX: 1,\n  titleY: 1,\n  values: 1,\n  zindex: 1\n};\n\nconst AXIS_PROPERTIES_INDEX: Flag<keyof Axis> = {\n  ...COMMON_AXIS_PROPERTIES_INDEX,\n  encoding: 1,\n  labelAngle: 1,\n  tickStep: 1\n};\n\nconst VG_AXIS_PROPERTIES_INDEX: Flag<keyof VgAxis> = {\n  gridScale: 1,\n  scale: 1,\n  ...COMMON_AXIS_PROPERTIES_INDEX,\n  encode: 1\n};\n\nexport function isAxisProperty(prop: string): prop is keyof Axis {\n  return !!AXIS_PROPERTIES_INDEX[prop];\n}\n\nexport const VG_AXIS_PROPERTIES = flagKeys(VG_AXIS_PROPERTIES_INDEX);\n\n// Export for dependent projects\nexport const AXIS_PROPERTIES = flagKeys(AXIS_PROPERTIES_INDEX);\n\nexport interface AxisConfigMixins {\n  /**\n   * Axis configuration, which determines default properties for all `x` and `y` [axes](https://vega.github.io/vega-lite/docs/axis.html). For a full list of axis configuration options, please see the [corresponding section of the axis documentation](https://vega.github.io/vega-lite/docs/axis.html#config).\n   */\n  axis?: AxisConfig;\n\n  /**\n   * X-axis specific config.\n   */\n  axisX?: AxisConfig;\n\n  /**\n   * Y-axis specific config.\n   */\n  axisY?: AxisConfig;\n\n  /**\n   * Specific axis config for y-axis along the left edge of the chart.\n   */\n  axisLeft?: AxisConfig;\n\n  /**\n   * Specific axis config for y-axis along the right edge of the chart.\n   */\n  axisRight?: AxisConfig;\n\n  /**\n   * Specific axis config for x-axis along the top edge of the chart.\n   */\n  axisTop?: AxisConfig;\n\n  /**\n   * Specific axis config for x-axis along the bottom edge of the chart.\n   */\n  axisBottom?: AxisConfig;\n\n  /**\n   * Specific axis config for axes with \"band\" scales.\n   */\n  axisBand?: AxisConfig;\n}\n","import {isBoolean, isObject} from 'vega-util';\nimport {BinParams} from './bin';\nimport {Channel, COLOR, COLUMN, FILL, OPACITY, ROW, SHAPE, SIZE, STROKE} from './channel';\nimport {keys, varName} from './util';\n\nexport interface BaseBin {\n  /**\n   * The number base to use for automatic bin determination (default is base 10).\n   *\n   * __Default value:__ `10`\n   *\n   */\n  base?: number;\n  /**\n   * An exact step size to use between bins.\n   *\n   * __Note:__ If provided, options such as maxbins will be ignored.\n   */\n  step?: number;\n  /**\n   * An array of allowable step sizes to choose from.\n   * @minItems 1\n   */\n  steps?: number[];\n  /**\n   * A minimum allowable step size (particularly useful for integer values).\n   */\n  minstep?: number;\n  /**\n   * Scale factors indicating allowable subdivisions. The default value is [5, 2], which indicates that for base 10 numbers (the default base), the method may consider dividing bin sizes by 5 and/or 2. For example, for an initial step size of 10, the method can check if bin sizes of 2 (= 10/5), 5 (= 10/2), or 1 (= 10/(5*2)) might also satisfy the given constraints.\n   *\n   * __Default value:__ `[5, 2]`\n   *\n   * @minItems 1\n   */\n  divide?: number[];\n  /**\n   * Maximum number of bins.\n   *\n   * __Default value:__ `6` for `row`, `column` and `shape` channels; `10` for other channels\n   *\n   * @minimum 2\n   */\n  maxbins?: number;\n  /**\n   * A value in the binned domain at which to anchor the bins, shifting the bin boundaries if necessary to ensure that a boundary aligns with the anchor value.\n   *\n   * __Default Value:__ the minimum bin extent value\n   */\n  anchor?: number;\n  /**\n   * If true (the default), attempts to make the bin boundaries use human-friendly boundaries, such as multiples of ten.\n   */\n  nice?: boolean;\n}\n\n/**\n * Binning properties or boolean flag for determining whether to bin data or not.\n */\nexport interface BinParams extends BaseBin {\n  /**\n   * A two-element (`[min, max]`) array indicating the range of desired bin values.\n   * @minItems 2\n   * @maxItems 2\n   */\n  extent?: number[]; // VgBinTransform uses a different extent so we need to pull this out.\n}\n\nexport function binToString(bin: BinParams | boolean) {\n  if (isBoolean(bin)) {\n    return 'bin';\n  }\n  return (\n    'bin' +\n    keys(bin)\n      .map(p => varName(`_${p}_${bin[p]}`))\n      .join('')\n  );\n}\n\nexport function isBinning(bin: BinParams | boolean | 'binned'): bin is BinParams | true {\n  return bin === true || isBinParams(bin);\n}\n\nexport function isBinned(bin: BinParams | boolean | 'binned'): bin is 'binned' {\n  return bin === 'binned';\n}\n\nexport function isBinParams(bin: BinParams | boolean | 'binned'): bin is BinParams {\n  return isObject(bin);\n}\n\nexport function autoMaxBins(channel: Channel): number {\n  switch (channel) {\n    case ROW:\n    case COLUMN:\n    case SIZE:\n    case COLOR:\n    case FILL:\n    case STROKE:\n    case OPACITY:\n    // Facets and Size shouldn't have too many bins\n    // We choose 6 like shape to simplify the rule\n    case SHAPE:\n      return 6; // Vega's \"shape\" has 6 distinct values\n    default:\n      return 10;\n  }\n}\n","/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\n\nimport {isBinned} from './bin';\nimport {RangeType} from './compile/scale/type';\nimport {Encoding} from './encoding';\nimport {FacetMapping} from './facet';\nimport {isFieldDef} from './fielddef';\nimport {CIRCLE, Mark, POINT, SQUARE, TICK} from './mark';\nimport {contains, Flag, flagKeys} from './util';\n\nexport namespace Channel {\n  // Facet\n  export const ROW: 'row' = 'row';\n  export const COLUMN: 'column' = 'column';\n\n  // Position\n  export const X: 'x' = 'x';\n  export const Y: 'y' = 'y';\n  export const X2: 'x2' = 'x2';\n  export const Y2: 'y2' = 'y2';\n\n  // Geo Position\n  export const LATITUDE: 'latitude' = 'latitude';\n  export const LONGITUDE: 'longitude' = 'longitude';\n  export const LATITUDE2: 'latitude2' = 'latitude2';\n  export const LONGITUDE2: 'longitude2' = 'longitude2';\n\n  // Mark property with scale\n  export const COLOR: 'color' = 'color';\n\n  export const FILL: 'fill' = 'fill';\n\n  export const STROKE: 'stroke' = 'stroke';\n\n  export const SHAPE: 'shape' = 'shape';\n  export const SIZE: 'size' = 'size';\n  export const OPACITY: 'opacity' = 'opacity';\n\n  // Non-scale channel\n  export const TEXT: 'text' = 'text';\n  export const ORDER: 'order' = 'order';\n  export const DETAIL: 'detail' = 'detail';\n  export const KEY: 'key' = 'key';\n\n  export const TOOLTIP: 'tooltip' = 'tooltip';\n  export const HREF: 'href' = 'href';\n}\n\nexport type Channel = keyof Encoding<any> | keyof FacetMapping<any>;\n\nexport const X = Channel.X;\nexport const Y = Channel.Y;\nexport const X2 = Channel.X2;\nexport const Y2 = Channel.Y2;\n\nexport const LATITUDE = Channel.LATITUDE;\nexport const LATITUDE2 = Channel.LATITUDE2;\nexport const LONGITUDE = Channel.LONGITUDE;\nexport const LONGITUDE2 = Channel.LONGITUDE2;\n\nexport const ROW = Channel.ROW;\nexport const COLUMN = Channel.COLUMN;\nexport const SHAPE = Channel.SHAPE;\nexport const SIZE = Channel.SIZE;\nexport const COLOR = Channel.COLOR;\n\nexport const FILL = Channel.FILL;\nexport const STROKE = Channel.STROKE;\nexport const TEXT = Channel.TEXT;\nexport const DETAIL = Channel.DETAIL;\nexport const KEY = Channel.KEY;\nexport const ORDER = Channel.ORDER;\nexport const OPACITY = Channel.OPACITY;\nexport const TOOLTIP = Channel.TOOLTIP;\nexport const HREF = Channel.HREF;\n\nexport type GeoPositionChannel = 'longitude' | 'latitude' | 'longitude2' | 'latitude2';\n\nexport const GEOPOSITION_CHANNEL_INDEX: Flag<GeoPositionChannel> = {\n  longitude: 1,\n  longitude2: 1,\n  latitude: 1,\n  latitude2: 1\n};\n\nexport const GEOPOSITION_CHANNELS = flagKeys(GEOPOSITION_CHANNEL_INDEX);\n\nconst UNIT_CHANNEL_INDEX: Flag<keyof Encoding<any>> = {\n  // position\n  x: 1,\n  y: 1,\n  x2: 1,\n  y2: 1,\n\n  ...GEOPOSITION_CHANNEL_INDEX,\n\n  // color\n  color: 1,\n  fill: 1,\n  stroke: 1,\n\n  // other non-position with scale\n  opacity: 1,\n  size: 1,\n  shape: 1,\n\n  // channels without scales\n  order: 1,\n  text: 1,\n  detail: 1,\n  key: 1,\n  tooltip: 1,\n  href: 1\n};\n\nexport type ColorChannel = 'color' | 'fill' | 'stroke';\n\nexport function isColorChannel(channel: Channel): channel is ColorChannel {\n  return channel === 'color' || channel === 'fill' || channel === 'stroke';\n}\n\nconst FACET_CHANNEL_INDEX: Flag<keyof FacetMapping<any>> = {\n  row: 1,\n  column: 1\n};\n\nconst CHANNEL_INDEX = {\n  ...UNIT_CHANNEL_INDEX,\n  ...FACET_CHANNEL_INDEX\n};\n\nexport const CHANNELS = flagKeys(CHANNEL_INDEX);\n\nconst {order: _o, detail: _d, ...SINGLE_DEF_CHANNEL_INDEX} = CHANNEL_INDEX;\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them.  Similarly, selection projection won't work with \"detail\" and \"order\".)\n */\n\nexport const SINGLE_DEF_CHANNELS: SingleDefChannel[] = flagKeys(SINGLE_DEF_CHANNEL_INDEX);\n\n// Using the following line leads to TypeError: Cannot read property 'elementTypes' of undefined\n// when running the schema generator\n// export type SingleDefChannel = typeof SINGLE_DEF_CHANNELS[0];\nexport type SingleDefChannel =\n  | 'x'\n  | 'y'\n  | 'x2'\n  | 'y2'\n  | 'longitude'\n  | 'latitude'\n  | 'longitude2'\n  | 'latitude2'\n  | 'row'\n  | 'column'\n  | 'color'\n  | 'fill'\n  | 'stroke'\n  | 'size'\n  | 'shape'\n  | 'opacity'\n  | 'text'\n  | 'tooltip'\n  | 'href'\n  | 'key';\n\nexport function isChannel(str: string): str is Channel {\n  return !!CHANNEL_INDEX[str];\n}\n\n// CHANNELS without COLUMN, ROW\nexport const UNIT_CHANNELS = flagKeys(UNIT_CHANNEL_INDEX);\n\n// NONPOSITION_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nconst {\n  x: _x,\n  y: _y,\n  // x2 and y2 share the same scale as x and y\n  x2: _x2,\n  y2: _y2,\n  latitude: _latitude,\n  longitude: _longitude,\n  latitude2: _latitude2,\n  longitude2: _longitude2,\n  // The rest of unit channels then have scale\n  ...NONPOSITION_CHANNEL_INDEX\n} = UNIT_CHANNEL_INDEX;\n\nexport const NONPOSITION_CHANNELS = flagKeys(NONPOSITION_CHANNEL_INDEX);\nexport type NonPositionChannel = typeof NONPOSITION_CHANNELS[0];\n\n// POSITION_SCALE_CHANNELS = X and Y;\nconst POSITION_SCALE_CHANNEL_INDEX: {x: 1; y: 1} = {x: 1, y: 1};\nexport const POSITION_SCALE_CHANNELS = flagKeys(POSITION_SCALE_CHANNEL_INDEX);\nexport type PositionScaleChannel = typeof POSITION_SCALE_CHANNELS[0];\n\n// NON_POSITION_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nconst {\n  // x2 and y2 share the same scale as x and y\n  // text and tooltip have format instead of scale,\n  // href has neither format, nor scale\n  text: _t,\n  tooltip: _tt,\n  href: _hr,\n  // detail and order have no scale\n  detail: _dd,\n  key: _k,\n  order: _oo,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n} = NONPOSITION_CHANNEL_INDEX;\nexport const NONPOSITION_SCALE_CHANNELS = flagKeys(NONPOSITION_SCALE_CHANNEL_INDEX);\nexport type NonPositionScaleChannel = typeof NONPOSITION_SCALE_CHANNELS[0];\n\n// Declare SCALE_CHANNEL_INDEX\nconst SCALE_CHANNEL_INDEX = {\n  ...POSITION_SCALE_CHANNEL_INDEX,\n  ...NONPOSITION_SCALE_CHANNEL_INDEX\n};\n\n/** List of channels with scales */\nexport const SCALE_CHANNELS = flagKeys(SCALE_CHANNEL_INDEX);\nexport type ScaleChannel = typeof SCALE_CHANNELS[0];\n\nexport function isScaleChannel(channel: Channel): channel is ScaleChannel {\n  return !!SCALE_CHANNEL_INDEX[channel];\n}\n\nexport type SupportedMark = {[mark in Mark]?: boolean};\n\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nexport function supportMark(encoding: Encoding<string>, channel: Channel, mark: Mark) {\n  if (contains([CIRCLE, POINT, SQUARE, TICK], mark) && contains([X2, Y2], channel)) {\n    const primaryFieldDef = encoding[channel === X2 ? X : Y];\n    // circle, point, square and tick only support x2/y2 when their corresponding x/y fieldDef\n    // has \"binned\" data and thus need x2/y2 to specify the bin-end field.\n    if (isFieldDef(primaryFieldDef) && isFieldDef(encoding[channel]) && isBinned(primaryFieldDef.bin)) {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return mark in getSupportedMark(channel);\n  }\n}\n\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nexport function getSupportedMark(channel: Channel): SupportedMark {\n  switch (channel) {\n    case COLOR:\n    case FILL:\n    case STROKE:\n\n    case DETAIL:\n    case KEY:\n    case TOOLTIP:\n    case HREF:\n    case ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n    case OPACITY:\n    case ROW:\n    case COLUMN:\n      return {\n        // all marks\n        point: true,\n        tick: true,\n        rule: true,\n        circle: true,\n        square: true,\n        bar: true,\n        rect: true,\n        line: true,\n        trail: true,\n        area: true,\n        text: true,\n        geoshape: true\n      };\n    case X:\n    case Y:\n    case LATITUDE:\n    case LONGITUDE:\n      return {\n        // all marks except geoshape. geoshape does not use X, Y -- it uses a projection\n        point: true,\n        tick: true,\n        rule: true,\n        circle: true,\n        square: true,\n        bar: true,\n        rect: true,\n        line: true,\n        trail: true,\n        area: true,\n        text: true\n      };\n    case X2:\n    case Y2:\n    case LATITUDE2:\n    case LONGITUDE2:\n      return {\n        rule: true,\n        bar: true,\n        rect: true,\n        area: true\n      };\n    case SIZE:\n      return {\n        point: true,\n        tick: true,\n        rule: true,\n        circle: true,\n        square: true,\n        bar: true,\n        text: true,\n        line: true,\n        trail: true\n      };\n    case SHAPE:\n      return {point: true, geoshape: true};\n    case TEXT:\n      return {text: true};\n  }\n}\n\nexport function rangeType(channel: Channel): RangeType {\n  switch (channel) {\n    case X:\n    case Y:\n    case SIZE:\n    case OPACITY:\n    // X2 and Y2 use X and Y scales, so they similarly have continuous range.\n    case X2:\n    case Y2:\n      return 'continuous';\n\n    case ROW:\n    case COLUMN:\n    case SHAPE:\n    // TEXT, TOOLTIP, and HREF have no scale but have discrete output\n    case TEXT:\n    case TOOLTIP:\n    case HREF:\n      return 'discrete';\n\n    // Color can be either continuous or discrete, depending on scale type.\n    case COLOR:\n    case FILL:\n    case STROKE:\n      return 'flexible';\n\n    // No scale, no range type.\n\n    case LATITUDE:\n    case LONGITUDE:\n    case LATITUDE2:\n    case LONGITUDE2:\n    case DETAIL:\n    case KEY:\n    case ORDER:\n      return undefined;\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('rangeType not implemented for ' + channel);\n}\n","import {Axis as VgAxis} from 'vega';\nimport {isArray} from 'vega-util';\nimport {AXIS_PARTS, AXIS_PROPERTY_TYPE} from '../../axis';\nimport {Config} from '../../config';\nimport {defaultTitle, FieldDefBase} from '../../fielddef';\nimport {getFirstDefined, keys} from '../../util';\nimport {AxisComponent, AxisComponentIndex} from './component';\n\nfunction assembleTitle(title: string | FieldDefBase<string>[], config: Config) {\n  if (isArray(title)) {\n    return title.map(fieldDef => defaultTitle(fieldDef, config)).join(', ');\n  }\n  return title;\n}\n\nexport function assembleAxis(\n  axisCmpt: AxisComponent,\n  kind: 'main' | 'grid',\n  config: Config,\n  opt: {\n    header: boolean; // whether this is called via a header\n  } = {header: false}\n): VgAxis {\n  const {orient, scale, title, zindex, ...axis} = axisCmpt.combine();\n\n  // Remove properties that are not valid for this kind of axis\n  keys(axis).forEach(key => {\n    const propType = AXIS_PROPERTY_TYPE[key];\n    if (propType && propType !== kind && propType !== 'both') {\n      delete axis[key];\n    }\n  });\n\n  if (kind === 'grid') {\n    if (!axis.grid) {\n      return undefined;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      // Only need to keep encode block for grid\n      const {grid} = axis.encode;\n      axis.encode = {\n        ...(grid ? {grid} : {})\n      };\n\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    return {\n      scale,\n      orient,\n      ...axis,\n      domain: false,\n      labels: false,\n\n      // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`\n      // would not affect gridAxis\n      maxExtent: 0,\n      minExtent: 0,\n      ticks: false,\n      zindex: getFirstDefined(zindex, 0) // put grid behind marks by default\n    };\n  } else {\n    // kind === 'main'\n\n    if (!opt.header && axisCmpt.mainExtracted) {\n      // if mainExtracted has been extracted to a separate facet\n      return undefined;\n    }\n\n    // Remove unnecessary encode block\n    if (axis.encode) {\n      for (const part of AXIS_PARTS) {\n        if (!axisCmpt.hasAxisPart(part)) {\n          delete axis.encode[part];\n        }\n      }\n      if (keys(axis.encode).length === 0) {\n        delete axis.encode;\n      }\n    }\n\n    const titleString = assembleTitle(title, config);\n\n    return {\n      scale,\n      orient,\n      grid: false,\n      ...(titleString ? {title: titleString} : {}),\n      ...axis,\n      zindex: getFirstDefined(zindex, 1) // put axis line above marks by default\n    };\n  }\n}\n\nexport function assembleAxes(axisComponents: AxisComponentIndex, config: Config): VgAxis[] {\n  const {x = [], y = []} = axisComponents;\n  return [\n    ...x.map(a => assembleAxis(a, 'main', config)),\n    ...x.map(a => assembleAxis(a, 'grid', config)),\n    ...y.map(a => assembleAxis(a, 'main', config)),\n    ...y.map(a => assembleAxis(a, 'grid', config))\n  ].filter(a => a); // filter undefined\n}\n","import {Axis as VgAxis} from 'vega';\nimport {Axis, AxisPart} from '../../axis';\nimport {FieldDefBase} from '../../fielddef';\nimport {duplicate, Omit} from '../../util';\nimport {Split} from '../split';\n\nfunction isFalseOrNull(v: any) {\n  return v === false || v === null;\n}\n\nexport interface AxisComponentProps extends Omit<VgAxis, 'title'> {\n  title: string | FieldDefBase<string>[];\n}\n\nexport class AxisComponent extends Split<AxisComponentProps> {\n  constructor(\n    public readonly explicit: Partial<AxisComponentProps> = {},\n    public readonly implicit: Partial<AxisComponentProps> = {},\n    public mainExtracted = false\n  ) {\n    super();\n  }\n\n  public clone() {\n    return new AxisComponent(duplicate(this.explicit), duplicate(this.implicit), this.mainExtracted);\n  }\n\n  public hasAxisPart(part: AxisPart) {\n    // FIXME(https://github.com/vega/vega-lite/issues/2552) this method can be wrong if users use a Vega theme.\n\n    if (part === 'axis') {\n      // always has the axis container part\n      return true;\n    }\n\n    if (part === 'grid' || part === 'title') {\n      return !!this.get(part);\n    }\n    // Other parts are enabled by default, so they should not be false or null.\n    return !isFalseOrNull(this.get(part));\n  }\n}\n\nexport interface AxisComponentIndex {\n  x?: AxisComponent[];\n  y?: AxisComponent[];\n}\n\nexport interface AxisIndex {\n  x?: Axis;\n  y?: Axis;\n}\n","import {PositionScaleChannel} from '../../channel';\nimport {Config} from '../../config';\nimport {ScaleType} from '../../scale';\n\nexport function getAxisConfig(\n  property: string,\n  config: Config,\n  channel: PositionScaleChannel,\n  orient: string = '',\n  scaleType: ScaleType\n) {\n  // configTypes to loop, starting from higher precedence\n  const configTypes = (scaleType === 'band' ? ['axisBand'] : []).concat([\n    channel === 'x' ? 'axisX' : 'axisY',\n    'axis' + orient.substr(0, 1).toUpperCase() + orient.substr(1), // axisTop, axisBottom, ...\n    'axis'\n  ]);\n  for (const configType of configTypes) {\n    if (config[configType] && config[configType][property] !== undefined) {\n      return config[configType][property];\n    }\n  }\n\n  return undefined;\n}\n","import {AxisOrient} from 'vega';\nimport {PositionScaleChannel} from '../../channel';\nimport {isTimeFieldDef} from '../../fielddef';\nimport {ScaleType} from '../../scale';\nimport {keys} from '../../util';\nimport {timeFormatExpression} from '../common';\nimport {UnitModel} from '../unit';\n\nexport function labels(model: UnitModel, channel: PositionScaleChannel, specifiedLabelsSpec: any, orient: AxisOrient) {\n  const fieldDef =\n    model.fieldDef(channel) ||\n    (channel === 'x' ? model.fieldDef('x2') : channel === 'y' ? model.fieldDef('y2') : undefined);\n  const axis = model.axis(channel);\n  const config = model.config;\n\n  let labelsSpec: any = {};\n\n  // Text\n  if (isTimeFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n\n    const expr = timeFormatExpression(\n      'datum.value',\n      fieldDef.timeUnit,\n      axis.format,\n      config.axis.shortTimeLabels,\n      null,\n      isUTCScale\n    );\n\n    if (expr) {\n      labelsSpec.text = {signal: expr};\n    }\n  }\n\n  labelsSpec = {\n    ...labelsSpec,\n    ...specifiedLabelsSpec\n  };\n\n  return keys(labelsSpec).length === 0 ? undefined : labelsSpec;\n}\n","import {Axis as VgAxis, AxisEncode as VgAxisEncode, AxisOrient} from 'vega';\nimport {Axis, AXIS_PARTS, isAxisProperty, VG_AXIS_PROPERTIES} from '../../axis';\nimport {isBinned} from '../../bin';\nimport {POSITION_SCALE_CHANNELS, PositionScaleChannel, X, Y} from '../../channel';\nimport {FieldDefBase, toFieldDefBase} from '../../fielddef';\nimport {getFirstDefined, keys} from '../../util';\nimport {VgSignalRef} from '../../vega.schema';\nimport {guideEncodeEntry, mergeTitle, mergeTitleComponent, mergeTitleFieldDefs, numberFormat} from '../common';\nimport {LayerModel} from '../layer';\nimport {parseGuideResolve} from '../resolve';\nimport {defaultTieBreaker, Explicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {AxisComponent, AxisComponentIndex, AxisComponentProps} from './component';\nimport {getAxisConfig} from './config';\nimport * as encode from './encode';\nimport * as properties from './properties';\n\nexport function parseUnitAxis(model: UnitModel): AxisComponentIndex {\n  return POSITION_SCALE_CHANNELS.reduce(\n    (axis, channel) => {\n      if (model.component.scales[channel] && model.axis(channel)) {\n        axis[channel] = [parseAxis(channel, model)];\n      }\n      return axis;\n    },\n    {} as AxisComponentIndex\n  );\n}\n\nconst OPPOSITE_ORIENT: {[K in AxisOrient]: AxisOrient} = {\n  bottom: 'top',\n  top: 'bottom',\n  left: 'right',\n  right: 'left'\n};\n\nexport function parseLayerAxis(model: LayerModel) {\n  const {axes, resolve} = model.component;\n  const axisCount: {\n    // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n    [k in AxisOrient]: number\n  } = {top: 0, bottom: 0, right: 0, left: 0};\n\n  for (const child of model.children) {\n    child.parseAxisAndHeader();\n\n    for (const channel of keys(child.component.axes)) {\n      resolve.axis[channel] = parseGuideResolve(model.component.resolve, channel);\n      if (resolve.axis[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        axes[channel] = mergeAxisComponents(axes[channel], child.component.axes[channel]);\n\n        if (!axes[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the axis shared.\n          // Thus, mark axis as independent and remove the axis component.\n          resolve.axis[channel] = 'independent';\n          delete axes[channel];\n        }\n      }\n    }\n  }\n\n  // Move axes to layer's axis component and merge shared axes\n  for (const channel of [X, Y]) {\n    for (const child of model.children) {\n      if (!child.component.axes[channel]) {\n        // skip if the child does not have a particular axis\n        continue;\n      }\n\n      if (resolve.axis[channel] === 'independent') {\n        // If axes are independent, concat the axisComponent array.\n        axes[channel] = (axes[channel] || []).concat(child.component.axes[channel]);\n\n        // Automatically adjust orient\n        for (const axisComponent of child.component.axes[channel]) {\n          const {value: orient, explicit} = axisComponent.getWithExplicit('orient');\n          if (axisCount[orient] > 0 && !explicit) {\n            // Change axis orient if the number do not match\n            const oppositeOrient = OPPOSITE_ORIENT[orient];\n            if (axisCount[orient] > axisCount[oppositeOrient]) {\n              axisComponent.set('orient', oppositeOrient, false);\n            }\n          }\n          axisCount[orient]++;\n\n          // TODO(https://github.com/vega/vega-lite/issues/2634): automaticaly add extra offset?\n        }\n      }\n\n      // After merging, make sure to remove axes from child\n      delete child.component.axes[channel];\n    }\n  }\n}\n\nfunction mergeAxisComponents(mergedAxisCmpts: AxisComponent[], childAxisCmpts: AxisComponent[]): AxisComponent[] {\n  if (mergedAxisCmpts) {\n    // FIXME: this is a bit wrong once we support multiple axes\n    if (mergedAxisCmpts.length !== childAxisCmpts.length) {\n      return undefined; // Cannot merge axis component with different number of axes.\n    }\n    const length = mergedAxisCmpts.length;\n    for (let i = 0; i < length; i++) {\n      const merged = mergedAxisCmpts[i];\n      const child = childAxisCmpts[i];\n\n      if (!!merged !== !!child) {\n        return undefined;\n      } else if (merged && child) {\n        const mergedOrient = merged.getWithExplicit('orient');\n        const childOrient = child.getWithExplicit('orient');\n\n        if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n          // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n\n          // Cannot merge due to inconsistent orient\n          return undefined;\n        } else {\n          mergedAxisCmpts[i] = mergeAxisComponent(merged, child);\n        }\n      }\n    }\n  } else {\n    // For first one, return a copy of the child\n    return childAxisCmpts.map(axisComponent => axisComponent.clone());\n  }\n  return mergedAxisCmpts;\n}\n\nfunction mergeAxisComponent(merged: AxisComponent, child: AxisComponent): AxisComponent {\n  for (const prop of VG_AXIS_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<VgAxis, any>(\n      merged.getWithExplicit(prop),\n      child.getWithExplicit(prop),\n      prop,\n      'axis',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>) => {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'gridScale':\n            return {\n              explicit: v1.explicit, // keep the old explicit\n              value: getFirstDefined(v1.value, v2.value)\n            };\n        }\n        return defaultTieBreaker<VgAxis, any>(v1, v2, prop, 'axis');\n      }\n    );\n    merged.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  return merged;\n}\n\nfunction getFieldDefTitle(model: UnitModel, channel: 'x' | 'y') {\n  const channel2 = channel === 'x' ? 'x2' : 'y2';\n  const fieldDef = model.fieldDef(channel);\n  const fieldDef2 = model.fieldDef(channel2);\n\n  const title1 = fieldDef ? fieldDef.title : undefined;\n  const title2 = fieldDef2 ? fieldDef2.title : undefined;\n\n  if (title1 && title2) {\n    return mergeTitle(title1, title2);\n  } else if (title1) {\n    return title1;\n  } else if (title2) {\n    return title2;\n  } else if (title1 !== undefined) {\n    // falsy value to disable config\n    return title1;\n  } else if (title2 !== undefined) {\n    // falsy value to disable config\n    return title2;\n  }\n\n  return undefined;\n}\n\nfunction isExplicit<T extends string | number | object | boolean>(\n  value: T,\n  property: keyof VgAxis,\n  axis: Axis,\n  model: UnitModel,\n  channel: PositionScaleChannel\n) {\n  switch (property) {\n    case 'values':\n      return !!axis.values;\n    // specified axis.values is already respected, but may get transformed.\n    case 'encode':\n      // both VL axis.encoding and axis.labelAngle affect VG axis.encode\n      return !!axis.encoding || !!axis.labelAngle;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (value === getFieldDefTitle(model, channel)) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === axis[property];\n}\n\nfunction parseAxis(channel: PositionScaleChannel, model: UnitModel): AxisComponent {\n  const axis = model.axis(channel);\n\n  const axisComponent = new AxisComponent();\n\n  // 1.2. Add properties\n  VG_AXIS_PROPERTIES.forEach(property => {\n    const value = getProperty(property, axis, channel, model);\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, axis, model, channel);\n\n      const configValue = getAxisConfig(\n        property,\n        model.config,\n        channel,\n        axisComponent.get('orient'),\n        model.getScaleComponent(channel).get('type')\n      );\n\n      // only set property if it is explicitly set or has no config value (otherwise we will accidentally override config)\n      if (explicit || configValue === undefined) {\n        // Do not apply implicit rule if there is a config value\n        axisComponent.set(property, value, explicit);\n      } else if (property === 'grid' && configValue) {\n        // Grid is an exception because we need to set grid = true to generate another grid axis\n        axisComponent.set(property, configValue, false);\n      }\n    }\n  });\n\n  // 2) Add guide encode definition groups\n  const axisEncoding = axis.encoding || {};\n  const axisEncode = AXIS_PARTS.reduce(\n    (e: VgAxisEncode, part) => {\n      if (!axisComponent.hasAxisPart(part)) {\n        // No need to create encode for a disabled part.\n        return e;\n      }\n\n      const axisEncodingPart = guideEncodeEntry(axisEncoding[part] || {}, model);\n\n      const value =\n        part === 'labels'\n          ? encode.labels(model, channel, axisEncodingPart, axisComponent.get('orient'))\n          : axisEncodingPart;\n\n      if (value !== undefined && keys(value).length > 0) {\n        e[part] = {update: value};\n      }\n      return e;\n    },\n    {} as VgAxisEncode\n  );\n\n  // FIXME: By having encode as one property, we won't have fine grained encode merging.\n  if (keys(axisEncode).length > 0) {\n    axisComponent.set('encode', axisEncode, !!axis.encoding || axis.labelAngle !== undefined);\n  }\n\n  return axisComponent;\n}\n\nfunction getProperty<K extends keyof AxisComponentProps>(\n  property: K,\n  specifiedAxis: Axis,\n  channel: PositionScaleChannel,\n  model: UnitModel\n): AxisComponentProps[K] {\n  const fieldDef = model.fieldDef(channel);\n\n  // Some properties depend on labelAngle so we have to declare it here.\n  // Also, we don't use `getFirstDefined` for labelAngle\n  // as we want to normalize specified value to be within [0,360)\n  const labelAngle = properties.labelAngle(model, specifiedAxis, channel, fieldDef);\n\n  switch (property) {\n    case 'scale':\n      return model.scaleName(channel);\n    case 'gridScale':\n      return properties.gridScale(model, channel);\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      return numberFormat(fieldDef, specifiedAxis.format, model.config);\n    case 'grid': {\n      if (isBinned(model.fieldDef(channel).bin)) {\n        return false;\n      } else {\n        const scaleType = model.getScaleComponent(channel).get('type');\n        return getFirstDefined(specifiedAxis.grid, properties.grid(scaleType, fieldDef));\n      }\n    }\n    case 'labelAlign':\n      return getFirstDefined(specifiedAxis.labelAlign, properties.labelAlign(labelAngle, properties.orient(channel)));\n    case 'labelAngle':\n      return labelAngle;\n    case 'labelBaseline':\n      return getFirstDefined(\n        specifiedAxis.labelBaseline,\n        properties.labelBaseline(labelAngle, properties.orient(channel))\n      );\n    case 'labelFlush':\n      return properties.labelFlush(fieldDef, channel, specifiedAxis);\n    case 'labelOverlap': {\n      const scaleType = model.getScaleComponent(channel).get('type');\n      return properties.labelOverlap(fieldDef, specifiedAxis, channel, scaleType);\n    }\n    case 'orient':\n      return getFirstDefined(specifiedAxis.orient, properties.orient(channel));\n    case 'tickCount': {\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const scaleName = model.scaleName(channel);\n      const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n      const size = sizeType ? model.getSizeSignalRef(sizeType) : undefined;\n      return getFirstDefined<number | VgSignalRef>(\n        specifiedAxis.tickCount,\n        properties.tickCount(channel, fieldDef, scaleType, size, scaleName, specifiedAxis)\n      );\n    }\n    case 'title':\n      const channel2 = channel === 'x' ? 'x2' : 'y2';\n      const fieldDef2 = model.fieldDef(channel2);\n      // Keep undefined so we use default if title is unspecified.\n      // For other falsy value, keep them so we will hide the title.\n      return getFirstDefined<string | FieldDefBase<string>[]>(\n        specifiedAxis.title,\n        getFieldDefTitle(model, channel), // If title not specified, store base parts of fieldDef (and fieldDef2 if exists)\n        mergeTitleFieldDefs([toFieldDefBase(fieldDef)], fieldDef2 ? [toFieldDefBase(fieldDef2)] : [])\n      );\n\n    case 'values':\n      return properties.values(specifiedAxis, model, fieldDef, channel);\n  }\n  // Otherwise, return specified property.\n  return isAxisProperty(property) ? specifiedAxis[property] : undefined;\n}\n","import {Align, AxisOrient, SignalRef} from 'vega';\nimport {Axis} from '../../axis';\nimport {binToString, isBinning} from '../../bin';\nimport {PositionScaleChannel, X, Y} from '../../channel';\nimport {FieldDef, valueArray} from '../../fielddef';\nimport * as log from '../../log';\nimport {hasDiscreteDomain, isSelectionDomain, ScaleType} from '../../scale';\nimport {NOMINAL, ORDINAL, QUANTITATIVE} from '../../type';\nimport {contains} from '../../util';\nimport {UnitModel} from '../unit';\nimport {getAxisConfig} from './config';\n\n// TODO: we need to refactor this method after we take care of config refactoring\n/**\n * Default rules for whether to show a grid should be shown for a channel.\n * If `grid` is unspecified, the default value is `true` for ordinal scales that are not binned\n */\nexport function grid(scaleType: ScaleType, fieldDef: FieldDef<string>) {\n  return !hasDiscreteDomain(scaleType) && !isBinning(fieldDef.bin);\n}\n\nexport function gridScale(model: UnitModel, channel: PositionScaleChannel) {\n  const gridChannel: PositionScaleChannel = channel === 'x' ? 'y' : 'x';\n  if (model.getScaleComponent(gridChannel)) {\n    return model.scaleName(gridChannel);\n  }\n  return undefined;\n}\n\nexport function labelAngle(\n  model: UnitModel,\n  specifiedAxis: Axis,\n  channel: PositionScaleChannel,\n  fieldDef: FieldDef<string>\n) {\n  // try axis value\n  if (specifiedAxis.labelAngle !== undefined) {\n    // Make angle within [0,360)\n    return ((specifiedAxis.labelAngle % 360) + 360) % 360;\n  } else {\n    // try axis config value\n    const angle = getAxisConfig(\n      'labelAngle',\n      model.config,\n      channel,\n      orient(channel),\n      model.getScaleComponent(channel).get('type')\n    );\n    if (angle !== undefined) {\n      return ((angle % 360) + 360) % 360;\n    } else {\n      // get default value\n      if (channel === X && contains([NOMINAL, ORDINAL], fieldDef.type)) {\n        return 270;\n      }\n      // no default\n      return undefined;\n    }\n  }\n}\n\nexport function labelBaseline(angle: number, axisOrient: AxisOrient) {\n  if (angle !== undefined) {\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle <= 45 || 315 <= angle) {\n        return axisOrient === 'top' ? 'bottom' : 'top';\n      } else if (135 <= angle && angle <= 225) {\n        return axisOrient === 'top' ? 'top' : 'bottom';\n      } else {\n        return 'middle';\n      }\n    } else {\n      if (angle <= 45 || 315 <= angle || (135 <= angle && angle <= 225)) {\n        return 'middle';\n      } else if (45 <= angle && angle <= 135) {\n        return axisOrient === 'left' ? 'top' : 'bottom';\n      } else {\n        return axisOrient === 'left' ? 'bottom' : 'top';\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function labelAlign(angle: number, axisOrient: AxisOrient): Align {\n  if (angle !== undefined) {\n    angle = ((angle % 360) + 360) % 360;\n    if (axisOrient === 'top' || axisOrient === 'bottom') {\n      if (angle % 180 === 0) {\n        return 'center';\n      } else if (0 < angle && angle < 180) {\n        return axisOrient === 'top' ? 'right' : 'left';\n      } else {\n        return axisOrient === 'top' ? 'left' : 'right';\n      }\n    } else {\n      if ((angle + 90) % 180 === 0) {\n        return 'center';\n      } else if (90 <= angle && angle < 270) {\n        return axisOrient === 'left' ? 'left' : 'right';\n      } else {\n        return axisOrient === 'left' ? 'right' : 'left';\n      }\n    }\n  }\n  return undefined;\n}\n\nexport function labelFlush(fieldDef: FieldDef<string>, channel: PositionScaleChannel, specifiedAxis: Axis) {\n  if (specifiedAxis.labelFlush !== undefined) {\n    return specifiedAxis.labelFlush;\n  }\n  if (channel === 'x' && contains(['quantitative', 'temporal'], fieldDef.type)) {\n    return true;\n  }\n  return undefined;\n}\n\nexport function labelOverlap(\n  fieldDef: FieldDef<string>,\n  specifiedAxis: Axis,\n  channel: PositionScaleChannel,\n  scaleType: ScaleType\n) {\n  if (specifiedAxis.labelOverlap !== undefined) {\n    return specifiedAxis.labelOverlap;\n  }\n\n  // do not prevent overlap for nominal data because there is no way to infer what the missing labels are\n  if (fieldDef.type !== 'nominal') {\n    if (scaleType === 'log') {\n      return 'greedy';\n    }\n    return true;\n  }\n\n  return undefined;\n}\n\nexport function orient(channel: PositionScaleChannel) {\n  switch (channel) {\n    case X:\n      return 'bottom';\n    case Y:\n      return 'left';\n  }\n  /* istanbul ignore next: This should never happen. */\n  throw new Error(log.message.INVALID_CHANNEL_FOR_AXIS);\n}\n\nexport function tickCount(\n  channel: PositionScaleChannel,\n  fieldDef: FieldDef<string>,\n  scaleType: ScaleType,\n  size: SignalRef,\n  scaleName: string,\n  specifiedAxis: Axis\n) {\n  if (\n    !hasDiscreteDomain(scaleType) &&\n    scaleType !== 'log' &&\n    !contains(['month', 'hours', 'day', 'quarter'], fieldDef.timeUnit)\n  ) {\n    if (specifiedAxis.tickStep) {\n      return {signal: `(domain('${scaleName}')[1] - domain('${scaleName}')[0]) / ${specifiedAxis.tickStep} + 1`};\n    } else if (isBinning(fieldDef.bin)) {\n      // for binned data, we don't want more ticks than maxbins\n      return {signal: `ceil(${size.signal}/20)`};\n    }\n    return {signal: `ceil(${size.signal}/40)`};\n  }\n\n  return undefined;\n}\n\nexport function values(\n  specifiedAxis: Axis,\n  model: UnitModel,\n  fieldDef: FieldDef<string>,\n  channel: PositionScaleChannel\n) {\n  const vals = specifiedAxis.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n\n  if (fieldDef.type === QUANTITATIVE) {\n    if (isBinning(fieldDef.bin)) {\n      const domain = model.scaleDomain(channel);\n      if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n        // explicit value\n        return vals;\n      }\n      const signal = model.getName(`${binToString(fieldDef.bin)}_${fieldDef.field}_bins`);\n      return {signal: `sequence(${signal}.start, ${signal}.stop + ${signal}.step, ${signal}.step)`};\n    } else if (specifiedAxis.tickStep) {\n      const scaleName = model.scaleName(channel);\n      const step = specifiedAxis.tickStep;\n      return {signal: `sequence(domain('${scaleName}')[0], domain('${scaleName}')[1] + ${step}, ${step})`};\n    }\n  }\n\n  return undefined;\n}\n","import {Config} from '../config';\nimport {Resolve} from '../resolve';\nimport {BaseSpec} from '../spec';\nimport {keys} from '../util';\nimport {VgData, VgSignal} from '../vega.schema';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {Model} from './model';\nimport {RepeaterValue} from './repeater';\n\nexport abstract class BaseConcatModel extends Model {\n  constructor(\n    spec: BaseSpec,\n    parent: Model,\n    parentGivenName: string,\n    config: Config,\n    repeater: RepeaterValue,\n    resolve: Resolve\n  ) {\n    super(spec, parent, parentGivenName, config, repeater, resolve);\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    this.children.forEach(child => {\n      child.parseData();\n    });\n  }\n  public parseSelection() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelection();\n      keys(child.component.selection).forEach(key => {\n        this.component.selection[key] = child.component.selection[key];\n      });\n    }\n  }\n\n  public parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  public parseAxisAndHeader() {\n    for (const child of this.children) {\n      child.parseAxisAndHeader();\n    }\n\n    // TODO(#2415): support shared axes\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  public assembleSelectionSignals(): VgSignal[] {\n    this.children.forEach(child => child.assembleSelectionSignals());\n    return [];\n  }\n\n  public assembleLayoutSignals(): VgSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, assembleLayoutSignals(this));\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  public assembleMarks(): any[] {\n    // only children have marks\n    return this.children.map(child => {\n      const title = child.assembleTitle();\n      const style = child.assembleGroupStyle();\n      const layoutSizeEncodeEntry = child.assembleLayoutSize();\n      return {\n        type: 'group',\n        name: child.getName('group'),\n        ...(title ? {title} : {}),\n        ...(style ? {style} : {}),\n        ...(layoutSizeEncodeEntry\n          ? {\n              encode: {\n                update: layoutSizeEncodeEntry\n              }\n            }\n          : {}),\n        ...child.assembleGroup()\n      };\n    });\n  }\n}\n","import {Config} from '../config';\nimport * as log from '../log';\nimport {\n  isConcatSpec,\n  isFacetSpec,\n  isLayerSpec,\n  isRepeatSpec,\n  isUnitSpec,\n  LayoutSizeMixins,\n  NormalizedSpec\n} from '../spec';\nimport {ConcatModel} from './concat';\nimport {FacetModel} from './facet';\nimport {LayerModel} from './layer';\nimport {Model} from './model';\nimport {RepeatModel} from './repeat';\nimport {RepeaterValue} from './repeater';\nimport {UnitModel} from './unit';\n\nexport function buildModel(\n  spec: NormalizedSpec,\n  parent: Model,\n  parentGivenName: string,\n  unitSize: LayoutSizeMixins,\n  repeater: RepeaterValue,\n  config: Config,\n  fit: boolean\n): Model {\n  if (isFacetSpec(spec)) {\n    return new FacetModel(spec, parent, parentGivenName, repeater, config);\n  }\n\n  if (isLayerSpec(spec)) {\n    return new LayerModel(spec, parent, parentGivenName, unitSize, repeater, config, fit);\n  }\n\n  if (isUnitSpec(spec)) {\n    return new UnitModel(spec, parent, parentGivenName, unitSize, repeater, config, fit);\n  }\n\n  if (isRepeatSpec(spec)) {\n    return new RepeatModel(spec, parent, parentGivenName, repeater, config);\n  }\n\n  if (isConcatSpec(spec)) {\n    return new ConcatModel(spec, parent, parentGivenName, repeater, config);\n  }\n\n  throw new Error(log.message.INVALID_SPEC);\n}\n","import {isArray} from 'vega-util';\nimport {isBinning} from '../bin';\nimport {Channel, isScaleChannel} from '../channel';\nimport {Config, StyleConfigIndex, ViewConfig} from '../config';\nimport {\n  FieldDef,\n  FieldDefBase,\n  FieldRefOption,\n  isScaleFieldDef,\n  isTimeFieldDef,\n  OrderFieldDef,\n  ValueDef,\n  vgField\n} from '../fielddef';\nimport {GuideEncodingEntry} from '../guide';\nimport {MarkConfig, MarkDef, TextConfig} from '../mark';\nimport {ScaleType} from '../scale';\nimport {formatExpression, TimeUnit} from '../timeunit';\nimport {QUANTITATIVE} from '../type';\nimport {contains, getFirstDefined, keys, stringify} from '../util';\nimport {VgEncodeChannel, VgEncodeEntry, VgMarkConfig, VgSort} from '../vega.schema';\nimport {AxisComponentProps} from './axis/component';\nimport {wrapCondition} from './mark/mixins';\nimport {Explicit} from './split';\nimport {UnitModel} from './unit';\n\nexport function applyConfig(\n  e: VgEncodeEntry,\n  config: ViewConfig | MarkConfig | TextConfig, // TODO(#1842): consolidate MarkConfig | TextConfig?\n  propsList: string[]\n) {\n  for (const property of propsList) {\n    const value = config[property];\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function applyMarkConfig(e: VgEncodeEntry, model: UnitModel, propsList: (keyof MarkConfig)[]) {\n  for (const property of propsList) {\n    const value = getMarkConfig(property, model.markDef, model.config);\n    if (value !== undefined) {\n      e[property] = {value: value};\n    }\n  }\n  return e;\n}\n\nexport function getStyles(mark: MarkDef): string[] {\n  return [].concat(mark.type, mark.style || []);\n}\n\n/**\n * Return property value from style or mark specific config property if exists.\n * Otherwise, return general mark specific config.\n */\nexport function getMarkConfig<P extends keyof MarkConfig>(\n  prop: P,\n  mark: MarkDef,\n  config: Config,\n  {skipGeneralMarkConfig = false}: {skipGeneralMarkConfig?: boolean} = {}\n): MarkConfig[P] {\n  return getFirstDefined(\n    // style config has highest precedence\n    getStyleConfig(prop, mark, config.style),\n    // then mark-specific config\n    config[mark.type][prop],\n    // then general mark config (if not skipped)\n    skipGeneralMarkConfig ? undefined : config.mark[prop]\n  );\n}\n\nexport function getStyleConfig<P extends keyof MarkConfig>(prop: P, mark: MarkDef, styleConfigIndex: StyleConfigIndex) {\n  const styles = getStyles(mark);\n  let value;\n  for (const style of styles) {\n    const styleConfig = styleConfigIndex[style];\n\n    // MarkConfig extends VgMarkConfig so a prop may not be a valid property for style\n    // However here we also check if it is defined, so it is okay to cast here\n    const p = prop as keyof VgMarkConfig;\n    if (styleConfig && styleConfig[p] !== undefined) {\n      value = styleConfig[p];\n    }\n  }\n  return value;\n}\n\nexport function formatSignalRef(\n  fieldDef: FieldDef<string>,\n  specifiedFormat: string,\n  expr: 'datum' | 'parent',\n  config: Config\n) {\n  const format = numberFormat(fieldDef, specifiedFormat, config);\n  if (isBinning(fieldDef.bin)) {\n    const startField = vgField(fieldDef, {expr});\n    const endField = vgField(fieldDef, {expr, binSuffix: 'end'});\n    return {\n      signal: binFormatExpression(startField, endField, format, config)\n    };\n  } else if (fieldDef.type === 'quantitative') {\n    return {\n      signal: `${formatExpr(vgField(fieldDef, {expr, binSuffix: 'range'}), format)}`\n    };\n  } else if (isTimeFieldDef(fieldDef)) {\n    const isUTCScale = isScaleFieldDef(fieldDef) && fieldDef['scale'] && fieldDef['scale'].type === ScaleType.UTC;\n    return {\n      signal: timeFormatExpression(\n        vgField(fieldDef, {expr}),\n        fieldDef.timeUnit,\n        specifiedFormat,\n        config.text.shortTimeLabels,\n        config.timeFormat,\n        isUTCScale,\n        true\n      )\n    };\n  } else {\n    return {\n      signal: `''+${vgField(fieldDef, {expr})}`\n    };\n  }\n}\n\n/**\n * Returns number format for a fieldDef\n *\n * @param format explicitly specified format\n */\nexport function numberFormat(fieldDef: FieldDef<string>, specifiedFormat: string, config: Config) {\n  if (fieldDef.type === QUANTITATIVE) {\n    // add number format for quantitative type only\n\n    // Specified format in axis/legend has higher precedence than fieldDef.format\n    if (specifiedFormat) {\n      return specifiedFormat;\n    }\n\n    // TODO: need to make this work correctly for numeric ordinal / nominal type\n    return config.numberFormat;\n  }\n  return undefined;\n}\n\nfunction formatExpr(field: string, format: string) {\n  return `format(${field}, \"${format || ''}\")`;\n}\n\nexport function numberFormatExpr(field: string, specifiedFormat: string, config: Config) {\n  return formatExpr(field, specifiedFormat || config.numberFormat);\n}\n\nexport function binFormatExpression(startField: string, endField: string, format: string, config: Config) {\n  return `${startField} === null || isNaN(${startField}) ? \"null\" : ${numberFormatExpr(\n    startField,\n    format,\n    config\n  )} + \" - \" + ${numberFormatExpr(endField, format, config)}`;\n}\n\n/**\n * Returns the time expression used for axis/legend labels or text mark for a temporal field\n */\nexport function timeFormatExpression(\n  field: string,\n  timeUnit: TimeUnit,\n  format: string,\n  shortTimeLabels: boolean,\n  rawTimeFormat: string, // should be provided only for actual text and headers, not axis/legend labels\n  isUTCScale: boolean,\n  alwaysReturn: boolean = false\n): string {\n  if (!timeUnit || format) {\n    // If there is not time unit, or if user explicitly specify format for axis/legend/text.\n    format = format || rawTimeFormat; // only use provided timeFormat if there is no timeUnit.\n\n    if (format || alwaysReturn) {\n      return `${isUTCScale ? 'utc' : 'time'}Format(${field}, '${format}')`;\n    } else {\n      return undefined;\n    }\n  } else {\n    return formatExpression(timeUnit, field, shortTimeLabels, isUTCScale);\n  }\n}\n\n/**\n * Return Vega sort parameters (tuple of field and order).\n */\nexport function sortParams(\n  orderDef: OrderFieldDef<string> | OrderFieldDef<string>[],\n  fieldRefOption?: FieldRefOption\n): VgSort {\n  return (isArray(orderDef) ? orderDef : [orderDef]).reduce(\n    (s, orderChannelDef) => {\n      s.field.push(vgField(orderChannelDef, fieldRefOption));\n      s.order.push(orderChannelDef.sort || 'ascending');\n      return s;\n    },\n    {field: [], order: []}\n  );\n}\n\nexport type AxisTitleComponent = AxisComponentProps['title'];\n\nexport function mergeTitleFieldDefs(f1: FieldDefBase<string>[], f2: FieldDefBase<string>[]) {\n  const merged = [...f1];\n\n  f2.forEach(fdToMerge => {\n    for (const fieldDef1 of merged) {\n      // If already exists, no need to append to merged array\n      if (stringify(fieldDef1) === stringify(fdToMerge)) {\n        return;\n      }\n    }\n    merged.push(fdToMerge);\n  });\n  return merged;\n}\n\nexport function mergeTitle(title1: string, title2: string) {\n  return title1 === title2\n    ? title1 // if title is the same just use one of them\n    : title1 + ', ' + title2; // join title with comma if different\n}\n\nexport function mergeTitleComponent(v1: Explicit<AxisTitleComponent>, v2: Explicit<AxisTitleComponent>) {\n  if (isArray(v1.value) && isArray(v2.value)) {\n    return {\n      explicit: v1.explicit,\n      value: mergeTitleFieldDefs(v1.value, v2.value)\n    };\n  } else if (!isArray(v1.value) && !isArray(v2.value)) {\n    return {\n      explicit: v1.explicit, // keep the old explicit\n      value: mergeTitle(v1.value, v2.value)\n    };\n  }\n  /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n  throw new Error('It should never reach here');\n}\n\n/**\n * Checks whether a fieldDef for a particular channel requires a computed bin range.\n */\nexport function binRequiresRange(fieldDef: FieldDef<string>, channel: Channel) {\n  if (!isBinning(fieldDef.bin)) {\n    console.warn('Only use this method with binned field defs');\n    return false;\n  }\n\n  // We need the range only when the user explicitly forces a binned field to be use discrete scale. In this case, bin range is used in axis and legend labels.\n  // We could check whether the axis or legend exists (not disabled) but that seems overkill.\n  return isScaleChannel(channel) && contains(['ordinal', 'nominal'], fieldDef.type);\n}\n\nexport function guideEncodeEntry(encoding: GuideEncodingEntry, model: UnitModel) {\n  return keys(encoding).reduce((encode, channel: VgEncodeChannel) => {\n    const valueDef = encoding[channel];\n    return {\n      ...encode,\n      ...wrapCondition(model, valueDef, channel, (x: ValueDef) => ({value: x.value}))\n    };\n  }, {});\n}\n","import {Config, initConfig, stripAndRedirectConfig} from '../config';\nimport * as vlFieldDef from '../fielddef';\nimport * as log from '../log';\nimport {isLayerSpec, isUnitSpec, LayoutSizeMixins, normalize, TopLevel, TopLevelSpec} from '../spec';\nimport {AutoSizeParams, extractTopLevelProperties, normalizeAutoSize, TopLevelProperties} from '../toplevelprops';\nimport {keys, mergeDeep} from '../util';\nimport {buildModel} from './buildmodel';\nimport {assembleRootData} from './data/assemble';\nimport {optimizeDataflow} from './data/optimize';\nimport {Model} from './model';\n\nexport interface CompileOptions {\n  config?: Config;\n  logger?: log.LoggerInterface;\n\n  fieldTitle?: vlFieldDef.FieldTitleFormatter;\n}\n\n/**\n * Vega-Lite's main function, for compiling Vega-lite spec into Vega spec.\n *\n * At a high-level, we make the following transformations in different phases:\n *\n * Input spec\n *     |\n *     |  (Normalization)\n *     v\n * Normalized Spec (Row/Column channels in single-view specs becomes faceted specs, composite marks becomes layered specs.)\n *     |\n *     |  (Build Model)\n *     v\n * A model tree of the spec\n *     |\n *     |  (Parse)\n *     v\n * A model tree with parsed components (intermediate structure of visualization primitives in a format that can be easily merged)\n *     |\n *     | (Optimize)\n *     v\n * A model tree with parsed components with the data component optimized\n *     |\n *     | (Assemble)\n *     v\n * Vega spec\n */\nexport function compile(inputSpec: TopLevelSpec, opt: CompileOptions = {}) {\n  // 0. Augment opt with default opts\n  if (opt.logger) {\n    // set the singleton logger to the provided logger\n    log.set(opt.logger);\n  }\n\n  if (opt.fieldTitle) {\n    // set the singleton field title formatter\n    vlFieldDef.setTitleFormatter(opt.fieldTitle);\n  }\n\n  try {\n    // 1. Initialize config by deep merging default config with the config provided via option and the input spec.\n    const config = initConfig(mergeDeep({}, opt.config, inputSpec.config));\n\n    // 2. Normalize: Convert input spec -> normalized spec\n\n    // - Decompose all extended unit specs into composition of unit spec.  For example, a box plot get expanded into multiple layers of bars, ticks, and rules. The shorthand row/column channel is also expanded to a facet spec.\n    const spec = normalize(inputSpec, config);\n    // - Normalize autosize to be a autosize properties object.\n    const autosize = normalizeAutoSize(inputSpec.autosize, config.autosize, isLayerSpec(spec) || isUnitSpec(spec));\n\n    // 3. Build Model: normalized spec -> Model (a tree structure)\n\n    // This phases instantiates the models with default config by doing a top-down traversal. This allows us to pass properties that child models derive from their parents via their constructors.\n    // See the abstract `Model` class and its children (UnitModel, LayerModel, FacetModel, RepeatModel, ConcatModel) for different types of models.\n    const model: Model = buildModel(spec, null, '', undefined, undefined, config, autosize.type === 'fit');\n\n    // 4 Parse: Model --> Model with components\n\n    // Note that components = intermediate representations that are equivalent to Vega specs.\n    // We need these intermediate representation because we need to merge many visualizaiton \"components\" like projections, scales, axes, and legends.\n    // We will later convert these components into actual Vega specs in the assemble phase.\n\n    // In this phase, we do a bottom-up traversal over the whole tree to\n    // parse for each type of components once (e.g., data, layout, mark, scale).\n    // By doing bottom-up traversal, we start parsing components of unit specs and\n    // then merge child components of parent composite specs.\n    //\n    // Please see inside model.parse() for order of different components parsed.\n    model.parse();\n\n    // 5. Optimize the dataflow.  This will modify the data component of the model.\n    optimizeDataflow(model.component.data);\n\n    // 6. Assemble: convert model components --> Vega Spec.\n    return assembleTopLevelModel(model, getTopLevelProperties(inputSpec, config, autosize));\n  } finally {\n    // Reset the singleton logger if a logger is provided\n    if (opt.logger) {\n      log.reset();\n    }\n    // Reset the singleton field title formatter if provided\n    if (opt.fieldTitle) {\n      vlFieldDef.resetTitleFormatter();\n    }\n  }\n}\n\nfunction getTopLevelProperties(topLevelSpec: TopLevel<any>, config: Config, autosize: AutoSizeParams) {\n  return {\n    autosize: keys(autosize).length === 1 && autosize.type ? autosize.type : autosize,\n    ...extractTopLevelProperties(config),\n    ...extractTopLevelProperties(topLevelSpec)\n  };\n}\n\n/*\n * Assemble the top-level model.\n *\n * Note: this couldn't be `model.assemble()` since the top-level model\n * needs some special treatment to generate top-level properties.\n */\nfunction assembleTopLevelModel(model: Model, topLevelProperties: TopLevelProperties & LayoutSizeMixins) {\n  // TODO: change type to become VgSpec\n\n  // Config with Vega-Lite only config removed.\n  const vgConfig = model.config ? stripAndRedirectConfig(model.config) : undefined;\n\n  const data = [].concat(\n    model.assembleSelectionData([]),\n    // only assemble data in the root\n    assembleRootData(model.component.data, topLevelProperties.datasets || {})\n  );\n\n  delete topLevelProperties.datasets;\n\n  const projections = model.assembleProjections();\n  const title = model.assembleTitle();\n  const style = model.assembleGroupStyle();\n\n  let layoutSignals = model.assembleLayoutSignals();\n\n  // move width and height signals with values to top level\n  layoutSignals = layoutSignals.filter(signal => {\n    if ((signal.name === 'width' || signal.name === 'height') && signal.value !== undefined) {\n      topLevelProperties[signal.name] = +signal.value;\n      return false;\n    }\n    return true;\n  });\n\n  const output = {\n    $schema: 'https://vega.github.io/schema/vega/v4.json',\n    ...(model.description ? {description: model.description} : {}),\n    ...topLevelProperties,\n    ...(title ? {title} : {}),\n    ...(style ? {style} : {}),\n    data: data,\n    ...(projections.length > 0 ? {projections: projections} : {}),\n    ...model.assembleGroup([...layoutSignals, ...model.assembleSelectionTopLevelSignals([])]),\n    ...(vgConfig ? {config: vgConfig} : {})\n  };\n\n  return {\n    spec: output\n    // TODO: add warning / errors here\n  };\n}\n","import {Config} from '../config';\nimport * as log from '../log';\nimport {isVConcatSpec, NormalizedConcatSpec} from '../spec';\nimport {VgLayout} from '../vega.schema';\nimport {BaseConcatModel} from './baseconcat';\nimport {buildModel} from './buildmodel';\nimport {parseConcatLayoutSize} from './layoutsize/parse';\nimport {Model} from './model';\nimport {RepeaterValue} from './repeater';\n\nexport class ConcatModel extends BaseConcatModel {\n  public readonly type: 'concat' = 'concat';\n\n  public readonly children: Model[];\n\n  public readonly isVConcat: boolean;\n\n  constructor(\n    spec: NormalizedConcatSpec,\n    parent: Model,\n    parentGivenName: string,\n    repeater: RepeaterValue,\n    config: Config\n  ) {\n    super(spec, parent, parentGivenName, config, repeater, spec.resolve);\n\n    if (spec.resolve && spec.resolve.axis && (spec.resolve.axis.x === 'shared' || spec.resolve.axis.y === 'shared')) {\n      log.warn(log.message.CONCAT_CANNOT_SHARE_AXIS);\n    }\n\n    this.isVConcat = isVConcatSpec(spec);\n\n    this.children = (isVConcatSpec(spec) ? spec.vconcat : spec.hconcat).map((child, i) => {\n      return buildModel(child, this, this.getName('concat_' + i), undefined, repeater, config, false);\n    });\n  }\n\n  public parseLayoutSize() {\n    parseConcatLayoutSize(this);\n  }\n\n  public parseAxisGroup(): void {\n    return null;\n  }\n\n  protected assembleDefaultLayout(): VgLayout {\n    return {\n      ...(this.isVConcat ? {columns: 1} : {}),\n      bounds: 'full',\n      // Use align each so it can work with multiple plots with different size\n      align: 'each'\n    };\n  }\n}\n","import {AggregateOp} from 'vega';\nimport {isBinning} from '../../bin';\nimport {Channel, isScaleChannel} from '../../channel';\nimport {FieldDef, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {AggregateTransform} from '../../transform';\nimport {Dict, differ, duplicate, hash, keys, replacePathInField, StringSet} from '../../util';\nimport {VgAggregateTransform} from '../../vega.schema';\nimport {binRequiresRange} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\nfunction addDimension(dims: {[field: string]: boolean}, channel: Channel, fieldDef: FieldDef<string>) {\n  if (isBinning(fieldDef.bin)) {\n    dims[vgField(fieldDef, {})] = true;\n    dims[vgField(fieldDef, {binSuffix: 'end'})] = true;\n\n    if (binRequiresRange(fieldDef, channel)) {\n      dims[vgField(fieldDef, {binSuffix: 'range'})] = true;\n    }\n  } else {\n    dims[vgField(fieldDef)] = true;\n  }\n  return dims;\n}\n\nfunction mergeMeasures(parentMeasures: Dict<Dict<string>>, childMeasures: Dict<Dict<string>>) {\n  for (const f in childMeasures) {\n    if (childMeasures.hasOwnProperty(f)) {\n      // when we merge a measure, we either have to add an aggregation operator or even a new field\n      const ops = childMeasures[f];\n      for (const op in ops) {\n        if (ops.hasOwnProperty(op)) {\n          if (f in parentMeasures) {\n            // add operator to existing measure field\n            parentMeasures[f][op] = ops[op];\n          } else {\n            parentMeasures[f] = {op: ops[op]};\n          }\n        }\n      }\n    }\n  }\n}\n\nexport class AggregateNode extends TransformNode {\n  public clone() {\n    return new AggregateNode(null, {...this.dimensions}, duplicate(this.measures));\n  }\n\n  /**\n   * @param dimensions string set for dimensions\n   * @param measures dictionary mapping field name => dict of aggregation functions and names to use\n   */\n  constructor(\n    parent: DataFlowNode,\n    private dimensions: StringSet,\n    private measures: Dict<{[key in AggregateOp]?: string}>\n  ) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel): AggregateNode {\n    let isAggregate = false;\n    model.forEachFieldDef(fd => {\n      if (fd.aggregate) {\n        isAggregate = true;\n      }\n    });\n\n    const meas = {};\n    const dims = {};\n\n    if (!isAggregate) {\n      // no need to create this node if the model has no aggregation\n      return null;\n    }\n\n    model.forEachFieldDef((fieldDef, channel) => {\n      const {aggregate, field} = fieldDef;\n      if (aggregate) {\n        if (aggregate === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = vgField(fieldDef, {forAs: true});\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][aggregate] = vgField(fieldDef, {forAs: true});\n\n          // For scale channel with domain === 'unaggregated', add min/max so we can use their union as unaggregated domain\n          if (isScaleChannel(channel) && model.scaleDomain(channel) === 'unaggregated') {\n            meas[field]['min'] = vgField({field, aggregate: 'min'}, {forAs: true});\n            meas[field]['max'] = vgField({field, aggregate: 'max'}, {forAs: true});\n          }\n        }\n      } else {\n        addDimension(dims, channel, fieldDef);\n      }\n    });\n\n    if (keys(dims).length + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: AggregateTransform): AggregateNode {\n    const dims = {};\n    const meas = {};\n\n    for (const s of t.aggregate) {\n      const {op, field, as} = s;\n      if (op) {\n        if (op === 'count') {\n          meas['*'] = meas['*'] || {};\n          meas['*']['count'] = as || vgField(s, {forAs: true});\n        } else {\n          meas[field] = meas[field] || {};\n          meas[field][op] = as || vgField(s, {forAs: true});\n        }\n      }\n    }\n\n    for (const s of t.groupby || []) {\n      dims[s] = true;\n    }\n\n    if (keys(dims).length + keys(meas).length === 0) {\n      return null;\n    }\n\n    return new AggregateNode(parent, dims, meas);\n  }\n\n  public merge(other: AggregateNode) {\n    if (!differ(this.dimensions, other.dimensions)) {\n      mergeMeasures(this.measures, other.measures);\n      other.remove();\n    } else {\n      log.debug('different dimensions, cannot merge');\n    }\n  }\n\n  public addDimensions(fields: string[]) {\n    fields.forEach(f => (this.dimensions[f] = true));\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    keys(this.dimensions).forEach(f => (out[f] = true));\n    keys(this.measures).forEach(m => (out[m] = true));\n\n    return out;\n  }\n\n  public producedFields() {\n    const out = {};\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        out[this.measures[field][op] || `${op}_${field}`] = true;\n      }\n    }\n\n    return out;\n  }\n\n  public hash() {\n    return `Aggregate ${hash({dimensions: this.dimensions, measures: this.measures})}`;\n  }\n\n  public assemble(): VgAggregateTransform {\n    const ops: AggregateOp[] = [];\n    const fields: string[] = [];\n    const as: string[] = [];\n\n    for (const field of keys(this.measures)) {\n      for (const op of keys(this.measures[field])) {\n        as.push(this.measures[field][op]);\n        ops.push(op);\n        fields.push(replacePathInField(field));\n      }\n    }\n\n    const result: VgAggregateTransform = {\n      type: 'aggregate',\n      groupby: keys(this.dimensions),\n      ops,\n      fields,\n      as\n    };\n\n    return result;\n  }\n}\n","import {InlineDataset, isUrlData} from '../../data';\nimport {Dict, vals} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {DataComponent} from './';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {ParseNode} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {LookupNode} from './lookup';\nimport {SampleTransformNode} from './sample';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\n/**\n * Print debug information for dataflow tree.\n */\n// tslint:disable-next-line\nexport function debug(node: DataFlowNode) {\n  console.log(\n    `${(node.constructor as any).name}${node.debugName ? ` (${node.debugName})` : ''} -> ${node.children.map(c => {\n      return `${(c.constructor as any).name}${c.debugName ? ` (${c.debugName})` : ''}`;\n    })}`\n  );\n  console.log(node);\n  node.children.forEach(debug);\n}\n\nfunction makeWalkTree(data: VgData[]) {\n  // to name datasources\n  let datasetIndex = 0;\n\n  /**\n   * Recursively walk down the tree.\n   */\n  function walkTree(node: DataFlowNode, dataSource: VgData) {\n    if (node instanceof SourceNode) {\n      // If the source is a named data source or a data source with values, we need\n      // to put it in a different data source. Otherwise, Vega may override the data.\n      if (!isUrlData(node.data)) {\n        data.push(dataSource);\n        const newData: VgData = {\n          name: null,\n          source: dataSource.name,\n          transform: []\n        };\n        dataSource = newData;\n      }\n    }\n\n    if (node instanceof ParseNode) {\n      if (node.parent instanceof SourceNode && !dataSource.source) {\n        // If node's parent is a root source and the data source does not refer to another data source, use normal format parse\n        dataSource.format = {\n          ...(dataSource.format || {}),\n          parse: node.assembleFormatParse()\n        };\n\n        // add calculates for all nested fields\n        dataSource.transform = dataSource.transform.concat(node.assembleTransforms(true));\n      } else {\n        // Otherwise use Vega expression to parse\n        dataSource.transform = dataSource.transform.concat(node.assembleTransforms());\n      }\n    }\n\n    if (node instanceof FacetNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n\n      if (!dataSource.source || dataSource.transform.length > 0) {\n        data.push(dataSource);\n        node.data = dataSource.name;\n      } else {\n        node.data = dataSource.source;\n      }\n\n      node.assemble().forEach(d => data.push(d));\n\n      // break here because the rest of the tree has to be taken care of by the facet.\n      return;\n    }\n\n    if (\n      node instanceof FilterNode ||\n      node instanceof CalculateNode ||\n      node instanceof GeoPointNode ||\n      node instanceof GeoJSONNode ||\n      node instanceof AggregateNode ||\n      node instanceof LookupNode ||\n      node instanceof WindowTransformNode ||\n      node instanceof FoldTransformNode ||\n      node instanceof FlattenTransformNode ||\n      node instanceof IdentifierNode ||\n      node instanceof SampleTransformNode\n    ) {\n      dataSource.transform.push(node.assemble());\n    }\n\n    if (\n      node instanceof BinNode ||\n      node instanceof TimeUnitNode ||\n      node instanceof ImputeNode ||\n      node instanceof StackNode\n    ) {\n      dataSource.transform = dataSource.transform.concat(node.assemble());\n    }\n\n    if (node instanceof AggregateNode) {\n      if (!dataSource.name) {\n        dataSource.name = `data_${datasetIndex++}`;\n      }\n    }\n\n    if (node instanceof OutputNode) {\n      if (dataSource.source && dataSource.transform.length === 0) {\n        node.setSource(dataSource.source);\n      } else if (node.parent instanceof OutputNode) {\n        // Note that an output node may be required but we still do not assemble a\n        // separate data source for it.\n        node.setSource(dataSource.name);\n      } else {\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        // Here we set the name of the datasource we generated. From now on\n        // other assemblers can use it.\n        node.setSource(dataSource.name);\n\n        // if this node has more than one child, we will add a datasource automatically\n        if (node.numChildren() === 1) {\n          data.push(dataSource);\n          const newData: VgData = {\n            name: null,\n            source: dataSource.name,\n            transform: []\n          };\n          dataSource = newData;\n        }\n      }\n    }\n\n    switch (node.numChildren()) {\n      case 0:\n        // done\n        if (node instanceof OutputNode && (!dataSource.source || dataSource.transform.length > 0)) {\n          // do not push empty datasources that are simply references\n          data.push(dataSource);\n        }\n        break;\n      case 1:\n        walkTree(node.children[0], dataSource);\n        break;\n      default:\n        if (!dataSource.name) {\n          dataSource.name = `data_${datasetIndex++}`;\n        }\n\n        let source = dataSource.name;\n        if (!dataSource.source || dataSource.transform.length > 0) {\n          data.push(dataSource);\n        } else {\n          source = dataSource.source;\n        }\n\n        node.children.forEach(child => {\n          const newData: VgData = {\n            name: null,\n            source: source,\n            transform: []\n          };\n          walkTree(child, newData);\n        });\n        break;\n    }\n  }\n\n  return walkTree;\n}\n\n/**\n * Assemble data sources that are derived from faceted data.\n */\nexport function assembleFacetData(root: FacetNode): VgData[] {\n  const data: VgData[] = [];\n  const walkTree = makeWalkTree(data);\n\n  root.children.forEach(child =>\n    walkTree(child, {\n      source: root.name,\n      name: null,\n      transform: []\n    })\n  );\n\n  return data;\n}\n\n/**\n * Create Vega Data array from a given compiled model and append all of them to the given array\n *\n * @param  model\n * @param  data array\n * @return modified data array\n */\nexport function assembleRootData(dataComponent: DataComponent, datasets: Dict<InlineDataset>): VgData[] {\n  const roots: SourceNode[] = vals(dataComponent.sources);\n  const data: VgData[] = [];\n\n  // roots.forEach(debug);\n\n  const walkTree = makeWalkTree(data);\n\n  let sourceIndex = 0;\n\n  roots.forEach(root => {\n    // assign a name if the source does not have a name yet\n    if (!root.hasName()) {\n      root.dataName = `source_${sourceIndex++}`;\n    }\n\n    const newData: VgData = root.assemble();\n\n    walkTree(root, newData);\n  });\n\n  // remove empty transform arrays for cleaner output\n  data.forEach(d => {\n    if (d.transform.length === 0) {\n      delete d.transform;\n    }\n  });\n\n  // move sources without transforms (the ones that are potentially used in lookups) to the beginning\n  let whereTo = 0;\n  for (let i = 0; i < data.length; i++) {\n    const d = data[i];\n    if ((d.transform || []).length === 0 && !d.source) {\n      data.splice(whereTo++, 0, data.splice(i, 1)[0]);\n    }\n  }\n\n  // now fix the from references in lookup transforms\n  for (const d of data) {\n    for (const t of d.transform || []) {\n      if (t.type === 'lookup') {\n        t.from = dataComponent.outputNodes[t.from].getSource();\n      }\n    }\n  }\n\n  // inline values for datasets that are in the datastore\n  for (const d of data) {\n    if (d.name in datasets) {\n      d.values = datasets[d.name];\n    }\n  }\n\n  return data;\n}\n","import {isString} from 'vega-util';\nimport {BinParams, binToString, isBinning} from '../../bin';\nimport {Channel} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef, normalizeBin, vgField} from '../../fielddef';\nimport {BinTransform} from '../../transform';\nimport {Dict, duplicate, flatten, hash, keys, vals} from '../../util';\nimport {VgBinTransform, VgTransform} from '../../vega.schema';\nimport {binFormatExpression, binRequiresRange} from '../common';\nimport {isUnitModel, Model, ModelWithField} from '../model';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\nfunction rangeFormula(model: ModelWithField, fieldDef: FieldDef<string>, channel: Channel, config: Config) {\n  if (binRequiresRange(fieldDef, channel)) {\n    // read format from axis or legend, if there is no format then use config.numberFormat\n\n    const guide = isUnitModel(model) ? model.axis(channel) || model.legend(channel) || {} : {};\n\n    const startField = vgField(fieldDef, {expr: 'datum'});\n    const endField = vgField(fieldDef, {expr: 'datum', binSuffix: 'end'});\n\n    return {\n      formulaAs: vgField(fieldDef, {binSuffix: 'range', forAs: true}),\n      formula: binFormatExpression(startField, endField, guide.format, config)\n    };\n  }\n  return {};\n}\n\nfunction binKey(bin: BinParams, field: string) {\n  return `${binToString(bin)}_${field}`;\n}\n\nfunction getSignalsFromModel(model: Model, key: string) {\n  return {\n    signal: model.getName(`${key}_bins`),\n    extentSignal: model.getName(`${key}_extent`)\n  };\n}\n\nfunction isBinTransform(t: FieldDef<string> | BinTransform): t is BinTransform {\n  return 'as' in t;\n}\n\nfunction createBinComponent(t: FieldDef<string> | BinTransform, bin: boolean | BinParams, model: Model) {\n  let as: [string, string];\n\n  if (isBinTransform(t)) {\n    as = isString(t.as) ? [t.as, `${t.as}_end`] : [t.as[0], t.as[1]];\n  } else {\n    as = [vgField(t, {forAs: true}), vgField(t, {binSuffix: 'end', forAs: true})];\n  }\n\n  const normalizedBin = normalizeBin(bin, undefined) || {};\n  const key = binKey(normalizedBin, t.field);\n  const {signal, extentSignal} = getSignalsFromModel(model, key);\n\n  const binComponent: BinComponent = {\n    bin: normalizedBin,\n    field: t.field,\n    as: as,\n    ...(signal ? {signal} : {}),\n    ...(extentSignal ? {extentSignal} : {})\n  };\n\n  return {key, binComponent};\n}\n\nexport interface BinComponent {\n  bin: BinParams;\n  field: string;\n  extentSignal?: string;\n  signal?: string;\n  as: string[];\n\n  // Range Formula\n\n  formula?: string;\n  formulaAs?: string;\n}\n\nexport class BinNode extends TransformNode {\n  public clone() {\n    return new BinNode(null, duplicate(this.bins));\n  }\n\n  constructor(parent: DataFlowNode, private bins: Dict<BinComponent>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const bins = model.reduceFieldDef((binComponentIndex: Dict<BinComponent>, fieldDef, channel) => {\n      if (isBinning(fieldDef.bin)) {\n        const {key, binComponent} = createBinComponent(fieldDef, fieldDef.bin, model);\n        binComponentIndex[key] = {\n          ...binComponent,\n          ...binComponentIndex[key],\n          ...rangeFormula(model, fieldDef, channel, model.config)\n        };\n      }\n      return binComponentIndex;\n    }, {});\n\n    if (keys(bins).length === 0) {\n      return null;\n    }\n\n    return new BinNode(parent, bins);\n  }\n\n  /**\n   * Creates a bin node from BinTransform.\n   * The optional parameter should provide\n   */\n  public static makeFromTransform(parent: DataFlowNode, t: BinTransform, model: Model) {\n    const {key, binComponent} = createBinComponent(t, t.bin, model);\n    return new BinNode(parent, {\n      [key]: binComponent\n    });\n  }\n\n  public merge(other: BinNode) {\n    this.bins = {...this.bins, ...other.bins};\n    other.remove();\n  }\n\n  public producedFields() {\n    const out = {};\n\n    vals(this.bins).forEach(c => {\n      c.as.forEach(f => (out[f] = true));\n    });\n\n    return out;\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    vals(this.bins).forEach(c => {\n      out[c.field] = true;\n    });\n\n    return out;\n  }\n\n  public hash() {\n    return `Bin ${hash(this.bins)}`;\n  }\n\n  public assemble(): VgTransform[] {\n    return flatten(\n      vals(this.bins).map(bin => {\n        const transform: VgTransform[] = [];\n\n        const binTrans: VgBinTransform = {\n          type: 'bin',\n          field: bin.field,\n          as: bin.as,\n          signal: bin.signal,\n          ...bin.bin\n        };\n\n        if (!bin.bin.extent && bin.extentSignal) {\n          transform.push({\n            type: 'extent',\n            field: bin.field,\n            signal: bin.extentSignal\n          });\n          binTrans.extent = {signal: bin.extentSignal};\n        }\n\n        transform.push(binTrans);\n\n        if (bin.formula) {\n          transform.push({\n            type: 'formula',\n            expr: bin.formula,\n            as: bin.formulaAs\n          });\n        }\n\n        return transform;\n      })\n    );\n  }\n}\n","import {SingleDefChannel} from '../../channel';\nimport {DateTime} from '../../datetime';\nimport {FieldDef, isScaleFieldDef, vgField} from '../../fielddef';\nimport {FieldRefOption} from '../../fielddef';\nimport {fieldFilterExpression} from '../../predicate';\nimport {isSortArray} from '../../sort';\nimport {CalculateTransform} from '../../transform';\nimport {duplicate, hash, StringSet} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {ModelWithField} from '../model';\n\nimport {DataFlowNode, TransformNode} from './dataflow';\nimport {getDependentFields} from './expressions';\n\n/**\n * We don't know what a calculate node depends on so we should never move it beyond anything that produces fields.\n */\n\nexport class CalculateNode extends TransformNode {\n  private _dependentFields: StringSet;\n\n  public clone() {\n    return new CalculateNode(null, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private transform: CalculateTransform) {\n    super(parent);\n\n    this._dependentFields = getDependentFields(this.transform.calculate);\n  }\n\n  public static parseAllForSortIndex(parent: DataFlowNode, model: ModelWithField) {\n    // get all the encoding with sort fields from model\n    model.forEachFieldDef((fieldDef: FieldDef<string>, channel: SingleDefChannel) => {\n      if (!isScaleFieldDef(fieldDef)) {\n        return;\n      }\n      if (isSortArray(fieldDef.sort)) {\n        const {field, timeUnit} = fieldDef;\n        const sort: (number | string | boolean | DateTime)[] = fieldDef.sort;\n        // generate `datum[\"a\"] === val0 ? 0 : datum[\"a\"] === val1 ? 1 : ... : n` via FieldEqualPredicate\n        const calculate =\n          sort\n            .map((sortValue, i) => {\n              return `${fieldFilterExpression({field, timeUnit, equal: sortValue})} ? ${i} : `;\n            })\n            .join('') + sort.length;\n\n        parent = new CalculateNode(parent, {\n          calculate,\n          as: sortArrayIndexField(fieldDef, channel, {forAs: true})\n        });\n      }\n    });\n    return parent;\n  }\n\n  public producedFields() {\n    const out = {};\n    out[this.transform.as] = true;\n    return out;\n  }\n\n  public dependentFields() {\n    return this._dependentFields;\n  }\n\n  public assemble(): VgFormulaTransform {\n    return {\n      type: 'formula',\n      expr: this.transform.calculate,\n      as: this.transform.as\n    };\n  }\n\n  public hash() {\n    return `Calculate ${hash(this.transform)}`;\n  }\n}\n\nexport function sortArrayIndexField(fieldDef: FieldDef<string>, channel: SingleDefChannel, opt?: FieldRefOption) {\n  return vgField(fieldDef, {prefix: channel, suffix: 'sort_index', ...(opt || {})});\n}\n","import {DataSourceType} from '../../data';\nimport {Dict, StringSet} from '../../util';\n\n/**\n * A node in the dataflow tree.\n */\nexport class DataFlowNode {\n  private _children: DataFlowNode[] = [];\n\n  private _parent: DataFlowNode = null;\n\n  constructor(parent: DataFlowNode, public readonly debugName?: string) {\n    if (parent) {\n      this.parent = parent;\n    }\n  }\n\n  /**\n   * Clone this node with a deep copy but don't clone links to children or parents.\n   */\n  public clone(): DataFlowNode {\n    throw new Error('Cannot clone node');\n  }\n\n  /**\n   * Set of fields that are being created by this node.\n   */\n  public producedFields(): StringSet {\n    return {};\n  }\n\n  public dependentFields(): StringSet {\n    return {};\n  }\n\n  get parent() {\n    return this._parent;\n  }\n\n  /**\n   * Set the parent of the node and also add this not to the parent's children.\n   */\n  set parent(parent: DataFlowNode) {\n    this._parent = parent;\n    parent.addChild(this);\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  public numChildren() {\n    return this._children.length;\n  }\n\n  public addChild(child: DataFlowNode, loc?: number) {\n    if (loc !== undefined) {\n      this._children.splice(loc, 0, child);\n    } else {\n      this._children.push(child);\n    }\n  }\n\n  public removeChild(oldChild: DataFlowNode) {\n    const loc = this._children.indexOf(oldChild);\n    this._children.splice(loc, 1);\n    return loc;\n  }\n\n  /**\n   * Remove node from the dataflow.\n   */\n  public remove() {\n    let loc = this._parent.removeChild(this);\n    for (const child of this._children) {\n      // do not use the set method because we want to insert at a particular location\n      child._parent = this._parent;\n      this._parent.addChild(child, loc++);\n    }\n  }\n\n  /**\n   * Insert another node as a parent of this node.\n   */\n  public insertAsParentOf(other: DataFlowNode) {\n    const parent = other.parent;\n    parent.removeChild(this);\n    this.parent = parent;\n    other.parent = this;\n  }\n\n  public swapWithParent() {\n    const parent = this._parent;\n    const newParent = parent.parent;\n\n    // reconnect the children\n    for (const child of this._children) {\n      child.parent = parent;\n    }\n\n    // remove old links\n    this._children = []; // equivalent to removing every child link one by one\n    parent.removeChild(this);\n    parent.parent.removeChild(parent);\n\n    // swap two nodes\n    this.parent = newParent;\n    parent.parent = this;\n  }\n}\n\nexport class OutputNode extends DataFlowNode {\n  private _source: string;\n\n  private _name: string;\n\n  public clone(): this {\n    const cloneObj = new (this.constructor as any)();\n    cloneObj.debugName = 'clone_' + this.debugName;\n    cloneObj._source = this._source;\n    cloneObj._name = 'clone_' + this._name;\n    cloneObj.type = this.type;\n    cloneObj.refCounts = this.refCounts;\n    cloneObj.refCounts[cloneObj._name] = 0;\n    return cloneObj;\n  }\n\n  /**\n   * @param source The name of the source. Will change in assemble.\n   * @param type The type of the output node.\n   * @param refCounts A global ref counter map.\n   */\n  constructor(\n    parent: DataFlowNode,\n    source: string,\n    public readonly type: DataSourceType,\n    private readonly refCounts: Dict<number>\n  ) {\n    super(parent, source);\n\n    this._source = this._name = source;\n\n    if (this.refCounts && !(this._name in this.refCounts)) {\n      this.refCounts[this._name] = 0;\n    }\n  }\n\n  /**\n   * Request the datasource name and increase the ref counter.\n   *\n   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.\n   * It is crucial to request the name from an output node to mark it as a required node.\n   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.\n   *\n   * In the assemble phase, this will return the correct name.\n   */\n  public getSource() {\n    this.refCounts[this._name]++;\n    return this._source;\n  }\n\n  public isRequired(): boolean {\n    return !!this.refCounts[this._name];\n  }\n\n  public setSource(source: string) {\n    this._source = source;\n  }\n}\n\nexport abstract class TransformNode extends DataFlowNode {\n  public abstract hash(): string | number;\n}\n\nexport function isTransformNode(x: DataFlowNode) {\n  return x instanceof TransformNode;\n}\n","import {parse} from 'vega-expression';\nimport {StringSet} from './../../util';\n\nfunction getName(node: any) {\n  let name: string[] = [];\n\n  if (node.type === 'Identifier') {\n    return [node.name];\n  }\n\n  if (node.type === 'Literal') {\n    return [node.value];\n  }\n\n  if (node.type === 'MemberExpression') {\n    name = name.concat(getName(node.object));\n    name = name.concat(getName(node.property));\n  }\n\n  return name;\n}\n\nfunction startsWithDatum(node: any): boolean {\n  if (node.object.type === 'MemberExpression') {\n    return startsWithDatum(node.object);\n  }\n  return node.object.name === 'datum';\n}\n\nexport function getDependentFields(expression: string) {\n  const ast = parse(expression);\n  const dependents: StringSet = {};\n  ast.visit((node: any) => {\n    if (node.type === 'MemberExpression' && startsWithDatum(node)) {\n      dependents[\n        getName(node)\n          .slice(1)\n          .join('.')\n      ] = true;\n    }\n  });\n\n  return dependents;\n}\n","import {AggregateOp} from 'vega';\nimport {isArray} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {COLUMN, ROW, ScaleChannel} from '../../channel';\nimport {vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {hasDiscreteDomain} from '../../scale';\nimport {EncodingSortField, isSortField} from '../../sort';\nimport {isVgRangeStep, VgData} from '../../vega.schema';\nimport {FacetModel} from '../facet';\nimport {Model} from '../model';\nimport {assembleDomain, getFieldFromDomain} from '../scale/domain';\nimport {sortArrayIndexField} from './calculate';\nimport {DataFlowNode} from './dataflow';\n\ninterface ChildIndependentFieldsWithStep {\n  x?: string;\n  y?: string;\n}\n\ninterface FacetChannelInfo {\n  name: string;\n  fields: string[];\n  sortField?: EncodingSortField<string>;\n\n  sortIndexField?: string;\n}\n\n/**\n * A node that helps us track what fields we are faceting by.\n */\nexport class FacetNode extends DataFlowNode {\n  private readonly column: FacetChannelInfo;\n\n  private readonly row: FacetChannelInfo;\n\n  private readonly childModel: Model;\n\n  /**\n   * @param model The facet model.\n   * @param name The name that this facet source will have.\n   * @param data The source data for this facet data.\n   */\n  public constructor(\n    parent: DataFlowNode,\n    public readonly model: FacetModel,\n    public readonly name: string,\n    public data: string\n  ) {\n    super(parent);\n\n    for (const channel of [COLUMN, ROW]) {\n      const fieldDef = model.facet[channel];\n      if (fieldDef) {\n        const {bin, sort} = fieldDef;\n        this[channel] = {\n          name: model.getName(`${channel}_domain`),\n          fields: [vgField(fieldDef), ...(isBinning(bin) ? [vgField(fieldDef, {binSuffix: 'end'})] : [])],\n          ...(isSortField(sort)\n            ? {sortField: sort}\n            : isArray(sort)\n              ? {sortIndexField: sortArrayIndexField(fieldDef, channel)}\n              : {})\n        };\n      }\n    }\n    this.childModel = model.child;\n  }\n\n  get fields() {\n    return [...((this.column && this.column.fields) || []), ...((this.row && this.row.fields) || [])];\n  }\n\n  /**\n   * The name to reference this source is its name.\n   */\n  public getSource() {\n    return this.name;\n  }\n\n  private getChildIndependentFieldsWithStep() {\n    const childIndependentFieldsWithStep: ChildIndependentFieldsWithStep = {};\n\n    for (const channel of ['x', 'y'] as ScaleChannel[]) {\n      const childScaleComponent = this.childModel.component.scales[channel];\n      if (childScaleComponent && !childScaleComponent.merged) {\n        const type = childScaleComponent.get('type');\n        const range = childScaleComponent.get('range');\n\n        if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n          const domain = assembleDomain(this.childModel, channel);\n          const field = getFieldFromDomain(domain);\n          if (field) {\n            childIndependentFieldsWithStep[channel] = field;\n          } else {\n            log.warn('Unknown field for ${channel}.  Cannot calculate view size.');\n          }\n        }\n      }\n    }\n\n    return childIndependentFieldsWithStep;\n  }\n\n  private assembleRowColumnData(\n    channel: 'row' | 'column',\n    crossedDataName: string,\n    childIndependentFieldsWithStep: ChildIndependentFieldsWithStep\n  ): VgData {\n    const childChannel = channel === 'row' ? 'y' : 'x';\n\n    const fields: string[] = [];\n    const ops: AggregateOp[] = [];\n    const as: string[] = [];\n\n    if (childIndependentFieldsWithStep[childChannel]) {\n      if (crossedDataName) {\n        // If there is a crossed data, calculate max\n        fields.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n\n        ops.push('max');\n      } else {\n        // If there is no crossed data, just calculate distinct\n        fields.push(childIndependentFieldsWithStep[childChannel]);\n        ops.push('distinct');\n      }\n      // Although it is technically a max, just name it distinct so it's easier to refer to it\n      as.push(`distinct_${childIndependentFieldsWithStep[childChannel]}`);\n    }\n\n    const {sortField, sortIndexField} = this[channel];\n    if (sortField) {\n      const {op, field} = sortField;\n      fields.push(field);\n      ops.push(op);\n      as.push(vgField(sortField, {forAs: true}));\n    } else if (sortIndexField) {\n      fields.push(sortIndexField);\n      ops.push('max');\n      as.push(sortIndexField);\n    }\n\n    return {\n      name: this[channel].name,\n      // Use data from the crossed one if it exist\n      source: crossedDataName || this.data,\n      transform: [\n        {\n          type: 'aggregate',\n          groupby: this[channel].fields,\n          ...(fields.length\n            ? {\n                fields,\n                ops,\n                as\n              }\n            : {})\n        }\n      ]\n    };\n  }\n\n  public assemble() {\n    const data: VgData[] = [];\n    let crossedDataName = null;\n    const childIndependentFieldsWithStep = this.getChildIndependentFieldsWithStep();\n\n    if (this.column && this.row && (childIndependentFieldsWithStep.x || childIndependentFieldsWithStep.y)) {\n      // Need to create a cross dataset to correctly calculate cardinality\n      crossedDataName = `cross_${this.column.name}_${this.row.name}`;\n\n      const fields = [].concat(\n        childIndependentFieldsWithStep.x ? [childIndependentFieldsWithStep.x] : [],\n        childIndependentFieldsWithStep.y ? [childIndependentFieldsWithStep.y] : []\n      );\n      const ops = fields.map((): AggregateOp => 'distinct');\n\n      data.push({\n        name: crossedDataName,\n        source: this.data,\n        transform: [\n          {\n            type: 'aggregate',\n            groupby: [...this.column.fields, ...this.row.fields],\n            fields,\n            ops\n          }\n        ]\n      });\n    }\n\n    for (const channel of [COLUMN, ROW]) {\n      if (this[channel]) {\n        data.push(this.assembleRowColumnData(channel, crossedDataName, childIndependentFieldsWithStep));\n      }\n    }\n\n    return data;\n  }\n}\n","import {LogicalOperand} from '../../logical';\nimport {expression, Predicate} from '../../predicate';\nimport {duplicate, hash, StringSet} from '../../util';\nimport {VgFilterTransform} from '../../vega.schema';\nimport {Model} from '../model';\nimport {DataFlowNode, TransformNode} from './dataflow';\nimport {getDependentFields} from './expressions';\n\nexport class FilterNode extends TransformNode {\n  private expr: string;\n  private _dependentFields: StringSet;\n  public clone() {\n    return new FilterNode(null, this.model, duplicate(this.filter));\n  }\n\n  constructor(parent: DataFlowNode, private readonly model: Model, private filter: LogicalOperand<Predicate>) {\n    super(parent);\n    this.expr = expression(this.model, this.filter, this);\n\n    this._dependentFields = getDependentFields(this.expr);\n  }\n\n  public dependentFields() {\n    return this._dependentFields;\n  }\n\n  public assemble(): VgFilterTransform {\n    return {\n      type: 'filter',\n      expr: this.expr\n    };\n  }\n\n  public hash() {\n    return `Filter ${hash(this.filter)}`;\n  }\n}\n","import {FlattenTransform as VgFlattenTransform} from 'vega';\nimport {FlattenTransform} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\n/**\n * A class for flatten transform nodes\n */\nexport class FlattenTransformNode extends TransformNode {\n  public clone() {\n    return new FlattenTransformNode(this.parent, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private transform: FlattenTransform) {\n    super(parent);\n    const {flatten, as = []} = this.transform;\n    this.transform.as = flatten.map((f, i) => as[i] || f);\n  }\n\n  public producedFields() {\n    return this.transform.flatten.reduce((out, field, i) => {\n      out[this.transform.as[i]] = true;\n      return out;\n    }, {});\n  }\n\n  public hash() {\n    return `FlattenTransform ${hash(this.transform)}`;\n  }\n\n  public assemble(): VgFlattenTransform {\n    const {flatten: fields, as} = this.transform;\n\n    const result: VgFlattenTransform = {\n      type: 'flatten',\n      fields,\n      as\n    };\n    return result;\n  }\n}\n","import {FoldTransform as VgFoldTransform} from 'vega';\nimport {FoldTransform} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\n/**\n * A class for flatten transform nodes\n */\nexport class FoldTransformNode extends TransformNode {\n  public clone() {\n    return new FoldTransformNode(this.parent, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private transform: FoldTransform) {\n    super(parent);\n    const specifiedAs = this.transform.as || [undefined, undefined];\n    this.transform.as = [specifiedAs[0] || 'key', specifiedAs[1] || 'value'];\n  }\n\n  public producedFields() {\n    return this.transform.as.reduce((result, item) => {\n      result[item] = true;\n      return result;\n    }, {});\n  }\n\n  public hash() {\n    return `FoldTransform ${hash(this.transform)}`;\n  }\n\n  public assemble(): VgFoldTransform {\n    const {fold, as} = this.transform;\n    const result: VgFoldTransform = {\n      type: 'fold',\n      fields: fold,\n      as\n    };\n    return result;\n  }\n}\n","import {isNumber, isString, toSet} from 'vega-util';\nimport {AncestorParse} from '.';\nimport {isCountingAggregateOp} from '../../aggregate';\nimport {Parse} from '../../data';\nimport {DateTime, isDateTime} from '../../datetime';\nimport {isNumberFieldDef, isScaleFieldDef, isTimeFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {forEachLeaf} from '../../logical';\nimport {isFieldEqualPredicate, isFieldOneOfPredicate, isFieldPredicate, isFieldRangePredicate} from '../../predicate';\nimport {isSortField} from '../../sort';\nimport {FilterTransform} from '../../transform';\nimport {accessPathDepth, accessPathWithDatum, duplicate, keys, removePathFromField, StringSet} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {Split} from '../split';\nimport {DataFlowNode} from './dataflow';\n\n/**\n * @param field The field.\n * @param parse What to parse the field as.\n */\nfunction parseExpression(field: string, parse: string): string {\n  const f = accessPathWithDatum(field);\n  if (parse === 'number') {\n    return `toNumber(${f})`;\n  } else if (parse === 'boolean') {\n    return `toBoolean(${f})`;\n  } else if (parse === 'string') {\n    return `toString(${f})`;\n  } else if (parse === 'date') {\n    return `toDate(${f})`;\n  } else if (parse === 'flatten') {\n    return f;\n  } else if (parse.indexOf('date:') === 0) {\n    const specifier = parse.slice(5, parse.length);\n    return `timeParse(${f},${specifier})`;\n  } else if (parse.indexOf('utc:') === 0) {\n    const specifier = parse.slice(4, parse.length);\n    return `utcParse(${f},${specifier})`;\n  } else {\n    log.warn(log.message.unrecognizedParse(parse));\n    return null;\n  }\n}\n\nexport class ParseNode extends DataFlowNode {\n  private _parse: Parse;\n\n  public clone() {\n    return new ParseNode(null, duplicate(this._parse));\n  }\n\n  constructor(parent: DataFlowNode, parse: Parse) {\n    super(parent);\n\n    this._parse = parse;\n  }\n\n  /**\n   * Creates a parse node from a data.format.parse and updates ancestorParse.\n   */\n  public static makeExplicit(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    // Custom parse\n    let explicit = {};\n    const data = model.data;\n    if (data && data.format && data.format.parse) {\n      explicit = data.format.parse;\n    }\n\n    return this.makeWithAncestors(parent, explicit, {}, ancestorParse);\n  }\n\n  public static makeImplicitFromFilterTransform(\n    parent: DataFlowNode,\n    transform: FilterTransform,\n    ancestorParse: AncestorParse\n  ) {\n    const parse = {};\n    forEachLeaf(transform.filter, filter => {\n      if (isFieldPredicate(filter)) {\n        // Automatically add a parse node for filters with filter objects\n        let val: string | number | boolean | DateTime = null;\n\n        // For EqualFilter, just use the equal property.\n        // For RangeFilter and OneOfFilter, all array members should have\n        // the same type, so we only use the first one.\n        if (isFieldEqualPredicate(filter)) {\n          val = filter.equal;\n        } else if (isFieldRangePredicate(filter)) {\n          val = filter.range[0];\n        } else if (isFieldOneOfPredicate(filter)) {\n          val = (filter.oneOf || filter['in'])[0];\n        } // else -- for filter expression, we can't infer anything\n        if (val) {\n          if (isDateTime(val)) {\n            parse[filter.field] = 'date';\n          } else if (isNumber(val)) {\n            parse[filter.field] = 'number';\n          } else if (isString(val)) {\n            parse[filter.field] = 'string';\n          }\n        }\n\n        if (filter.timeUnit) {\n          parse[filter.field] = 'date';\n        }\n      }\n    });\n\n    if (keys(parse).length === 0) {\n      return null;\n    }\n\n    return this.makeWithAncestors(parent, {}, parse, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node for implicit parsing from a model and updates ancestorParse.\n   */\n  public static makeImplicitFromEncoding(parent: DataFlowNode, model: Model, ancestorParse: AncestorParse) {\n    const implicit = {};\n\n    if (isUnitModel(model) || isFacetModel(model)) {\n      // Parse encoded fields\n      model.forEachFieldDef(fieldDef => {\n        if (isTimeFieldDef(fieldDef)) {\n          implicit[fieldDef.field] = 'date';\n        } else if (isNumberFieldDef(fieldDef)) {\n          if (!isCountingAggregateOp(fieldDef.aggregate)) {\n            implicit[fieldDef.field] = 'number';\n          }\n        } else if (accessPathDepth(fieldDef.field) > 1) {\n          // For non-date/non-number (strings and booleans), derive a flattened field for a referenced nested field.\n          // (Parsing numbers / dates already flattens numeric and temporal fields.)\n          if (!(fieldDef.field in implicit)) {\n            implicit[fieldDef.field] = 'flatten';\n          }\n        } else if (\n          isScaleFieldDef(fieldDef) &&\n          isSortField(fieldDef.sort) &&\n          accessPathDepth(fieldDef.sort.field) > 1\n        ) {\n          // Flatten fields that we sort by but that are not otherwise flattened.\n          if (!(fieldDef.sort.field in implicit)) {\n            implicit[fieldDef.sort.field] = 'flatten';\n          }\n        }\n      });\n    }\n\n    return this.makeWithAncestors(parent, {}, implicit, ancestorParse);\n  }\n\n  /**\n   * Creates a parse node from \"explicit\" parse and \"implicit\" parse and updates ancestorParse.\n   */\n  private static makeWithAncestors(\n    parent: DataFlowNode,\n    explicit: Parse,\n    implicit: Parse,\n    ancestorParse: AncestorParse\n  ) {\n    // We should not parse what has already been parsed in a parent (explicitly or implicitly) or what has been derived (maked as \"derived\"). We also don't need to flatten a field that has already been parsed.\n    for (const field of keys(implicit)) {\n      const parsedAs = ancestorParse.getWithExplicit(field);\n      if (parsedAs.value !== undefined) {\n        // We always ignore derived fields even if they are implicitly defined because we expect users to create the right types.\n        if (\n          parsedAs.explicit ||\n          parsedAs.value === implicit[field] ||\n          parsedAs.value === 'derived' ||\n          implicit[field] === 'flatten'\n        ) {\n          delete implicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, implicit[field], parsedAs.value));\n        }\n      }\n    }\n\n    for (const field of keys(explicit)) {\n      const parsedAs = ancestorParse.get(field);\n      if (parsedAs !== undefined) {\n        // Don't parse a field again if it has been parsed with the same type already.\n        if (parsedAs === explicit[field]) {\n          delete explicit[field];\n        } else {\n          log.warn(log.message.differentParse(field, explicit[field], parsedAs));\n        }\n      }\n    }\n\n    const parse = new Split(explicit, implicit);\n\n    // add the format parse from this model so that children don't parse the same field again\n    ancestorParse.copyAll(parse);\n\n    // copy only non-null parses\n    const p = {};\n    for (const key of keys(parse.combine())) {\n      const val = parse.get(key);\n      if (val !== null) {\n        p[key] = val;\n      }\n    }\n\n    if (keys(p).length === 0 || ancestorParse.parseNothing) {\n      return null;\n    }\n\n    return new ParseNode(parent, p);\n  }\n\n  public get parse() {\n    return this._parse;\n  }\n\n  public merge(other: ParseNode) {\n    this._parse = {...this._parse, ...other.parse};\n    other.remove();\n  }\n\n  /**\n   * Assemble an object for Vega's format.parse property.\n   */\n  public assembleFormatParse() {\n    const formatParse = {};\n    for (const field of keys(this._parse)) {\n      const p = this._parse[field];\n      if (accessPathDepth(field) === 1) {\n        formatParse[field] = p;\n      }\n    }\n    return formatParse;\n  }\n\n  // format parse depends and produces all fields in its parse\n  public producedFields(): StringSet {\n    return toSet(keys(this._parse));\n  }\n\n  public dependentFields(): StringSet {\n    return toSet(keys(this._parse));\n  }\n\n  public assembleTransforms(onlyNested = false): VgFormulaTransform[] {\n    return keys(this._parse)\n      .filter(field => (onlyNested ? accessPathDepth(field) > 1 : true))\n      .map(field => {\n        const expr = parseExpression(field, this._parse[field]);\n        if (!expr) {\n          return null;\n        }\n\n        const formula: VgFormulaTransform = {\n          type: 'formula',\n          expr,\n          as: removePathFromField(field) // Vega output is always flattened\n        };\n        return formula;\n      })\n      .filter(t => t !== null);\n  }\n}\n","import {GeoPositionChannel, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE} from '../../channel';\nimport {GEOJSON} from '../../type';\nimport {duplicate} from '../../util';\nimport {VgGeoJSONTransform} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class GeoJSONNode extends DataFlowNode {\n  public clone() {\n    return new GeoJSONNode(null, duplicate(this.fields), this.geojson, this.signal);\n  }\n\n  public static parseAll(parent: DataFlowNode, model: UnitModel): DataFlowNode {\n    let geoJsonCounter = 0;\n\n    [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]].forEach((coordinates: GeoPositionChannel[]) => {\n      const pair = coordinates.map(\n        channel => (model.channelHasField(channel) ? model.fieldDef(channel).field : undefined)\n      );\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoJSONNode(parent, pair, null, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    });\n\n    if (model.channelHasField(SHAPE)) {\n      const fieldDef = model.fieldDef(SHAPE);\n      if (fieldDef.type === GEOJSON) {\n        parent = new GeoJSONNode(parent, null, fieldDef.field, model.getName(`geojson_${geoJsonCounter++}`));\n      }\n    }\n\n    return parent;\n  }\n\n  constructor(parent: DataFlowNode, private fields?: string[], private geojson?: string, private signal?: string) {\n    super(parent);\n  }\n\n  public assemble(): VgGeoJSONTransform {\n    return {\n      type: 'geojson',\n      ...(this.fields ? {fields: this.fields} : {}),\n      ...(this.geojson ? {geojson: this.geojson} : {}),\n      signal: this.signal\n    };\n  }\n}\n","import {GeoPositionChannel, LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2} from '../../channel';\nimport {duplicate} from '../../util';\nimport {VgGeoPointTransform} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode} from './dataflow';\n\nexport class GeoPointNode extends DataFlowNode {\n  public clone() {\n    return new GeoPointNode(null, this.projection, duplicate(this.fields), duplicate(this.as));\n  }\n\n  constructor(parent: DataFlowNode, private projection: string, private fields: string[], private as: string[]) {\n    super(parent);\n  }\n\n  public static parseAll(parent: DataFlowNode, model: UnitModel): DataFlowNode {\n    if (!model.projectionName()) {\n      return parent;\n    }\n\n    [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]].forEach((coordinates: GeoPositionChannel[]) => {\n      const pair = coordinates.map(\n        channel => (model.channelHasField(channel) ? model.fieldDef(channel).field : undefined)\n      );\n\n      const suffix = coordinates[0] === LONGITUDE2 ? '2' : '';\n\n      if (pair[0] || pair[1]) {\n        parent = new GeoPointNode(parent, model.projectionName(), pair, [\n          model.getName('x' + suffix),\n          model.getName('y' + suffix)\n        ]);\n      }\n    });\n\n    return parent;\n  }\n\n  public assemble(): VgGeoPointTransform {\n    return {\n      type: 'geopoint',\n      projection: this.projection,\n      fields: this.fields,\n      as: this.as\n    };\n  }\n}\n","import {SELECTION_ID} from '../../selection';\nimport {StringSet} from '../../util';\nimport {VgIdentifierTransform} from '../../vega.schema';\nimport {DataFlowNode} from './dataflow';\n\nexport class IdentifierNode extends DataFlowNode {\n  public clone() {\n    return new IdentifierNode(null);\n  }\n\n  constructor(parent: DataFlowNode) {\n    super(parent);\n  }\n\n  public producedFields(): StringSet {\n    return {[SELECTION_ID]: true};\n  }\n\n  public assemble(): VgIdentifierTransform {\n    return {type: 'identifier', as: SELECTION_ID};\n  }\n}\n","import {SignalRef} from 'vega';\nimport {isFieldDef} from '../../fielddef';\nimport {ImputeSequence, ImputeTransform, isImputeSequence} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {VgFormulaTransform, VgImputeTransform, VgWindowTransform} from '../../vega.schema';\nimport {pathGroupingFields} from '../mark/mark';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\nexport class ImputeNode extends TransformNode {\n  public clone() {\n    return new ImputeNode(this.parent, duplicate(this.transform));\n  }\n\n  public producedFields() {\n    // typescript detects true as boolean type\n    return {[this.transform.impute]: true as true};\n  }\n\n  constructor(parent: DataFlowNode, private transform: ImputeTransform) {\n    super(parent);\n  }\n\n  private processSequence(keyvals: ImputeSequence): SignalRef {\n    const {start = 0, stop, step} = keyvals;\n    const result = [start, stop, ...(step ? [step] : [])].join(',');\n\n    return {signal: `sequence(${result})`};\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, imputeTransform: ImputeTransform): ImputeNode {\n    return new ImputeNode(parent, imputeTransform);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel) {\n    const encoding = model.encoding;\n    const xDef = encoding.x;\n    const yDef = encoding.y;\n\n    if (isFieldDef(xDef) && isFieldDef(yDef)) {\n      const imputedChannel = xDef.impute ? xDef : yDef.impute ? yDef : undefined;\n      if (imputedChannel === undefined) {\n        return undefined;\n      }\n      const keyChannel = xDef.impute ? yDef : yDef.impute ? xDef : undefined;\n      const {method, value, frame, keyvals} = imputedChannel.impute;\n      const groupbyFields = pathGroupingFields(model.mark, encoding);\n\n      return new ImputeNode(parent, {\n        impute: imputedChannel.field,\n        key: keyChannel.field,\n        ...(method ? {method} : {}),\n        ...(value !== undefined ? {value} : {}),\n        ...(frame ? {frame} : {}),\n        ...(keyvals !== undefined ? {keyvals} : {}),\n        ...(groupbyFields.length ? {groupby: groupbyFields} : {})\n      });\n    }\n    return null;\n  }\n\n  public hash() {\n    return `Impute ${hash(this.transform)}`;\n  }\n\n  public assemble() {\n    const {impute, key, keyvals, method, groupby, value, frame = [null, null]} = this.transform;\n\n    const initialImpute: VgImputeTransform = {\n      type: 'impute',\n      field: impute,\n      key,\n      ...(keyvals ? {keyvals: isImputeSequence(keyvals) ? this.processSequence(keyvals) : keyvals} : {}),\n      method: 'value',\n      ...(groupby ? {groupby} : {}),\n      value: null\n    };\n    let setImputedField;\n    if (method && method !== 'value') {\n      const deriveNewField: VgWindowTransform = {\n        type: 'window',\n        as: [`imputed_${impute}_value`],\n        ops: [method],\n        fields: [impute],\n        frame,\n        ignorePeers: false,\n        ...(groupby ? {groupby} : {})\n      };\n      const replaceOriginal: VgFormulaTransform = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? datum.imputed_${impute}_value : datum.${impute}`,\n        as: impute\n      };\n      setImputedField = [deriveNewField, replaceOriginal];\n    } else {\n      const replaceWithValue: VgFormulaTransform = {\n        type: 'formula',\n        expr: `datum.${impute} === null ? ${value} : datum.${impute}`,\n        as: impute\n      };\n      setImputedField = [replaceWithValue];\n    }\n\n    return [initialImpute, ...setImputedField];\n  }\n}\n","import {Parse} from '../../data';\nimport {Dict} from '../../util';\nimport {Split} from '../split';\nimport {OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {SourceNode} from './source';\n\nexport interface DataComponent {\n  /**\n   * A dictionary of sources indexed by a hash.\n   */\n  sources: Dict<SourceNode>;\n\n  /**\n   * Registry of output nodes.\n   */\n  outputNodes: Dict<OutputNode | FacetNode>;\n\n  /**\n   * How often is an output node used. If it is not used, we don't need to\n   * instantiate it in the assemble step.\n   */\n  outputNodeRefCounts: Dict<number>;\n\n  /**\n   * The output node before aggregation.\n   */\n  raw?: OutputNode;\n\n  /**\n   * The main output node.\n   */\n  main?: OutputNode;\n\n  /**\n   * For facets, we store the reference to the root node.\n   */\n  facetRoot?: FacetNode;\n\n  /**\n   * True if the data for this model is faceted.\n   * A dataset is faceted if a parent model is a facet and no new dataset is\n   * defined (which would make the data unfaceted again).\n   */\n  isFaceted: boolean;\n\n  /**\n   * Parse properties passed down from ancestors. Helps us to keep track of what has been parsed or is derived.\n   */\n  ancestorParse?: AncestorParse;\n}\n\n/**\n * Class to track interesting properties (see https://15721.courses.cs.cmu.edu/spring2016/papers/graefe-ieee1995.pdf)\n * about how fields have been parsed or whether they have been derived in a transform. We use this to not parse the\n * same field again (or differently).\n */\nexport class AncestorParse extends Split<Parse> {\n  constructor(\n    public readonly explicit: Partial<Parse> = {},\n    public readonly implicit: Partial<Parse> = {},\n    public parseNothing = false\n  ) {\n    super(explicit, implicit);\n  }\n\n  public clone(): AncestorParse {\n    const clone = super.clone() as AncestorParse;\n    clone.parseNothing = this.parseNothing;\n    return clone;\n  }\n}\n","import {isString, toSet} from 'vega-util';\nimport * as log from '../../log';\nimport {LookupTransform} from '../../transform';\nimport {hash, StringSet} from '../../util';\nimport {VgLookupTransform} from '../../vega.schema';\nimport {Model} from '../model';\nimport {DataFlowNode, OutputNode, TransformNode} from './dataflow';\nimport {SourceNode} from './source';\n\nexport class LookupNode extends TransformNode {\n  constructor(parent: DataFlowNode, public readonly transform: LookupTransform, public readonly secondary: string) {\n    super(parent);\n  }\n\n  public static make(parent: DataFlowNode, model: Model, transform: LookupTransform, counter: number) {\n    const sources = model.component.data.sources;\n    const s = new SourceNode(transform.from.data);\n    let fromSource = sources[s.hash()];\n    if (!fromSource) {\n      sources[s.hash()] = s;\n      fromSource = s;\n    }\n\n    const fromOutputName = model.getName(`lookup_${counter}`);\n    const fromOutputNode = new OutputNode(\n      fromSource,\n      fromOutputName,\n      'lookup',\n      model.component.data.outputNodeRefCounts\n    );\n\n    model.component.data.outputNodes[fromOutputName] = fromOutputNode;\n\n    return new LookupNode(parent, transform, fromOutputNode.getSource());\n  }\n\n  public producedFields(): StringSet {\n    return toSet(\n      this.transform.from.fields || (this.transform.as instanceof Array ? this.transform.as : [this.transform.as])\n    );\n  }\n\n  public hash() {\n    return `Lookup ${hash({transform: this.transform, secondary: this.secondary})}`;\n  }\n\n  public assemble(): VgLookupTransform {\n    let foreign: Partial<VgLookupTransform>;\n\n    if (this.transform.from.fields) {\n      // lookup a few fields and add create a flat output\n      foreign = {\n        values: this.transform.from.fields,\n        ...(this.transform.as ? {as: this.transform.as instanceof Array ? this.transform.as : [this.transform.as]} : {})\n      };\n    } else {\n      // lookup full record and nest it\n      let asName = this.transform.as;\n      if (!isString(asName)) {\n        log.warn(log.message.NO_FIELDS_NEEDS_AS);\n        asName = '_lookup';\n      }\n\n      foreign = {\n        as: [asName]\n      };\n    }\n\n    return {\n      type: 'lookup',\n      from: this.secondary,\n      key: this.transform.from.key,\n      fields: [this.transform.lookup],\n      ...foreign,\n      ...(this.transform.default ? {default: this.transform.default} : {})\n    };\n  }\n}\n","import {MAIN} from '../../data';\nimport {flatten, keys, vals} from '../../util';\nimport {AggregateNode} from './aggregate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {DataComponent} from './index';\nimport * as optimizers from './optimizers';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\n\nexport const FACET_SCALE_PREFIX = 'scale_';\n\n/**\n * Clones the subtree and ignores output nodes except for the leafs, which are renamed.\n */\nfunction cloneSubtree(facet: FacetNode) {\n  function clone(node: DataFlowNode): DataFlowNode[] {\n    if (!(node instanceof FacetNode)) {\n      const copy = node.clone();\n\n      if (copy instanceof OutputNode) {\n        const newName = FACET_SCALE_PREFIX + copy.getSource();\n        copy.setSource(newName);\n\n        facet.model.component.data.outputNodes[newName] = copy;\n      } else if (copy instanceof AggregateNode || copy instanceof StackNode) {\n        copy.addDimensions(facet.fields);\n      }\n      flatten(node.children.map(clone)).forEach((n: DataFlowNode) => (n.parent = copy));\n\n      return [copy];\n    }\n\n    return flatten(node.children.map(clone));\n  }\n  return clone;\n}\n\n/**\n * Move facet nodes down to the next fork or output node. Also pull the main output with the facet node.\n * After moving down the facet node, make a copy of the subtree and make it a child of the main output.\n */\nfunction moveFacetDown(node: DataFlowNode) {\n  if (node instanceof FacetNode) {\n    if (node.numChildren() === 1 && !(node.children[0] instanceof OutputNode)) {\n      // move down until we hit a fork or output node\n\n      const child = node.children[0];\n\n      if (child instanceof AggregateNode || child instanceof StackNode) {\n        child.addDimensions(node.fields);\n      }\n\n      child.swapWithParent();\n      moveFacetDown(node);\n    } else {\n      // move main to facet\n      moveMainDownToFacet(node.model.component.data.main);\n\n      // replicate the subtree and place it before the facet's main node\n      const copy: DataFlowNode[] = flatten(node.children.map(cloneSubtree(node)));\n      copy.forEach(c => (c.parent = node.model.component.data.main));\n    }\n  } else {\n    node.children.forEach(moveFacetDown);\n  }\n}\n\nfunction moveMainDownToFacet(node: DataFlowNode) {\n  if (node instanceof OutputNode && node.type === MAIN) {\n    if (node.numChildren() === 1) {\n      const child = node.children[0];\n\n      if (!(child instanceof FacetNode)) {\n        child.swapWithParent();\n        moveMainDownToFacet(node);\n      }\n    }\n  }\n}\n\n/**\n * Remove nodes that are not required starting from a root.\n */\nfunction removeUnnecessaryNodes(node: DataFlowNode) {\n  // remove output nodes that are not required\n  if (node instanceof OutputNode && !node.isRequired()) {\n    node.remove();\n  }\n\n  node.children.forEach(removeUnnecessaryNodes);\n}\n\n/**\n * Return all leaf nodes.\n */\nfunction getLeaves(roots: DataFlowNode[]) {\n  const leaves: DataFlowNode[] = [];\n  function append(node: DataFlowNode) {\n    if (node.numChildren() === 0) {\n      leaves.push(node);\n    } else {\n      node.children.forEach(append);\n    }\n  }\n\n  roots.forEach(append);\n  return leaves;\n}\n\n/**\n * Inserts an Intermediate ParseNode containing all non-conflicting Parse fields and removes the empty ParseNodes\n */\nexport function mergeParse(node: DataFlowNode) {\n  const parseChildren = node.children.filter((x): x is ParseNode => x instanceof ParseNode);\n  if (parseChildren.length > 1) {\n    const commonParse = {};\n    for (const parseNode of parseChildren) {\n      const parse = parseNode.parse;\n      for (const k of keys(parse)) {\n        if (commonParse[k] === undefined) {\n          commonParse[k] = parse[k];\n        } else if (commonParse[k] !== parse[k]) {\n          delete commonParse[k];\n        }\n      }\n    }\n    if (keys(commonParse).length !== 0) {\n      const mergedParseNode = new ParseNode(node, commonParse);\n      for (const parseNode of parseChildren) {\n        for (const key of keys(commonParse)) {\n          delete parseNode.parse[key];\n        }\n        node.removeChild(parseNode);\n        parseNode.parent = mergedParseNode;\n        if (keys(parseNode.parse).length === 0) {\n          parseNode.remove();\n        }\n      }\n    }\n  }\n  node.children.forEach(mergeParse);\n}\n\n/**\n * Optimizes the dataflow of the passed in data component.\n */\nexport function optimizeDataflow(dataComponent: DataComponent) {\n  let roots: SourceNode[] = vals(dataComponent.sources);\n\n  roots.forEach(removeUnnecessaryNodes);\n\n  // remove source nodes that don't have any children because they also don't have output nodes\n  roots = roots.filter(r => r.numChildren() > 0);\n  getLeaves(roots).forEach(optimizers.iterateFromLeaves(optimizers.removeUnusedSubtrees));\n  roots = roots.filter(r => r.numChildren() > 0);\n\n  getLeaves(roots).forEach(optimizers.iterateFromLeaves(optimizers.moveParseUp));\n  getLeaves(roots).forEach(optimizers.removeDuplicateTimeUnits);\n\n  roots.forEach(moveFacetDown);\n  roots.forEach(mergeParse);\n  roots.forEach(optimizers.mergeIdenticalTransforms);\n\n  keys(dataComponent.sources).forEach(s => {\n    if (dataComponent.sources[s].numChildren() === 0) {\n      delete dataComponent.sources[s];\n    }\n  });\n}\n","import {hasIntersection, keys} from '../../util';\nimport {DataFlowNode, isTransformNode, OutputNode, TransformNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {ParseNode} from './formatparse';\nimport {SourceNode} from './source';\nimport {TimeUnitNode} from './timeunit';\n\n/**\n * Start optimization path at the leaves. Useful for merging up or removing things.\n *\n * If the callback returns true, the recursion continues.\n */\nexport function iterateFromLeaves(f: (node: DataFlowNode) => boolean) {\n  function optimizeNextFromLeaves(node: DataFlowNode) {\n    if (node instanceof SourceNode) {\n      return;\n    }\n\n    const next = node.parent;\n    if (f(node)) {\n      optimizeNextFromLeaves(next);\n    }\n  }\n\n  return optimizeNextFromLeaves;\n}\n\n/**\n * Move parse nodes up to forks.\n */\nexport function moveParseUp(node: DataFlowNode) {\n  const parent = node.parent;\n\n  // move parse up by merging or swapping\n  if (node instanceof ParseNode) {\n    if (parent instanceof SourceNode) {\n      return false;\n    }\n\n    if (parent.numChildren() > 1) {\n      // don't move parse further up but continue with parent.\n      return true;\n    }\n\n    if (parent instanceof ParseNode) {\n      parent.merge(node);\n    } else {\n      // don't swap with nodes that produce something that the parse node depends on (e.g. lookup)\n      if (hasIntersection(parent.producedFields(), node.dependentFields())) {\n        return true;\n      }\n\n      node.swapWithParent();\n    }\n  }\n\n  return true;\n}\n\nfunction mergeBucket(parent: DataFlowNode, nodes: DataFlowNode[]) {\n  const mergedTransform = nodes.shift();\n  nodes.forEach(x => {\n    parent.removeChild(x);\n    x.parent = mergedTransform;\n    x.remove();\n  });\n}\n\n/**\n * Merge Identical Transforms at forks by comparing hashes.\n */\nexport function mergeIdenticalTransforms(node: DataFlowNode) {\n  const transforms = node.children.filter((x): x is TransformNode => isTransformNode(x));\n  const hashes = transforms.map(x => x.hash());\n  const buckets = {};\n  for (let i = 0; i < hashes.length; i++) {\n    if (buckets[hashes[i]] === undefined) {\n      buckets[hashes[i]] = [transforms[i]];\n    } else {\n      buckets[hashes[i]].push(transforms[i]);\n    }\n  }\n  for (const k of keys(buckets)) {\n    mergeBucket(node, buckets[k]);\n  }\n  node.children.forEach(mergeIdenticalTransforms);\n}\n\n/**\n * Repeatedly remove leaf nodes that are not output or facet nodes.\n * The reason is that we don't need subtrees that don't have any output nodes.\n * Facet nodes are needed for the row or column domains.\n */\nexport function removeUnusedSubtrees(node: DataFlowNode) {\n  if (node instanceof OutputNode || node.numChildren() > 0 || node instanceof FacetNode) {\n    // no need to continue with parent because it is output node or will have children (there was a fork)\n    return false;\n  } else {\n    node.remove();\n  }\n  return true;\n}\n\n/**\n * Removes duplicate time unit nodes (as determined by the name of the\n * output field) that may be generated due to selections projected over\n * time units.\n */\nexport function removeDuplicateTimeUnits(leaf: DataFlowNode) {\n  let fields = {};\n  return iterateFromLeaves((node: DataFlowNode) => {\n    if (node instanceof TimeUnitNode) {\n      const pfields = node.producedFields();\n      const dupe = keys(pfields).every(k => !!fields[k]);\n\n      if (dupe) {\n        node.remove();\n      } else {\n        fields = {...fields, ...pfields};\n      }\n    }\n\n    return true;\n  })(leaf);\n}\n","import {MAIN, ParseValue, RAW} from '../../data';\nimport * as log from '../../log';\nimport {\n  isAggregate,\n  isBin,\n  isCalculate,\n  isFilter,\n  isFlatten,\n  isFold,\n  isImpute,\n  isLookup,\n  isSample,\n  isStack,\n  isTimeUnit,\n  isWindow\n} from '../../transform';\nimport {Dict, keys} from '../../util';\nimport {isFacetModel, isLayerModel, isUnitModel, Model} from '../model';\nimport {requiresSelectionId} from '../selection/selection';\nimport {AggregateNode} from './aggregate';\nimport {BinNode} from './bin';\nimport {CalculateNode} from './calculate';\nimport {DataFlowNode, OutputNode} from './dataflow';\nimport {FacetNode} from './facet';\nimport {FilterNode} from './filter';\nimport {FlattenTransformNode} from './flatten';\nimport {FoldTransformNode} from './fold';\nimport {ParseNode} from './formatparse';\nimport {GeoJSONNode} from './geojson';\nimport {GeoPointNode} from './geopoint';\nimport {IdentifierNode} from './identifier';\nimport {ImputeNode} from './impute';\nimport {AncestorParse, DataComponent} from './index';\nimport {LookupNode} from './lookup';\nimport {SampleTransformNode} from './sample';\nimport {SourceNode} from './source';\nimport {StackNode} from './stack';\nimport {TimeUnitNode} from './timeunit';\nimport {WindowTransformNode} from './window';\n\nfunction parseRoot(model: Model, sources: Dict<SourceNode>): DataFlowNode {\n  if (model.data || !model.parent) {\n    // if the model defines a data source or is the root, create a source node\n    const source = new SourceNode(model.data);\n    const hash = source.hash();\n    if (hash in sources) {\n      // use a reference if we already have a source\n      return sources[hash];\n    } else {\n      // otherwise add a new one\n      sources[hash] = source;\n      return source;\n    }\n  } else {\n    // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.\n    return model.parent.component.data.facetRoot\n      ? model.parent.component.data.facetRoot\n      : model.parent.component.data.main;\n  }\n}\n\n/**\n * Parses a transforms array into a chain of connected dataflow nodes.\n */\nexport function parseTransformArray(head: DataFlowNode, model: Model, ancestorParse: AncestorParse): DataFlowNode {\n  let lookupCounter = 0;\n\n  model.transforms.forEach(t => {\n    let derivedType: ParseValue = undefined;\n    let transformNode: DataFlowNode;\n\n    if (isCalculate(t)) {\n      transformNode = head = new CalculateNode(head, t);\n      derivedType = 'derived';\n    } else if (isFilter(t)) {\n      transformNode = head = ParseNode.makeImplicitFromFilterTransform(head, t, ancestorParse) || head;\n\n      head = new FilterNode(head, model, t.filter);\n    } else if (isBin(t)) {\n      transformNode = head = BinNode.makeFromTransform(head, t, model);\n      derivedType = 'number';\n    } else if (isTimeUnit(t)) {\n      transformNode = head = TimeUnitNode.makeFromTransform(head, t);\n      derivedType = 'date';\n    } else if (isAggregate(t)) {\n      transformNode = head = AggregateNode.makeFromTransform(head, t);\n      derivedType = 'number';\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    } else if (isLookup(t)) {\n      transformNode = head = LookupNode.make(head, model, t, lookupCounter++);\n      derivedType = 'derived';\n    } else if (isWindow(t)) {\n      transformNode = head = new WindowTransformNode(head, t);\n      derivedType = 'number';\n    } else if (isStack(t)) {\n      transformNode = head = StackNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else if (isFold(t)) {\n      transformNode = head = new FoldTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isFlatten(t)) {\n      transformNode = head = new FlattenTransformNode(head, t);\n      derivedType = 'derived';\n    } else if (isSample(t)) {\n      head = new SampleTransformNode(head, t);\n    } else if (isImpute(t)) {\n      transformNode = head = ImputeNode.makeFromTransform(head, t);\n      derivedType = 'derived';\n    } else {\n      log.warn(log.message.invalidTransformIgnored(t));\n      return;\n    }\n\n    if (transformNode && derivedType !== undefined) {\n      for (const field of keys(transformNode.producedFields())) {\n        ancestorParse.set(field, derivedType, false);\n      }\n    }\n  });\n\n  return head;\n}\n\n/*\nDescription of the dataflow (http://asciiflow.com/):\n     +--------+\n     | Source |\n     +---+----+\n         |\n         v\n     FormatParse\n     (explicit)\n         |\n         v\n     Transforms\n(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)\n         |\n         v\n     FormatParse\n     (implicit)\n         |\n         v\n Binning (in `encoding`)\n         |\n         v\n Timeunit (in `encoding`)\n         |\n         v\nFormula From Sort Array\n         |\n         v\n      +--+--+\n      | Raw |\n      +-----+\n         |\n         v\n  Aggregate (in `encoding`)\n         |\n         v\n  Stack (in `encoding`)\n         |\n         v\n  Invalid Filter\n         |\n         v\n   +----------+\n   |   Main   |\n   +----------+\n         |\n         v\n     +-------+\n     | Facet |----> \"column\", \"column-layout\", and \"row\"\n     +-------+\n         |\n         v\n  ...Child data...\n*/\n\nexport function parseData(model: Model): DataComponent {\n  let head = parseRoot(model, model.component.data.sources);\n\n  const {outputNodes, outputNodeRefCounts} = model.component.data;\n  const ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();\n\n  // format.parse: null means disable parsing\n  if (model.data && model.data.format && model.data.format.parse === null) {\n    ancestorParse.parseNothing = true;\n  }\n\n  head = ParseNode.makeExplicit(head, model, ancestorParse) || head;\n\n  // Default discrete selections require an identifier transform to\n  // uniquely identify data points as the _id field is volatile. Add\n  // this transform at the head of our pipeline such that the identifier\n  // field is available for all subsequent datasets. Additional identifier\n  // transforms will be necessary when new tuples are constructed\n  // (e.g., post-aggregation).\n  if (requiresSelectionId(model) && (isUnitModel(model) || isLayerModel(model))) {\n    head = new IdentifierNode(head);\n  }\n\n  // HACK: This is equivalent for merging bin extent for union scale.\n  // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale\n  const parentIsLayer = model.parent && isLayerModel(model.parent);\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) || head;\n    }\n  }\n\n  if (model.transforms.length > 0) {\n    head = parseTransformArray(head, model, ancestorParse);\n  }\n\n  head = ParseNode.makeImplicitFromEncoding(head, model, ancestorParse) || head;\n\n  if (isUnitModel(model)) {\n    head = GeoJSONNode.parseAll(head, model);\n    head = GeoPointNode.parseAll(head, model);\n  }\n\n  if (isUnitModel(model) || isFacetModel(model)) {\n    if (!parentIsLayer) {\n      head = BinNode.makeFromEncoding(head, model) || head;\n    }\n\n    head = TimeUnitNode.makeFromEncoding(head, model) || head;\n    head = CalculateNode.parseAllForSortIndex(head, model);\n  }\n\n  // add an output node pre aggregation\n  const rawName = model.getName(RAW);\n  const raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);\n  outputNodes[rawName] = raw;\n  head = raw;\n\n  if (isUnitModel(model)) {\n    const agg = AggregateNode.makeFromEncoding(head, model);\n    if (agg) {\n      head = agg;\n\n      if (requiresSelectionId(model)) {\n        head = new IdentifierNode(head);\n      }\n    }\n    head = ImputeNode.makeFromEncoding(head, model) || head;\n    head = StackNode.makeFromEncoding(head, model) || head;\n  }\n\n  // output node for marks\n  const mainName = model.getName(MAIN);\n  const main = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);\n  outputNodes[mainName] = main;\n  head = main;\n\n  // add facet marker\n  let facetRoot = null;\n  if (isFacetModel(model)) {\n    const facetName = model.getName('facet');\n\n    // Derive new sort index field for facet's sort array\n    head = CalculateNode.parseAllForSortIndex(head, model);\n\n    // Derive new aggregate (via window) for facet's sort field\n    // TODO: use JoinAggregate once we have it\n    // augment data source with new fields for crossed facet\n    head = WindowTransformNode.makeFromFacet(head, model.facet) || head;\n\n    facetRoot = new FacetNode(head, model, facetName, main.getSource());\n    outputNodes[facetName] = facetRoot;\n    head = facetRoot;\n  }\n\n  return {\n    ...model.component.data,\n    outputNodes,\n    outputNodeRefCounts,\n    raw,\n    main,\n    facetRoot,\n    ancestorParse\n  };\n}\n","import {SampleTransform as VgSampleTransform} from 'vega';\nimport {SampleTransform} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\n/**\n * A class for the sample transform nodes\n */\nexport class SampleTransformNode extends TransformNode {\n  public clone() {\n    return new SampleTransformNode(this.parent, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private transform: SampleTransform) {\n    super(parent);\n  }\n\n  public hash() {\n    return `SampleTransform ${hash(this.transform)}`;\n  }\n  public assemble(): VgSampleTransform {\n    return {\n      type: 'sample',\n      size: this.transform.sample\n    };\n  }\n}\n","import {Data, DataFormatType, isInlineData, isNamedData, isUrlData} from '../../data';\nimport {contains, hash} from '../../util';\nimport {VgData} from '../../vega.schema';\nimport {DataFlowNode} from './dataflow';\n\nexport class SourceNode extends DataFlowNode {\n  private _data: Partial<VgData>;\n\n  private _name: string;\n\n  private _hash: string | number;\n\n  constructor(data: Data) {\n    super(null); // source cannot have parent\n\n    data = data || {name: 'source'};\n\n    if (isInlineData(data)) {\n      this._data = {values: data.values};\n    } else if (isUrlData(data)) {\n      this._data = {url: data.url};\n\n      if (!data.format) {\n        data.format = {};\n      }\n\n      if (!data.format || !data.format.type) {\n        // Extract extension from URL using snippet from\n        // http://stackoverflow.com/questions/680929/how-to-extract-extension-from-filename-string-in-javascript\n        let defaultExtension = /(?:\\.([^.]+))?$/.exec(data.url)[1];\n        if (!contains(['json', 'csv', 'tsv', 'dsv', 'topojson'], defaultExtension)) {\n          defaultExtension = 'json';\n        }\n\n        // defaultExtension has type string but we ensure that it is DataFormatType above\n        data.format.type = defaultExtension as DataFormatType;\n      }\n    } else if (isNamedData(data)) {\n      this._data = {};\n    }\n\n    // any dataset can be named\n    if (data.name) {\n      this._name = data.name;\n    }\n\n    if (data.format) {\n      const {parse = null, ...format} = data.format;\n      this._data.format = format;\n    }\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  public hasName(): boolean {\n    return !!this._name;\n  }\n\n  get dataName() {\n    return this._name;\n  }\n\n  set dataName(name: string) {\n    this._name = name;\n  }\n\n  set parent(parent: DataFlowNode) {\n    throw new Error('Source nodes have to be roots.');\n  }\n\n  public remove() {\n    throw new Error('Source nodes are roots and cannot be removed.');\n  }\n\n  /**\n   * Return a unique identifier for this data source.\n   */\n  public hash() {\n    if (isInlineData(this._data)) {\n      if (!this._hash) {\n        // Hashing can be expensive for large inline datasets.\n        this._hash = hash(this._data);\n      }\n      return this._hash;\n    } else if (isUrlData(this._data)) {\n      return hash([this._data.url, this._data.format]);\n    } else {\n      return this._name;\n    }\n  }\n\n  public assemble(): VgData {\n    return {\n      name: this._name,\n      ...this._data,\n      transform: []\n    };\n  }\n}\n","import {isArray, isString} from 'vega-util';\nimport {FieldDef, isFieldDef, vgField} from '../../fielddef';\nimport {StackOffset} from '../../stack';\nimport {StackTransform} from '../../transform';\nimport {duplicate, getFirstDefined, hash} from '../../util';\nimport {VgComparatorOrder, VgSort, VgTransform} from '../../vega.schema';\nimport {sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\nfunction getStackByFields(model: UnitModel): string[] {\n  return model.stack.stackBy.reduce(\n    (fields, by) => {\n      const fieldDef = by.fieldDef;\n\n      const _field = vgField(fieldDef);\n      if (_field) {\n        fields.push(_field);\n      }\n      return fields;\n    },\n    [] as string[]\n  );\n}\n\nexport interface StackComponent {\n  /**\n   * Faceted field.\n   */\n  facetby: string[];\n\n  dimensionFieldDef?: FieldDef<string>;\n\n  /**\n   * Stack measure's field. Used in makeFromEncoding.\n   */\n  stackField: string;\n\n  /**\n   * Level of detail fields for each level in the stacked charts such as color or detail.\n   * Used in makeFromEncoding.\n   */\n  stackby?: string[];\n\n  /**\n   * Field that determines order of levels in the stacked charts.\n   * Used in both but optional in transform.\n   */\n  sort: VgSort;\n\n  /** Mode for stacking marks.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether to impute the data before stacking. Used only in makeFromEncoding.\n   */\n  impute?: boolean;\n\n  /**\n   * The data fields to group by.\n   */\n  groupby?: string[];\n  /**\n   * Output field names of each stack field.\n   */\n  as: string[];\n}\n\nfunction isValidAsArray(as: string[] | string): as is string[] {\n  return isArray(as) && as.every(s => isString(s)) && as.length > 1;\n}\n\nexport class StackNode extends TransformNode {\n  private _stack: StackComponent;\n\n  public clone() {\n    return new StackNode(null, duplicate(this._stack));\n  }\n\n  constructor(parent: DataFlowNode, stack: StackComponent) {\n    super(parent);\n\n    this._stack = stack;\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, stackTransform: StackTransform) {\n    const {stack, groupby, as, offset = 'zero'} = stackTransform;\n\n    const sortFields: string[] = [];\n    const sortOrder: VgComparatorOrder[] = [];\n    if (stackTransform.sort !== undefined) {\n      for (const sortField of stackTransform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(getFirstDefined(sortField.order, 'ascending'));\n      }\n    }\n    const sort: VgSort = {\n      field: sortFields,\n      order: sortOrder\n    };\n    let normalizedAs: string[];\n    if (isValidAsArray(as)) {\n      normalizedAs = as;\n    } else if (isString(as)) {\n      normalizedAs = [as, as + '_end'];\n    } else {\n      normalizedAs = [stackTransform.stack + '_start', stackTransform.stack + '_end'];\n    }\n\n    return new StackNode(parent, {\n      stackField: stack,\n      groupby,\n      offset,\n      sort,\n      facetby: [],\n      as: normalizedAs\n    });\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: UnitModel) {\n    const stackProperties = model.stack;\n\n    if (!stackProperties) {\n      return null;\n    }\n\n    let dimensionFieldDef: FieldDef<string>;\n    if (stackProperties.groupbyChannel) {\n      dimensionFieldDef = model.fieldDef(stackProperties.groupbyChannel);\n    }\n\n    const stackby = getStackByFields(model);\n    const orderDef = model.encoding.order;\n\n    let sort: VgSort;\n    if (isArray(orderDef) || isFieldDef(orderDef)) {\n      sort = sortParams(orderDef);\n    } else {\n      // default = descending by stackFields\n      // FIXME is the default here correct for binned fields?\n      sort = stackby.reduce(\n        (s, field) => {\n          s.field.push(field);\n          s.order.push('descending');\n          return s;\n        },\n        {field: [], order: []}\n      );\n    }\n\n    return new StackNode(parent, {\n      dimensionFieldDef,\n      stackField: model.vgField(stackProperties.fieldChannel),\n      facetby: [],\n      stackby,\n      sort,\n      offset: stackProperties.offset,\n      impute: stackProperties.impute,\n      as: [\n        model.vgField(stackProperties.fieldChannel, {suffix: 'start', forAs: true}),\n        model.vgField(stackProperties.fieldChannel, {suffix: 'end', forAs: true})\n      ]\n    });\n  }\n\n  get stack(): StackComponent {\n    return this._stack;\n  }\n\n  public addDimensions(fields: string[]) {\n    this._stack.facetby = this._stack.facetby.concat(fields);\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    out[this._stack.stackField] = true;\n\n    this.getGroupbyFields().forEach(f => (out[f] = true));\n    this._stack.facetby.forEach(f => (out[f] = true));\n    const field = this._stack.sort.field;\n    isArray(field) ? field.forEach(f => (out[f] = true)) : (out[field] = true);\n\n    return out;\n  }\n\n  public producedFields() {\n    return this._stack.as.reduce((result, item) => {\n      result[item] = true;\n      return result;\n    }, {});\n  }\n\n  public hash() {\n    return `Stack ${hash(this._stack)}`;\n  }\n\n  private getGroupbyFields() {\n    const {dimensionFieldDef, impute, groupby} = this._stack;\n    if (dimensionFieldDef) {\n      if (dimensionFieldDef.bin) {\n        if (impute) {\n          // For binned group by field with impute, we calculate bin_mid\n          // as we cannot impute two fields simultaneously\n          return [vgField(dimensionFieldDef, {binSuffix: 'mid'})];\n        }\n        return [\n          // For binned group by field without impute, we need both bin (start) and bin_end\n          vgField(dimensionFieldDef, {}),\n          vgField(dimensionFieldDef, {binSuffix: 'end'})\n        ];\n      }\n      return [vgField(dimensionFieldDef)];\n    }\n    return groupby || [];\n  }\n\n  public assemble(): VgTransform[] {\n    const transform: VgTransform[] = [];\n    const {facetby, dimensionFieldDef, stackField: field, stackby, sort, offset, impute, as} = this._stack;\n\n    // Impute\n    if (impute && dimensionFieldDef) {\n      if (dimensionFieldDef.bin) {\n        // As we can only impute one field at a time, we need to calculate\n        // mid point for a binned field\n        transform.push({\n          type: 'formula',\n          expr:\n            '(' +\n            vgField(dimensionFieldDef, {expr: 'datum'}) +\n            '+' +\n            vgField(dimensionFieldDef, {expr: 'datum', binSuffix: 'end'}) +\n            ')/2',\n          as: vgField(dimensionFieldDef, {binSuffix: 'mid', forAs: true})\n        });\n      }\n\n      transform.push({\n        type: 'impute',\n        field,\n        groupby: stackby,\n        key: vgField(dimensionFieldDef, {binSuffix: 'mid'}),\n        method: 'value',\n        value: 0\n      });\n    }\n\n    // Stack\n    transform.push({\n      type: 'stack',\n      groupby: this.getGroupbyFields().concat(facetby),\n      field,\n      sort,\n      as,\n      offset\n    });\n\n    return transform;\n  }\n}\n","import {vgField} from '../../fielddef';\nimport {fieldExpr, TimeUnit} from '../../timeunit';\nimport {TimeUnitTransform} from '../../transform';\nimport {Dict, duplicate, hash, keys, vals} from '../../util';\nimport {VgFormulaTransform} from '../../vega.schema';\nimport {ModelWithField} from '../model';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\nexport interface TimeUnitComponent {\n  as: string;\n  timeUnit: TimeUnit;\n  field: string;\n}\n\nexport class TimeUnitNode extends TransformNode {\n  public clone() {\n    return new TimeUnitNode(null, duplicate(this.formula));\n  }\n\n  constructor(parent: DataFlowNode, private formula: Dict<TimeUnitComponent>) {\n    super(parent);\n  }\n\n  public static makeFromEncoding(parent: DataFlowNode, model: ModelWithField) {\n    const formula = model.reduceFieldDef(\n      (timeUnitComponent: TimeUnitComponent, fieldDef) => {\n        if (fieldDef.timeUnit) {\n          const f = vgField(fieldDef, {forAs: true});\n          timeUnitComponent[f] = {\n            as: f,\n            timeUnit: fieldDef.timeUnit,\n            field: fieldDef.field\n          };\n        }\n        return timeUnitComponent;\n      },\n      {} as Dict<TimeUnitComponent>\n    );\n\n    if (keys(formula).length === 0) {\n      return null;\n    }\n\n    return new TimeUnitNode(parent, formula);\n  }\n\n  public static makeFromTransform(parent: DataFlowNode, t: TimeUnitTransform) {\n    return new TimeUnitNode(parent, {\n      [t.field]: {\n        as: t.as,\n        timeUnit: t.timeUnit,\n        field: t.field\n      }\n    });\n  }\n\n  public merge(other: TimeUnitNode) {\n    this.formula = {...this.formula, ...other.formula};\n    other.remove();\n  }\n\n  public producedFields() {\n    const out = {};\n\n    vals(this.formula).forEach(f => {\n      out[f.as] = true;\n    });\n\n    return out;\n  }\n\n  public dependentFields() {\n    const out = {};\n\n    vals(this.formula).forEach(f => {\n      out[f.field] = true;\n    });\n\n    return out;\n  }\n\n  public hash() {\n    return `TimeUnit ${hash(this.formula)}`;\n  }\n\n  public assemble() {\n    return vals(this.formula).map(c => {\n      return {\n        type: 'formula',\n        as: c.as,\n        expr: fieldExpr(c.timeUnit, c.field)\n      } as VgFormulaTransform;\n    });\n  }\n}\n","import {AggregateOp} from 'vega';\nimport {FacetMapping} from '../../facet';\nimport {vgField} from '../../fielddef';\nimport {isSortField} from '../../sort';\nimport {WindowFieldDef, WindowOnlyOp, WindowTransform} from '../../transform';\nimport {duplicate, hash} from '../../util';\nimport {VgComparator, VgComparatorOrder, VgWindowTransform} from '../../vega.schema';\nimport {facetSortFieldName} from '../facet';\nimport {DataFlowNode, TransformNode} from './dataflow';\n\n/**\n * A class for the window transform nodes\n */\nexport class WindowTransformNode extends TransformNode {\n  public static makeFromFacet(parent: DataFlowNode, facet: FacetMapping<string>): WindowTransformNode {\n    const {row, column} = facet;\n    if (row && column) {\n      let newParent = null;\n      // only need to make one for crossed facet\n      for (const fieldDef of [row, column]) {\n        if (isSortField(fieldDef.sort)) {\n          const {field, op} = fieldDef.sort;\n          parent = newParent = new WindowTransformNode(parent, {\n            window: [\n              {\n                op,\n                field,\n                as: facetSortFieldName(fieldDef, fieldDef.sort, {forAs: true})\n              }\n            ],\n            groupby: [vgField(fieldDef)],\n            frame: [null, null]\n          });\n        }\n      }\n      return newParent;\n    }\n    return null;\n  }\n\n  public clone() {\n    return new WindowTransformNode(this.parent, duplicate(this.transform));\n  }\n\n  constructor(parent: DataFlowNode, private transform: WindowTransform) {\n    super(parent);\n  }\n\n  public producedFields() {\n    const out = {};\n    this.transform.window.forEach(windowFieldDef => {\n      out[this.getDefaultName(windowFieldDef)] = true;\n    });\n\n    return out;\n  }\n\n  private getDefaultName(windowFieldDef: WindowFieldDef): string {\n    return windowFieldDef.as || vgField(windowFieldDef);\n  }\n\n  public hash() {\n    return `WindowTransform ${hash(this.transform)}`;\n  }\n\n  public assemble(): VgWindowTransform {\n    const fields: string[] = [];\n    const ops: (AggregateOp | WindowOnlyOp)[] = [];\n    const as = [];\n    const params = [];\n    for (const window of this.transform.window) {\n      ops.push(window.op);\n      as.push(this.getDefaultName(window));\n      params.push(window.param === undefined ? null : window.param);\n      fields.push(window.field === undefined ? null : window.field);\n    }\n\n    const frame = this.transform.frame;\n    const groupby = this.transform.groupby;\n    const sortFields: string[] = [];\n    const sortOrder: VgComparatorOrder[] = [];\n    if (this.transform.sort !== undefined) {\n      for (const sortField of this.transform.sort) {\n        sortFields.push(sortField.field);\n        sortOrder.push(sortField.order || 'ascending');\n      }\n    }\n    const sort: VgComparator = {\n      field: sortFields,\n      order: sortOrder\n    };\n    const ignorePeers = this.transform.ignorePeers;\n\n    const result: VgWindowTransform = {\n      type: 'window',\n      params,\n      as,\n      ops,\n      fields,\n      sort\n    };\n\n    if (ignorePeers !== undefined) {\n      result.ignorePeers = ignorePeers;\n    }\n\n    if (groupby !== undefined) {\n      result.groupby = groupby;\n    }\n\n    if (frame !== undefined) {\n      result.frame = frame;\n    }\n\n    return result;\n  }\n}\n","import {AggregateOp} from 'vega';\nimport {isArray} from 'vega-util';\nimport {Channel, COLUMN, ROW, ScaleChannel} from '../channel';\nimport {Config} from '../config';\nimport {reduce} from '../encoding';\nimport {FacetFieldDef, FacetMapping} from '../facet';\nimport {FieldDef, FieldRefOption, normalize, title as fieldDefTitle, vgField} from '../fielddef';\nimport * as log from '../log';\nimport {hasDiscreteDomain} from '../scale';\nimport {EncodingSortField, isSortField, SortOrder} from '../sort';\nimport {NormalizedFacetSpec} from '../spec';\nimport {contains} from '../util';\nimport {isVgRangeStep, VgData, VgLayout, VgMarkGroup, VgSignal} from '../vega.schema';\nimport {assembleAxis} from './axis/assemble';\nimport {buildModel} from './buildmodel';\nimport {assembleFacetData} from './data/assemble';\nimport {sortArrayIndexField} from './data/calculate';\nimport {parseData} from './data/parse';\nimport {getHeaderType, HeaderChannel, HeaderComponent} from './header/index';\nimport {parseChildrenLayoutSize} from './layoutsize/parse';\nimport {Model, ModelWithField} from './model';\nimport {RepeaterValue, replaceRepeaterInFacet} from './repeater';\nimport {parseGuideResolve} from './resolve';\nimport {assembleDomain, getFieldFromDomain} from './scale/domain';\nimport {assembleFacetSignals} from './selection/selection';\n\nexport function facetSortFieldName(\n  fieldDef: FacetFieldDef<string>,\n  sort: EncodingSortField<string>,\n  opt?: FieldRefOption\n) {\n  return vgField(sort, {suffix: `by_${vgField(fieldDef)}`, ...(opt || {})});\n}\n\nexport class FacetModel extends ModelWithField {\n  public readonly type: 'facet' = 'facet';\n  public readonly facet: FacetMapping<string>;\n\n  public readonly child: Model;\n\n  public readonly children: Model[];\n\n  constructor(\n    spec: NormalizedFacetSpec,\n    parent: Model,\n    parentGivenName: string,\n    repeater: RepeaterValue,\n    config: Config\n  ) {\n    super(spec, parent, parentGivenName, config, repeater, spec.resolve);\n\n    this.child = buildModel(spec.spec, this, this.getName('child'), undefined, repeater, config, false);\n    this.children = [this.child];\n\n    const facet: FacetMapping<string> = replaceRepeaterInFacet(spec.facet, repeater);\n\n    this.facet = this.initFacet(facet);\n  }\n\n  private initFacet(facet: FacetMapping<string>): FacetMapping<string> {\n    // clone to prevent side effect to the original spec\n    return reduce(\n      facet,\n      (normalizedFacet, fieldDef: FieldDef<string>, channel: Channel) => {\n        if (!contains([ROW, COLUMN], channel)) {\n          // Drop unsupported channel\n          log.warn(log.message.incompatibleChannel(channel, 'facet'));\n          return normalizedFacet;\n        }\n\n        if (fieldDef.field === undefined) {\n          log.warn(log.message.emptyFieldDef(fieldDef, channel));\n          return normalizedFacet;\n        }\n\n        // Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n        normalizedFacet[channel] = normalize(fieldDef, channel);\n        return normalizedFacet;\n      },\n      {}\n    );\n  }\n\n  public channelHasField(channel: Channel): boolean {\n    return !!this.facet[channel];\n  }\n\n  public fieldDef(channel: Channel): FieldDef<string> {\n    return this.facet[channel];\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    this.child.parseData();\n  }\n\n  public parseLayoutSize() {\n    parseChildrenLayoutSize(this);\n  }\n\n  public parseSelection() {\n    // As a facet has a single child, the selection components are the same.\n    // The child maintains its selections to assemble signals, which remain\n    // within its unit.\n    this.child.parseSelection();\n    this.component.selection = this.child.component.selection;\n  }\n\n  public parseMarkGroup() {\n    this.child.parseMarkGroup();\n  }\n\n  public parseAxisAndHeader() {\n    this.child.parseAxisAndHeader();\n\n    this.parseHeader('column');\n    this.parseHeader('row');\n\n    this.mergeChildAxis('x');\n    this.mergeChildAxis('y');\n  }\n\n  private parseHeader(channel: HeaderChannel) {\n    if (this.channelHasField(channel)) {\n      const fieldDef = this.facet[channel];\n      let title = fieldDefTitle(fieldDef, this.config, {allowDisabling: true});\n\n      if (this.child.component.layoutHeaders[channel].title) {\n        // merge title with child to produce \"Title / Subtitle / Sub-subtitle\"\n        title += ' / ' + this.child.component.layoutHeaders[channel].title;\n        this.child.component.layoutHeaders[channel].title = null;\n      }\n\n      this.component.layoutHeaders[channel] = {\n        title,\n        facetFieldDef: fieldDef,\n        // TODO: support adding label to footer as well\n        header: [this.makeHeaderComponent(channel, true)]\n      };\n    }\n  }\n\n  private makeHeaderComponent(channel: HeaderChannel, labels: boolean): HeaderComponent {\n    const sizeType = channel === 'row' ? 'height' : 'width';\n\n    return {\n      labels,\n      sizeSignal: this.child.component.layoutSize.get(sizeType) ? this.child.getSizeSignalRef(sizeType) : undefined,\n      axes: []\n    };\n  }\n\n  private mergeChildAxis(channel: 'x' | 'y') {\n    const {child} = this;\n    if (child.component.axes[channel]) {\n      const {layoutHeaders, resolve} = this.component;\n      resolve.axis[channel] = parseGuideResolve(resolve, channel);\n\n      if (resolve.axis[channel] === 'shared') {\n        // For shared axis, move the axes to facet's header or footer\n        const headerChannel = channel === 'x' ? 'column' : 'row';\n\n        const layoutHeader = layoutHeaders[headerChannel];\n        for (const axisComponent of child.component.axes[channel]) {\n          const headerType = getHeaderType(axisComponent.get('orient'));\n          layoutHeader[headerType] = layoutHeader[headerType] || [this.makeHeaderComponent(headerChannel, false)];\n\n          const mainAxis = assembleAxis(axisComponent, 'main', this.config, {header: true});\n          // LayoutHeader no longer keep track of property precedence, thus let's combine.\n          layoutHeader[headerType][0].axes.push(mainAxis);\n          axisComponent.mainExtracted = true;\n        }\n      } else {\n        // Otherwise do nothing for independent axes\n      }\n    }\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return this.child.assembleSelectionTopLevelSignals(signals);\n  }\n\n  public assembleSelectionSignals(): VgSignal[] {\n    this.child.assembleSelectionSignals();\n    return [];\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return this.child.assembleSelectionData(data);\n  }\n\n  private getHeaderLayoutMixins(): VgLayout {\n    const layoutMixins: VgLayout = {};\n\n    ['row', 'column'].forEach((channel: 'row' | 'column') => {\n      ['header', 'footer'].forEach((headerType: 'header' | 'footer') => {\n        const layoutHeaderComponent = this.component.layoutHeaders[channel];\n        const headerComponent = layoutHeaderComponent[headerType];\n        if (headerComponent && headerComponent[0]) {\n          // set header/footerBand\n          const sizeType = channel === 'row' ? 'height' : 'width';\n          const bandType = headerType === 'header' ? 'headerBand' : 'footerBand';\n          if (!this.child.component.layoutSize.get(sizeType)) {\n            // If facet child does not have size signal, then apply headerBand\n            layoutMixins[bandType] = layoutMixins[bandType] || {};\n            layoutMixins[bandType][channel] = 0.5;\n          }\n\n          if (layoutHeaderComponent.title) {\n            layoutMixins.offset = layoutMixins.offset || {};\n            layoutMixins.offset[channel === 'row' ? 'rowTitle' : 'columnTitle'] = 10;\n          }\n        }\n      });\n    });\n    return layoutMixins;\n  }\n\n  protected assembleDefaultLayout(): VgLayout {\n    const columns = this.channelHasField('column') ? this.columnDistinctSignal() : 1;\n\n    // TODO: determine default align based on shared / independent scales\n\n    return {\n      ...this.getHeaderLayoutMixins(),\n\n      columns,\n      bounds: 'full',\n      align: 'all'\n    };\n  }\n\n  public assembleLayoutSignals(): VgSignal[] {\n    // FIXME(https://github.com/vega/vega-lite/issues/1193): this can be incorrect if we have independent scales.\n    return this.child.assembleLayoutSignals();\n  }\n\n  private columnDistinctSignal() {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // For nested facet, we will add columns to group mark instead\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return undefined;\n    } else {\n      // In facetNode.assemble(), the name is always this.getName('column') + '_layout'.\n      const facetLayoutDataName = this.getName('column_domain');\n      return {signal: `length(data('${facetLayoutDataName}'))`};\n    }\n  }\n\n  public assembleGroup(signals: VgSignal[]) {\n    if (this.parent && this.parent instanceof FacetModel) {\n      // Provide number of columns for layout.\n      // See discussion in https://github.com/vega/vega/issues/952\n      // and https://github.com/vega/vega-view/releases/tag/v1.2.6\n      return {\n        ...(this.channelHasField('column')\n          ? {\n              encode: {\n                update: {\n                  // TODO(https://github.com/vega/vega-lite/issues/2759):\n                  // Correct the signal for facet of concat of facet_column\n                  columns: {field: vgField(this.facet.column, {prefix: 'distinct'})}\n                }\n              }\n            }\n          : {}),\n        ...super.assembleGroup(signals)\n      };\n    }\n    return super.assembleGroup(signals);\n  }\n\n  /**\n   * Aggregate cardinality for calculating size\n   */\n  private getCardinalityAggregateForChild() {\n    const fields: string[] = [];\n    const ops: AggregateOp[] = [];\n    const as: string[] = [];\n\n    if (this.child instanceof FacetModel) {\n      if (this.child.channelHasField('column')) {\n        const field = vgField(this.child.facet.column);\n        fields.push(field);\n        ops.push('distinct');\n        as.push(`distinct_${field}`);\n      }\n    } else {\n      for (const channel of ['x', 'y'] as ScaleChannel[]) {\n        const childScaleComponent = this.child.component.scales[channel];\n        if (childScaleComponent && !childScaleComponent.merged) {\n          const type = childScaleComponent.get('type');\n          const range = childScaleComponent.get('range');\n\n          if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n            const domain = assembleDomain(this.child, channel);\n            const field = getFieldFromDomain(domain);\n            if (field) {\n              fields.push(field);\n              ops.push('distinct');\n              as.push(`distinct_${field}`);\n            } else {\n              log.warn('Unknown field for ${channel}.  Cannot calculate view size.');\n            }\n          }\n        }\n      }\n    }\n    return {fields, ops, as};\n  }\n\n  private assembleFacet() {\n    const {name, data} = this.component.data.facetRoot;\n    const {row, column} = this.facet;\n    const {fields, ops, as} = this.getCardinalityAggregateForChild();\n    const groupby: string[] = [];\n\n    ['row', 'column'].forEach((channel: 'row' | 'column') => {\n      const fieldDef = this.facet[channel];\n      if (fieldDef) {\n        groupby.push(vgField(fieldDef));\n        const {sort} = fieldDef;\n        if (isSortField(sort)) {\n          const {field, op} = sort;\n          const outputName = facetSortFieldName(fieldDef, sort);\n          if (row && column) {\n            // For crossed facet, use pre-calculate field as it requires a different groupby\n            // For each calculated field, apply max and assign them to the same name as\n            // all values of the same group should be the same anyway.\n            fields.push(outputName);\n            ops.push('max');\n            as.push(outputName);\n          } else {\n            fields.push(field);\n            ops.push(op);\n            as.push(outputName);\n          }\n        } else if (isArray(sort)) {\n          const outputName = sortArrayIndexField(fieldDef, channel);\n          fields.push(outputName);\n          ops.push('max');\n          as.push(outputName);\n        }\n      }\n    });\n\n    const cross = !!row && !!column;\n\n    return {\n      name,\n      data,\n      groupby,\n      ...(cross || fields.length\n        ? {\n            aggregate: {\n              ...(cross ? {cross} : {}),\n              ...(fields.length ? {fields, ops, as} : {})\n            }\n          }\n        : {})\n    };\n  }\n\n  private headerSortFields(channel: 'row' | 'column'): string[] {\n    const {facet} = this;\n    const fieldDef = facet[channel];\n\n    if (fieldDef) {\n      if (isSortField(fieldDef.sort)) {\n        return [facetSortFieldName(fieldDef, fieldDef.sort, {expr: 'datum'})];\n      } else if (isArray(fieldDef.sort)) {\n        return [sortArrayIndexField(fieldDef, channel, {expr: 'datum'})];\n      }\n      return [vgField(fieldDef, {expr: 'datum'})];\n    }\n    return [];\n  }\n\n  private headerSortOrder(channel: 'row' | 'column'): SortOrder[] {\n    const {facet} = this;\n    const fieldDef = facet[channel];\n    if (fieldDef) {\n      const {sort} = fieldDef;\n      const order = (isSortField(sort) ? sort.order : !isArray(sort) && sort) || 'ascending';\n      return [order];\n    }\n    return [];\n  }\n\n  public assembleMarks(): VgMarkGroup[] {\n    const {child} = this;\n    const facetRoot = this.component.data.facetRoot;\n    const data = assembleFacetData(facetRoot);\n\n    // If we facet by two dimensions, we need to add a cross operator to the aggregation\n    // so that we create all groups\n    const layoutSizeEncodeEntry = child.assembleLayoutSize();\n\n    const title = child.assembleTitle();\n    const style = child.assembleGroupStyle();\n\n    const markGroup = {\n      name: this.getName('cell'),\n      type: 'group',\n      ...(title ? {title} : {}),\n      ...(style ? {style} : {}),\n      from: {\n        facet: this.assembleFacet()\n      },\n      // TODO: move this to after data\n      sort: {\n        field: [...this.headerSortFields('row'), ...this.headerSortFields('column')],\n        order: [...this.headerSortOrder('row'), ...this.headerSortOrder('column')]\n      },\n      ...(data.length > 0 ? {data: data} : {}),\n      ...(layoutSizeEncodeEntry ? {encode: {update: layoutSizeEncodeEntry}} : {}),\n      ...child.assembleGroup(assembleFacetSignals(this, []))\n    };\n\n    return [markGroup];\n  }\n\n  protected getMapping() {\n    return this.facet;\n  }\n}\n","/**\n * Utility for generating row / column headers\n */\nimport {Axis as VgAxis, AxisOrient, TitleConfig as VgTitleConfig} from 'vega';\nimport {isArray} from 'vega-util';\nimport {Config} from '../../config';\nimport {FacetFieldDef} from '../../facet';\nimport {vgField} from '../../fielddef';\nimport {\n  HEADER_LABEL_PROPERTIES,\n  HEADER_LABEL_PROPERTIES_MAP,\n  HEADER_TITLE_PROPERTIES,\n  HEADER_TITLE_PROPERTIES_MAP,\n  HeaderConfig\n} from '../../header';\nimport {isSortField} from '../../sort';\nimport {keys} from '../../util';\nimport {VgComparator, VgMarkGroup} from '../../vega.schema';\nimport {formatSignalRef} from '../common';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {Model} from '../model';\n\nexport type HeaderChannel = 'row' | 'column';\nexport const HEADER_CHANNELS: HeaderChannel[] = ['row', 'column'];\n\nexport type HeaderType = 'header' | 'footer';\nexport const HEADER_TYPES: HeaderType[] = ['header', 'footer'];\n\n/**\n * A component that represents all header, footers and title of a Vega group with layout directive.\n */\nexport interface LayoutHeaderComponent {\n  title?: string;\n\n  // TODO: repeat and concat can have multiple header / footer.\n  // Need to redesign this part a bit.\n\n  facetFieldDef?: FacetFieldDef<string>;\n\n  /**\n   * An array of header components for headers.\n   * For facet, there should be only one header component, which is data-driven.\n   * For repeat and concat, there can be multiple header components that explicitly list different axes.\n   */\n  header?: HeaderComponent[];\n\n  /**\n   * An array of header components for footers.\n   * For facet, there should be only one header component, which is data-driven.\n   * For repeat and concat, there can be multiple header components that explicitly list different axes.\n   */\n  footer?: HeaderComponent[];\n}\n\n/**\n * A component that represents one group of row/column-header/footer.\n */\nexport interface HeaderComponent {\n  labels: boolean;\n\n  sizeSignal: {signal: string};\n\n  axes: VgAxis[];\n}\n\nexport function getHeaderType(orient: AxisOrient) {\n  if (orient === 'top' || orient === 'left') {\n    return 'header';\n  }\n  return 'footer';\n}\n\nexport function getTitleGroup(model: Model, channel: HeaderChannel) {\n  const title = model.component.layoutHeaders[channel].title;\n  const config = model.config ? model.config : undefined;\n  const facetFieldDef = model.component.layoutHeaders[channel].facetFieldDef\n    ? model.component.layoutHeaders[channel].facetFieldDef\n    : undefined;\n\n  return {\n    name: `${channel}-title`,\n    type: 'group',\n    role: `${channel}-title`,\n    title: {\n      text: title,\n      offset: 10,\n      ...(channel === 'row' ? {orient: 'left'} : {}),\n      style: 'guide-title',\n      ...getHeaderProperties(config, facetFieldDef, HEADER_TITLE_PROPERTIES, HEADER_TITLE_PROPERTIES_MAP)\n    }\n  };\n}\n\nexport function getHeaderGroups(model: Model, channel: HeaderChannel): VgMarkGroup[] {\n  const layoutHeader = model.component.layoutHeaders[channel];\n  const groups = [];\n  for (const headerType of HEADER_TYPES) {\n    if (layoutHeader[headerType]) {\n      for (const headerCmpt of layoutHeader[headerType]) {\n        groups.push(getHeaderGroup(model, channel, headerType, layoutHeader, headerCmpt));\n      }\n    }\n  }\n  return groups;\n}\n\n// 0, (0,90), 90, (90, 180), 180, (180, 270), 270, (270, 0)\n\nexport function labelAlign(angle: number) {\n  // to keep angle in [0, 360)\n  angle = ((angle % 360) + 360) % 360;\n  if ((angle + 90) % 180 === 0) {\n    // for 90 and 270\n    return {}; // default center\n  } else if (angle < 90 || 270 < angle) {\n    return {align: {value: 'right'}};\n  } else if (135 <= angle && angle < 225) {\n    return {align: {value: 'left'}};\n  }\n  return {};\n}\n\nexport function labelBaseline(angle: number) {\n  // to keep angle in [0, 360)\n  angle = ((angle % 360) + 360) % 360;\n  if (45 <= angle && angle <= 135) {\n    return {baseline: 'top'};\n  }\n  return {baseline: 'middle'};\n}\n\nfunction getSort(facetFieldDef: FacetFieldDef<string>, channel: 'row' | 'column'): VgComparator {\n  const {sort} = facetFieldDef;\n  if (isSortField(sort)) {\n    return {\n      field: vgField(sort, {expr: 'datum'}),\n      order: sort.order || 'ascending'\n    };\n  } else if (isArray(sort)) {\n    return {\n      field: sortArrayIndexField(facetFieldDef, channel, {expr: 'datum'}),\n      order: 'ascending'\n    };\n  } else {\n    return {\n      field: vgField(facetFieldDef, {expr: 'datum'}),\n      order: sort || 'ascending'\n    };\n  }\n}\n\nexport function getHeaderGroup(\n  model: Model,\n  channel: HeaderChannel,\n  headerType: HeaderType,\n  layoutHeader: LayoutHeaderComponent,\n  headerCmpt: HeaderComponent\n) {\n  if (headerCmpt) {\n    let title = null;\n    const {facetFieldDef} = layoutHeader;\n    if (facetFieldDef && headerCmpt.labels) {\n      const {header = {}} = facetFieldDef;\n      const {format, labelAngle} = header;\n      const config = model.config ? model.config : undefined;\n\n      const update = {\n        ...labelAlign(labelAngle)\n      };\n\n      title = {\n        text: formatSignalRef(facetFieldDef, format, 'parent', model.config),\n        offset: 10,\n        ...(channel === 'row' ? {orient: 'left'} : {}),\n        style: 'guide-label',\n        ...(labelAngle !== undefined ? {angle: labelAngle} : {}),\n        ...labelBaseline(labelAngle),\n        ...getHeaderProperties(config, facetFieldDef, HEADER_LABEL_PROPERTIES, HEADER_LABEL_PROPERTIES_MAP),\n        ...(keys(update).length > 0 ? {encode: {update}} : {})\n      };\n    }\n\n    const axes = headerCmpt.axes;\n\n    const hasAxes = axes && axes.length > 0;\n    if (title || hasAxes) {\n      const sizeChannel = channel === 'row' ? 'height' : 'width';\n\n      return {\n        name: model.getName(`${channel}_${headerType}`),\n        type: 'group',\n        role: `${channel}-${headerType}`,\n        ...(layoutHeader.facetFieldDef\n          ? {\n              from: {data: model.getName(channel + '_domain')},\n              sort: getSort(facetFieldDef, channel)\n            }\n          : {}),\n        ...(title ? {title} : {}),\n        ...(headerCmpt.sizeSignal\n          ? {\n              encode: {\n                update: {\n                  [sizeChannel]: headerCmpt.sizeSignal\n                }\n              }\n            }\n          : {}),\n        ...(hasAxes ? {axes} : {})\n      };\n    }\n  }\n  return null;\n}\n\nexport function getHeaderProperties(\n  config: Config,\n  facetFieldDef: FacetFieldDef<string>,\n  properties: string[],\n  propertiesMap: {[k in keyof HeaderConfig]: keyof VgTitleConfig}\n) {\n  const props = {};\n  for (const prop of properties) {\n    if (config && config.header) {\n      if (config.header[prop]) {\n        props[propertiesMap[prop]] = config.header[prop];\n      }\n    }\n    if (facetFieldDef && facetFieldDef.header) {\n      if (facetFieldDef.header[prop]) {\n        props[propertiesMap[prop]] = facetFieldDef.header[prop];\n      }\n    }\n  }\n  return props;\n}\n","import {Legend as VgLegend} from 'vega';\nimport {Title as VgTitle} from 'vega';\nimport {Config} from '../config';\nimport * as log from '../log';\nimport {isLayerSpec, isUnitSpec, LayoutSizeMixins, NormalizedLayerSpec} from '../spec';\nimport {flatten, keys} from '../util';\nimport {VgData, VgLayout, VgSignal} from '../vega.schema';\nimport {parseLayerAxis} from './axis/parse';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {parseLayerLayoutSize} from './layoutsize/parse';\nimport {assembleLegends} from './legend/assemble';\nimport {Model} from './model';\nimport {RepeaterValue} from './repeater';\nimport {assembleLayerSelectionMarks} from './selection/selection';\nimport {UnitModel} from './unit';\n\nexport class LayerModel extends Model {\n  public readonly type: 'layer' = 'layer';\n\n  // HACK: This should be (LayerModel | UnitModel)[], but setting the correct type leads to weird error.\n  // So I'm just putting generic Model for now.\n  public readonly children: Model[];\n\n  constructor(\n    spec: NormalizedLayerSpec,\n    parent: Model,\n    parentGivenName: string,\n    parentGivenSize: LayoutSizeMixins,\n    repeater: RepeaterValue,\n    config: Config,\n    fit: boolean\n  ) {\n    super(spec, parent, parentGivenName, config, repeater, spec.resolve);\n\n    const layoutSize = {\n      ...parentGivenSize,\n      ...(spec.width ? {width: spec.width} : {}),\n      ...(spec.height ? {height: spec.height} : {})\n    };\n\n    this.initSize(layoutSize);\n\n    this.children = spec.layer.map((layer, i) => {\n      if (isLayerSpec(layer)) {\n        return new LayerModel(layer, this, this.getName('layer_' + i), layoutSize, repeater, config, fit);\n      }\n\n      if (isUnitSpec(layer)) {\n        return new UnitModel(layer, this, this.getName('layer_' + i), layoutSize, repeater, config, fit);\n      }\n\n      throw new Error(log.message.INVALID_SPEC);\n    });\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n    for (const child of this.children) {\n      child.parseData();\n    }\n  }\n\n  public parseLayoutSize() {\n    parseLayerLayoutSize(this);\n  }\n\n  public parseSelection() {\n    // Merge selections up the hierarchy so that they may be referenced\n    // across unit specs. Persist their definitions within each child\n    // to assemble signals which remain within output Vega unit groups.\n    this.component.selection = {};\n    for (const child of this.children) {\n      child.parseSelection();\n      keys(child.component.selection).forEach(key => {\n        this.component.selection[key] = child.component.selection[key];\n      });\n    }\n  }\n\n  public parseMarkGroup() {\n    for (const child of this.children) {\n      child.parseMarkGroup();\n    }\n  }\n\n  public parseAxisAndHeader() {\n    parseLayerAxis(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return this.children.reduce((sg, child) => child.assembleSelectionTopLevelSignals(sg), signals);\n  }\n\n  // TODO: Support same named selections across children.\n  public assembleSelectionSignals(): VgSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleSelectionSignals());\n    }, []);\n  }\n\n  public assembleLayoutSignals(): VgSignal[] {\n    return this.children.reduce((signals, child) => {\n      return signals.concat(child.assembleLayoutSignals());\n    }, assembleLayoutSignals(this));\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return this.children.reduce((db, child) => child.assembleSelectionData(db), data);\n  }\n\n  public assembleTitle(): VgTitle {\n    let title = super.assembleTitle();\n    if (title) {\n      return title;\n    }\n    // If title does not provide layer, look into children\n    for (const child of this.children) {\n      title = child.assembleTitle();\n      if (title) {\n        return title;\n      }\n    }\n    return undefined;\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleMarks(): any[] {\n    return assembleLayerSelectionMarks(\n      this,\n      flatten(\n        this.children.map(child => {\n          return child.assembleMarks();\n        })\n      )\n    );\n  }\n\n  public assembleLegends(): VgLegend[] {\n    return this.children.reduce((legends, child) => {\n      return legends.concat(child.assembleLegends());\n    }, assembleLegends(this));\n  }\n}\n","import {hasDiscreteDomain} from '../../scale';\nimport {getFirstDefined} from '../../util';\nimport {isVgRangeStep, VgRangeStep, VgSignal} from '../../vega.schema';\nimport {isFacetModel, Model} from '../model';\nimport {ScaleComponent} from '../scale/component';\n\nexport function assembleLayoutSignals(model: Model): VgSignal[] {\n  return [].concat(sizeSignals(model, 'width'), sizeSignals(model, 'height'));\n}\n\nexport function sizeSignals(model: Model, sizeType: 'width' | 'height'): VgSignal[] {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const size = model.component.layoutSize.get(sizeType);\n  if (!size || size === 'merged') {\n    return [];\n  }\n\n  // Read size signal name from name map, just in case it is the top-level size signal that got renamed.\n  const name = model.getSizeSignalRef(sizeType).signal;\n\n  if (size === 'range-step') {\n    const scaleComponent = model.getScaleComponent(channel);\n\n    if (scaleComponent) {\n      const type = scaleComponent.get('type');\n      const range = scaleComponent.get('range');\n\n      if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n        const scaleName = model.scaleName(channel);\n\n        if (isFacetModel(model.parent)) {\n          // If parent is facet and this is an independent scale, return only signal signal\n          // as the width/height will be calculated using the cardinality from\n          // facet's aggregate rather than reading from scale domain\n          const parentResolve = model.parent.component.resolve;\n          if (parentResolve.scale[channel] === 'independent') {\n            return [stepSignal(scaleName, range)];\n          }\n        }\n\n        return [\n          stepSignal(scaleName, range),\n          {\n            name,\n            update: sizeExpr(scaleName, scaleComponent, `domain('${scaleName}').length`)\n          }\n        ];\n      }\n    }\n    /* istanbul ignore next: Condition should not happen -- only for warning in development. */\n    throw new Error('layout size is range step although there is no rangeStep.');\n  } else {\n    return [\n      {\n        name,\n        value: size\n      }\n    ];\n  }\n}\n\nfunction stepSignal(scaleName: string, range: VgRangeStep): VgSignal {\n  return {\n    name: scaleName + '_step',\n    value: range.step\n  };\n}\n\nexport function sizeExpr(scaleName: string, scaleComponent: ScaleComponent, cardinality: string) {\n  const type = scaleComponent.get('type');\n  const padding = scaleComponent.get('padding');\n  const paddingOuter = getFirstDefined(scaleComponent.get('paddingOuter'), padding);\n\n  let paddingInner = scaleComponent.get('paddingInner');\n  paddingInner =\n    type === 'band'\n      ? // only band has real paddingInner\n        paddingInner !== undefined\n        ? paddingInner\n        : padding\n      : // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,\n        // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.\n        1;\n  return `bandspace(${cardinality}, ${paddingInner}, ${paddingOuter}) * ${scaleName}_step`;\n}\n","import {defaultScaleConfig, hasDiscreteDomain} from '../../scale';\nimport {isVgRangeStep} from '../../vega.schema';\nimport {ConcatModel} from '../concat';\nimport {Model} from '../model';\nimport {Explicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {LayoutSize, LayoutSizeIndex} from './component';\n\nexport function parseLayerLayoutSize(model: Model) {\n  parseChildrenLayoutSize(model);\n\n  const layoutSizeCmpt = model.component.layoutSize;\n  layoutSizeCmpt.setWithExplicit('width', parseNonUnitLayoutSizeForChannel(model, 'width'));\n  layoutSizeCmpt.setWithExplicit('height', parseNonUnitLayoutSizeForChannel(model, 'height'));\n}\n\nexport const parseRepeatLayoutSize = parseLayerLayoutSize;\n\nexport function parseConcatLayoutSize(model: ConcatModel) {\n  parseChildrenLayoutSize(model);\n  const layoutSizeCmpt = model.component.layoutSize;\n\n  const sizeTypeToMerge = model.isVConcat ? 'width' : 'height';\n  layoutSizeCmpt.setWithExplicit(sizeTypeToMerge, parseNonUnitLayoutSizeForChannel(model, sizeTypeToMerge));\n}\n\nexport function parseChildrenLayoutSize(model: Model) {\n  for (const child of model.children) {\n    child.parseLayoutSize();\n  }\n}\n\nfunction parseNonUnitLayoutSizeForChannel(model: Model, sizeType: 'width' | 'height'): Explicit<LayoutSize> {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const resolve = model.component.resolve;\n\n  let mergedSize: Explicit<LayoutSize>;\n  // Try to merge layout size\n  for (const child of model.children) {\n    const childSize = child.component.layoutSize.getWithExplicit(sizeType);\n    const scaleResolve = resolve.scale[channel];\n    if (scaleResolve === 'independent' && childSize.value === 'range-step') {\n      // Do not merge independent scales with range-step as their size depends\n      // on the scale domains, which can be different between scales.\n      mergedSize = undefined;\n      break;\n    }\n\n    if (mergedSize) {\n      if (scaleResolve === 'independent' && mergedSize.value !== childSize.value) {\n        // For independent scale, only merge if all the sizes are the same.\n        // If the values are different, abandon the merge!\n        mergedSize = undefined;\n        break;\n      }\n      mergedSize = mergeValuesWithExplicit<LayoutSizeIndex, LayoutSize>(mergedSize, childSize, sizeType, '');\n    } else {\n      mergedSize = childSize;\n    }\n  }\n\n  if (mergedSize) {\n    // If merged, rename size and set size of all children.\n    for (const child of model.children) {\n      model.renameLayoutSize(child.getName(sizeType), model.getName(sizeType));\n      child.component.layoutSize.set(sizeType, 'merged', false);\n    }\n    return mergedSize;\n  } else {\n    // Otherwise, there is no merged size.\n    return {\n      explicit: false,\n      value: undefined\n    };\n  }\n}\n\nexport function parseUnitLayoutSize(model: UnitModel) {\n  const layoutSizeComponent = model.component.layoutSize;\n  if (!layoutSizeComponent.explicit.width) {\n    const width = defaultUnitSize(model, 'width');\n    layoutSizeComponent.set('width', width, false);\n  }\n\n  if (!layoutSizeComponent.explicit.height) {\n    const height = defaultUnitSize(model, 'height');\n    layoutSizeComponent.set('height', height, false);\n  }\n}\n\nfunction defaultUnitSize(model: UnitModel, sizeType: 'width' | 'height'): LayoutSize {\n  const channel = sizeType === 'width' ? 'x' : 'y';\n  const config = model.config;\n  const scaleComponent = model.getScaleComponent(channel);\n\n  if (scaleComponent) {\n    const scaleType = scaleComponent.get('type');\n    const range = scaleComponent.get('range');\n\n    if (hasDiscreteDomain(scaleType) && isVgRangeStep(range)) {\n      // For discrete domain with range.step, use dynamic width/height\n      return 'range-step';\n    } else {\n      return config.view[sizeType];\n    }\n  } else if (model.hasProjection) {\n    return config.view[sizeType];\n  } else {\n    // No scale - set default size\n    if (sizeType === 'width' && model.mark === 'text') {\n      // width for text mark without x-field is a bit wider than typical range step\n      return config.scale.textXRangeStep;\n    }\n\n    // Set width/height equal to rangeStep config or if rangeStep is null, use value from default scale config.\n    return config.scale.rangeStep || defaultScaleConfig.rangeStep;\n  }\n}\n","import {Legend as VgLegend} from 'vega';\nimport {flatten, keys, stringify, vals} from '../../util';\nimport {Model} from '../model';\nimport {LegendComponent} from './component';\nimport {mergeLegendComponent} from './parse';\n\nexport function assembleLegends(model: Model): VgLegend[] {\n  const legendComponentIndex = model.component.legends;\n  const legendByDomain: {[domainHash: string]: LegendComponent[]} = {};\n\n  for (const channel of keys(legendComponentIndex)) {\n    const scaleComponent = model.getScaleComponent(channel);\n    const domainHash = stringify(scaleComponent.domains);\n    if (legendByDomain[domainHash]) {\n      for (const mergedLegendComponent of legendByDomain[domainHash]) {\n        const merged = mergeLegendComponent(mergedLegendComponent, legendComponentIndex[channel]);\n        if (!merged) {\n          // If cannot merge, need to add this legend separately\n          legendByDomain[domainHash].push(legendComponentIndex[channel]);\n        }\n      }\n    } else {\n      legendByDomain[domainHash] = [legendComponentIndex[channel].clone()];\n    }\n  }\n\n  return flatten(vals(legendByDomain)).map((legendCmpt: LegendComponent) => legendCmpt.combine());\n}\n","import {Legend as VgLegend} from 'vega';\nimport {NonPositionScaleChannel} from '../../channel';\nimport {Legend} from '../../legend';\nimport {Split} from '../split';\n\nexport class LegendComponent extends Split<VgLegend> {}\n\n// Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\nexport type LegendComponentIndex = {[P in NonPositionScaleChannel]?: LegendComponent};\n\nexport type LegendIndex = {[P in NonPositionScaleChannel]?: Legend};\n","import {SymbolEncodeEntry} from 'vega';\nimport {isArray} from 'vega-util';\nimport {Channel, COLOR, NonPositionScaleChannel, OPACITY, SHAPE} from '../../channel';\nimport {\n  Conditional,\n  FieldDef,\n  FieldDefWithCondition,\n  hasConditionalValueDef,\n  isTimeFieldDef,\n  isValueDef,\n  MarkPropFieldDef,\n  ValueDef,\n  ValueDefWithCondition\n} from '../../fielddef';\nimport {AREA, BAR, CIRCLE, FILL_STROKE_CONFIG, GEOSHAPE, LINE, POINT, SQUARE, TEXT, TICK} from '../../mark';\nimport {ScaleType} from '../../scale';\nimport {getFirstDefined, keys} from '../../util';\nimport {applyMarkConfig, timeFormatExpression} from '../common';\nimport * as mixins from '../mark/mixins';\nimport {UnitModel} from '../unit';\nimport {LegendComponent} from './component';\n\nexport function symbols(\n  fieldDef: FieldDef<string>,\n  symbolsSpec: any,\n  model: UnitModel,\n  channel: Channel,\n  legendCmp: LegendComponent\n): SymbolEncodeEntry {\n  if (legendCmp.get('type') === 'gradient') {\n    return undefined;\n  }\n\n  let out = {\n    ...applyMarkConfig({}, model, FILL_STROKE_CONFIG),\n    ...mixins.color(model)\n  } as SymbolEncodeEntry; // FIXME: remove this when VgEncodeEntry is compatible with SymbolEncodeEntry\n\n  switch (model.mark) {\n    case BAR:\n    case TICK:\n    case TEXT:\n      out.shape = {value: 'square'};\n      break;\n    case CIRCLE:\n    case SQUARE:\n      out.shape = {value: model.mark};\n      break;\n    case POINT:\n    case LINE:\n    case GEOSHAPE:\n    case AREA:\n      // use default circle\n      break;\n  }\n\n  const {markDef, encoding} = model;\n  const filled = markDef.filled;\n\n  const opacity = getMaxValue(encoding.opacity) || markDef.opacity;\n\n  if (out.fill) {\n    // for fill legend, we don't want any fill in symbol\n    if (channel === 'fill' || (filled && channel === COLOR)) {\n      delete out.fill;\n    } else {\n      if (out.fill['field']) {\n        // For others, set fill to some opaque value (or nothing if a color is already set)\n        if (legendCmp.get('symbolFillColor')) {\n          delete out.fill;\n        } else {\n          out.fill = {value: 'black'};\n          out.fillOpacity = {value: opacity || 1};\n        }\n      } else if (isArray(out.fill)) {\n        const fill =\n          (getFirstConditionValue(encoding.fill || encoding.color) as string) ||\n          markDef.fill ||\n          (filled && markDef.color);\n        if (fill) {\n          out.fill = {value: fill};\n        }\n      }\n    }\n  }\n\n  if (out.stroke) {\n    if (channel === 'stroke' || (!filled && channel === COLOR)) {\n      delete out.stroke;\n    } else {\n      if (out.stroke['field']) {\n        // For others, remove stroke field\n        delete out.stroke;\n      } else if (isArray(out.stroke)) {\n        const stroke = getFirstDefined(\n          getFirstConditionValue(encoding.stroke || encoding.color) as string,\n          markDef.stroke,\n          filled ? markDef.color : undefined\n        );\n        if (stroke) {\n          out.stroke = {value: stroke};\n        }\n      }\n    }\n  }\n\n  if (out.fill && out.fill['value'] !== 'transparent' && !out.stroke) {\n    // for non color channel's legend, we need to override symbol stroke config from Vega config\n    out.stroke = {value: 'transparent'};\n  }\n\n  if (channel !== SHAPE) {\n    const shape = (getFirstConditionValue(encoding.shape) as string) || markDef.shape;\n    if (shape) {\n      out.shape = {value: shape};\n    }\n  }\n\n  if (channel !== OPACITY) {\n    if (opacity) {\n      // only apply opacity if it is neither zero or undefined\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...symbolsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function gradient(\n  fieldDef: FieldDef<string>,\n  gradientSpec: any,\n  model: UnitModel,\n  channel: Channel,\n  legendCmp: LegendComponent\n) {\n  let out: SymbolEncodeEntry = {};\n\n  if (legendCmp.get('type') === 'gradient') {\n    const opacity = getMaxValue(model.encoding.opacity) || model.markDef.opacity;\n    if (opacity) {\n      // only apply opacity if it is neither zero or undefined\n      out.opacity = {value: opacity};\n    }\n  }\n\n  out = {...out, ...gradientSpec};\n  return keys(out).length > 0 ? out : undefined;\n}\n\nexport function labels(\n  fieldDef: FieldDef<string>,\n  labelsSpec: any,\n  model: UnitModel,\n  channel: NonPositionScaleChannel,\n  legendCmp: LegendComponent\n) {\n  const legend = model.legend(channel);\n  const config = model.config;\n\n  let out: SymbolEncodeEntry = {};\n\n  if (isTimeFieldDef(fieldDef)) {\n    const isUTCScale = model.getScaleComponent(channel).get('type') === ScaleType.UTC;\n    const expr = timeFormatExpression(\n      'datum.value',\n      fieldDef.timeUnit,\n      legend.format,\n      config.legend.shortTimeLabels,\n      config.timeFormat,\n      isUTCScale\n    );\n    labelsSpec = {\n      ...(expr ? {text: {signal: expr}} : {}),\n      ...labelsSpec\n    };\n  }\n\n  out = {...out, ...labelsSpec};\n\n  return keys(out).length > 0 ? out : undefined;\n}\n\nfunction getMaxValue(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>\n) {\n  return getConditionValue(channelDef, (v: number, conditionalDef) => Math.max(v, conditionalDef.value as any));\n}\n\nfunction getFirstConditionValue(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>\n) {\n  return getConditionValue(channelDef, (v: number, conditionalDef) => {\n    return getFirstDefined(v, conditionalDef.value);\n  });\n}\n\nfunction getConditionValue<T>(\n  channelDef: FieldDefWithCondition<MarkPropFieldDef<string>> | ValueDefWithCondition<MarkPropFieldDef<string>>,\n  reducer: (val: T, conditionalDef: Conditional<ValueDef>) => T\n): T {\n  if (hasConditionalValueDef(channelDef)) {\n    return (isArray(channelDef.condition) ? channelDef.condition : [channelDef.condition]).reduce(\n      reducer,\n      channelDef.value as any\n    );\n  } else if (isValueDef(channelDef)) {\n    return channelDef.value as any;\n  }\n  return undefined;\n}\n","import {Legend as VgLegend, LegendEncode} from 'vega';\nimport {COLOR, FILL, NonPositionScaleChannel, OPACITY, SHAPE, SIZE, STROKE} from '../../channel';\nimport {FieldDef, isFieldDef, title as fieldDefTitle} from '../../fielddef';\nimport {Legend, LEGEND_PROPERTIES, VG_LEGEND_PROPERTIES} from '../../legend';\nimport {GEOJSON} from '../../type';\nimport {deleteNestedProperty, getFirstDefined, keys} from '../../util';\nimport {guideEncodeEntry, mergeTitleComponent, numberFormat} from '../common';\nimport {isUnitModel, Model} from '../model';\nimport {parseGuideResolve} from '../resolve';\nimport {defaultTieBreaker, Explicit, makeImplicit, mergeValuesWithExplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {LegendComponent, LegendComponentIndex} from './component';\nimport * as encode from './encode';\nimport * as properties from './properties';\n\nexport function parseLegend(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.legends = parseUnitLegend(model);\n  } else {\n    model.component.legends = parseNonUnitLegend(model);\n  }\n}\n\nfunction parseUnitLegend(model: UnitModel): LegendComponentIndex {\n  const {encoding} = model;\n  return [COLOR, FILL, STROKE, SIZE, SHAPE, OPACITY].reduce((legendComponent, channel) => {\n    const def = encoding[channel];\n    if (\n      model.legend(channel) &&\n      model.getScaleComponent(channel) &&\n      !(isFieldDef(def) && (channel === SHAPE && def.type === GEOJSON))\n    ) {\n      legendComponent[channel] = parseLegendForChannel(model, channel);\n    }\n    return legendComponent;\n  }, {});\n}\n\nfunction getLegendDefWithScale(model: UnitModel, channel: NonPositionScaleChannel): VgLegend {\n  // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels\n  switch (channel) {\n    case COLOR:\n      const scale = model.scaleName(COLOR);\n      return model.markDef.filled ? {fill: scale} : {stroke: scale};\n    case FILL:\n    case STROKE:\n    case SIZE:\n    case SHAPE:\n    case OPACITY:\n      return {[channel]: model.scaleName(channel)};\n  }\n}\n\nfunction isExplicit<T extends string | number | object | boolean>(\n  value: T,\n  property: keyof VgLegend,\n  legend: Legend,\n  fieldDef: FieldDef<string>\n) {\n  switch (property) {\n    case 'values':\n      // specified legend.values is already respected, but may get transformed.\n      return !!legend.values;\n    case 'title':\n      // title can be explicit if fieldDef.title is set\n      if (property === 'title' && value === fieldDef.title) {\n        return true;\n      }\n  }\n  // Otherwise, things are explicit if the returned value matches the specified property\n  return value === legend[property];\n}\n\nexport function parseLegendForChannel(model: UnitModel, channel: NonPositionScaleChannel): LegendComponent {\n  const fieldDef = model.fieldDef(channel);\n  const legend = model.legend(channel);\n\n  const legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));\n\n  for (const property of LEGEND_PROPERTIES) {\n    const value = getProperty(property, legend, channel, model);\n    if (value !== undefined) {\n      const explicit = isExplicit(value, property, legend, fieldDef);\n      if (explicit || model.config.legend[property] === undefined) {\n        legendCmpt.set(property, value, explicit);\n      }\n    }\n  }\n\n  const legendEncoding = legend.encoding || {};\n  const legendEncode = ['labels', 'legend', 'title', 'symbols', 'gradient'].reduce(\n    (e: LegendEncode, part) => {\n      const legendEncodingPart = guideEncodeEntry(legendEncoding[part] || {}, model);\n      const value = encode[part]\n        ? encode[part](fieldDef, legendEncodingPart, model, channel, legendCmpt) // apply rule\n        : legendEncodingPart; // no rule -- just default values\n      if (value !== undefined && keys(value).length > 0) {\n        e[part] = {update: value};\n      }\n      return e;\n    },\n    {} as LegendEncode\n  );\n\n  if (keys(legendEncode).length > 0) {\n    legendCmpt.set('encode', legendEncode, !!legend.encoding);\n  }\n\n  return legendCmpt;\n}\n\nfunction getProperty<K extends keyof VgLegend>(\n  property: K,\n  specifiedLegend: Legend,\n  channel: NonPositionScaleChannel,\n  model: UnitModel\n): VgLegend[K] {\n  const fieldDef = model.fieldDef(channel);\n\n  switch (property) {\n    case 'format':\n      // We don't include temporal field here as we apply format in encode block\n      return numberFormat(fieldDef, specifiedLegend.format, model.config);\n    case 'title':\n      return fieldDefTitle(fieldDef, model.config, {allowDisabling: true}) || undefined;\n\n    // TODO: enable when https://github.com/vega/vega/issues/1351 is fixed\n    // case 'clipHeight':\n    //   return getFirstDefined(specifiedLegend.clipHeight, properties.clipHeight(model.getScaleComponent(channel).get('type')));\n    case 'labelOverlap':\n      return getFirstDefined(\n        specifiedLegend.labelOverlap,\n        properties.labelOverlap(model.getScaleComponent(channel).get('type'))\n      );\n    case 'values':\n      return properties.values(specifiedLegend, fieldDef);\n  }\n\n  // Otherwise, return specified property.\n  return (specifiedLegend as VgLegend)[property];\n}\n\nfunction parseNonUnitLegend(model: Model) {\n  const {legends, resolve} = model.component;\n\n  for (const child of model.children) {\n    parseLegend(child);\n\n    keys(child.component.legends).forEach((channel: NonPositionScaleChannel) => {\n      resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);\n\n      if (resolve.legend[channel] === 'shared') {\n        // If the resolve says shared (and has not been overridden)\n        // We will try to merge and see if there is a conflict\n\n        legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);\n\n        if (!legends[channel]) {\n          // If merge returns nothing, there is a conflict so we cannot make the legend shared.\n          // Thus, mark legend as independent and remove the legend component.\n          resolve.legend[channel] = 'independent';\n          delete legends[channel];\n        }\n      }\n    });\n  }\n\n  keys(legends).forEach((channel: NonPositionScaleChannel) => {\n    for (const child of model.children) {\n      if (!child.component.legends[channel]) {\n        // skip if the child does not have a particular legend\n        continue;\n      }\n\n      if (resolve.legend[channel] === 'shared') {\n        // After merging shared legend, make sure to remove legend from child\n        delete child.component.legends[channel];\n      }\n    }\n  });\n  return legends;\n}\n\nexport function mergeLegendComponent(mergedLegend: LegendComponent, childLegend: LegendComponent): LegendComponent {\n  if (!mergedLegend) {\n    return childLegend.clone();\n  }\n  const mergedOrient = mergedLegend.getWithExplicit('orient');\n  const childOrient = childLegend.getWithExplicit('orient');\n\n  if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {\n    // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)\n    // Cannot merge due to inconsistent orient\n    return undefined;\n  }\n\n  let typeMerged = false;\n  // Otherwise, let's merge\n  for (const prop of VG_LEGEND_PROPERTIES) {\n    const mergedValueWithExplicit = mergeValuesWithExplicit<VgLegend, any>(\n      mergedLegend.getWithExplicit(prop),\n      childLegend.getWithExplicit(prop),\n      prop,\n      'legend',\n\n      // Tie breaker function\n      (v1: Explicit<any>, v2: Explicit<any>): any => {\n        switch (prop) {\n          case 'title':\n            return mergeTitleComponent(v1, v2);\n          case 'type':\n            // There are only two types. If we have different types, then prefer symbol over gradient.\n            typeMerged = true;\n            return makeImplicit('symbol');\n        }\n        return defaultTieBreaker<VgLegend, any>(v1, v2, prop, 'legend');\n      }\n    );\n    mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);\n  }\n  if (typeMerged) {\n    if (((mergedLegend.implicit || {}).encode || {}).gradient) {\n      deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);\n    }\n    if (((mergedLegend.explicit || {}).encode || {}).gradient) {\n      deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);\n    }\n  }\n\n  return mergedLegend;\n}\n","import {LabelOverlap} from 'vega';\nimport {FieldDef, valueArray} from '../../fielddef';\nimport {Legend} from '../../legend';\nimport {hasContinuousDomain, ScaleType} from '../../scale';\nimport {contains} from '../../util';\n\nexport function values(legend: Legend, fieldDef: FieldDef<string>) {\n  const vals = legend.values;\n\n  if (vals) {\n    return valueArray(fieldDef, vals);\n  }\n  return undefined;\n}\n\nexport function clipHeight(scaleType: ScaleType) {\n  if (hasContinuousDomain(scaleType)) {\n    return 20;\n  }\n  return undefined;\n}\n\nexport function labelOverlap(scaleType: ScaleType): LabelOverlap {\n  if (contains(['quantile', 'threshold', 'log'], scaleType)) {\n    return 'greedy';\n  }\n  return undefined;\n}\n","import {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\n\nexport const area: MarkCompiler = {\n  vgMark: 'area',\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'include'}),\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', model.markDef.orient === 'horizontal' ? 'x2' : 'y2'),\n      ...mixins.defined(model)\n    };\n  }\n};\n","import {isNumber} from 'vega-util';\nimport {isBinned, isBinning} from '../../bin';\nimport {X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {isFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {MarkDef} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {getFirstDefined} from '../../util';\nimport {isVgRangeStep, VgEncodeEntry, VgValueRef} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\nimport {ScaleComponent} from '../scale/component';\nimport {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\n\nexport const bar: MarkCompiler = {\n  vgMark: 'rect',\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n      ...x(model),\n      ...y(model)\n    };\n  }\n};\n\nfunction x(model: UnitModel): VgEncodeEntry {\n  const {config, encoding, markDef, width} = model;\n  const orient = markDef.orient;\n  const sizeDef = encoding.size;\n\n  const xDef = encoding.x;\n  const x2Def = encoding.x2;\n  const xScaleName = model.scaleName(X);\n  const xScale = model.getScaleComponent(X);\n  // x, x2, and width -- we must specify two of these in all conditions\n  if (isFieldDef(xDef) && isBinned(xDef.bin)) {\n    return mixins.binPosition(\n      xDef,\n      x2Def,\n      X,\n      xScaleName,\n      getFirstDefined(markDef.binSpacing, config.bar.binSpacing),\n      xScale.get('reverse')\n    );\n  } else if (orient === 'horizontal' || x2Def) {\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'x2')\n    };\n  } else {\n    // vertical\n    if (isFieldDef(xDef)) {\n      const xScaleType = xScale.get('type');\n      if (isBinning(xDef.bin) && !sizeDef && !hasDiscreteDomain(xScaleType)) {\n        return mixins.binPosition(\n          xDef,\n          undefined,\n          X,\n          model.scaleName('x'),\n          getFirstDefined(markDef.binSpacing, config.bar.binSpacing),\n          xScale.get('reverse')\n        );\n      } else {\n        if (xScaleType === ScaleType.BAND) {\n          return mixins.bandPosition(xDef, 'x', model);\n        }\n      }\n    }\n    // sized bin, normal point-ordinal axis, quantitative x-axis, or no x\n\n    return mixins.centeredBandPosition(\n      'x',\n      model,\n      {...ref.mid(width)},\n      defaultSizeRef(markDef, xScaleName, xScale, config)\n    );\n  }\n}\n\nfunction y(model: UnitModel) {\n  const {config, encoding, height, markDef} = model;\n  const orient = markDef.orient;\n  const sizeDef = encoding.size;\n\n  const yDef = encoding.y;\n  const y2Def = encoding.y2;\n  const yScaleName = model.scaleName(Y);\n  const yScale = model.getScaleComponent(Y);\n\n  // y, y2 & height -- we must specify two of these in all conditions\n  if (isFieldDef(yDef) && isBinned(yDef.bin)) {\n    return mixins.binPosition(\n      yDef,\n      y2Def,\n      Y,\n      yScaleName,\n      getFirstDefined(markDef.binSpacing, config.bar.binSpacing),\n      yScale.get('reverse')\n    );\n  } else if (orient === 'vertical' || y2Def) {\n    return {\n      ...mixins.pointPosition('y', model, 'zeroOrMin'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'y2')\n    };\n  } else {\n    if (isFieldDef(yDef)) {\n      const yScaleType = yScale.get('type');\n      if (isBinning(yDef.bin) && !sizeDef && !hasDiscreteDomain(yScaleType)) {\n        return mixins.binPosition(\n          yDef,\n          undefined,\n          Y,\n          model.scaleName('y'),\n          getFirstDefined(markDef.binSpacing, config.bar.binSpacing),\n          yScale.get('reverse')\n        );\n      } else if (yScaleType === ScaleType.BAND) {\n        return mixins.bandPosition(yDef, 'y', model);\n      }\n    }\n    return mixins.centeredBandPosition(\n      'y',\n      model,\n      ref.mid(height),\n      defaultSizeRef(markDef, yScaleName, yScale, config)\n    );\n  }\n}\n\nfunction defaultSizeRef(markDef: MarkDef, scaleName: string, scale: ScaleComponent, config: Config): VgValueRef {\n  if (markDef.size !== undefined) {\n    return {value: markDef.size};\n  }\n  const sizeConfig = getMarkConfig('size', markDef, config, {\n    // config.mark.size shouldn't affect bar size\n    skipGeneralMarkConfig: true\n  });\n\n  if (sizeConfig !== undefined) {\n    return {value: sizeConfig};\n  }\n\n  if (scale) {\n    const scaleType = scale.get('type');\n    if (scaleType === 'point' || scaleType === 'band') {\n      if (config.bar.discreteBandSize !== undefined) {\n        return {value: config.bar.discreteBandSize};\n      }\n      if (scaleType === ScaleType.POINT) {\n        const scaleRange = scale.get('range');\n        if (isVgRangeStep(scaleRange) && isNumber(scaleRange.step)) {\n          return {value: scaleRange.step - 1};\n        }\n        log.warn(log.message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL);\n      } else {\n        // BAND\n        return ref.bandRef(scaleName);\n      }\n    } else {\n      // continuous scale\n      return {value: config.bar.continuousBandSize};\n    }\n  }\n  // No Scale\n  const value = getFirstDefined(\n    // No scale is like discrete bar (with one item)\n    config.bar.discreteBandSize,\n    config.scale.rangeStep ? config.scale.rangeStep - 1 : undefined,\n    // If somehow default rangeStep is set to null or undefined, use 20 as back up\n    20\n  );\n  return {value};\n}\n","import {UnitModel} from '../unit';\nimport * as mixins from './mixins';\n\nimport {isFieldDef, vgField} from '../../fielddef';\nimport {GEOJSON} from '../../type';\nimport {VgGeoShapeTransform, VgPostEncodingTransform} from '../../vega.schema';\nimport {MarkCompiler} from './base';\n\nexport const geoshape: MarkCompiler = {\n  vgMark: 'shape',\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'})\n    };\n  },\n  postEncodingTransform: (model: UnitModel): VgPostEncodingTransform[] => {\n    const {encoding} = model;\n    const shapeDef = encoding.shape;\n\n    const transform: VgGeoShapeTransform = {\n      type: 'geoshape',\n      projection: model.projectionName(),\n      // as: 'shape',\n      ...(shapeDef && isFieldDef(shapeDef) && shapeDef.type === GEOJSON\n        ? {field: vgField(shapeDef, {expr: 'datum'})}\n        : {})\n    };\n    return [transform];\n  }\n};\n","import {isBinned, isBinning} from '../../bin';\nimport {Config} from '../../config';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {FieldDef, isContinuous, isFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {AREA, BAR, CIRCLE, isMarkDef, LINE, Mark, MarkDef, POINT, RECT, RULE, SQUARE, TEXT, TICK} from '../../mark';\nimport {QUANTITATIVE, TEMPORAL} from '../../type';\nimport {contains, getFirstDefined} from '../../util';\nimport {Orient} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\n\nexport function normalizeMarkDef(mark: Mark | MarkDef, encoding: Encoding<string>, config: Config) {\n  const markDef: MarkDef = isMarkDef(mark) ? {...mark} : {type: mark};\n\n  // set orient, which can be overridden by rules as sometimes the specified orient is invalid.\n  const specifiedOrient = markDef.orient || getMarkConfig('orient', markDef, config);\n  markDef.orient = orient(markDef.type, encoding, specifiedOrient);\n  if (specifiedOrient !== undefined && specifiedOrient !== markDef.orient) {\n    log.warn(log.message.orientOverridden(markDef.orient, specifiedOrient));\n  }\n\n  // set opacity and filled if not specified in mark config\n  const specifiedOpacity = getFirstDefined(markDef.opacity, getMarkConfig('opacity', markDef, config));\n  if (specifiedOpacity === undefined) {\n    markDef.opacity = opacity(markDef.type, encoding);\n  }\n\n  const specifiedFilled = markDef.filled;\n  if (specifiedFilled === undefined) {\n    markDef.filled = filled(markDef, config);\n  }\n\n  // set cursor, which should be pointer if href channel is present unless otherwise specified\n  const specifiedCursor = markDef.cursor || getMarkConfig('cursor', markDef, config);\n  if (specifiedCursor === undefined) {\n    markDef.cursor = cursor(markDef, encoding, config);\n  }\n\n  return markDef;\n}\n\nfunction cursor(markDef: MarkDef, encoding: Encoding<string>, config: Config) {\n  if (encoding.href || markDef.href || getMarkConfig('href', markDef, config)) {\n    return 'pointer';\n  }\n  return markDef.cursor;\n}\n\nfunction opacity(mark: Mark, encoding: Encoding<string>) {\n  if (contains([POINT, TICK, CIRCLE, SQUARE], mark)) {\n    // point-based marks\n    if (!isAggregate(encoding)) {\n      return 0.7;\n    }\n  }\n  return undefined;\n}\n\nfunction filled(markDef: MarkDef, config: Config) {\n  const filledConfig = getMarkConfig('filled', markDef, config);\n  const mark = markDef.type;\n  return getFirstDefined(filledConfig, mark !== POINT && mark !== LINE && mark !== RULE);\n}\n\nfunction orient(mark: Mark, encoding: Encoding<string>, specifiedOrient: Orient): Orient {\n  switch (mark) {\n    case POINT:\n    case CIRCLE:\n    case SQUARE:\n    case TEXT:\n    case RECT:\n      // orient is meaningless for these marks.\n      return undefined;\n  }\n\n  const {x, y, x2, y2} = encoding;\n\n  switch (mark) {\n    case BAR:\n      if (isFieldDef(x) && isBinned(x.bin)) {\n        return 'vertical';\n      }\n      if (isFieldDef(y) && isBinned(y.bin)) {\n        return 'horizontal';\n      }\n      if (y2 || x2) {\n        // Ranged bar does not always have clear orientation, so we allow overriding\n        if (specifiedOrient) {\n          return specifiedOrient;\n        }\n\n        // If y is range and x is non-range, non-bin Q, y is likely a prebinned field\n        if (!x2 && isFieldDef(x) && x.type === QUANTITATIVE && !isBinning(x.bin)) {\n          return 'horizontal';\n        }\n\n        // If x is range and y is non-range, non-bin Q, x is likely a prebinned field\n        if (!y2 && isFieldDef(y) && y.type === QUANTITATIVE && !isBinning(y.bin)) {\n          return 'vertical';\n        }\n      }\n    /* tslint:disable */\n    case RULE: // intentionally fall through\n      // return undefined for line segment rule and bar with both axis ranged\n      if (x2 && y2) {\n        return undefined;\n      }\n\n    case AREA: // intentionally fall through\n      // If there are range for both x and y, y (vertical) has higher precedence.\n      if (y2) {\n        if (isFieldDef(y) && isBinned(y.bin)) {\n          return 'horizontal';\n        } else {\n          return 'vertical';\n        }\n      } else if (x2) {\n        if (isFieldDef(x) && isBinned(x.bin)) {\n          return 'vertical';\n        } else {\n          return 'horizontal';\n        }\n      } else if (mark === RULE) {\n        if (encoding.x && !encoding.y) {\n          return 'vertical';\n        } else if (encoding.y && !encoding.x) {\n          return 'horizontal';\n        }\n      }\n\n    case LINE: // intentional fall through\n    case TICK: // Tick is opposite to bar, line, area and never have ranged mark.\n      /* tslint:enable */\n      const xIsContinuous = isFieldDef(encoding.x) && isContinuous(encoding.x);\n      const yIsContinuous = isFieldDef(encoding.y) && isContinuous(encoding.y);\n      if (xIsContinuous && !yIsContinuous) {\n        return mark !== 'tick' ? 'horizontal' : 'vertical';\n      } else if (!xIsContinuous && yIsContinuous) {\n        return mark !== 'tick' ? 'vertical' : 'horizontal';\n      } else if (xIsContinuous && yIsContinuous) {\n        const xDef = encoding.x as FieldDef<string>; // we can cast here since they are surely fieldDef\n        const yDef = encoding.y as FieldDef<string>;\n\n        const xIsTemporal = xDef.type === TEMPORAL;\n        const yIsTemporal = yDef.type === TEMPORAL;\n\n        // temporal without timeUnit is considered continuous, but better serves as dimension\n        if (xIsTemporal && !yIsTemporal) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (!xIsTemporal && yIsTemporal) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (!xDef.aggregate && yDef.aggregate) {\n          return mark !== 'tick' ? 'vertical' : 'horizontal';\n        } else if (xDef.aggregate && !yDef.aggregate) {\n          return mark !== 'tick' ? 'horizontal' : 'vertical';\n        }\n\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        return 'vertical';\n      } else {\n        // Discrete x Discrete case\n        if (specifiedOrient) {\n          // When ambiguous, use user specified one.\n          return specifiedOrient;\n        }\n\n        return undefined;\n      }\n  }\n  return 'vertical';\n}\n","import {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\n\nexport const line: MarkCompiler = {\n  vgMark: 'line',\n  encodeEntry: (model: UnitModel) => {\n    const {width, height} = model;\n\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n      ...mixins.pointPosition('x', model, ref.mid(width)),\n      ...mixins.pointPosition('y', model, ref.mid(height)),\n      ...mixins.nonPosition('size', model, {\n        vgChannel: 'strokeWidth' // VL's line size is strokeWidth\n      }),\n      ...mixins.defined(model)\n    };\n  }\n};\n\nexport const trail: MarkCompiler = {\n  vgMark: 'trail',\n  encodeEntry: (model: UnitModel) => {\n    const {width, height} = model;\n\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'include', orient: 'ignore'}),\n      ...mixins.pointPosition('x', model, ref.mid(width)),\n      ...mixins.pointPosition('y', model, ref.mid(height)),\n      ...mixins.nonPosition('size', model),\n      ...mixins.defined(model)\n    };\n  }\n};\n","import {isArray} from 'vega-util';\nimport {MAIN} from '../../data';\nimport {Encoding, isAggregate} from '../../encoding';\nimport {getFieldDef, isFieldDef, isValueDef, vgField} from '../../fielddef';\nimport {AREA, isPathMark, LINE, Mark, TRAIL} from '../../mark';\nimport {isSortField} from '../../sort';\nimport {contains, getFirstDefined, keys} from '../../util';\nimport {getStyles, sortParams} from '../common';\nimport {UnitModel} from '../unit';\nimport {area} from './area';\nimport {bar} from './bar';\nimport {MarkCompiler} from './base';\nimport {geoshape} from './geoshape';\nimport {line, trail} from './line';\nimport {circle, point, square} from './point';\nimport {rect} from './rect';\nimport {rule} from './rule';\nimport {text} from './text';\nimport {tick} from './tick';\n\nconst markCompiler: {[m in Mark]: MarkCompiler} = {\n  area,\n  bar,\n  circle,\n  geoshape,\n  line,\n  point,\n  rect,\n  rule,\n  square,\n  text,\n  tick,\n  trail\n};\n\nexport function parseMarkGroup(model: UnitModel): any[] {\n  if (contains([LINE, AREA, TRAIL], model.mark)) {\n    return parsePathMark(model);\n  } else {\n    return getMarkGroups(model);\n  }\n}\n\nconst FACETED_PATH_PREFIX = 'faceted_path_';\n\nfunction parsePathMark(model: UnitModel) {\n  const details = pathGroupingFields(model.mark, model.encoding);\n\n  const pathMarks = getMarkGroups(model, {\n    // If has subfacet for line/area group, need to use faceted data from below.\n    fromPrefix: details.length > 0 ? FACETED_PATH_PREFIX : ''\n  });\n\n  if (details.length > 0) {\n    // have level of details - need to facet line into subgroups\n    // TODO: for non-stacked plot, map order to zindex. (Maybe rename order for layer to zindex?)\n\n    return [\n      {\n        name: model.getName('pathgroup'),\n        type: 'group',\n        from: {\n          facet: {\n            name: FACETED_PATH_PREFIX + model.requestDataName(MAIN),\n            data: model.requestDataName(MAIN),\n            groupby: details\n          }\n        },\n        encode: {\n          update: {\n            width: {field: {group: 'width'}},\n            height: {field: {group: 'height'}}\n          }\n        },\n        marks: pathMarks\n      }\n    ];\n  } else {\n    return pathMarks;\n  }\n}\n\nexport function getSort(model: UnitModel) {\n  const {encoding, stack, mark, markDef} = model;\n  const order = encoding.order;\n  if (!isArray(order) && isValueDef(order)) {\n    return undefined;\n  } else if ((isArray(order) || isFieldDef(order)) && !stack) {\n    // Sort by the order field if it is specified and the field is not stacked. (For stacked field, order specify stack order.)\n    return sortParams(order, {expr: 'datum'});\n  } else if (isPathMark(mark)) {\n    // For both line and area, we sort values based on dimension by default\n    const dimensionChannelDef = encoding[markDef.orient === 'horizontal' ? 'y' : 'x'];\n    if (isFieldDef(dimensionChannelDef)) {\n      const s = dimensionChannelDef.sort;\n      const sortField = isSortField(s)\n        ? vgField(\n            {\n              // FIXME: this op might not already exist?\n              // FIXME: what if dimensionChannel (x or y) contains custom domain?\n              aggregate: isAggregate(model.encoding) ? s.op : undefined,\n              field: s.field\n            },\n            {expr: 'datum'}\n          )\n        : vgField(dimensionChannelDef, {\n            // For stack with imputation, we only have bin_mid\n            binSuffix: model.stack && model.stack.impute ? 'mid' : undefined,\n            expr: 'datum'\n          });\n\n      return {\n        field: sortField,\n        order: 'descending'\n      };\n    }\n    return undefined;\n  }\n  return undefined;\n}\n\nfunction getMarkGroups(\n  model: UnitModel,\n  opt: {\n    fromPrefix: string;\n  } = {fromPrefix: ''}\n) {\n  const mark = model.mark;\n\n  const clip = getFirstDefined(model.markDef.clip, scaleClip(model));\n  const style = getStyles(model.markDef);\n  const key = model.encoding.key;\n  const sort = getSort(model);\n\n  const postEncodingTransform = markCompiler[mark].postEncodingTransform\n    ? markCompiler[mark].postEncodingTransform(model)\n    : null;\n\n  return [\n    {\n      name: model.getName('marks'),\n      type: markCompiler[mark].vgMark,\n      ...(clip ? {clip: true} : {}),\n      ...(style ? {style} : {}),\n      ...(key ? {key: {field: key.field}} : {}),\n      ...(sort ? {sort} : {}),\n      from: {data: opt.fromPrefix + model.requestDataName(MAIN)},\n      encode: {\n        update: markCompiler[mark].encodeEntry(model)\n      },\n      ...(postEncodingTransform\n        ? {\n            transform: postEncodingTransform\n          }\n        : {})\n    }\n  ];\n}\n\n/**\n * Returns list of path grouping fields\n * that the model's spec contains.\n */\nexport function pathGroupingFields(mark: Mark, encoding: Encoding<string>): string[] {\n  return keys(encoding).reduce((details, channel) => {\n    switch (channel) {\n      // x, y, x2, y2, lat, long, lat1, long2, order, tooltip, href, cursor should not cause lines to group\n      case 'x':\n      case 'y':\n      case 'order':\n      case 'href':\n      case 'x2':\n      case 'y2':\n\n      case 'latitude':\n      case 'longitude':\n      case 'latitude2':\n      case 'longitude2':\n      // TODO: case 'cursor':\n\n      // text, shape, shouldn't be a part of line/trail/area\n      case 'text':\n      case 'shape':\n        return details;\n\n      case 'tooltip':\n      case 'detail':\n      case 'key':\n        const channelDef = encoding[channel];\n        if (isArray(channelDef) || isFieldDef(channelDef)) {\n          (isArray(channelDef) ? channelDef : [channelDef]).forEach(fieldDef => {\n            if (!fieldDef.aggregate) {\n              details.push(vgField(fieldDef, {}));\n            }\n          });\n        }\n        return details;\n\n      case 'size':\n        if (mark === 'trail') {\n          // For trail, size should not group trail lines.\n          return details;\n        }\n      // For line, it should group lines.\n\n      /* tslint:disable */\n      // intentional fall through\n\n      case 'color':\n      case 'fill':\n      case 'stroke':\n      case 'opacity':\n        // TODO strokeDashOffset:\n\n        /* tslint:enable */\n        const fieldDef = getFieldDef<string>(encoding[channel]);\n        if (fieldDef && !fieldDef.aggregate) {\n          details.push(vgField(fieldDef, {}));\n        }\n        return details;\n      default:\n        throw new Error(`Bug: Channel ${channel} unimplemented for line mark`);\n    }\n  }, []);\n}\n\n/**\n * If scales are bound to interval selections, we want to automatically clip\n * marks to account for panning/zooming interactions. We identify bound scales\n * by the domainRaw property, which gets added during scale parsing.\n */\nfunction scaleClip(model: UnitModel) {\n  const xScale = model.getScaleComponent('x');\n  const yScale = model.getScaleComponent('y');\n  return (xScale && xScale.get('domainRaw')) || (yScale && yScale.get('domainRaw')) ? true : false;\n}\n","import {array, isArray, isObject, isString} from 'vega-util';\nimport {isBinned, isBinning} from '../../bin';\nimport {Channel, NonPositionScaleChannel, SCALE_CHANNELS, ScaleChannel, X, X2, Y2} from '../../channel';\nimport {fieldDefs} from '../../encoding';\nimport {\n  ChannelDef,\n  FieldDef,\n  getFieldDef,\n  isConditionalSelection,\n  isFieldDef,\n  isValueDef,\n  ValueDef\n} from '../../fielddef';\nimport * as log from '../../log';\nimport {isPathMark, MarkDef} from '../../mark';\nimport {expression} from '../../predicate';\nimport {hasContinuousDomain} from '../../scale';\nimport {contains, Dict, getFirstDefined, keys} from '../../util';\nimport {VG_MARK_CONFIGS, VgEncodeEntry, VgValueRef} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\nimport {selectionPredicate} from '../selection/selection';\nimport {UnitModel} from '../unit';\nimport * as ref from './valueref';\n\nexport function color(model: UnitModel): VgEncodeEntry {\n  const {markDef, encoding, config} = model;\n  const {filled, type: markType} = markDef;\n\n  const configValue = {\n    fill: getMarkConfig('fill', markDef, config),\n    stroke: getMarkConfig('stroke', markDef, config),\n    color: getMarkConfig('color', markDef, config)\n  };\n\n  const transparentIfNeeded = contains(['bar', 'point', 'circle', 'square', 'geoshape'], markType)\n    ? 'transparent'\n    : undefined;\n\n  const defaultValue = {\n    fill: getFirstDefined(\n      markDef.fill,\n      configValue.fill,\n      // If there is no fill, always fill symbols, bar, geoshape\n      // with transparent fills https://github.com/vega/vega-lite/issues/1316\n      transparentIfNeeded\n    ),\n    stroke: getFirstDefined(markDef.stroke, configValue.stroke)\n  };\n\n  const colorVgChannel = filled ? 'fill' : 'stroke';\n\n  const fillStrokeMarkDefAndConfig: VgEncodeEntry = {\n    ...(defaultValue.fill\n      ? {\n          fill: {value: defaultValue.fill}\n        }\n      : {}),\n    ...(defaultValue.stroke\n      ? {\n          stroke: {value: defaultValue.stroke}\n        }\n      : {})\n  };\n\n  if (encoding.fill || encoding.stroke) {\n    // ignore encoding.color, markDef.color, config.color\n    if (markDef.color) {\n      // warn for markDef.color  (no need to warn encoding.color as it will be dropped in normalized already)\n      log.warn(log.message.droppingColor('property', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n    }\n\n    return {\n      ...nonPosition('fill', model, {defaultValue: getFirstDefined(defaultValue.fill, transparentIfNeeded)}),\n      ...nonPosition('stroke', model, {defaultValue: defaultValue.stroke})\n    };\n  } else if (encoding.color) {\n    return {\n      ...fillStrokeMarkDefAndConfig,\n      // override them with encoded color field\n      ...nonPosition('color', model, {\n        vgChannel: colorVgChannel,\n        // apply default fill/stroke first, then color config, then transparent if needed.\n        defaultValue: getFirstDefined(\n          markDef[colorVgChannel],\n          markDef.color,\n          configValue[colorVgChannel],\n          configValue.color,\n          filled ? transparentIfNeeded : undefined\n        )\n      })\n    };\n  } else if (markDef.fill !== undefined || markDef.stroke !== undefined) {\n    // Ignore markDef.color, config.color\n    if (markDef.color) {\n      log.warn(log.message.droppingColor('property', {fill: 'fill' in markDef, stroke: 'stroke' in markDef}));\n    }\n    return fillStrokeMarkDefAndConfig;\n  } else if (markDef.color) {\n    return {\n      ...fillStrokeMarkDefAndConfig, // in this case, fillStrokeMarkDefAndConfig only include config\n\n      // override config with markDef.color\n      [colorVgChannel]: {value: markDef.color}\n    };\n  } else if (configValue.fill !== undefined || configValue.stroke !== undefined) {\n    // ignore config.color\n    return fillStrokeMarkDefAndConfig;\n  } else if (configValue.color) {\n    return {\n      ...(transparentIfNeeded ? {fill: {value: 'transparent'}} : {}),\n      [colorVgChannel]: {value: configValue.color}\n    };\n  }\n  return {};\n}\n\nexport type Ignore = Record<'size' | 'orient', 'ignore' | 'include'>;\n\nexport function baseEncodeEntry(model: UnitModel, ignore: Ignore) {\n  const {fill, stroke} = color(model);\n  return {\n    ...markDefProperties(model.markDef, ignore),\n    ...wrapInvalid(model, 'fill', fill),\n    ...wrapInvalid(model, 'stroke', stroke),\n    ...nonPosition('opacity', model),\n    ...tooltip(model),\n    ...text(model, 'href')\n  };\n}\n\nfunction wrapInvalid(model: UnitModel, channel: Channel, valueRef: VgValueRef | VgValueRef[]): VgEncodeEntry {\n  const {config, mark} = model;\n\n  if (config.invalidValues && valueRef && !isPathMark(mark)) {\n    // For non-path marks, we have to exclude invalid values (null and NaN) for scales with continuous domains.\n    // For path marks, we will use \"defined\" property and skip these values instead.\n    const test = validPredicate(model, {invalid: true, channels: SCALE_CHANNELS});\n    if (test) {\n      return {\n        [channel]: [\n          // prepend the invalid case\n          // TODO: support custom value\n          {test, value: null},\n          ...array(valueRef)\n        ]\n      };\n    }\n  }\n  return valueRef ? {[channel]: valueRef} : {};\n}\n\nfunction markDefProperties(mark: MarkDef, ignore: Ignore) {\n  return VG_MARK_CONFIGS.reduce((m, prop) => {\n    if (mark[prop] !== undefined && ignore[prop] !== 'ignore') {\n      m[prop] = {value: mark[prop]};\n    }\n    return m;\n  }, {});\n}\n\nexport function valueIfDefined(prop: string, value: string | number | boolean): VgEncodeEntry {\n  if (value !== undefined) {\n    return {[prop]: {value: value}};\n  }\n  return undefined;\n}\n\nfunction validPredicate(model: UnitModel, {invalid = false, channels}: {invalid?: boolean; channels: ScaleChannel[]}) {\n  const filterIndex = channels.reduce((aggregator: Dict<true>, channel) => {\n    const scaleComponent = model.getScaleComponent(channel);\n    if (scaleComponent) {\n      const scaleType = scaleComponent.get('type');\n      const field = model.vgField(channel, {expr: 'datum'});\n\n      // While discrete domain scales can handle invalid values, continuous scales can't.\n      if (field && hasContinuousDomain(scaleType)) {\n        aggregator[field] = true;\n      }\n    }\n    return aggregator;\n  }, {});\n\n  const fields = keys(filterIndex);\n  if (fields.length > 0) {\n    const op = invalid ? '||' : '&&';\n    return fields\n      .map(field => {\n        const eq = invalid ? '===' : '!==';\n        return `${field} ${eq} null ${op} ${invalid ? '' : '!'}isNaN(${field})`;\n      })\n      .join(` ${op} `);\n  }\n  return undefined;\n}\nexport function defined(model: UnitModel): VgEncodeEntry {\n  if (model.config.invalidValues === 'filter') {\n    const signal = validPredicate(model, {channels: ['x', 'y']});\n\n    if (signal) {\n      return {defined: {signal}};\n    }\n  }\n  return {};\n}\n\n/**\n * Return mixins for non-positional channels with scales.  (Text doesn't have scale.)\n */\nexport function nonPosition(\n  channel: NonPositionScaleChannel,\n  model: UnitModel,\n  opt: {defaultValue?: number | string | boolean; vgChannel?: string; defaultRef?: VgValueRef} = {}\n): VgEncodeEntry {\n  const {defaultValue, vgChannel} = opt;\n  const defaultRef = opt.defaultRef || (defaultValue !== undefined ? {value: defaultValue} : undefined);\n\n  const channelDef = model.encoding[channel];\n\n  return wrapCondition(model, channelDef, vgChannel || channel, cDef => {\n    return ref.midPoint(\n      channel,\n      cDef,\n      undefined,\n      model.scaleName(channel),\n      model.getScaleComponent(channel),\n      null, // No need to provide stack for non-position as it does not affect mid point\n      defaultRef\n    );\n  });\n}\n\n/**\n * Return a mixin that include a Vega production rule for a Vega-Lite conditional channel definition.\n * or a simple mixin if channel def has no condition.\n */\nexport function wrapCondition(\n  model: UnitModel,\n  channelDef: ChannelDef<string>,\n  vgChannel: string,\n  refFn: (cDef: ChannelDef<string>) => VgValueRef\n): VgEncodeEntry {\n  const condition = channelDef && channelDef.condition;\n  const valueRef = refFn(channelDef);\n  if (condition) {\n    const conditions = isArray(condition) ? condition : [condition];\n    const vgConditions = conditions.map(c => {\n      const conditionValueRef = refFn(c);\n      const test = isConditionalSelection(c) ? selectionPredicate(model, c.selection) : expression(model, c.test);\n      return {\n        test,\n        ...conditionValueRef\n      };\n    });\n    return {\n      [vgChannel]: [...vgConditions, ...(valueRef !== undefined ? [valueRef] : [])]\n    };\n  } else {\n    return valueRef !== undefined ? {[vgChannel]: valueRef} : {};\n  }\n}\n\nexport function tooltip(model: UnitModel) {\n  const {encoding, markDef, config} = model;\n  const channelDef = encoding.tooltip;\n  if (isArray(channelDef)) {\n    return {tooltip: ref.tooltipForChannelDefs(channelDef, config)};\n  } else {\n    return wrapCondition(model, channelDef, 'tooltip', cDef => {\n      // use valueRef based on channelDef first\n      const tooltipRefFromChannelDef = ref.text(cDef, model.config);\n      if (tooltipRefFromChannelDef) {\n        return tooltipRefFromChannelDef;\n      }\n\n      // If tooltipDef does not exist, then use value from markDef or config\n      const markTooltip = getFirstDefined(markDef.tooltip, getMarkConfig('tooltip', markDef, config));\n      if (isString(markTooltip)) {\n        return {value: markTooltip};\n      } else if (isObject(markTooltip)) {\n        // `tooltip` is `{fields: 'encodings' | 'fields'}`\n        if (markTooltip.content === 'encoding') {\n          return ref.tooltipForChannelDefs(fieldDefs(encoding), config);\n        } else {\n          return {signal: 'datum'};\n        }\n      }\n\n      return undefined;\n    });\n  }\n}\n\nexport function text(model: UnitModel, channel: 'text' | 'href' = 'text') {\n  const channelDef = model.encoding[channel];\n  return wrapCondition(model, channelDef, channel, cDef => ref.text(cDef, model.config));\n}\n\nexport function bandPosition(fieldDef: FieldDef<string>, channel: 'x' | 'y', model: UnitModel) {\n  const scaleName = model.scaleName(channel);\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n\n  if (model.encoding.size || model.markDef.size !== undefined) {\n    const orient = model.markDef.orient;\n    if (orient) {\n      const centeredBandPositionMixins = {\n        // Use xc/yc and place the mark at the middle of the band\n        // This way we never have to deal with size's condition for x/y position.\n        [channel + 'c']: ref.fieldRef(fieldDef, scaleName, {}, {band: 0.5})\n      };\n\n      if (getFieldDef(model.encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (isValueDef(model.encoding.size)) {\n        return {\n          ...centeredBandPositionMixins,\n          ...nonPosition('size', model, {vgChannel: sizeChannel})\n        };\n      } else if (model.markDef.size !== undefined) {\n        return {\n          ...centeredBandPositionMixins,\n          [sizeChannel]: {value: model.markDef.size}\n        };\n      }\n    } else {\n      log.warn(log.message.cannotApplySizeToNonOrientedMark(model.markDef.type));\n    }\n  }\n  return {\n    [channel]: ref.fieldRef(fieldDef, scaleName, {binSuffix: 'range'}),\n    [sizeChannel]: ref.bandRef(scaleName)\n  };\n}\n\nexport function centeredBandPosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  defaultPosRef: VgValueRef,\n  defaultSizeRef: VgValueRef\n) {\n  const centerChannel: 'xc' | 'yc' = channel === 'x' ? 'xc' : 'yc';\n  const sizeChannel = channel === 'x' ? 'width' : 'height';\n  return {\n    ...pointPosition(channel, model, defaultPosRef, centerChannel),\n    ...nonPosition('size', model, {defaultRef: defaultSizeRef, vgChannel: sizeChannel})\n  };\n}\n\nexport function binPosition(\n  fieldDef: FieldDef<string>,\n  fieldDef2: ValueDef | FieldDef<string>,\n  channel: 'x' | 'y',\n  scaleName: string,\n  spacing: number,\n  reverse: boolean\n) {\n  const binSpacing = {\n    x: reverse ? spacing : 0,\n    x2: reverse ? 0 : spacing,\n    y: reverse ? 0 : spacing,\n    y2: reverse ? spacing : 0\n  };\n  const channel2 = channel === X ? X2 : Y2;\n  if (isBinning(fieldDef.bin)) {\n    return {\n      [channel2]: ref.bin(fieldDef, scaleName, 'start', binSpacing[`${channel}2`]),\n      [channel]: ref.bin(fieldDef, scaleName, 'end', binSpacing[channel])\n    };\n  } else if (isBinned(fieldDef.bin) && isFieldDef(fieldDef2)) {\n    return {\n      [channel2]: ref.fieldRef(fieldDef, scaleName, {}, {offset: binSpacing[`${channel}2`]}),\n      [channel]: ref.fieldRef(fieldDef2, scaleName, {}, {offset: binSpacing[channel]})\n    };\n  } else {\n    log.warn(log.message.channelRequiredForBinned(channel2));\n    return undefined;\n  }\n}\n\n/**\n * Return mixins for point (non-band) position channels.\n */\nexport function pointPosition(\n  channel: 'x' | 'y',\n  model: UnitModel,\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax',\n  vgChannel?: 'x' | 'y' | 'xc' | 'yc'\n) {\n  // TODO: refactor how refer to scale as discussed in https://github.com/vega/vega-lite/pull/1613\n\n  const {encoding, mark, stack} = model;\n\n  const channelDef = encoding[channel];\n  const channel2Def = encoding[channel === X ? X2 : Y2];\n  const scaleName = model.scaleName(channel);\n  const scale = model.getScaleComponent(channel);\n\n  const offset = ref.getOffset(channel, model.markDef);\n\n  const valueRef =\n    !channelDef && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat/long and there is no point position overriding lat/long.\n        {field: model.getName(channel)}\n      : {\n          ...ref.position(\n            channel,\n            channelDef,\n            channel2Def,\n            scaleName,\n            scale,\n            stack,\n            ref.getDefaultRef(defaultRef, channel, scaleName, scale, mark)\n          ),\n          ...(offset ? {offset} : {})\n        };\n\n  return {\n    [vgChannel || channel]: valueRef\n  };\n}\n\n/**\n * Return mixins for x2, y2.\n * If channel is not specified, return one channel based on orientation.\n */\nexport function pointPosition2(model: UnitModel, defaultRef: 'zeroOrMin' | 'zeroOrMax', channel: 'x2' | 'y2') {\n  const {encoding, mark, stack} = model;\n\n  const baseChannel = channel === 'x2' ? 'x' : 'y';\n  const channelDef = encoding[baseChannel];\n  const scaleName = model.scaleName(baseChannel);\n  const scale = model.getScaleComponent(baseChannel);\n\n  const offset = ref.getOffset(channel, model.markDef);\n\n  const valueRef =\n    !channelDef && (encoding.latitude || encoding.longitude)\n      ? // use geopoint output if there are lat2/long2 and there is no point position2 overriding lat2/long2.\n        {field: model.getName(channel)}\n      : {\n          ...ref.position2(\n            channel,\n            channelDef,\n            encoding[channel],\n            scaleName,\n            scale,\n            stack,\n            ref.getDefaultRef(defaultRef, baseChannel, scaleName, scale, mark)\n          ),\n          ...(offset ? {offset} : {})\n        };\n\n  return {[channel]: valueRef};\n}\n","import {Config} from '../../config';\nimport {VgEncodeEntry} from '../../vega.schema';\nimport {getMarkConfig} from '../common';\nimport {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\n\nfunction encodeEntry(model: UnitModel, fixedShape?: 'circle' | 'square') {\n  const {config, markDef, width, height} = model;\n\n  return {\n    ...mixins.baseEncodeEntry(model, {size: 'include', orient: 'ignore'}),\n    ...mixins.pointPosition('x', model, ref.mid(width)),\n    ...mixins.pointPosition('y', model, ref.mid(height)),\n    ...mixins.nonPosition('size', model, {defaultValue: getMarkConfig('size', markDef, config)}),\n    ...shapeMixins(model, config, fixedShape)\n  };\n}\n\nexport function shapeMixins(model: UnitModel, config: Config, fixedShape?: 'circle' | 'square'): VgEncodeEntry {\n  if (fixedShape) {\n    return {shape: {value: fixedShape}};\n  }\n  return mixins.nonPosition('shape', model, {defaultValue: getMarkConfig('shape', model.markDef, config) as string});\n}\n\nexport const point: MarkCompiler = {\n  vgMark: 'symbol',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model);\n  }\n};\n\nexport const circle: MarkCompiler = {\n  vgMark: 'symbol',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model, 'circle');\n  }\n};\n\nexport const square: MarkCompiler = {\n  vgMark: 'symbol',\n  encodeEntry: (model: UnitModel) => {\n    return encodeEntry(model, 'square');\n  }\n};\n","import {isBinned, isBinning} from '../../bin';\nimport {X, Y} from '../../channel';\nimport {isFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {RECT} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {VgEncodeEntry} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\n\nexport const rect: MarkCompiler = {\n  vgMark: 'rect',\n  encodeEntry: (model: UnitModel) => {\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n      ...x(model),\n      ...y(model)\n    };\n  }\n};\n\nexport function x(model: UnitModel): VgEncodeEntry {\n  const xDef = model.encoding.x;\n  const x2Def = model.encoding.x2;\n  const xScale = model.getScaleComponent(X);\n  const xScaleType = xScale ? xScale.get('type') : undefined;\n  const xScaleName = model.scaleName(X);\n\n  if (isFieldDef(xDef) && (isBinning(xDef.bin) || isBinned(xDef.bin))) {\n    return mixins.binPosition(xDef, x2Def, X, xScaleName, 0, xScale.get('reverse'));\n  } else if (isFieldDef(xDef) && xScale && hasDiscreteDomain(xScaleType)) {\n    /* istanbul ignore else */\n    if (xScaleType === ScaleType.BAND) {\n      return mixins.bandPosition(xDef, 'x', model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, xScaleType));\n    }\n  } else {\n    // continuous scale or no scale\n    return {\n      ...mixins.pointPosition('x', model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'x2')\n    };\n  }\n}\n\nexport function y(model: UnitModel): VgEncodeEntry {\n  const yDef = model.encoding.y;\n  const y2Def = model.encoding.y2;\n  const yScale = model.getScaleComponent(Y);\n  const yScaleType = yScale ? yScale.get('type') : undefined;\n  const yScaleName = model.scaleName(Y);\n\n  if (isFieldDef(yDef) && (isBinning(yDef.bin) || isBinned(yDef.bin))) {\n    return mixins.binPosition(yDef, y2Def, Y, yScaleName, 0, yScale.get('reverse'));\n  } else if (isFieldDef(yDef) && yScale && hasDiscreteDomain(yScaleType)) {\n    /* istanbul ignore else */\n    if (yScaleType === ScaleType.BAND) {\n      return mixins.bandPosition(yDef, 'y', model);\n    } else {\n      // We don't support rect mark with point/ordinal scale\n      throw new Error(log.message.scaleTypeNotWorkWithMark(RECT, yScaleType));\n    }\n  } else {\n    // continuous scale or no scale\n    return {\n      ...mixins.pointPosition('y', model, 'zeroOrMax'),\n      ...mixins.pointPosition2(model, 'zeroOrMin', 'y2')\n    };\n  }\n}\n","import {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\n\nexport const rule: MarkCompiler = {\n  vgMark: 'rule',\n  encodeEntry: (model: UnitModel) => {\n    const {markDef, width, height} = model;\n    const orient = markDef.orient;\n\n    if (!model.encoding.x && !model.encoding.y && !model.encoding.latitude && !model.encoding.longitude) {\n      // Show nothing if we have none of x, y, lat, and long.\n      return {};\n    }\n\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n      ...mixins.pointPosition('x', model, orient === 'horizontal' ? 'zeroOrMin' : ref.mid(width)),\n      ...mixins.pointPosition('y', model, orient === 'vertical' ? 'zeroOrMin' : ref.mid(height)),\n\n      // include x2 for horizontal or line segment rule\n      ...(orient !== 'vertical' ? mixins.pointPosition2(model, 'zeroOrMax', 'x2') : {}),\n\n      // include y2 for vertical or line segment rule\n      ...(orient !== 'horizontal' ? mixins.pointPosition2(model, 'zeroOrMax', 'y2') : {}),\n\n      ...mixins.nonPosition('size', model, {\n        vgChannel: 'strokeWidth', // VL's rule size is strokeWidth\n        defaultValue: markDef.size\n      })\n    };\n  }\n};\n","import {Config} from '../../config';\nimport {Encoding} from '../../encoding';\nimport {MarkDef} from '../../mark';\nimport {getFirstDefined} from '../../util';\nimport {getMarkConfig, getStyleConfig} from '../common';\nimport {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\n\nexport const text: MarkCompiler = {\n  vgMark: 'text',\n\n  encodeEntry: (model: UnitModel) => {\n    const {config, encoding, width, height, markDef} = model;\n\n    // We have to support mark property and config for both size and fontSize for text\n    // - size is from original Vega-Lite, which allows users to easily transition from size channel of other marks to text.\n    // - fontSize is from Vega and we need support it to make sure that all Vega configs all work correctly in Vega-Lite.\n    // Precedence: markDef > style config > mark-specific config\n    // For each of them, fontSize is more specific than size, thus has higher precedence\n    const defaultValue = getFirstDefined(\n      markDef.fontSize,\n      markDef.size,\n      getStyleConfig('fontSize', markDef, config.style),\n      getStyleConfig('size', markDef, config.style),\n      config[markDef.type].fontSize,\n      config[markDef.type].size\n      // general mark config shouldn't be used as they are only for point/circle/square\n    );\n\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n      ...mixins.pointPosition('x', model, ref.mid(width)),\n      ...mixins.pointPosition('y', model, ref.mid(height)),\n      ...mixins.text(model),\n      ...mixins.nonPosition('size', model, {\n        defaultValue,\n        vgChannel: 'fontSize' // VL's text size is fontSize\n      }),\n      ...mixins.valueIfDefined('align', align(model.markDef, encoding, config))\n    };\n  }\n};\nfunction align(markDef: MarkDef, encoding: Encoding<string>, config: Config) {\n  const a = markDef.align || getMarkConfig('align', markDef, config);\n  if (a === undefined) {\n    return 'center';\n  }\n  // If there is a config, Vega-parser will process this already.\n  return undefined;\n}\n","import {getFirstDefined} from '../../util';\nimport {isVgRangeStep} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {MarkCompiler} from './base';\nimport * as mixins from './mixins';\nimport * as ref from './valueref';\n\nexport const tick: MarkCompiler = {\n  vgMark: 'rect',\n\n  encodeEntry: (model: UnitModel) => {\n    const {config, markDef, width, height} = model;\n    const orient = markDef.orient;\n\n    const vgSizeChannel = orient === 'horizontal' ? 'width' : 'height';\n    const vgThicknessChannel = orient === 'horizontal' ? 'height' : 'width';\n\n    return {\n      ...mixins.baseEncodeEntry(model, {size: 'ignore', orient: 'ignore'}),\n\n      ...mixins.pointPosition('x', model, ref.mid(width), 'xc'),\n      ...mixins.pointPosition('y', model, ref.mid(height), 'yc'),\n\n      // size / thickness => width / height\n      ...mixins.nonPosition('size', model, {\n        defaultValue: defaultSize(model),\n        vgChannel: vgSizeChannel\n      }),\n      [vgThicknessChannel]: {value: getFirstDefined(markDef.thickness, config.tick.thickness)}\n    };\n  }\n};\n\nfunction defaultSize(model: UnitModel): number {\n  const {config, markDef} = model;\n  const orient = markDef.orient;\n  const scale = model.getScaleComponent(orient === 'horizontal' ? 'x' : 'y');\n\n  if (markDef.size !== undefined) {\n    return markDef.size;\n  } else if (config.tick.bandSize !== undefined) {\n    return config.tick.bandSize;\n  } else {\n    const scaleRange = scale ? scale.get('range') : undefined;\n    const rangeStep = scaleRange && isVgRangeStep(scaleRange) ? scaleRange.step : config.scale.rangeStep;\n    if (typeof rangeStep !== 'number') {\n      // FIXME consolidate this log\n      throw new Error('Function does not handle non-numeric rangeStep');\n    }\n    return rangeStep / 1.5;\n  }\n}\n","/**\n * Utility files for producing Vega ValueRef for marks\n */\nimport {SignalRef} from 'vega';\nimport {isArray, isFunction, isString} from 'vega-util';\nimport {isBinned, isBinning} from '../../bin';\nimport {Channel, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {\n  ChannelDef,\n  ChannelDefWithCondition,\n  FieldDef,\n  FieldRefOption,\n  format,\n  isFieldDef,\n  isValueDef,\n  TextFieldDef,\n  title,\n  vgField\n} from '../../fielddef';\nimport * as log from '../../log';\nimport {Mark, MarkDef} from '../../mark';\nimport {hasDiscreteDomain, ScaleType} from '../../scale';\nimport {StackProperties} from '../../stack';\nimport {QUANTITATIVE} from '../../type';\nimport {contains, some} from '../../util';\nimport {VgValueRef} from '../../vega.schema';\nimport {binRequiresRange, formatSignalRef} from '../common';\nimport {ScaleComponent} from '../scale/component';\n\n// TODO: we need to find a way to refactor these so that scaleName is a part of scale\n// but that's complicated.  For now, this is a huge step moving forward.\n\n/**\n * @return Vega ValueRef for normal x- or y-position without projection\n */\nexport function position(\n  channel: 'x' | 'y',\n  channelDef: ChannelDef<string>,\n  channel2Def: ChannelDef<string>,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  if (isFieldDef(channelDef) && stack && channel === stack.fieldChannel) {\n    // x or y use stack_end so that stacked line's point mark use stack_end too.\n    return fieldRef(channelDef, scaleName, {suffix: 'end'});\n  }\n  return midPoint(channel, channelDef, channel2Def, scaleName, scale, stack, defaultRef);\n}\n\n/**\n * @return Vega ValueRef for normal x2- or y2-position without projection\n */\nexport function position2(\n  channel: 'x2' | 'y2',\n  aFieldDef: ChannelDef<string>,\n  a2fieldDef: ChannelDef<string>,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  if (\n    isFieldDef(aFieldDef) &&\n    stack &&\n    // If fieldChannel is X and channel is X2 (or Y and Y2)\n    channel.charAt(0) === stack.fieldChannel.charAt(0)\n  ) {\n    return fieldRef(aFieldDef, scaleName, {suffix: 'start'});\n  }\n  return midPoint(channel, a2fieldDef, undefined, scaleName, scale, stack, defaultRef);\n}\n\nexport function getOffset(channel: 'x' | 'y' | 'x2' | 'y2', markDef: MarkDef) {\n  const offsetChannel = channel + 'Offset';\n  // TODO: in the future read from encoding channel too\n\n  const markDefOffsetValue = markDef[offsetChannel];\n  if (markDefOffsetValue) {\n    return markDefOffsetValue;\n  }\n\n  return undefined;\n}\n\n/**\n * Value Ref for binned fields\n */\nexport function bin(fieldDef: FieldDef<string>, scaleName: string, side: 'start' | 'end', offset?: number) {\n  const binSuffix = side === 'start' ? undefined : 'end';\n  return fieldRef(fieldDef, scaleName, {binSuffix}, offset ? {offset} : {});\n}\n\nexport function fieldRef(\n  fieldDef: FieldDef<string>,\n  scaleName: string,\n  opt: FieldRefOption,\n  mixins?: {offset?: number | VgValueRef; band?: number | boolean}\n): VgValueRef {\n  const ref: VgValueRef = {\n    ...(scaleName ? {scale: scaleName} : {}),\n    field: vgField(fieldDef, opt)\n  };\n\n  if (mixins) {\n    return {\n      ...ref,\n      ...mixins\n    };\n  }\n  return ref;\n}\n\nexport function bandRef(scaleName: string, band: number | boolean = true): VgValueRef {\n  return {\n    scale: scaleName,\n    band: band\n  };\n}\n\n/**\n * Signal that returns the middle of a bin from start and end field. Should only be used with x and y.\n */\nfunction binMidSignal(scaleName: string, fieldDef: FieldDef<string>, fieldDef2?: FieldDef<string>) {\n  const start = vgField(fieldDef, {expr: 'datum'});\n  const end =\n    fieldDef2 !== undefined\n      ? vgField(fieldDef2, {expr: 'datum'})\n      : vgField(fieldDef, {binSuffix: 'end', expr: 'datum'});\n\n  return {\n    signal: `scale(\"${scaleName}\", (${start} + ${end}) / 2)`\n  };\n}\n\n/**\n * @returns {VgValueRef} Value Ref for xc / yc or mid point for other channels.\n */\nexport function midPoint(\n  channel: Channel,\n  channelDef: ChannelDef<string>,\n  channel2Def: ChannelDef<string>,\n  scaleName: string,\n  scale: ScaleComponent,\n  stack: StackProperties,\n  defaultRef: VgValueRef | (() => VgValueRef)\n): VgValueRef {\n  // TODO: datum support\n\n  if (channelDef) {\n    /* istanbul ignore else */\n\n    if (isFieldDef(channelDef)) {\n      if (isBinning(channelDef.bin)) {\n        // Use middle only for x an y to place marks in the center between start and end of the bin range.\n        // We do not use the mid point for other channels (e.g. size) so that properties of legends and marks match.\n        if (contains([X, Y], channel) && channelDef.type === QUANTITATIVE) {\n          if (stack && stack.impute) {\n            // For stack, we computed bin_mid so we can impute.\n            return fieldRef(channelDef, scaleName, {binSuffix: 'mid'});\n          }\n          // For non-stack, we can just calculate bin mid on the fly using signal.\n          return binMidSignal(scaleName, channelDef);\n        }\n        return fieldRef(channelDef, scaleName, binRequiresRange(channelDef, channel) ? {binSuffix: 'range'} : {});\n      } else if (isBinned(channelDef.bin)) {\n        if (isFieldDef(channel2Def)) {\n          return binMidSignal(scaleName, channelDef, channel2Def);\n        } else {\n          log.warn(log.message.channelRequiredForBinned(channel));\n        }\n      }\n\n      if (scale) {\n        const scaleType = scale.get('type');\n        if (hasDiscreteDomain(scaleType)) {\n          if (scaleType === 'band') {\n            // For band, to get mid point, need to offset by half of the band\n            return fieldRef(channelDef, scaleName, {binSuffix: 'range'}, {band: 0.5});\n          }\n          return fieldRef(channelDef, scaleName, {binSuffix: 'range'});\n        }\n      }\n      return fieldRef(channelDef, scaleName, {}); // no need for bin suffix\n    } else if (isValueDef(channelDef)) {\n      const value = channelDef.value;\n\n      if (contains(['x', 'x2'], channel) && value === 'width') {\n        return {field: {group: 'width'}};\n      } else if (contains(['y', 'y2'], channel) && value === 'height') {\n        return {field: {group: 'height'}};\n      }\n\n      return {value};\n    }\n\n    // If channelDef is neither field def or value def, it's a condition-only def.\n    // In such case, we will use default ref.\n  }\n\n  return isFunction(defaultRef) ? defaultRef() : defaultRef;\n}\n\nexport function tooltipForChannelDefs(channelDefs: FieldDef<string>[], config: Config) {\n  const keyValues: string[] = [];\n  const usedKey = {};\n  for (const fieldDef of channelDefs) {\n    const key = title(fieldDef, config, {allowDisabling: false});\n    const value = text(fieldDef, config).signal;\n    if (!usedKey[key]) {\n      keyValues.push(`\"${key}\": ${value}`);\n    }\n    usedKey[key] = true;\n  }\n  return keyValues.length ? {signal: `{${keyValues.join(', ')}}`} : undefined;\n}\n\nexport function text(channelDef: ChannelDefWithCondition<TextFieldDef<string>>, config: Config): VgValueRef {\n  // text\n  if (channelDef) {\n    if (isValueDef(channelDef)) {\n      return {value: channelDef.value};\n    }\n    if (isFieldDef(channelDef)) {\n      return formatSignalRef(channelDef, format(channelDef), 'datum', config);\n    }\n  }\n  return undefined;\n}\n\nexport function mid(sizeRef: SignalRef): VgValueRef {\n  return {...sizeRef, mult: 0.5};\n}\n\n/**\n * Whether the scale definitely includes zero in the domain\n */\nfunction domainDefinitelyIncludeZero(scale: ScaleComponent) {\n  if (scale.get('zero') !== false) {\n    return true;\n  }\n  const domains = scale.domains;\n  if (isArray(domains)) {\n    return some(domains, d => isArray(d) && d.length === 2 && d[0] <= 0 && d[1] >= 0);\n  }\n  return false;\n}\n\nexport function getDefaultRef(\n  defaultRef: VgValueRef | 'zeroOrMin' | 'zeroOrMax',\n  channel: 'x' | 'y',\n  scaleName: string,\n  scale: ScaleComponent,\n  mark: Mark\n) {\n  return () => {\n    if (isString(defaultRef)) {\n      if (scaleName) {\n        const scaleType = scale.get('type');\n        if (contains([ScaleType.LOG, ScaleType.TIME, ScaleType.UTC], scaleType)) {\n          // Log scales cannot have zero.\n          // Zero in time scale is arbitrary, and does not affect ratio.\n          // (Time is an interval level of measurement, not ratio).\n          // See https://en.wikipedia.org/wiki/Level_of_measurement for more info.\n          if (mark === 'bar' || mark === 'area') {\n            log.warn(log.message.nonZeroScaleUsedWithLengthMark(mark, channel, {scaleType}));\n          }\n        } else {\n          if (domainDefinitelyIncludeZero(scale)) {\n            return {\n              scale: scaleName,\n              value: 0\n            };\n          }\n          if (mark === 'bar' || mark === 'area') {\n            log.warn(\n              log.message.nonZeroScaleUsedWithLengthMark(mark, channel, {zeroFalse: scale.explicit.zero === false})\n            );\n          }\n        }\n      }\n\n      if (defaultRef === 'zeroOrMin') {\n        return channel === 'x' ? {value: 0} : {field: {group: 'height'}};\n      } else {\n        // zeroOrMax\n        return channel === 'x' ? {field: {group: 'width'}} : {value: 0};\n      }\n    }\n    return defaultRef;\n  };\n}\n","import {Axis as VgAxis, Legend as VgLegend, SignalRef, Title as VgTitle} from 'vega';\nimport {isNumber, isString} from 'vega-util';\nimport {Channel, isChannel, isScaleChannel, ScaleChannel, SingleDefChannel} from '../channel';\nimport {Config} from '../config';\nimport {Data, DataSourceType} from '../data';\nimport {forEach, reduce} from '../encoding';\nimport {ChannelDef, FieldDef, FieldRefOption, getFieldDef, vgField} from '../fielddef';\nimport * as log from '../log';\nimport {Resolve} from '../resolve';\nimport {hasDiscreteDomain} from '../scale';\nimport {BaseSpec, isFacetSpec, isLayerSpec, isUnitSpec} from '../spec';\nimport {extractTitleConfig, TitleParams} from '../title';\nimport {extractCompositionLayout, GenericCompositionLayout} from '../toplevelprops';\nimport {normalizeTransform, Transform} from '../transform';\nimport {contains, Dict, keys, varName} from '../util';\nimport {isVgRangeStep, VgData, VgEncodeEntry, VgLayout, VgMarkGroup, VgProjection, VgSignal} from '../vega.schema';\nimport {TopLevelFacetSpec} from './../spec';\nimport {assembleAxes} from './axis/assemble';\nimport {AxisComponentIndex} from './axis/component';\nimport {ConcatModel} from './concat';\nimport {DataComponent} from './data';\nimport {FacetModel} from './facet';\nimport {getHeaderGroups, getTitleGroup, HEADER_CHANNELS, LayoutHeaderComponent} from './header/index';\nimport {LayerModel} from './layer';\nimport {sizeExpr} from './layoutsize/assemble';\nimport {LayoutSizeComponent, LayoutSizeIndex} from './layoutsize/component';\nimport {assembleLegends} from './legend/assemble';\nimport {LegendComponentIndex} from './legend/component';\nimport {parseLegend} from './legend/parse';\nimport {assembleProjections} from './projection/assemble';\nimport {ProjectionComponent} from './projection/component';\nimport {parseProjection} from './projection/parse';\nimport {RepeatModel} from './repeat';\nimport {RepeaterValue} from './repeater';\nimport {assembleScales} from './scale/assemble';\nimport {ScaleComponent, ScaleComponentIndex} from './scale/component';\nimport {assembleDomain, getFieldFromDomain} from './scale/domain';\nimport {parseScale} from './scale/parse';\nimport {SelectionComponent} from './selection/selection';\nimport {Split} from './split';\nimport {UnitModel} from './unit';\n\n/**\n * Composable Components that are intermediate results of the parsing phase of the\n * compilations.  The components represents parts of the specification in a form that\n * can be easily merged (during parsing for composite specs).\n * In addition, these components are easily transformed into Vega specifications\n * during the \"assemble\" phase, which is the last phase of the compilation step.\n */\nexport interface Component {\n  data: DataComponent;\n\n  layoutSize: LayoutSizeComponent;\n\n  layoutHeaders: {\n    row?: LayoutHeaderComponent;\n    column?: LayoutHeaderComponent;\n  };\n\n  mark: VgMarkGroup[];\n  scales: ScaleComponentIndex;\n  projection: ProjectionComponent;\n  selection: Dict<SelectionComponent>;\n\n  /** Dictionary mapping channel to VgAxis definition */\n  axes: AxisComponentIndex;\n\n  /** Dictionary mapping channel to VgLegend definition */\n  legends: LegendComponentIndex;\n\n  resolve: Resolve;\n}\n\nexport interface NameMapInterface {\n  rename(oldname: string, newName: string): void;\n  has(name: string): boolean;\n  get(name: string): string;\n}\n\nexport class NameMap implements NameMapInterface {\n  private nameMap: Dict<string>;\n\n  constructor() {\n    this.nameMap = {};\n  }\n\n  public rename(oldName: string, newName: string) {\n    this.nameMap[oldName] = newName;\n  }\n\n  public has(name: string): boolean {\n    return this.nameMap[name] !== undefined;\n  }\n\n  public get(name: string): string {\n    // If the name appears in the _nameMap, we need to read its new name.\n    // We have to loop over the dict just in case the new name also gets renamed.\n    while (this.nameMap[name] && name !== this.nameMap[name]) {\n      name = this.nameMap[name];\n    }\n\n    return name;\n  }\n}\n\n/*\n  We use type guards instead of `instanceof` as `instanceof` makes\n  different parts of the compiler depend on the actual implementation of\n  the model classes, which in turn depend on different parts of the compiler.\n  Thus, `instanceof` leads to circular dependency problems.\n\n  On the other hand, type guards only make different parts of the compiler\n  depend on the type of the model classes, but not the actual implementation.\n*/\n\nexport function isUnitModel(model: Model): model is UnitModel {\n  return model && model.type === 'unit';\n}\n\nexport function isFacetModel(model: Model): model is FacetModel {\n  return model && model.type === 'facet';\n}\n\nexport function isRepeatModel(model: Model): model is RepeatModel {\n  return model && model.type === 'repeat';\n}\n\nexport function isConcatModel(model: Model): model is ConcatModel {\n  return model && model.type === 'concat';\n}\n\nexport function isLayerModel(model: Model): model is LayerModel {\n  return model && model.type === 'layer';\n}\n\nexport abstract class Model {\n  public abstract readonly type: 'unit' | 'facet' | 'layer' | 'concat' | 'repeat';\n  public readonly parent: Model;\n  public readonly name: string;\n\n  public readonly title: TitleParams;\n  public readonly description: string;\n\n  public readonly data: Data;\n  public readonly transforms: Transform[];\n  public readonly layout: GenericCompositionLayout;\n\n  /** Name map for scales, which can be renamed by a model's parent. */\n  protected scaleNameMap: NameMapInterface;\n\n  /** Name map for projections, which can be renamed by a model's parent. */\n  protected projectionNameMap: NameMapInterface;\n\n  /** Name map for size, which can be renamed by a model's parent. */\n  protected layoutSizeNameMap: NameMapInterface;\n\n  public readonly repeater: RepeaterValue;\n\n  public readonly config: Config;\n\n  public readonly component: Component;\n\n  public abstract readonly children: Model[] = [];\n\n  constructor(\n    spec: BaseSpec,\n    parent: Model,\n    parentGivenName: string,\n    config: Config,\n    repeater: RepeaterValue,\n    resolve: Resolve\n  ) {\n    this.parent = parent;\n    this.config = config;\n    this.repeater = repeater;\n\n    // If name is not provided, always use parent's givenName to avoid name conflicts.\n    this.name = spec.name || parentGivenName;\n    this.title = isString(spec.title) ? {text: spec.title} : spec.title;\n\n    // Shared name maps\n    this.scaleNameMap = parent ? parent.scaleNameMap : new NameMap();\n    this.projectionNameMap = parent ? parent.projectionNameMap : new NameMap();\n    this.layoutSizeNameMap = parent ? parent.layoutSizeNameMap : new NameMap();\n\n    this.data = spec.data;\n\n    this.description = spec.description;\n    this.transforms = normalizeTransform(spec.transform || []);\n    this.layout =\n      isUnitSpec(spec) || isLayerSpec(spec) ? undefined : extractCompositionLayout(spec as TopLevelFacetSpec);\n\n    this.component = {\n      data: {\n        sources: parent ? parent.component.data.sources : {},\n        outputNodes: parent ? parent.component.data.outputNodes : {},\n        outputNodeRefCounts: parent ? parent.component.data.outputNodeRefCounts : {},\n        // data is faceted if the spec is a facet spec or the parent has faceted data and no data is defined\n        isFaceted: isFacetSpec(spec) || (parent && parent.component.data.isFaceted && !spec.data)\n      },\n      layoutSize: new Split<LayoutSizeIndex>(),\n      layoutHeaders: {row: {}, column: {}},\n      mark: null,\n      resolve: {\n        scale: {},\n        axis: {},\n        legend: {},\n        ...(resolve || {})\n      },\n      selection: null,\n      scales: null,\n      projection: null,\n      axes: {},\n      legends: {}\n    };\n  }\n\n  public get width(): SignalRef {\n    return this.getSizeSignalRef('width');\n  }\n\n  public get height(): SignalRef {\n    return this.getSizeSignalRef('height');\n  }\n\n  protected initSize(size: LayoutSizeIndex) {\n    const {width, height} = size;\n    if (width) {\n      this.component.layoutSize.set('width', width, true);\n    }\n\n    if (height) {\n      this.component.layoutSize.set('height', height, true);\n    }\n  }\n\n  public parse() {\n    this.parseScale();\n\n    this.parseLayoutSize(); // depends on scale\n    this.renameTopLevelLayoutSize();\n\n    this.parseSelection();\n    this.parseProjection();\n    this.parseData(); // (pathorder) depends on markDef; selection filters depend on parsed selections; depends on projection because some transforms require the finalized projection name.\n    this.parseAxisAndHeader(); // depends on scale and layout size\n    this.parseLegend(); // depends on scale, markDef\n    this.parseMarkGroup(); // depends on data name, scale, layout size, axisGroup, and children's scale, axis, legend and mark.\n  }\n\n  public abstract parseData(): void;\n\n  public abstract parseSelection(): void;\n\n  public parseScale() {\n    parseScale(this);\n  }\n\n  public parseProjection() {\n    parseProjection(this);\n  }\n\n  public abstract parseLayoutSize(): void;\n\n  /**\n   * Rename top-level spec's size to be just width / height, ignoring model name.\n   * This essentially merges the top-level spec's width/height signals with the width/height signals\n   * to help us reduce redundant signals declaration.\n   */\n  private renameTopLevelLayoutSize() {\n    if (this.getName('width') !== 'width') {\n      this.renameLayoutSize(this.getName('width'), 'width');\n    }\n    if (this.getName('height') !== 'height') {\n      this.renameLayoutSize(this.getName('height'), 'height');\n    }\n  }\n\n  public abstract parseMarkGroup(): void;\n\n  public abstract parseAxisAndHeader(): void;\n\n  public parseLegend() {\n    parseLegend(this);\n  }\n\n  public abstract assembleSelectionTopLevelSignals(signals: any[]): any[];\n  public abstract assembleSelectionSignals(): any[];\n\n  public abstract assembleSelectionData(data: VgData[]): VgData[];\n\n  public assembleGroupStyle(): string {\n    if (this.type === 'unit' || this.type === 'layer') {\n      return 'cell';\n    }\n    return undefined;\n  }\n\n  public assembleLayoutSize(): VgEncodeEntry {\n    if (this.type === 'unit' || this.type === 'layer') {\n      return {\n        width: this.getSizeSignalRef('width'),\n        height: this.getSizeSignalRef('height')\n      };\n    }\n    return undefined;\n  }\n\n  public assembleLayout(): VgLayout {\n    if (!this.layout) {\n      return undefined;\n    }\n\n    const {align, bounds, center, spacing = {}} = this.layout;\n\n    return {\n      padding: isNumber(spacing)\n        ? spacing\n        : {\n            row: spacing.row || 10,\n            column: spacing.column || 10\n          },\n      ...this.assembleDefaultLayout(),\n      ...(align ? {align} : {}),\n      ...(bounds ? {bounds} : {}),\n      ...(center ? {center} : {})\n    };\n  }\n\n  protected assembleDefaultLayout(): VgLayout {\n    return {};\n  }\n\n  public abstract assembleLayoutSignals(): VgSignal[];\n\n  public assembleHeaderMarks(): VgMarkGroup[] {\n    const {layoutHeaders} = this.component;\n    let headerMarks = [];\n\n    for (const channel of HEADER_CHANNELS) {\n      if (layoutHeaders[channel].title) {\n        headerMarks.push(getTitleGroup(this, channel));\n      }\n    }\n\n    for (const channel of HEADER_CHANNELS) {\n      headerMarks = headerMarks.concat(getHeaderGroups(this, channel));\n    }\n    return headerMarks;\n  }\n\n  public abstract assembleMarks(): VgMarkGroup[]; // TODO: VgMarkGroup[]\n\n  public assembleAxes(): VgAxis[] {\n    return assembleAxes(this.component.axes, this.config);\n  }\n\n  public assembleLegends(): VgLegend[] {\n    return assembleLegends(this);\n  }\n\n  public assembleProjections(): VgProjection[] {\n    return assembleProjections(this);\n  }\n\n  public assembleTitle(): VgTitle {\n    const {encoding, ...titleNoEncoding} = this.title || ({} as TitleParams);\n\n    const title: VgTitle = {\n      ...extractTitleConfig(this.config.title).nonMark,\n      ...titleNoEncoding,\n      ...(encoding ? {encode: {update: encoding}} : {})\n    };\n\n    if (title.text) {\n      if (!contains(['unit', 'layer'], this.type)) {\n        // As described in https://github.com/vega/vega-lite/issues/2875:\n        // Due to vega/vega#960 (comment), we only support title's anchor for unit and layered spec for now.\n\n        if (title.anchor && title.anchor !== 'start') {\n          log.warn(log.message.cannotSetTitleAnchor(this.type));\n        }\n        title.anchor = 'start';\n      }\n\n      return keys(title).length > 0 ? title : undefined;\n    }\n    return undefined;\n  }\n\n  /**\n   * Assemble the mark group for this model.  We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.\n   */\n  public assembleGroup(signals: VgSignal[] = []) {\n    const group: VgMarkGroup = {};\n\n    signals = signals.concat(this.assembleSelectionSignals());\n\n    if (signals.length > 0) {\n      group.signals = signals;\n    }\n\n    const layout = this.assembleLayout();\n    if (layout) {\n      group.layout = layout;\n    }\n\n    group.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());\n\n    // Only include scales if this spec is top-level or if parent is facet.\n    // (Otherwise, it will be merged with upper-level's scope.)\n    const scales = !this.parent || isFacetModel(this.parent) ? assembleScales(this) : [];\n    if (scales.length > 0) {\n      group.scales = scales;\n    }\n\n    const axes = this.assembleAxes();\n    if (axes.length > 0) {\n      group.axes = axes;\n    }\n\n    const legends = this.assembleLegends();\n    if (legends.length > 0) {\n      group.legends = legends;\n    }\n\n    return group;\n  }\n\n  public hasDescendantWithFieldOnChannel(channel: Channel) {\n    for (const child of this.children) {\n      if (isUnitModel(child)) {\n        if (child.channelHasField(channel)) {\n          return true;\n        }\n      } else {\n        if (child.hasDescendantWithFieldOnChannel(channel)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  public getName(text: string) {\n    return varName((this.name ? this.name + '_' : '') + text);\n  }\n\n  /**\n   * Request a data source name for the given data source type and mark that data source as required. This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().\n   */\n  public requestDataName(name: DataSourceType) {\n    const fullName = this.getName(name);\n\n    // Increase ref count. This is critical because otherwise we won't create a data source.\n    // We also increase the ref counts on OutputNode.getSource() calls.\n    const refCounts = this.component.data.outputNodeRefCounts;\n    refCounts[fullName] = (refCounts[fullName] || 0) + 1;\n\n    return fullName;\n  }\n\n  public getSizeSignalRef(sizeType: 'width' | 'height'): SignalRef {\n    if (isFacetModel(this.parent)) {\n      const channel = sizeType === 'width' ? 'x' : 'y';\n      const scaleComponent = this.component.scales[channel];\n\n      if (scaleComponent && !scaleComponent.merged) {\n        // independent scale\n        const type = scaleComponent.get('type');\n        const range = scaleComponent.get('range');\n\n        if (hasDiscreteDomain(type) && isVgRangeStep(range)) {\n          const scaleName = scaleComponent.get('name');\n          const domain = assembleDomain(this, channel);\n          const field = getFieldFromDomain(domain);\n          if (field) {\n            const fieldRef = vgField({aggregate: 'distinct', field}, {expr: 'datum'});\n            return {\n              signal: sizeExpr(scaleName, scaleComponent, fieldRef)\n            };\n          } else {\n            log.warn('Unknown field for ${channel}.  Cannot calculate view size.');\n            return null;\n          }\n        }\n      }\n    }\n\n    return {\n      signal: this.layoutSizeNameMap.get(this.getName(sizeType))\n    };\n  }\n\n  /**\n   * Lookup the name of the datasource for an output node. You probably want to call this in assemble.\n   */\n  public lookupDataSource(name: string) {\n    const node = this.component.data.outputNodes[name];\n\n    if (!node) {\n      // Name not found in map so let's just return what we got.\n      // This can happen if we already have the correct name.\n      return name;\n    }\n\n    return node.getSource();\n  }\n\n  public getSizeName(oldSizeName: string): string {\n    return this.layoutSizeNameMap.get(oldSizeName);\n  }\n\n  public renameLayoutSize(oldName: string, newName: string) {\n    this.layoutSizeNameMap.rename(oldName, newName);\n  }\n\n  public renameScale(oldName: string, newName: string) {\n    this.scaleNameMap.rename(oldName, newName);\n  }\n\n  public renameProjection(oldName: string, newName: string) {\n    this.projectionNameMap.rename(oldName, newName);\n  }\n\n  /**\n   * @return scale name for a given channel after the scale has been parsed and named.\n   */\n  public scaleName(originalScaleName: Channel | string, parse?: boolean): string {\n    if (parse) {\n      // During the parse phase always return a value\n      // No need to refer to rename map because a scale can't be renamed\n      // before it has the original name.\n      return this.getName(originalScaleName);\n    }\n\n    // If there is a scale for the channel, it should either\n    // be in the scale component or exist in the name map\n    if (\n      // If there is a scale for the channel, there should be a local scale component for it\n      (isChannel(originalScaleName) && isScaleChannel(originalScaleName) && this.component.scales[originalScaleName]) ||\n      // in the scale name map (the scale get merged by its parent)\n      this.scaleNameMap.has(this.getName(originalScaleName))\n    ) {\n      return this.scaleNameMap.get(this.getName(originalScaleName));\n    }\n    return undefined;\n  }\n\n  /**\n   * @return projection name after the projection has been parsed and named.\n   */\n  public projectionName(parse?: boolean): string {\n    if (parse) {\n      // During the parse phase always return a value\n      // No need to refer to rename map because a projection can't be renamed\n      // before it has the original name.\n      return this.getName('projection');\n    }\n\n    if (\n      (this.component.projection && !this.component.projection.merged) ||\n      this.projectionNameMap.has(this.getName('projection'))\n    ) {\n      return this.projectionNameMap.get(this.getName('projection'));\n    }\n    return undefined;\n  }\n\n  /**\n   * Corrects the data references in marks after assemble.\n   */\n  public correctDataNames = (mark: VgMarkGroup) => {\n    // TODO: make this correct\n\n    // for normal data references\n    if (mark.from && mark.from.data) {\n      mark.from.data = this.lookupDataSource(mark.from.data);\n    }\n\n    // for access to facet data\n    if (mark.from && mark.from.facet && mark.from.facet.data) {\n      mark.from.facet.data = this.lookupDataSource(mark.from.facet.data);\n    }\n\n    return mark;\n  };\n\n  /**\n   * Traverse a model's hierarchy to get the scale component for a particular channel.\n   */\n  public getScaleComponent(channel: ScaleChannel): ScaleComponent {\n    /* istanbul ignore next: This is warning for debugging test */\n    if (!this.component.scales) {\n      throw new Error(\n        'getScaleComponent cannot be called before parseScale().  Make sure you have called parseScale or use parseUnitModelWithScale().'\n      );\n    }\n\n    const localScaleComponent = this.component.scales[channel];\n    if (localScaleComponent && !localScaleComponent.merged) {\n      return localScaleComponent;\n    }\n    return this.parent ? this.parent.getScaleComponent(channel) : undefined;\n  }\n\n  /**\n   * Traverse a model's hierarchy to get a particular selection component.\n   */\n  public getSelectionComponent(variableName: string, origName: string): SelectionComponent {\n    let sel = this.component.selection[variableName];\n    if (!sel && this.parent) {\n      sel = this.parent.getSelectionComponent(variableName, origName);\n    }\n    if (!sel) {\n      throw new Error(log.message.selectionNotFound(origName));\n    }\n    return sel;\n  }\n}\n\n/** Abstract class for UnitModel and FacetModel.  Both of which can contain fieldDefs as a part of its own specification. */\nexport abstract class ModelWithField extends Model {\n  public abstract fieldDef(channel: SingleDefChannel): FieldDef<string>;\n\n  /** Get \"field\" reference for Vega */\n  public vgField(channel: SingleDefChannel, opt: FieldRefOption = {}) {\n    const fieldDef = this.fieldDef(channel);\n\n    if (!fieldDef) {\n      return undefined;\n    }\n\n    return vgField(fieldDef, opt);\n  }\n\n  protected abstract getMapping(): {[key in Channel]?: any};\n\n  public reduceFieldDef<T, U>(f: (acc: U, fd: FieldDef<string>, c: Channel) => U, init: T, t?: any) {\n    return reduce(\n      this.getMapping(),\n      (acc: U, cd: ChannelDef<string>, c: Channel) => {\n        const fieldDef = getFieldDef(cd);\n        if (fieldDef) {\n          return f(acc, fieldDef, c);\n        }\n        return acc;\n      },\n      init,\n      t\n    );\n  }\n\n  public forEachFieldDef(f: (fd: FieldDef<string>, c: Channel) => void, t?: any) {\n    forEach(\n      this.getMapping(),\n      (cd: ChannelDef<string>, c: Channel) => {\n        const fieldDef = getFieldDef(cd);\n        if (fieldDef) {\n          f(fieldDef, c);\n        }\n      },\n      t\n    );\n  }\n  public abstract channelHasField(channel: Channel): boolean;\n}\n","import {SignalRef} from 'vega';\nimport {contains} from '../../util';\nimport {isSignalRef, VgProjection} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, isRepeatModel, Model} from '../model';\n\nexport function assembleProjections(model: Model): VgProjection[] {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    return assembleProjectionsForModelAndChildren(model);\n  } else {\n    return assembleProjectionForModel(model);\n  }\n}\n\nexport function assembleProjectionsForModelAndChildren(model: Model): VgProjection[] {\n  return model.children.reduce((projections, child) => {\n    return projections.concat(child.assembleProjections());\n  }, assembleProjectionForModel(model));\n}\n\nexport function assembleProjectionForModel(model: Model): VgProjection[] {\n  const component = model.component.projection;\n  if (!component || component.merged) {\n    return [];\n  }\n\n  const projection = component.combine();\n  const {name, ...rest} = projection; // we need to extract name so that it is always present in the output and pass TS type validation\n\n  const size: SignalRef = {\n    signal: `[${component.size.map(ref => ref.signal).join(', ')}]`\n  };\n\n  const fit: string[] = component.data.reduce((sources, data) => {\n    const source: string = isSignalRef(data) ? data.signal : `data('${model.lookupDataSource(data)}')`;\n    if (!contains(sources, source)) {\n      // build a unique list of sources\n      sources.push(source);\n    }\n    return sources;\n  }, []);\n\n  if (fit.length <= 0) {\n    throw new Error(\"Projection's fit didn't find any data sources\");\n  }\n\n  return [\n    {\n      name,\n      size,\n      fit: {\n        signal: fit.length > 1 ? `[${fit.join(', ')}]` : fit[0]\n      },\n      ...rest\n    }\n  ];\n}\n","import {SignalRef} from 'vega';\nimport {Projection} from '../../projection';\nimport {VgProjection} from '../../vega.schema';\nimport {Split} from '../split';\n\nexport class ProjectionComponent extends Split<VgProjection> {\n  public merged = false;\n\n  constructor(\n    name: string,\n    public specifiedProjection: Projection,\n    public size: SignalRef[],\n    public data: (string | SignalRef)[]\n  ) {\n    super(\n      {...specifiedProjection}, // all explicit properties of projection\n      {name} // name as initial implicit property\n    );\n  }\n}\n","import {SignalRef} from 'vega';\nimport {LATITUDE, LATITUDE2, LONGITUDE, LONGITUDE2, SHAPE} from '../../channel';\nimport {MAIN} from '../../data';\nimport {PROJECTION_PROPERTIES} from '../../projection';\nimport {GEOJSON} from '../../type';\nimport {duplicate, every, stringify} from '../../util';\nimport {isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport {ProjectionComponent} from './component';\n\nexport function parseProjection(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.projection = parseUnitProjection(model);\n  } else {\n    // because parse happens from leaves up (unit specs before layer spec),\n    // we can be sure that the above if statement has already occurred\n    // and therefore we have access to child.component.projection\n    // for each of model's children\n    model.component.projection = parseNonUnitProjections(model);\n  }\n}\n\nfunction parseUnitProjection(model: UnitModel): ProjectionComponent {\n  const {specifiedProjection, config, hasProjection} = model;\n\n  if (hasProjection) {\n    const data: (SignalRef | string)[] = [];\n\n    [[LONGITUDE, LATITUDE], [LONGITUDE2, LATITUDE2]].forEach(posssiblePair => {\n      if (model.channelHasField(posssiblePair[0]) || model.channelHasField(posssiblePair[1])) {\n        data.push({\n          signal: model.getName(`geojson_${data.length}`)\n        });\n      }\n    });\n\n    if (model.channelHasField(SHAPE) && model.fieldDef(SHAPE).type === GEOJSON) {\n      data.push({\n        signal: model.getName(`geojson_${data.length}`)\n      });\n    }\n\n    if (data.length === 0) {\n      // main source is geojson, so we can just use that\n      data.push(model.requestDataName(MAIN));\n    }\n\n    return new ProjectionComponent(\n      model.projectionName(true),\n      {\n        ...(config.projection || {}),\n        ...(specifiedProjection || {})\n      },\n      [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')],\n      data\n    );\n  }\n\n  return undefined;\n}\n\nfunction mergeIfNoConflict(first: ProjectionComponent, second: ProjectionComponent): ProjectionComponent {\n  const allPropertiesShared = every(PROJECTION_PROPERTIES, prop => {\n    // neither has the poperty\n    if (!first.explicit.hasOwnProperty(prop) && !second.explicit.hasOwnProperty(prop)) {\n      return true;\n    }\n    // both have property and an equal value for property\n    if (\n      first.explicit.hasOwnProperty(prop) &&\n      second.explicit.hasOwnProperty(prop) &&\n      // some properties might be signals or objects and require hashing for comparison\n      stringify(first.get(prop)) === stringify(second.get(prop))\n    ) {\n      return true;\n    }\n    return false;\n  });\n\n  const size = stringify(first.size) === stringify(second.size);\n  if (size) {\n    if (allPropertiesShared) {\n      return first;\n    } else if (stringify(first.explicit) === stringify({})) {\n      return second;\n    } else if (stringify(second.explicit) === stringify({})) {\n      return first;\n    }\n  }\n\n  // if all properties don't match, let each unit spec have its own projection\n  return null;\n}\n\nfunction parseNonUnitProjections(model: Model): ProjectionComponent {\n  if (model.children.length === 0) {\n    return undefined;\n  }\n\n  let nonUnitProjection: ProjectionComponent;\n  const mergable = every(model.children, child => {\n    parseProjection(child);\n    const projection = child.component.projection;\n    if (!projection) {\n      // child layer does not use a projection\n      return true;\n    } else if (!nonUnitProjection) {\n      // cached 'projection' is null, cache this one\n      nonUnitProjection = projection;\n      return true;\n    } else {\n      const merge = mergeIfNoConflict(nonUnitProjection, projection);\n      if (merge) {\n        nonUnitProjection = merge;\n      }\n      return !!merge;\n    }\n  });\n\n  // it cached one and all other children share the same projection,\n  if (nonUnitProjection && mergable) {\n    // so we can elevate it to the layer level\n    const name = model.projectionName(true);\n    const modelProjection = new ProjectionComponent(\n      name,\n      nonUnitProjection.specifiedProjection,\n      nonUnitProjection.size,\n      duplicate(nonUnitProjection.data)\n    );\n\n    // rename and assign all others as merged\n    model.children.forEach(child => {\n      if (child.component.projection) {\n        modelProjection.data = modelProjection.data.concat(child.component.projection.data);\n        child.renameProjection(child.component.projection.get('name'), name);\n        child.component.projection.merged = true;\n      }\n    });\n\n    return modelProjection;\n  }\n\n  return undefined;\n}\n","import {Config} from '../config';\nimport * as log from '../log';\nimport {Repeat} from '../repeat';\nimport {NormalizedRepeatSpec} from '../spec';\nimport {VgLayout} from '../vega.schema';\nimport {BaseConcatModel} from './baseconcat';\nimport {buildModel} from './buildmodel';\nimport {parseRepeatLayoutSize} from './layoutsize/parse';\nimport {Model} from './model';\nimport {RepeaterValue} from './repeater';\n\nexport class RepeatModel extends BaseConcatModel {\n  public readonly type: 'repeat' = 'repeat';\n  public readonly repeat: Repeat;\n\n  public readonly children: Model[];\n\n  constructor(\n    spec: NormalizedRepeatSpec,\n    parent: Model,\n    parentGivenName: string,\n    repeatValues: RepeaterValue,\n    config: Config\n  ) {\n    super(spec, parent, parentGivenName, config, repeatValues, spec.resolve);\n\n    if (spec.resolve && spec.resolve.axis && (spec.resolve.axis.x === 'shared' || spec.resolve.axis.y === 'shared')) {\n      log.warn(log.message.REPEAT_CANNOT_SHARE_AXIS);\n    }\n\n    this.repeat = spec.repeat;\n    this.children = this._initChildren(spec, this.repeat, repeatValues, config);\n  }\n\n  private _initChildren(spec: NormalizedRepeatSpec, repeat: Repeat, repeater: RepeaterValue, config: Config): Model[] {\n    const children: Model[] = [];\n    const row = repeat.row || [repeater ? repeater.row : null];\n    const column = repeat.column || [repeater ? repeater.column : null];\n\n    // cross product\n    for (const rowField of row) {\n      for (const columnField of column) {\n        const name = (rowField ? '_' + rowField : '') + (columnField ? '_' + columnField : '');\n\n        const childRepeat = {\n          row: rowField,\n          column: columnField\n        };\n\n        children.push(buildModel(spec.spec, this, this.getName('child' + name), undefined, childRepeat, config, false));\n      }\n    }\n\n    return children;\n  }\n\n  public parseLayoutSize() {\n    parseRepeatLayoutSize(this);\n  }\n\n  protected assembleDefaultLayout(): VgLayout {\n    return {\n      columns: this.repeat && this.repeat.column ? this.repeat.column.length : 1,\n      bounds: 'full',\n      align: 'all'\n    };\n  }\n}\n","import {isArray} from 'vega-util';\nimport {Encoding} from '../encoding';\nimport {FacetMapping} from '../facet';\nimport {Field, hasConditionalFieldDef, isConditionalDef, isFieldDef, isRepeatRef, ValueDef} from '../fielddef';\nimport {ChannelDef, ScaleFieldDef} from '../fielddef';\nimport * as log from '../log';\nimport {isSortField} from '../sort';\n\nexport interface RepeaterValue {\n  row?: string;\n  column?: string;\n}\n\nexport function replaceRepeaterInFacet(facet: FacetMapping<Field>, repeater: RepeaterValue): FacetMapping<string> {\n  return replaceRepeater(facet, repeater) as FacetMapping<string>;\n}\n\nexport function replaceRepeaterInEncoding(encoding: Encoding<Field>, repeater: RepeaterValue): Encoding<string> {\n  return replaceRepeater(encoding, repeater) as Encoding<string>;\n}\n\n/**\n * Replaces repeated value and returns if the repeated value is valid.\n */\nfunction replaceRepeat<T extends {field?: Field}>(o: T, repeater: RepeaterValue): T {\n  if (isRepeatRef(o.field)) {\n    if (o.field.repeat in repeater) {\n      // any needed to calm down ts compiler\n      return {...(o as any), field: repeater[o.field.repeat]};\n    } else {\n      log.warn(log.message.noSuchRepeatedValue(o.field.repeat));\n      return undefined;\n    }\n  }\n  return o;\n}\n\n/**\n * Replace repeater values in a field def with the concrete field name.\n */\nfunction replaceRepeaterInFieldDef(fieldDef: ScaleFieldDef<Field>, repeater: RepeaterValue): ScaleFieldDef<string> {\n  fieldDef = replaceRepeat(fieldDef, repeater);\n\n  if (fieldDef === undefined) {\n    // the field def should be ignored\n    return undefined;\n  }\n\n  if (fieldDef.sort && isSortField(fieldDef.sort)) {\n    const sort = replaceRepeat(fieldDef.sort, repeater);\n    fieldDef = {\n      ...fieldDef,\n      ...(sort ? {sort} : {})\n    };\n  }\n\n  return fieldDef as ScaleFieldDef<string>;\n}\n\nfunction replaceRepeaterInChannelDef(channelDef: ChannelDef<Field>, repeater: RepeaterValue): ChannelDef<string> {\n  if (isFieldDef(channelDef)) {\n    const fd = replaceRepeaterInFieldDef(channelDef, repeater);\n    if (fd) {\n      return fd;\n    } else if (isConditionalDef(channelDef)) {\n      return {condition: channelDef.condition};\n    }\n  } else {\n    if (hasConditionalFieldDef(channelDef)) {\n      const fd = replaceRepeaterInFieldDef(channelDef.condition, repeater);\n      if (fd) {\n        return {\n          ...channelDef,\n          condition: fd\n        } as ChannelDef<string>;\n      } else {\n        const {condition, ...channelDefWithoutCondition} = channelDef;\n        return channelDefWithoutCondition as ChannelDef<string>;\n      }\n    }\n    return channelDef as ValueDef;\n  }\n  return undefined;\n}\n\ntype EncodingOrFacet<F> = Encoding<F> | FacetMapping<F>;\n\nfunction replaceRepeater(mapping: EncodingOrFacet<Field>, repeater: RepeaterValue): EncodingOrFacet<string> {\n  const out: EncodingOrFacet<string> = {};\n  for (const channel in mapping) {\n    if (mapping.hasOwnProperty(channel)) {\n      const channelDef: ChannelDef<Field> | ChannelDef<Field>[] = mapping[channel];\n\n      if (isArray(channelDef)) {\n        // array cannot have condition\n        out[channel] = channelDef.map(cd => replaceRepeaterInChannelDef(cd, repeater)).filter(cd => cd);\n      } else {\n        const cd = replaceRepeaterInChannelDef(channelDef, repeater);\n        if (cd) {\n          out[channel] = cd;\n        }\n      }\n    }\n  }\n  return out;\n}\n","import {POSITION_SCALE_CHANNELS, ScaleChannel} from '../channel';\nimport * as log from '../log';\nimport {Resolve, ResolveMode} from '../resolve';\nimport {contains} from '../util';\nimport {isConcatModel, isFacetModel, isLayerModel, isRepeatModel, Model} from './model';\n\nexport function defaultScaleResolve(channel: ScaleChannel, model: Model): ResolveMode {\n  if (isLayerModel(model) || isFacetModel(model)) {\n    return 'shared';\n  } else if (isConcatModel(model) || isRepeatModel(model)) {\n    return contains(POSITION_SCALE_CHANNELS, channel) ? 'independent' : 'shared';\n  }\n  /* istanbul ignore next: should never reach here. */\n  throw new Error('invalid model type for resolve');\n}\n\nexport function parseGuideResolve(resolve: Resolve, channel: ScaleChannel): ResolveMode {\n  const channelScaleResolve = resolve.scale[channel];\n  const guide = contains(POSITION_SCALE_CHANNELS, channel) ? 'axis' : 'legend';\n\n  if (channelScaleResolve === 'independent') {\n    if (resolve[guide][channel] === 'shared') {\n      log.warn(log.message.independentScaleMeansIndependentGuide(channel));\n    }\n    return 'independent';\n  }\n\n  return resolve[guide][channel] || 'shared';\n}\n","import {isArray} from 'vega-util';\nimport {Channel, ScaleChannel} from '../../channel';\nimport {keys} from '../../util';\nimport {isSignalRef, isVgRangeStep, VgRange, VgScale} from '../../vega.schema';\nimport {isConcatModel, isLayerModel, isRepeatModel, Model} from '../model';\nimport {isRawSelectionDomain, selectionScaleDomain} from '../selection/selection';\nimport {assembleDomain} from './domain';\n\nexport function assembleScales(model: Model): VgScale[] {\n  if (isLayerModel(model) || isConcatModel(model) || isRepeatModel(model)) {\n    // For concat / layer / repeat, include scales of children too\n    return model.children.reduce((scales, child) => {\n      return scales.concat(assembleScales(child));\n    }, assembleScalesForModel(model));\n  } else {\n    // For facet, child scales would not be included in the parent's scope.\n    // For unit, there is no child.\n    return assembleScalesForModel(model);\n  }\n}\n\nexport function assembleScalesForModel(model: Model): VgScale[] {\n  return keys(model.component.scales).reduce(\n    (scales: VgScale[], channel: ScaleChannel) => {\n      const scaleComponent = model.component.scales[channel];\n      if (scaleComponent.merged) {\n        // Skipped merged scales\n        return scales;\n      }\n\n      const scale = scaleComponent.combine();\n\n      // need to separate const and non const object destruction\n      let {domainRaw, range} = scale;\n      const {name, type, domainRaw: _d, range: _r, ...otherScaleProps} = scale;\n\n      range = assembleScaleRange(range, name, model, channel);\n\n      // As scale parsing occurs before selection parsing, a temporary signal\n      // is used for domainRaw. Here, we detect if this temporary signal\n      // is set, and replace it with the correct domainRaw signal.\n      // For more information, see isRawSelectionDomain in selection.ts.\n      if (domainRaw && isRawSelectionDomain(domainRaw)) {\n        domainRaw = selectionScaleDomain(model, domainRaw);\n      }\n\n      scales.push({\n        name,\n        type,\n        domain: assembleDomain(model, channel),\n        ...(domainRaw ? {domainRaw} : {}),\n        range: range,\n        ...otherScaleProps\n      });\n\n      return scales;\n    },\n    [] as VgScale[]\n  );\n}\n\nexport function assembleScaleRange(scaleRange: VgRange, scaleName: string, model: Model, channel: Channel) {\n  // add signals to x/y range\n  if (channel === 'x' || channel === 'y') {\n    if (isVgRangeStep(scaleRange)) {\n      // For x/y range step, use a signal created in layout assemble instead of a constant range step.\n      return {\n        step: {signal: scaleName + '_step'}\n      };\n    } else if (isArray(scaleRange) && scaleRange.length === 2) {\n      const r0 = scaleRange[0];\n      const r1 = scaleRange[1];\n      if (r0 === 0 && isSignalRef(r1)) {\n        // Replace width signal just in case it is renamed.\n        return [0, {signal: model.getSizeName(r1.signal)}];\n      } else if (isSignalRef(r0) && r1 === 0) {\n        // Replace height signal just in case it is renamed.\n        return [{signal: model.getSizeName(r0.signal)}, 0];\n      }\n    }\n  }\n  return scaleRange;\n}\n","import {ScaleChannel} from '../../channel';\nimport {Scale, ScaleType} from '../../scale';\nimport {Omit} from '../../util';\nimport {VgNonUnionDomain, VgScale} from '../../vega.schema';\nimport {Explicit, Split} from '../split';\n\n/**\n * All VgDomain property except domain.\n * (We exclude domain as we have a special \"domains\" array that allow us merge them all at once in assemble.)\n */\n// TODO: also exclude domainRaw and property implement the right scaleComponent for selection domain\nexport type ScaleComponentProps = Omit<VgScale, 'domain'>;\n\nexport class ScaleComponent extends Split<ScaleComponentProps> {\n  public merged = false;\n\n  public domains: VgNonUnionDomain[] = [];\n\n  constructor(name: string, typeWithExplicit: Explicit<ScaleType>) {\n    super(\n      {}, // no initial explicit property\n      {name} // name as initial implicit property\n    );\n    this.setWithExplicit('type', typeWithExplicit);\n  }\n}\n\n// Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\nexport type ScaleComponentIndex = {[P in ScaleChannel]?: ScaleComponent};\n\nexport type ScaleIndex = {[P in ScaleChannel]?: Scale};\n","import {isString} from 'vega-util';\nimport {SHARED_DOMAIN_OP_INDEX} from '../../aggregate';\nimport {binToString, isBinning, isBinParams} from '../../bin';\nimport {isScaleChannel, ScaleChannel} from '../../channel';\nimport {MAIN, RAW} from '../../data';\nimport {DateTime} from '../../datetime';\nimport {FieldDef, ScaleFieldDef, valueExpr, vgField} from '../../fielddef';\nimport * as log from '../../log';\nimport {Domain, hasDiscreteDomain, isBinScale, isSelectionDomain, ScaleConfig, ScaleType} from '../../scale';\nimport {EncodingSortField, isSortArray, isSortField} from '../../sort';\nimport {TimeUnit} from '../../timeunit';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {\n  isDataRefDomain,\n  isDataRefUnionedDomain,\n  isFieldRefUnionDomain,\n  VgDataRef,\n  VgDomain,\n  VgFieldRefUnionDomain,\n  VgNonUnionDomain,\n  VgSortField,\n  VgUnionSortField\n} from '../../vega.schema';\nimport {binRequiresRange} from '../common';\nimport {sortArrayIndexField} from '../data/calculate';\nimport {FACET_SCALE_PREFIX} from '../data/optimize';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {SELECTION_DOMAIN} from '../selection/selection';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\n\nexport function parseScaleDomain(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleDomain(model);\n  } else {\n    parseNonUnitScaleDomain(model);\n  }\n}\n\nfunction parseUnitScaleDomain(model: UnitModel) {\n  const scales = model.specifiedScales;\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const specifiedScale = scales[channel];\n    const specifiedDomain = specifiedScale ? specifiedScale.domain : undefined;\n\n    const domains = parseDomainForChannel(model, channel);\n    const localScaleCmpt = localScaleComponents[channel];\n    localScaleCmpt.domains = domains;\n\n    if (isSelectionDomain(specifiedDomain)) {\n      // As scale parsing occurs before selection parsing, we use a temporary\n      // signal here and append the scale.domain definition. This is replaced\n      // with the correct domainRaw signal during scale assembly.\n      // For more information, see isRawSelectionDomain in selection.ts.\n\n      // FIXME: replace this with a special property in the scaleComponent\n      localScaleCmpt.set(\n        'domainRaw',\n        {\n          signal: SELECTION_DOMAIN + util.hash(specifiedDomain)\n        },\n        true\n      );\n    }\n\n    if (model.component.data.isFaceted) {\n      // get resolve from closest facet parent as this decides whether we need to refer to cloned subtree or not\n      let facetParent: Model = model;\n      while (!isFacetModel(facetParent) && facetParent.parent) {\n        facetParent = facetParent.parent;\n      }\n\n      const resolve = facetParent.component.resolve.scale[channel];\n\n      if (resolve === 'shared') {\n        for (const domain of domains) {\n          // Replace the scale domain with data output from a cloned subtree after the facet.\n          if (isDataRefDomain(domain)) {\n            // use data from cloned subtree (which is the same as data but with a prefix added once)\n            domain.data = FACET_SCALE_PREFIX + domain.data.replace(FACET_SCALE_PREFIX, '');\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction parseNonUnitScaleDomain(model: Model) {\n  for (const child of model.children) {\n    parseScaleDomain(child);\n  }\n\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  util.keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let domains: VgNonUnionDomain[];\n    let domainRaw = null;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        if (domains === undefined) {\n          domains = childComponent.domains;\n        } else {\n          domains = domains.concat(childComponent.domains);\n        }\n\n        const dr = childComponent.get('domainRaw');\n        if (domainRaw && dr && domainRaw.signal !== dr.signal) {\n          log.warn('The same selection must be used to override scale domains in a layered view.');\n        }\n        domainRaw = dr;\n      }\n    }\n\n    localScaleComponents[channel].domains = domains;\n\n    if (domainRaw) {\n      localScaleComponents[channel].set('domainRaw', domainRaw, true);\n    }\n  });\n}\n\n/**\n * Remove unaggregated domain if it is not applicable\n * Add unaggregated domain if domain is not specified and config.scale.useUnaggregatedDomain is true.\n */\nfunction normalizeUnaggregatedDomain(\n  domain: Domain,\n  fieldDef: FieldDef<string>,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig\n) {\n  if (domain === 'unaggregated') {\n    const {valid, reason} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (!valid) {\n      log.warn(reason);\n      return undefined;\n    }\n  } else if (domain === undefined && scaleConfig.useUnaggregatedDomain) {\n    // Apply config if domain is not specified.\n    const {valid} = canUseUnaggregatedDomain(fieldDef, scaleType);\n    if (valid) {\n      return 'unaggregated';\n    }\n  }\n\n  return domain;\n}\n\nexport function parseDomainForChannel(model: UnitModel, channel: ScaleChannel): VgNonUnionDomain[] {\n  const scaleType = model.getScaleComponent(channel).get('type');\n\n  const domain = normalizeUnaggregatedDomain(\n    model.scaleDomain(channel),\n    model.fieldDef(channel),\n    scaleType,\n    model.config.scale\n  );\n  if (domain !== model.scaleDomain(channel)) {\n    model.specifiedScales[channel] = {\n      ...model.specifiedScales[channel],\n      domain\n    };\n  }\n\n  // If channel is either X or Y then union them with X2 & Y2 if they exist\n  if (channel === 'x' && model.channelHasField('x2')) {\n    if (model.channelHasField('x')) {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x').concat(\n        parseSingleChannelDomain(scaleType, domain, model, 'x2')\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'x2');\n    }\n  } else if (channel === 'y' && model.channelHasField('y2')) {\n    if (model.channelHasField('y')) {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y').concat(\n        parseSingleChannelDomain(scaleType, domain, model, 'y2')\n      );\n    } else {\n      return parseSingleChannelDomain(scaleType, domain, model, 'y2');\n    }\n  }\n  return parseSingleChannelDomain(scaleType, domain, model, channel);\n}\n\nfunction mapDomainToDataSignal<T>(domain: T[], type: Type, timeUnit: TimeUnit) {\n  return domain.map(v => {\n    const data = valueExpr(v, {timeUnit, type});\n    return {signal: `{data: ${data}}`};\n  });\n}\n\nfunction parseSingleChannelDomain(\n  scaleType: ScaleType,\n  domain: Domain,\n  model: UnitModel,\n  channel: ScaleChannel | 'x2' | 'y2'\n): VgNonUnionDomain[] {\n  const fieldDef = model.fieldDef(channel);\n\n  if (domain && domain !== 'unaggregated' && !isSelectionDomain(domain)) {\n    // explicit value\n    const {type, timeUnit} = fieldDef;\n    if (type === 'temporal' || timeUnit) {\n      return mapDomainToDataSignal<number | string | boolean | DateTime>(domain, type, timeUnit);\n    }\n\n    return [domain];\n  }\n\n  const stack = model.stack;\n  if (stack && channel === stack.fieldChannel) {\n    if (stack.offset === 'normalize') {\n      return [[0, 1]];\n    }\n\n    const data = model.requestDataName(MAIN);\n    return [\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'start'})\n      },\n      {\n        data,\n        field: model.vgField(channel, {suffix: 'end'})\n      }\n    ];\n  }\n\n  const sort = isScaleChannel(channel) ? domainSort(model, channel, scaleType) : undefined;\n\n  if (domain === 'unaggregated') {\n    const data = model.requestDataName(MAIN);\n    const {field} = fieldDef;\n    return [\n      {\n        data,\n        field: vgField({field, aggregate: 'min'})\n      },\n      {\n        data,\n        field: vgField({field, aggregate: 'max'})\n      }\n    ];\n  } else if (isBinning(fieldDef.bin)) {\n    // bin\n    if (isBinScale(scaleType)) {\n      const signal = model.getName(`${binToString(fieldDef.bin)}_${fieldDef.field}_bins`);\n      return [{signal: `sequence(${signal}.start, ${signal}.stop + ${signal}.step, ${signal}.step)`}];\n    }\n\n    if (hasDiscreteDomain(scaleType)) {\n      // ordinal bin scale takes domain from bin_range, ordered by bin start\n      // This is useful for both axis-based scale (x/y) and legend-based scale (other channels).\n      return [\n        {\n          // If sort by aggregation of a specified sort field, we need to use RAW table,\n          // so we can aggregate values for the scale independently from the main aggregation.\n          data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n          // Use range if we added it and the scale does not support computing a range as a signal.\n          field: model.vgField(channel, binRequiresRange(fieldDef, channel) ? {binSuffix: 'range'} : {}),\n          // we have to use a sort object if sort = true to make the sort correct by bin start\n          sort:\n            sort === true || !isSortField(sort)\n              ? {\n                  field: model.vgField(channel, {}),\n                  op: 'min' // min or max doesn't matter since we sort by the start of the bin range\n                }\n              : sort\n        }\n      ];\n    } else {\n      // continuous scales\n      if (channel === 'x' || channel === 'y') {\n        if (isBinParams(fieldDef.bin) && fieldDef.bin.extent) {\n          return [fieldDef.bin.extent];\n        }\n        // X/Y position have to include start and end for non-ordinal scale\n        const data = model.requestDataName(MAIN);\n        return [\n          {\n            data,\n            field: model.vgField(channel, {})\n          },\n          {\n            data,\n            field: model.vgField(channel, {binSuffix: 'end'})\n          }\n        ];\n      } else {\n        // TODO: use bin_mid\n        return [\n          {\n            data: model.requestDataName(MAIN),\n            field: model.vgField(channel, {})\n          }\n        ];\n      }\n    }\n  } else if (sort) {\n    return [\n      {\n        // If sort by aggregation of a specified sort field, we need to use RAW table,\n        // so we can aggregate values for the scale independently from the main aggregation.\n        data: util.isBoolean(sort) ? model.requestDataName(MAIN) : model.requestDataName(RAW),\n        field: model.vgField(channel),\n        sort: sort\n      }\n    ];\n  } else {\n    return [\n      {\n        data: model.requestDataName(MAIN),\n        field: model.vgField(channel)\n      }\n    ];\n  }\n}\n\nexport function domainSort(\n  model: UnitModel,\n  channel: ScaleChannel,\n  scaleType: ScaleType\n): true | EncodingSortField<string> {\n  if (!hasDiscreteDomain(scaleType)) {\n    return undefined;\n  }\n\n  const fieldDef: ScaleFieldDef<string> = model.fieldDef(channel);\n  const sort = fieldDef.sort;\n\n  // if the sort is specified with array, use the derived sort index field\n  if (isSortArray(sort)) {\n    return {\n      op: 'min',\n      field: sortArrayIndexField(fieldDef, channel),\n      order: 'ascending'\n    };\n  }\n\n  // Sorted based on an aggregate calculation over a specified sort field (only for ordinal scale)\n  if (isSortField(sort)) {\n    // flatten nested fields\n    return {\n      ...sort,\n      ...(sort.field ? {field: util.replacePathInField(sort.field)} : {})\n    };\n  }\n\n  if (sort === 'descending') {\n    return {\n      op: 'min',\n      field: model.vgField(channel),\n      order: 'descending'\n    };\n  }\n\n  if (util.contains(['ascending', undefined /* default =ascending*/], sort)) {\n    return true;\n  }\n\n  // sort == null\n  return undefined;\n}\n\n/**\n * Determine if a scale can use unaggregated domain.\n * @return {Boolean} Returns true if all of the following conditons applies:\n * 1. `scale.domain` is `unaggregated`\n * 2. Aggregation function is not `count` or `sum`\n * 3. The scale is quantitative or time scale.\n */\nexport function canUseUnaggregatedDomain(\n  fieldDef: FieldDef<string>,\n  scaleType: ScaleType\n): {valid: boolean; reason?: string} {\n  if (!fieldDef.aggregate) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainHasNoEffectForRawField(fieldDef)\n    };\n  }\n\n  if (!SHARED_DOMAIN_OP_INDEX[fieldDef.aggregate]) {\n    return {\n      valid: false,\n      reason: log.message.unaggregateDomainWithNonSharedDomainOp(fieldDef.aggregate)\n    };\n  }\n\n  if (fieldDef.type === 'quantitative') {\n    if (scaleType === 'log') {\n      return {\n        valid: false,\n        reason: log.message.unaggregatedDomainWithLogScale(fieldDef)\n      };\n    }\n  }\n\n  return {valid: true};\n}\n\n/**\n * Converts an array of domains to a single Vega scale domain.\n */\nexport function mergeDomains(domains: VgNonUnionDomain[]): VgDomain {\n  const uniqueDomains = util.unique(\n    domains.map(domain => {\n      // ignore sort property when computing the unique domains\n      if (isDataRefDomain(domain)) {\n        const {sort: _s, ...domainWithoutSort} = domain;\n        return domainWithoutSort;\n      }\n      return domain;\n    }),\n    util.hash\n  );\n\n  const sorts: VgSortField[] = util.unique(\n    domains\n      .map(d => {\n        if (isDataRefDomain(d)) {\n          const s = d.sort;\n          if (s !== undefined && !util.isBoolean(s)) {\n            if (s.op === 'count') {\n              // let's make sure that if op is count, we don't use a field\n              delete s.field;\n            }\n            if (s.order === 'ascending') {\n              // drop order: ascending as it is the default\n              delete s.order;\n            }\n          }\n          return s;\n        }\n        return undefined;\n      })\n      .filter(s => s !== undefined),\n    util.hash\n  );\n\n  if (uniqueDomains.length === 1) {\n    const domain = domains[0];\n    if (isDataRefDomain(domain) && sorts.length > 0) {\n      let sort = sorts[0];\n      if (sorts.length > 1) {\n        log.warn(log.message.MORE_THAN_ONE_SORT);\n        sort = true;\n      }\n      return {\n        ...domain,\n        sort\n      };\n    }\n    return domain;\n  }\n\n  // only keep simple sort properties that work with unioned domains\n  const simpleSorts = util.unique(\n    sorts.map(s => {\n      if (util.isBoolean(s)) {\n        return s;\n      }\n      if (s.op === 'count') {\n        return s;\n      }\n      log.warn(log.message.domainSortDropped(s));\n      return true;\n    }),\n    util.hash\n  ) as VgUnionSortField[];\n\n  let sort: VgUnionSortField;\n\n  if (simpleSorts.length === 1) {\n    sort = simpleSorts[0];\n  } else if (simpleSorts.length > 1) {\n    log.warn(log.message.MORE_THAN_ONE_SORT);\n    sort = true;\n  }\n\n  const allData = util.unique(\n    domains.map(d => {\n      if (isDataRefDomain(d)) {\n        return d.data;\n      }\n      return null;\n    }),\n    x => x\n  );\n\n  if (allData.length === 1 && allData[0] !== null) {\n    // create a union domain of different fields with a single data source\n    const domain: VgFieldRefUnionDomain = {\n      data: allData[0],\n      fields: uniqueDomains.map(d => (d as VgDataRef).field),\n      ...(sort ? {sort} : {})\n    };\n\n    return domain;\n  }\n\n  return {fields: uniqueDomains, ...(sort ? {sort} : {})};\n}\n\n/**\n * Return a field if a scale single field.\n * Return `undefined` otherwise.\n *\n */\nexport function getFieldFromDomain(domain: VgDomain): string {\n  if (isDataRefDomain(domain) && isString(domain.field)) {\n    return domain.field;\n  } else if (isDataRefUnionedDomain(domain)) {\n    let field;\n    for (const nonUnionDomain of domain.fields) {\n      if (isDataRefDomain(nonUnionDomain) && isString(nonUnionDomain.field)) {\n        if (!field) {\n          field = nonUnionDomain.field;\n        } else if (field !== nonUnionDomain.field) {\n          log.warn(\n            'Detected faceted independent scales that union domain of multiple fields from different data sources.  We will use the first field.  The result view size may be incorrect.'\n          );\n          return field;\n        }\n      }\n    }\n    log.warn(\n      'Detected faceted independent scales that union domain of identical fields from different source detected.  We will assume that this is the same field from a different fork of the same data source.  However, if this is not case, the result view size maybe incorrect.'\n    );\n    return field;\n  } else if (isFieldRefUnionDomain(domain)) {\n    log.warn(\n      'Detected faceted independent scales that union domain of multiple fields from the same data source.  We will use the first field.  The result view size may be incorrect.'\n    );\n    const field = domain.fields[0];\n    return isString(field) ? field : undefined;\n  }\n\n  return undefined;\n}\n\nexport function assembleDomain(model: Model, channel: ScaleChannel) {\n  const scaleComponent = model.component.scales[channel];\n  const domains = scaleComponent.domains.map(domain => {\n    // Correct references to data as the original domain's data was determined\n    // in parseScale, which happens before parseData. Thus the original data\n    // reference can be incorrect.\n\n    if (isDataRefDomain(domain)) {\n      domain.data = model.lookupDataSource(domain.data);\n    }\n    return domain;\n  });\n\n  // domains is an array that has to be merged into a single vega domain\n  return mergeDomains(domains);\n}\n","import {SCALE_CHANNELS, ScaleChannel, SHAPE, X, Y} from '../../channel';\nimport {FieldDef, getFieldDef, hasConditionalFieldDef, isFieldDef} from '../../fielddef';\nimport {GEOSHAPE} from '../../mark';\nimport {\n  NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES,\n  Scale,\n  scaleCompatible,\n  ScaleType,\n  scaleTypePrecedence\n} from '../../scale';\nimport {GEOJSON} from '../../type';\nimport {keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {defaultScaleResolve} from '../resolve';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponent, ScaleComponentIndex} from './component';\nimport {parseScaleDomain} from './domain';\nimport {parseScaleProperty} from './properties';\nimport {parseScaleRange} from './range';\nimport {scaleType} from './type';\n\nexport function parseScale(model: Model) {\n  parseScaleCore(model);\n  parseScaleDomain(model);\n  for (const prop of NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES) {\n    parseScaleProperty(model, prop);\n  }\n  // range depends on zero\n  parseScaleRange(model);\n}\n\nexport function parseScaleCore(model: Model) {\n  if (isUnitModel(model)) {\n    model.component.scales = parseUnitScaleCore(model);\n  } else {\n    model.component.scales = parseNonUnitScaleCore(model);\n  }\n}\n\n/**\n * Parse scales for all channels of a model.\n */\nfunction parseUnitScaleCore(model: UnitModel): ScaleComponentIndex {\n  const {encoding, config, mark} = model;\n\n  return SCALE_CHANNELS.reduce((scaleComponents: ScaleComponentIndex, channel: ScaleChannel) => {\n    let fieldDef: FieldDef<string>;\n    let specifiedScale: Scale | null;\n\n    const channelDef = encoding[channel];\n\n    // Don't generate scale for shape of geoshape\n    if (isFieldDef(channelDef) && mark === GEOSHAPE && channel === SHAPE && channelDef.type === GEOJSON) {\n      return scaleComponents;\n    }\n\n    if (isFieldDef(channelDef)) {\n      fieldDef = channelDef;\n      specifiedScale = channelDef.scale;\n    } else if (hasConditionalFieldDef(channelDef)) {\n      fieldDef = channelDef.condition;\n      specifiedScale = channelDef.condition['scale']; // We use ['scale'] since we know that channel here has scale for sure\n    } else if (channel === X) {\n      fieldDef = getFieldDef(encoding.x2);\n    } else if (channel === Y) {\n      fieldDef = getFieldDef(encoding.y2);\n    }\n\n    if (fieldDef && specifiedScale !== null && specifiedScale !== false) {\n      specifiedScale = specifiedScale || {};\n\n      const sType = scaleType(specifiedScale, channel, fieldDef, mark, config.scale);\n      scaleComponents[channel] = new ScaleComponent(model.scaleName(channel + '', true), {\n        value: sType,\n        explicit: specifiedScale.type === sType\n      });\n    }\n    return scaleComponents;\n  }, {});\n}\n\nconst scaleTypeTieBreaker = tieBreakByComparing(\n  (st1: ScaleType, st2: ScaleType) => scaleTypePrecedence(st1) - scaleTypePrecedence(st2)\n);\n\nfunction parseNonUnitScaleCore(model: Model) {\n  const scaleComponents: ScaleComponentIndex = (model.component.scales = {});\n\n  const scaleTypeWithExplicitIndex: {\n    // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n    [k in ScaleChannel]?: Explicit<ScaleType>\n  } = {};\n  const resolve = model.component.resolve;\n\n  // Parse each child scale and determine if a particular channel can be merged.\n  for (const child of model.children) {\n    parseScaleCore(child);\n\n    // Instead of always merging right away -- check if it is compatible to merge first!\n    keys(child.component.scales).forEach((channel: ScaleChannel) => {\n      // if resolve is undefined, set default first\n      resolve.scale[channel] = resolve.scale[channel] || defaultScaleResolve(channel, model);\n\n      if (resolve.scale[channel] === 'shared') {\n        const explicitScaleType = scaleTypeWithExplicitIndex[channel];\n        const childScaleType = child.component.scales[channel].getWithExplicit('type');\n\n        if (explicitScaleType) {\n          if (scaleCompatible(explicitScaleType.value, childScaleType.value)) {\n            // merge scale component if type are compatible\n            scaleTypeWithExplicitIndex[channel] = mergeValuesWithExplicit<VgScale, ScaleType>(\n              explicitScaleType,\n              childScaleType,\n              'type',\n              'scale',\n              scaleTypeTieBreaker\n            );\n          } else {\n            // Otherwise, update conflicting channel to be independent\n            resolve.scale[channel] = 'independent';\n            // Remove from the index so they don't get merged\n            delete scaleTypeWithExplicitIndex[channel];\n          }\n        } else {\n          scaleTypeWithExplicitIndex[channel] = childScaleType;\n        }\n      }\n    });\n  }\n\n  // Merge each channel listed in the index\n  keys(scaleTypeWithExplicitIndex).forEach((channel: ScaleChannel) => {\n    // Create new merged scale component\n    const name = model.scaleName(channel, true);\n    const typeWithExplicit = scaleTypeWithExplicitIndex[channel];\n    scaleComponents[channel] = new ScaleComponent(name, typeWithExplicit);\n\n    // rename each child and mark them as merged\n    for (const child of model.children) {\n      const childScale = child.component.scales[channel];\n      if (childScale) {\n        child.renameScale(childScale.get('name'), name);\n        childScale.merged = true;\n      }\n    }\n  });\n\n  return scaleComponents;\n}\n","import {Channel, COLOR, FILL, ScaleChannel, STROKE, X, Y} from '../../channel';\nimport {Config} from '../../config';\nimport {FieldDef, ScaleFieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {BarConfig, MarkDef} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  isContinuousToContinuous,\n  isContinuousToDiscrete,\n  NiceTime,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty\n} from '../../scale';\nimport {Sort} from '../../sort';\nimport * as util from '../../util';\nimport {contains, keys} from '../../util';\nimport {VgScale} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {Explicit, mergeValuesWithExplicit, tieBreakByComparing} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex, ScaleComponentProps} from './component';\nimport {parseScaleRange} from './range';\n\nexport function parseScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  if (isUnitModel(model)) {\n    parseUnitScaleProperty(model, property);\n  } else {\n    parseNonUnitScaleProperty(model, property);\n  }\n}\n\nfunction parseUnitScaleProperty(model: UnitModel, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    const specifiedScale = model.specifiedScales[channel];\n    const localScaleCmpt = localScaleComponents[channel];\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n    const fieldDef = model.fieldDef(channel);\n    const config = model.config;\n\n    const specifiedValue = specifiedScale[property];\n    const sType = mergedScaleCmpt.get('type');\n\n    const supportedByScaleType = scaleTypeSupportProperty(sType, property);\n    const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n\n    if (specifiedValue !== undefined) {\n      // If there is a specified value, check if it is compatible with scale type and channel\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(sType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      }\n    }\n    if (supportedByScaleType && channelIncompatability === undefined) {\n      if (specifiedValue !== undefined) {\n        // copyKeyFromObject ensure type safety\n        localScaleCmpt.copyKeyFromObject(property, specifiedScale);\n      } else {\n        const value = getDefaultValue(\n          property,\n          channel,\n          fieldDef,\n          mergedScaleCmpt.get('type'),\n          mergedScaleCmpt.get('padding'),\n          mergedScaleCmpt.get('paddingInner'),\n          specifiedScale.domain,\n          model.markDef,\n          config\n        );\n        if (value !== undefined) {\n          localScaleCmpt.set(property, value, false);\n        }\n      }\n    }\n  });\n}\n\n// Note: This method is used in Voyager.\nexport function getDefaultValue(\n  property: keyof Scale,\n  channel: Channel,\n  fieldDef: ScaleFieldDef<string>,\n  scaleType: ScaleType,\n  scalePadding: number,\n  scalePaddingInner: number,\n  specifiedDomain: Scale['domain'],\n  markDef: MarkDef,\n  config: Config\n) {\n  const scaleConfig = config.scale;\n\n  // If we have default rule-base, determine default value first\n  switch (property) {\n    case 'interpolate':\n      return interpolate(channel, scaleType);\n    case 'nice':\n      return nice(scaleType, channel, fieldDef);\n    case 'padding':\n      return padding(channel, scaleType, scaleConfig, fieldDef, markDef, config.bar);\n    case 'paddingInner':\n      return paddingInner(scalePadding, channel, scaleConfig);\n    case 'paddingOuter':\n      return paddingOuter(scalePadding, channel, scaleType, scalePaddingInner, scaleConfig);\n    case 'reverse':\n      return reverse(scaleType, fieldDef.sort);\n    case 'zero':\n      return zero(channel, fieldDef, specifiedDomain, markDef, scaleType);\n  }\n  // Otherwise, use scale config\n  return scaleConfig[property];\n}\n\nexport function parseNonUnitScaleProperty(model: Model, property: keyof (Scale | ScaleComponentProps)) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  for (const child of model.children) {\n    if (property === 'range') {\n      parseScaleRange(child);\n    } else {\n      parseScaleProperty(child, property);\n    }\n  }\n\n  keys(localScaleComponents).forEach((channel: ScaleChannel) => {\n    let valueWithExplicit: Explicit<any>;\n\n    for (const child of model.children) {\n      const childComponent = child.component.scales[channel];\n      if (childComponent) {\n        const childValueWithExplicit = childComponent.getWithExplicit(property);\n        valueWithExplicit = mergeValuesWithExplicit<VgScale, any>(\n          valueWithExplicit,\n          childValueWithExplicit,\n          property,\n          'scale',\n          tieBreakByComparing<VgScale, any>((v1, v2) => {\n            switch (property) {\n              case 'range':\n                // For range step, prefer larger step\n                if (v1.step && v2.step) {\n                  return v1.step - v2.step;\n                }\n                return 0;\n              // TODO: precedence rule for other properties\n            }\n            return 0;\n          })\n        );\n      }\n    }\n    localScaleComponents[channel].setWithExplicit(property, valueWithExplicit);\n  });\n}\n\nexport function interpolate(channel: Channel, scaleType: ScaleType) {\n  if (contains([COLOR, FILL, STROKE], channel) && isContinuousToContinuous(scaleType)) {\n    return 'hcl';\n  }\n  return undefined;\n}\n\nexport function nice(scaleType: ScaleType, channel: Channel, fieldDef: FieldDef<string>): boolean | NiceTime {\n  if (fieldDef.bin || util.contains([ScaleType.TIME, ScaleType.UTC], scaleType)) {\n    return undefined;\n  }\n  return util.contains([X, Y], channel) ? true : undefined;\n}\n\nexport function padding(\n  channel: Channel,\n  scaleType: ScaleType,\n  scaleConfig: ScaleConfig,\n  fieldDef: FieldDef<string>,\n  markDef: MarkDef,\n  barConfig: BarConfig\n) {\n  if (util.contains([X, Y], channel)) {\n    if (isContinuousToContinuous(scaleType)) {\n      if (scaleConfig.continuousPadding !== undefined) {\n        return scaleConfig.continuousPadding;\n      }\n\n      const {type, orient} = markDef;\n      if (type === 'bar' && !fieldDef.bin) {\n        if ((orient === 'vertical' && channel === 'x') || (orient === 'horizontal' && channel === 'y')) {\n          return barConfig.continuousBandSize;\n        }\n      }\n    }\n\n    if (scaleType === ScaleType.POINT) {\n      return scaleConfig.pointPadding;\n    }\n  }\n  return undefined;\n}\n\nexport function paddingInner(paddingValue: number, channel: Channel, scaleConfig: ScaleConfig) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingInner.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n\n    // paddingOuter would only be called if it's a band scale, just return the default for bandScale.\n    return scaleConfig.bandPaddingInner;\n  }\n  return undefined;\n}\n\nexport function paddingOuter(\n  paddingValue: number,\n  channel: Channel,\n  scaleType: ScaleType,\n  paddingInnerValue: number,\n  scaleConfig: ScaleConfig\n) {\n  if (paddingValue !== undefined) {\n    // If user has already manually specified \"padding\", no need to add default paddingOuter.\n    return undefined;\n  }\n\n  if (util.contains([X, Y], channel)) {\n    // Padding is only set for X and Y by default.\n    // Basically it doesn't make sense to add padding for color and size.\n    if (scaleType === ScaleType.BAND) {\n      if (scaleConfig.bandPaddingOuter !== undefined) {\n        return scaleConfig.bandPaddingOuter;\n      }\n      /* By default, paddingOuter is paddingInner / 2. The reason is that\n          size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).\n          and we want the width/height to be integer by default.\n          Note that step (by default) and cardinality are integers.) */\n      return paddingInnerValue / 2;\n    }\n  }\n  return undefined;\n}\n\nexport function reverse(scaleType: ScaleType, sort: Sort<string>) {\n  if (hasContinuousDomain(scaleType) && sort === 'descending') {\n    // For continuous domain scales, Vega does not support domain sort.\n    // Thus, we reverse range instead if sort is descending\n    return true;\n  }\n  return undefined;\n}\n\nexport function zero(\n  channel: Channel,\n  fieldDef: FieldDef<string>,\n  specifiedScale: Domain,\n  markDef: MarkDef,\n  scaleType: ScaleType\n) {\n  // If users explicitly provide a domain range, we should not augment zero as that will be unexpected.\n  const hasCustomDomain = !!specifiedScale && specifiedScale !== 'unaggregated';\n  if (hasCustomDomain) {\n    return false;\n  }\n\n  // If there is no custom domain, return true only for the following cases:\n\n  // 1) using quantitative field with size\n  // While this can be either ratio or interval fields, our assumption is that\n  // ratio are more common. However, if the scaleType is discretizing scale, we want to return\n  // false so that range doesn't start at zero\n  if (channel === 'size' && fieldDef.type === 'quantitative' && !isContinuousToDiscrete(scaleType)) {\n    return true;\n  }\n\n  // 2) non-binned, quantitative x-scale or y-scale\n  // (For binning, we should not include zero by default because binning are calculated without zero.)\n  if (!fieldDef.bin && util.contains([X, Y], channel)) {\n    const {orient, type} = markDef;\n    if (contains(['bar', 'area', 'line', 'trail'], type)) {\n      if ((orient === 'horizontal' && channel === 'y') || (orient === 'vertical' && channel === 'x')) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  return false;\n}\n","import {isArray, isNumber} from 'vega-util';\nimport {Channel, COLOR, FILL, OPACITY, SCALE_CHANNELS, ScaleChannel, SHAPE, SIZE, STROKE, X, Y} from '../../channel';\nimport {Config, isVgScheme} from '../../config';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {\n  channelScalePropertyIncompatability,\n  Domain,\n  hasContinuousDomain,\n  isContinuousToContinuous,\n  isContinuousToDiscrete,\n  isExtendedScheme,\n  Range,\n  Scale,\n  ScaleConfig,\n  ScaleType,\n  scaleTypeSupportProperty,\n  Scheme\n} from '../../scale';\nimport {Type} from '../../type';\nimport * as util from '../../util';\nimport {isVgRangeStep, VgRange, VgScheme} from '../../vega.schema';\nimport {isUnitModel, Model} from '../model';\nimport {Explicit, makeExplicit, makeImplicit} from '../split';\nimport {UnitModel} from '../unit';\nimport {ScaleComponentIndex} from './component';\nimport {parseNonUnitScaleProperty} from './properties';\n\nexport type RangeMixins = {range: Range} | {rangeStep: number} | {scheme: Scheme};\n\nexport const RANGE_PROPERTIES: (keyof Scale)[] = ['range', 'rangeStep', 'scheme'];\n\nexport function parseScaleRange(model: Model) {\n  if (isUnitModel(model)) {\n    parseUnitScaleRange(model);\n  } else {\n    parseNonUnitScaleProperty(model, 'range');\n  }\n}\n\nfunction parseUnitScaleRange(model: UnitModel) {\n  const localScaleComponents: ScaleComponentIndex = model.component.scales;\n\n  // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!\n  SCALE_CHANNELS.forEach((channel: ScaleChannel) => {\n    const localScaleCmpt = localScaleComponents[channel];\n    if (!localScaleCmpt) {\n      return;\n    }\n    const mergedScaleCmpt = model.getScaleComponent(channel);\n\n    const specifiedScale = model.specifiedScales[channel];\n    const fieldDef = model.fieldDef(channel);\n\n    // Read if there is a specified width/height\n    const sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;\n    let sizeSpecified = sizeType ? !!model.component.layoutSize.get(sizeType) : undefined;\n\n    const scaleType = mergedScaleCmpt.get('type');\n\n    // if autosize is fit, size cannot be data driven\n    const rangeStep = util.contains(['point', 'band'], scaleType) || !!specifiedScale.rangeStep;\n    if (sizeType && model.fit && !sizeSpecified && rangeStep) {\n      log.warn(log.message.CANNOT_FIX_RANGE_STEP_WITH_FIT);\n      sizeSpecified = true;\n    }\n\n    const xyRangeSteps = getXYRangeStep(model);\n\n    const rangeWithExplicit = parseRangeForChannel(\n      channel,\n      scaleType,\n      fieldDef.type,\n      specifiedScale,\n      model.config,\n      localScaleCmpt.get('zero'),\n      model.mark,\n      sizeSpecified,\n      model.getName(sizeType),\n      xyRangeSteps\n    );\n\n    localScaleCmpt.setWithExplicit('range', rangeWithExplicit);\n  });\n}\n\nfunction getXYRangeStep(model: UnitModel) {\n  const xyRangeSteps: number[] = [];\n\n  const xScale = model.getScaleComponent('x');\n  const xRange = xScale && xScale.get('range');\n  if (xRange && isVgRangeStep(xRange) && isNumber(xRange.step)) {\n    xyRangeSteps.push(xRange.step);\n  }\n\n  const yScale = model.getScaleComponent('y');\n  const yRange = yScale && yScale.get('range');\n  if (yRange && isVgRangeStep(yRange) && isNumber(yRange.step)) {\n    xyRangeSteps.push(yRange.step);\n  }\n\n  return xyRangeSteps;\n}\n\n/**\n * Return mixins that includes one of the range properties (range, rangeStep, scheme).\n */\nexport function parseRangeForChannel(\n  channel: Channel,\n  scaleType: ScaleType,\n  type: Type,\n  specifiedScale: Scale,\n  config: Config,\n  zero: boolean,\n  mark: Mark,\n  sizeSpecified: boolean,\n  sizeSignal: string,\n  xyRangeSteps: number[]\n): Explicit<VgRange> {\n  const noRangeStep = sizeSpecified || specifiedScale.rangeStep === null;\n\n  // Check if any of the range properties is specified.\n  // If so, check if it is compatible and make sure that we only output one of the properties\n  for (const property of RANGE_PROPERTIES) {\n    if (specifiedScale[property] !== undefined) {\n      const supportedByScaleType = scaleTypeSupportProperty(scaleType, property);\n      const channelIncompatability = channelScalePropertyIncompatability(channel, property);\n      if (!supportedByScaleType) {\n        log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));\n      } else if (channelIncompatability) {\n        // channel\n        log.warn(channelIncompatability);\n      } else {\n        switch (property) {\n          case 'range':\n            return makeExplicit(specifiedScale[property]);\n          case 'scheme':\n            return makeExplicit(parseScheme(specifiedScale[property]));\n          case 'rangeStep':\n            const rangeStep = specifiedScale[property];\n            if (rangeStep !== null) {\n              if (!sizeSpecified) {\n                return makeExplicit({step: rangeStep});\n              } else {\n                // If top-level size is specified, we ignore specified rangeStep.\n                log.warn(log.message.rangeStepDropped(channel));\n              }\n            }\n        }\n      }\n    }\n  }\n  return makeImplicit(\n    defaultRange(\n      channel,\n      scaleType,\n      type,\n      config,\n      zero,\n      mark,\n      sizeSignal,\n      xyRangeSteps,\n      noRangeStep,\n      specifiedScale.domain\n    )\n  );\n}\n\nfunction parseScheme(scheme: Scheme) {\n  if (isExtendedScheme(scheme)) {\n    const r: VgScheme = {scheme: scheme.name};\n    if (scheme.count) {\n      r.count = scheme.count;\n    }\n    if (scheme.extent) {\n      r.extent = scheme.extent;\n    }\n    return r;\n  }\n  return {scheme: scheme};\n}\n\nexport function defaultRange(\n  channel: Channel,\n  scaleType: ScaleType,\n  type: Type,\n  config: Config,\n  zero: boolean,\n  mark: Mark,\n  sizeSignal: string,\n  xyRangeSteps: number[],\n  noRangeStep: boolean,\n  domain: Domain\n): VgRange {\n  switch (channel) {\n    case X:\n    case Y:\n      if (util.contains(['point', 'band'], scaleType) && !noRangeStep) {\n        if (channel === X && mark === 'text') {\n          if (config.scale.textXRangeStep) {\n            return {step: config.scale.textXRangeStep};\n          }\n        } else {\n          if (config.scale.rangeStep) {\n            return {step: config.scale.rangeStep};\n          }\n        }\n      }\n\n      // If range step is null, use zero to width or height.\n      // Note that these range signals are temporary\n      // as they can be merged and renamed.\n      // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)\n      // We will later replace these temporary names with\n      // the final name in assembleScaleRange()\n\n      if (channel === Y && hasContinuousDomain(scaleType)) {\n        // For y continuous scale, we have to start from the height as the bottom part has the max value.\n        return [{signal: sizeSignal}, 0];\n      } else {\n        return [0, {signal: sizeSignal}];\n      }\n    case SIZE:\n      // TODO: support custom rangeMin, rangeMax\n      const rangeMin = sizeRangeMin(mark, zero, config);\n      const rangeMax = sizeRangeMax(mark, xyRangeSteps, config);\n      if (isContinuousToDiscrete(scaleType)) {\n        return interpolateRange(\n          rangeMin,\n          rangeMax,\n          defaultContinuousToDiscreteCount(scaleType, config, domain, channel)\n        );\n      } else {\n        return [rangeMin, rangeMax];\n      }\n    case SHAPE:\n      return 'symbol';\n    case COLOR:\n    case FILL:\n    case STROKE:\n      if (scaleType === 'ordinal') {\n        // Only nominal data uses ordinal scale by default\n        return type === 'nominal' ? 'category' : 'ordinal';\n      } else if (isContinuousToDiscrete(scaleType)) {\n        const count = defaultContinuousToDiscreteCount(scaleType, config, domain, channel);\n        if (config.range && isVgScheme(config.range.ordinal)) {\n          return {\n            ...config.range.ordinal,\n            count\n          };\n        } else {\n          return {scheme: 'blues', count};\n        }\n      } else if (isContinuousToContinuous(scaleType)) {\n        // Manually set colors for now. We will revise this after https://github.com/vega/vega/issues/1369\n        return ['#f7fbff', '#0e427f'];\n      } else {\n        return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';\n      }\n    case OPACITY:\n      // TODO: support custom rangeMin, rangeMax\n      return [config.scale.minOpacity, config.scale.maxOpacity];\n  }\n  /* istanbul ignore next: should never reach here */\n  throw new Error(`Scale range undefined for channel ${channel}`);\n}\n\nexport function defaultContinuousToDiscreteCount(\n  scaleType: 'quantile' | 'quantize' | 'threshold',\n  config: Config,\n  domain: Domain,\n  channel: Channel\n) {\n  switch (scaleType) {\n    case 'quantile':\n      return config.scale.quantileCount;\n    case 'quantize':\n      return config.scale.quantizeCount;\n    case 'threshold':\n      if (domain !== undefined && isArray(domain)) {\n        return domain.length + 1;\n      } else {\n        log.warn(log.message.domainRequiredForThresholdScale(channel));\n        // default threshold boundaries for threshold scale since domain has cardinality of 2\n        return 3;\n      }\n  }\n}\n\n/**\n * Returns the linear interpolation of the range according to the cardinality\n *\n * @param rangeMin start of the range\n * @param rangeMax end of the range\n * @param cardinality number of values in the output range\n */\nexport function interpolateRange(rangeMin: number, rangeMax: number, cardinality: number) {\n  const ranges: number[] = [];\n  const step = (rangeMax - rangeMin) / (cardinality - 1);\n  for (let i = 0; i < cardinality; i++) {\n    ranges.push(rangeMin + i * step);\n  }\n  return ranges;\n}\n\nfunction sizeRangeMin(mark: Mark, zero: boolean, config: Config) {\n  if (zero) {\n    return 0;\n  }\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      return config.scale.minBandSize;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.minStrokeWidth;\n    case 'text':\n      return config.scale.minFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      return config.scale.minSize;\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMin not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\nfunction sizeRangeMax(mark: Mark, xyRangeSteps: number[], config: Config) {\n  const scaleConfig = config.scale;\n  switch (mark) {\n    case 'bar':\n    case 'tick':\n      if (config.scale.maxBandSize !== undefined) {\n        return config.scale.maxBandSize;\n      }\n      return minXYRangeStep(xyRangeSteps, config.scale) - 1;\n    case 'line':\n    case 'trail':\n    case 'rule':\n      return config.scale.maxStrokeWidth;\n    case 'text':\n      return config.scale.maxFontSize;\n    case 'point':\n    case 'square':\n    case 'circle':\n      if (config.scale.maxSize) {\n        return config.scale.maxSize;\n      }\n\n      // FIXME this case totally should be refactored\n      const pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);\n      return (pointStep - 2) * (pointStep - 2);\n  }\n  /* istanbul ignore next: should never reach here */\n  // sizeRangeMax not implemented for the mark\n  throw new Error(log.message.incompatibleChannel('size', mark));\n}\n\n/**\n * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.\n */\nfunction minXYRangeStep(xyRangeSteps: number[], scaleConfig: ScaleConfig): number {\n  if (xyRangeSteps.length > 0) {\n    return Math.min.apply(null, xyRangeSteps);\n  }\n  if (scaleConfig.rangeStep) {\n    return scaleConfig.rangeStep;\n  }\n  return 21; // FIXME: re-evaluate the default value here.\n}\n","import {isArray} from 'vega-util';\nimport {isBinning} from '../../bin';\nimport {Channel, isColorChannel, isScaleChannel, rangeType} from '../../channel';\nimport {FieldDef} from '../../fielddef';\nimport * as log from '../../log';\nimport {Mark} from '../../mark';\nimport {channelSupportScaleType, Scale, ScaleConfig, ScaleType, scaleTypeSupportDataType} from '../../scale';\nimport * as util from '../../util';\n\nexport type RangeType = 'continuous' | 'discrete' | 'flexible' | undefined;\n\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nexport function scaleType(\n  specifiedScale: Scale,\n  channel: Channel,\n  fieldDef: FieldDef<string>,\n  mark: Mark,\n  scaleConfig: ScaleConfig\n): ScaleType {\n  const defaultScaleType = defaultType(channel, fieldDef, mark, specifiedScale, scaleConfig);\n  const {type} = specifiedScale;\n\n  if (!isScaleChannel(channel)) {\n    // There is no scale for these channels\n    return null;\n  }\n  if (type !== undefined) {\n    // Check if explicitly specified scale type is supported by the channel\n    if (!channelSupportScaleType(channel, type)) {\n      log.warn(log.message.scaleTypeNotWorkWithChannel(channel, type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    // Check if explicitly specified scale type is supported by the data type\n    if (!scaleTypeSupportDataType(type, fieldDef.type, fieldDef.bin)) {\n      log.warn(log.message.scaleTypeNotWorkWithFieldDef(type, defaultScaleType));\n      return defaultScaleType;\n    }\n\n    return type;\n  }\n\n  return defaultScaleType;\n}\n\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(\n  channel: Channel,\n  fieldDef: FieldDef<string>,\n  mark: Mark,\n  specifiedScale: Scale,\n  scaleConfig: ScaleConfig\n): ScaleType {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n      if (isColorChannel(channel) || rangeType(channel) === 'discrete') {\n        if (channel === 'shape' && fieldDef.type === 'ordinal') {\n          log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n        }\n        return 'ordinal';\n      }\n\n      if (util.contains(['x', 'y'], channel)) {\n        if (util.contains(['rect', 'bar', 'rule'], mark)) {\n          // The rect/bar mark should fit into a band.\n          // For rule, using band scale to make rule align with axis ticks better https://github.com/vega/vega-lite/issues/3429\n          return 'band';\n        }\n        if (mark === 'bar') {\n          return 'band';\n        }\n      }\n      // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n      return 'point';\n\n    case 'temporal':\n      if (isColorChannel(channel)) {\n        return 'sequential';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n      return 'time';\n\n    case 'quantitative':\n      if (isColorChannel(channel)) {\n        if (isBinning(fieldDef.bin)) {\n          return 'bin-ordinal';\n        }\n\n        const {domain = undefined, range = undefined} = specifiedScale || {};\n        if (domain && isArray(domain) && domain.length > 2 && (range && isArray(range) && range.length > 2)) {\n          // If there are piecewise domain and range specified, use lineaer as default color scale as sequential does not support piecewise domain\n          return 'linear';\n        }\n\n        // Use `sequential` as the default color scale for continuous data\n        // since it supports both array range and scheme range.\n        return 'sequential';\n      } else if (rangeType(channel) === 'discrete') {\n        log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n        // TODO: consider using quantize (equivalent to binning) once we have it\n        return 'ordinal';\n      }\n\n      // x and y use a linear scale because selections don't work with bin scales.\n      // Binned scales apply discretization but pan/zoom apply transformations to a [min, max] extent domain.\n      if (isBinning(fieldDef.bin) && channel !== 'x' && channel !== 'y') {\n        return 'bin-linear';\n      }\n      return 'linear';\n\n    case 'geojson':\n      return undefined;\n  }\n\n  /* istanbul ignore next: should never reach this */\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n","import {stringValue} from 'vega-util';\nimport {X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {hasContinuousDomain, isBinScale} from '../../scale';\nimport {keys} from '../../util';\nimport {VgEventStream} from '../../vega.schema';\nimport {UnitModel} from '../unit';\nimport {\n  channelSignalName,\n  positionalProjections,\n  SelectionCompiler,\n  SelectionComponent,\n  STORE,\n  TUPLE,\n  unitName\n} from './selection';\nimport scales from './transforms/scales';\n\nexport const BRUSH = '_brush';\nexport const SCALE_TRIGGER = '_scale_trigger';\n\nconst interval: SelectionCompiler = {\n  predicate: 'vlInterval',\n  scaleDomain: 'vlIntervalDomain',\n\n  signals: (model, selCmpt) => {\n    const name = selCmpt.name;\n    const hasScales = scales.has(selCmpt);\n    const signals: any[] = [];\n    const intervals: any[] = [];\n    const tupleTriggers: string[] = [];\n    const scaleTriggers: any[] = [];\n\n    if (selCmpt.translate && !hasScales) {\n      const filterExpr = `!event.item || event.item.mark.name !== ${stringValue(name + BRUSH)}`;\n      events(selCmpt, (_: any[], evt: VgEventStream) => {\n        const filters = evt.between[0].filter || (evt.between[0].filter = []);\n        if (filters.indexOf(filterExpr) < 0) {\n          filters.push(filterExpr);\n        }\n      });\n    }\n\n    for (const p of selCmpt.project) {\n      const channel = p.channel;\n      if (channel !== X && channel !== Y) {\n        warn('Interval selections only support x and y encoding channels.');\n        continue;\n      }\n\n      const cs = channelSignals(model, selCmpt, channel);\n      const dname = channelSignalName(selCmpt, channel, 'data');\n      const vname = channelSignalName(selCmpt, channel, 'visual');\n      const scaleStr = stringValue(model.scaleName(channel));\n      const scaleType = model.getScaleComponent(channel).get('type');\n      const toNum = hasContinuousDomain(scaleType) ? '+' : '';\n\n      signals.push.apply(signals, cs);\n      tupleTriggers.push(dname);\n      intervals.push(`{encoding: ${stringValue(channel)}, ` + `field: ${stringValue(p.field)}, extent: ${dname}}`);\n\n      scaleTriggers.push({\n        scaleName: model.scaleName(channel),\n        expr:\n          `(!isArray(${dname}) || ` +\n          `(${toNum}invert(${scaleStr}, ${vname})[0] === ${toNum}${dname}[0] && ` +\n          `${toNum}invert(${scaleStr}, ${vname})[1] === ${toNum}${dname}[1]))`\n      });\n    }\n\n    // Proxy scale reactions to ensure that an infinite loop doesn't occur\n    // when an interval selection filter touches the scale.\n    if (!hasScales) {\n      signals.push({\n        name: name + SCALE_TRIGGER,\n        update: scaleTriggers.map(t => t.expr).join(' && ') + ` ? ${name + SCALE_TRIGGER} : {}`\n      });\n    }\n\n    // Only add an interval to the store if it has valid data extents. Data extents\n    // are set to null if pixel extents are equal to account for intervals over\n    // ordinal/nominal domains which, when inverted, will still produce a valid datum.\n    return signals.concat({\n      name: name + TUPLE,\n      on: [\n        {\n          events: tupleTriggers.map(t => ({signal: t})),\n          update:\n            tupleTriggers.join(' && ') + ` ? {unit: ${unitName(model)}, intervals: [${intervals.join(', ')}]} : null`\n        }\n      ]\n    });\n  },\n\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`);\n  },\n\n  marks: (model, selCmpt, marks) => {\n    const name = selCmpt.name;\n    const {xi, yi} = positionalProjections(selCmpt);\n    const store = `data(${stringValue(selCmpt.name + STORE)})`;\n\n    // Do not add a brush if we're binding to scales.\n    if (scales.has(selCmpt)) {\n      return marks;\n    }\n\n    const update: any = {\n      x: xi !== null ? {signal: `${name}_x[0]`} : {value: 0},\n      y: yi !== null ? {signal: `${name}_y[0]`} : {value: 0},\n      x2: xi !== null ? {signal: `${name}_x[1]`} : {field: {group: 'width'}},\n      y2: yi !== null ? {signal: `${name}_y[1]`} : {field: {group: 'height'}}\n    };\n\n    // If the selection is resolved to global, only a single interval is in\n    // the store. Wrap brush mark's encodings with a production rule to test\n    // this based on the `unit` property. Hide the brush mark if it corresponds\n    // to a unit different from the one in the store.\n    if (selCmpt.resolve === 'global') {\n      for (const key of keys(update)) {\n        update[key] = [\n          {\n            test: `${store}.length && ${store}[0].unit === ${unitName(model)}`,\n            ...update[key]\n          },\n          {value: 0}\n        ];\n      }\n    }\n\n    // Two brush marks ensure that fill colors and other aesthetic choices do\n    // not interefere with the core marks, but that the brushed region can still\n    // be interacted with (e.g., dragging it around).\n    const {fill, fillOpacity, ...stroke} = selCmpt.mark;\n    const vgStroke = keys(stroke).reduce((def, k) => {\n      def[k] = [\n        {\n          test: [xi !== null && `${name}_x[0] !== ${name}_x[1]`, yi != null && `${name}_y[0] !== ${name}_y[1]`]\n            .filter(x => x)\n            .join(' && '),\n          value: stroke[k]\n        },\n        {value: null}\n      ];\n      return def;\n    }, {});\n\n    return [\n      {\n        name: name + BRUSH + '_bg',\n        type: 'rect',\n        clip: true,\n        encode: {\n          enter: {\n            fill: {value: fill},\n            fillOpacity: {value: fillOpacity}\n          },\n          update: update\n        }\n      } as any\n    ].concat(marks, {\n      name: name + BRUSH,\n      type: 'rect',\n      clip: true,\n      encode: {\n        enter: {\n          fill: {value: 'transparent'}\n        },\n        update: {...update, ...vgStroke}\n      }\n    });\n  }\n};\nexport default interval;\n\n/**\n * Returns the visual and data signals for an interval selection.\n */\nfunction channelSignals(model: UnitModel, selCmpt: SelectionComponent, channel: 'x' | 'y'): any {\n  const vname = channelSignalName(selCmpt, channel, 'visual');\n  const dname = channelSignalName(selCmpt, channel, 'data');\n  const hasScales = scales.has(selCmpt);\n  const scaleName = model.scaleName(channel);\n  const scaleStr = stringValue(scaleName);\n  const scale = model.getScaleComponent(channel);\n  const scaleType = scale ? scale.get('type') : undefined;\n  const size = model.getSizeSignalRef(channel === X ? 'width' : 'height').signal;\n  const coord = `${channel}(unit)`;\n\n  const on = events(selCmpt, (def: any[], evt: VgEventStream) => {\n    return def.concat(\n      {events: evt.between[0], update: `[${coord}, ${coord}]`}, // Brush Start\n      {events: evt, update: `[${vname}[0], clamp(${coord}, 0, ${size})]`} // Brush End\n    );\n  });\n\n  // React to pan/zooms of continuous scales. Non-continuous scales\n  // (bin-linear, band, point) cannot be pan/zoomed and any other changes\n  // to their domains (e.g., filtering) should clear the brushes.\n  on.push({\n    events: {signal: selCmpt.name + SCALE_TRIGGER},\n    update:\n      hasContinuousDomain(scaleType) && !isBinScale(scaleType)\n        ? `[scale(${scaleStr}, ${dname}[0]), scale(${scaleStr}, ${dname}[1])]`\n        : `[0, 0]`\n  });\n\n  return hasScales\n    ? [{name: dname, on: []}]\n    : [\n        {\n          name: vname,\n          value: [],\n          on: on\n        },\n        {\n          name: dname,\n          on: [{events: {signal: vname}, update: `${vname}[0] === ${vname}[1] ? null : invert(${scaleStr}, ${vname})`}]\n        }\n      ];\n}\n\nfunction events(selCmpt: SelectionComponent, cb: (...args: any[]) => void) {\n  return selCmpt.events.reduce((on: any[], evt: VgEventStream) => {\n    if (!evt.between) {\n      warn(`${evt} is not an ordered event stream for interval selections`);\n      return on;\n    }\n    return cb(on, evt);\n  }, []);\n}\n","import {stringValue} from 'vega-util';\n\nimport {accessPathWithDatum} from '../../util';\nimport {UnitModel} from '../unit';\nimport {SelectionCompiler, SelectionComponent, TUPLE, unitName} from './selection';\nimport nearest from './transforms/nearest';\n\nexport function signals(model: UnitModel, selCmpt: SelectionComponent) {\n  const proj = selCmpt.project;\n  const datum = nearest.has(selCmpt) ? '(item().isVoronoi ? datum.datum : datum)' : 'datum';\n  const bins: string[] = [];\n  const encodings = proj\n    .map(p => stringValue(p.channel))\n    .filter(e => e)\n    .join(', ');\n  const fields = proj.map(p => stringValue(p.field)).join(', ');\n  const values = proj\n    .map(p => {\n      const channel = p.channel;\n      const fieldDef = model.fieldDef(channel);\n      // Binned fields should capture extents, for a range test against the raw field.\n      return fieldDef && fieldDef.bin\n        ? (bins.push(p.field),\n          `[${accessPathWithDatum(model.vgField(channel, {}), datum)}, ` +\n            `${accessPathWithDatum(model.vgField(channel, {binSuffix: 'end'}), datum)}]`)\n        : `${accessPathWithDatum(p.field, datum)}`;\n    })\n    .join(', ');\n\n  // Only add a discrete selection to the store if a datum is present _and_\n  // the interaction isn't occurring on a group mark. This guards against\n  // polluting interactive state with invalid values in faceted displays\n  // as the group marks are also data-driven. We force the update to account\n  // for constant null states but varying toggles (e.g., shift-click in\n  // whitespace followed by a click in whitespace; the store should only\n  // be cleared on the second click).\n  return [\n    {\n      name: selCmpt.name + TUPLE,\n      value: {},\n      on: [\n        {\n          events: selCmpt.events,\n          update:\n            `datum && item().mark.marktype !== 'group' ? ` +\n            `{unit: ${unitName(model)}, encodings: [${encodings}], ` +\n            `fields: [${fields}], values: [${values}]` +\n            (bins.length ? ', ' + bins.map(b => `${stringValue('bin_' + b)}: 1`).join(', ') : '') +\n            '} : null',\n          force: true\n        }\n      ]\n    }\n  ];\n}\n\nconst multi: SelectionCompiler = {\n  predicate: 'vlMulti',\n  scaleDomain: 'vlMultiDomain',\n\n  signals: signals,\n\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'null' : `{unit: ${unitName(model)}}`);\n  }\n};\n\nexport default multi;\n","import {SignalRef} from 'vega';\nimport {selector as parseSelector} from 'vega-event-selector';\nimport {isString, stringValue} from 'vega-util';\nimport {Channel, ScaleChannel, X, Y} from '../../channel';\nimport {warn} from '../../log';\nimport {LogicalOperand} from '../../logical';\nimport {BrushConfig, SELECTION_ID, SelectionDef, SelectionResolution, SelectionType} from '../../selection';\nimport {accessPathWithDatum, Dict, keys, logicalExpr, varName} from '../../util';\nimport {VgBinding, VgData, VgEventStream} from '../../vega.schema';\nimport {DataFlowNode} from '../data/dataflow';\nimport {TimeUnitNode} from '../data/timeunit';\nimport {FacetModel} from '../facet';\nimport {LayerModel} from '../layer';\nimport {isFacetModel, isUnitModel, Model} from '../model';\nimport {UnitModel} from '../unit';\nimport intervalCompiler from './interval';\nimport multiCompiler from './multi';\nimport {SelectionComponent} from './selection';\nimport singleCompiler from './single';\nimport {forEachTransform} from './transforms/transforms';\n\nexport const STORE = '_store';\nexport const TUPLE = '_tuple';\nexport const MODIFY = '_modify';\nexport const SELECTION_DOMAIN = '_selection_domain_';\n\nexport interface SelectionComponent {\n  name: string;\n  type: SelectionType;\n  events: VgEventStream;\n  // predicate?: string;\n  bind?: 'scales' | VgBinding | {[key: string]: VgBinding};\n  resolve: SelectionResolution;\n  empty: 'all' | 'none';\n  mark?: BrushConfig;\n\n  _signalNames: {};\n\n  // Transforms\n  project?: ProjectComponent[];\n  fields?: any;\n  timeUnit?: TimeUnitNode;\n  scales?: Channel[];\n  toggle?: any;\n  translate?: any;\n  zoom?: any;\n  nearest?: any;\n}\n\nexport interface ProjectComponent {\n  field?: string;\n  channel?: ScaleChannel;\n}\n\nexport interface SelectionCompiler {\n  signals: (model: UnitModel, selCmpt: SelectionComponent) => any[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent, signals: any[]) => any[];\n  modifyExpr: (model: UnitModel, selCmpt: SelectionComponent) => string;\n  marks?: (model: UnitModel, selCmpt: SelectionComponent, marks: any[]) => any[];\n  predicate: string; // Vega expr string to determine inclusion in selection.\n  scaleDomain: string; // Vega expr string to materialize a scale domain.\n}\n\nexport function parseUnitSelection(model: UnitModel, selDefs: Dict<SelectionDef>) {\n  const selCmpts: Dict<SelectionComponent> = {};\n  const selectionConfig = model.config.selection;\n\n  for (let name in selDefs) {\n    if (!selDefs.hasOwnProperty(name)) {\n      continue;\n    }\n\n    const selDef = selDefs[name];\n    const cfg = selectionConfig[selDef.type];\n\n    // Set default values from config if a property hasn't been specified,\n    // or if it is true. E.g., \"translate\": true should use the default\n    // event handlers for translate. However, true may be a valid value for\n    // a property (e.g., \"nearest\": true).\n    for (const key in cfg) {\n      // A selection should contain either `encodings` or `fields`, only use\n      // default values for these two values if neither of them is specified.\n      if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {\n        continue;\n      }\n\n      if (key === 'mark') {\n        selDef[key] = {...cfg[key], ...selDef[key]};\n      }\n\n      if (selDef[key] === undefined || selDef[key] === true) {\n        selDef[key] = cfg[key] || selDef[key];\n      }\n    }\n\n    name = varName(name);\n    const selCmpt = (selCmpts[name] = {\n      ...selDef,\n      name: name,\n      events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : selDef.on\n    } as SelectionComponent);\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.parse) {\n        txCompiler.parse(model, selDef, selCmpt);\n      }\n    });\n  }\n\n  return selCmpts;\n}\n\nexport function assembleUnitSelectionSignals(model: UnitModel, signals: any[]) {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    const name = selCmpt.name;\n    let modifyExpr = selCompiler.modifyExpr(model, selCmpt);\n\n    signals.push.apply(signals, selCompiler.signals(model, selCmpt));\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.signals) {\n        signals = txCompiler.signals(model, selCmpt, signals);\n      }\n      if (txCompiler.modifyExpr) {\n        modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);\n      }\n    });\n\n    signals.push({\n      name: name + MODIFY,\n      on: [\n        {\n          events: {signal: name + TUPLE},\n          update: `modify(${stringValue(selCmpt.name + STORE)}, ${modifyExpr})`\n        }\n      ]\n    });\n  });\n\n  return signals;\n}\n\nexport function assembleFacetSignals(model: FacetModel, signals: any[]) {\n  if (model.component.selection && keys(model.component.selection).length) {\n    const name = stringValue(model.getName('cell'));\n    signals.unshift({\n      name: 'facet',\n      value: {},\n      on: [\n        {\n          events: parseSelector('mousemove', 'scope'),\n          update: `isTuple(facet) ? facet : group(${name}).datum`\n        }\n      ]\n    });\n  }\n\n  return signals;\n}\n\nexport function assembleTopLevelSignals(model: UnitModel, signals: any[]) {\n  let needsUnit = false;\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    if (selCompiler.topLevelSignals) {\n      signals = selCompiler.topLevelSignals(model, selCmpt, signals);\n    }\n\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.topLevelSignals) {\n        signals = txCompiler.topLevelSignals(model, selCmpt, signals);\n      }\n    });\n\n    needsUnit = true;\n  });\n\n  if (needsUnit) {\n    const hasUnit = signals.filter(s => s.name === 'unit');\n    if (!hasUnit.length) {\n      signals.unshift({\n        name: 'unit',\n        value: {},\n        on: [{events: 'mousemove', update: 'isTuple(group()) ? group() : unit'}]\n      });\n    }\n  }\n\n  return signals;\n}\n\nexport function assembleUnitSelectionData(model: UnitModel, data: VgData[]): VgData[] {\n  forEachSelection(model, selCmpt => {\n    const contains = data.filter(d => d.name === selCmpt.name + STORE);\n    if (!contains.length) {\n      data.push({name: selCmpt.name + STORE});\n    }\n  });\n\n  return data;\n}\n\nexport function assembleUnitSelectionMarks(model: UnitModel, marks: any[]): any[] {\n  forEachSelection(model, (selCmpt, selCompiler) => {\n    marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;\n    forEachTransform(selCmpt, txCompiler => {\n      if (txCompiler.marks) {\n        marks = txCompiler.marks(model, selCmpt, marks);\n      }\n    });\n  });\n\n  return marks;\n}\n\nexport function assembleLayerSelectionMarks(model: LayerModel, marks: any[]): any[] {\n  model.children.forEach(child => {\n    if (isUnitModel(child)) {\n      marks = assembleUnitSelectionMarks(child, marks);\n    }\n  });\n\n  return marks;\n}\n\nexport function selectionPredicate(model: Model, selections: LogicalOperand<string>, dfnode?: DataFlowNode): string {\n  const stores: string[] = [];\n  function expr(name: string): string {\n    const vname = varName(name);\n    const selCmpt = model.getSelectionComponent(vname, name);\n    const store = stringValue(vname + STORE);\n\n    if (selCmpt.timeUnit) {\n      const child = dfnode || model.component.data.raw;\n      const tunode = selCmpt.timeUnit.clone();\n      if (child.parent) {\n        tunode.insertAsParentOf(child);\n      } else {\n        child.parent = tunode;\n      }\n    }\n\n    if (selCmpt.empty !== 'none') {\n      stores.push(store);\n    }\n\n    return (\n      compiler(selCmpt.type).predicate +\n      `(${store}, datum` +\n      (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`)\n    );\n  }\n\n  const predicateStr = logicalExpr(selections, expr);\n  return (\n    (stores.length ? '!(' + stores.map(s => `length(data(${s}))`).join(' || ') + ') || ' : '') + `(${predicateStr})`\n  );\n}\n\n// Selections are parsed _after_ scales. If a scale domain is set to\n// use a selection, the SELECTION_DOMAIN constant is used as the\n// domainRaw.signal during scale.parse and then replaced with the necessary\n// selection expression function during scale.assemble. To not pollute the\n// type signatures to account for this setup, the selection domain definition\n// is coerced to a string and appended to SELECTION_DOMAIN.\nexport function isRawSelectionDomain(domainRaw: SignalRef) {\n  return domainRaw.signal.indexOf(SELECTION_DOMAIN) >= 0;\n}\nexport function selectionScaleDomain(model: Model, domainRaw: SignalRef): SignalRef {\n  const selDomain = JSON.parse(domainRaw.signal.replace(SELECTION_DOMAIN, ''));\n  const name = varName(selDomain.selection);\n\n  let selCmpt = model.component.selection && model.component.selection[name];\n  if (selCmpt) {\n    warn('Use \"bind\": \"scales\" to setup a binding for scales and selections within the same view.');\n  } else {\n    selCmpt = model.getSelectionComponent(name, selDomain.selection);\n    if (!selDomain.encoding && !selDomain.field) {\n      selDomain.field = selCmpt.project[0].field;\n      if (selCmpt.project.length > 1) {\n        warn(\n          'A \"field\" or \"encoding\" must be specified when using a selection as a scale domain. ' +\n            `Using \"field\": ${stringValue(selDomain.field)}.`\n        );\n      }\n    }\n    return {\n      signal:\n        compiler(selCmpt.type).scaleDomain +\n        `(${stringValue(name + STORE)}, ${stringValue(selDomain.encoding || null)}, ` +\n        stringValue(selDomain.field || null) +\n        (selCmpt.resolve === 'global' ? ')' : `, ${stringValue(selCmpt.resolve)})`)\n    };\n  }\n\n  return {signal: 'null'};\n}\n\n// Utility functions\n\nfunction forEachSelection(model: Model, cb: (selCmpt: SelectionComponent, selCompiler: SelectionCompiler) => void) {\n  const selections = model.component.selection;\n  for (const name in selections) {\n    if (selections.hasOwnProperty(name)) {\n      const sel = selections[name];\n      cb(sel, compiler(sel.type));\n    }\n  }\n}\n\nfunction compiler(type: SelectionType): SelectionCompiler {\n  switch (type) {\n    case 'single':\n      return singleCompiler;\n    case 'multi':\n      return multiCompiler;\n    case 'interval':\n      return intervalCompiler;\n  }\n  return null;\n}\n\nfunction getFacetModel(model: Model): FacetModel {\n  let parent = model.parent;\n  while (parent) {\n    if (isFacetModel(parent)) {\n      break;\n    }\n    parent = parent.parent;\n  }\n\n  return parent as FacetModel;\n}\n\nexport function unitName(model: Model) {\n  let name = stringValue(model.name);\n  const facet = getFacetModel(model);\n  if (facet) {\n    name +=\n      (facet.facet.row ? ` + '_' + (${accessPathWithDatum(facet.vgField('row'), 'facet')})` : '') +\n      (facet.facet.column ? ` + '_' + (${accessPathWithDatum(facet.vgField('column'), 'facet')})` : '');\n  }\n  return name;\n}\n\nexport function requiresSelectionId(model: Model) {\n  let identifier = false;\n  forEachSelection(model, selCmpt => {\n    identifier = identifier || selCmpt.project.some(proj => proj.field === SELECTION_ID);\n  });\n  return identifier;\n}\n\nexport function channelSignalName(selCmpt: SelectionComponent, channel: Channel, range: 'visual' | 'data') {\n  const sgNames = selCmpt._signalNames || (selCmpt._signalNames = {});\n  if (sgNames[channel] && sgNames[channel][range]) {\n    return sgNames[channel][range];\n  }\n\n  sgNames[channel] = sgNames[channel] || {};\n  const basename = varName(selCmpt.name + '_' + (range === 'visual' ? channel : selCmpt.fields[channel]));\n  let name = basename;\n  let counter = 1;\n  while (sgNames[name]) {\n    name = `${basename}_${counter++}`;\n  }\n\n  return (sgNames[name] = sgNames[channel][range] = name);\n}\n\nexport function positionalProjections(selCmpt: SelectionComponent) {\n  let x: ProjectComponent = null;\n  let xi: number = null;\n  let y: ProjectComponent = null;\n  let yi: number = null;\n\n  selCmpt.project.forEach((p, i) => {\n    if (p.channel === X) {\n      x = p;\n      xi = i;\n    } else if (p.channel === Y) {\n      y = p;\n      yi = i;\n    }\n  });\n  return {x, xi, y, yi};\n}\n","import {stringValue} from 'vega-util';\n\nimport {signals as multiSignals} from './multi';\nimport {SelectionCompiler, STORE, TUPLE, unitName} from './selection';\n\nconst single: SelectionCompiler = {\n  predicate: 'vlSingle',\n  scaleDomain: 'vlSingleDomain',\n\n  signals: multiSignals,\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    const hasSignal = signals.filter(s => s.name === selCmpt.name);\n    const data = `data(${stringValue(selCmpt.name + STORE)})`;\n    const values = `${data}[0].values`;\n    return hasSignal.length\n      ? signals\n      : signals.concat({\n          name: selCmpt.name,\n          update: `${data}.length && {` + selCmpt.project.map((p, i) => `${p.field}: ${values}[${i}]`).join(', ') + '}'\n        });\n  },\n\n  modifyExpr: (model, selCmpt) => {\n    const tpl = selCmpt.name + TUPLE;\n    return tpl + ', ' + (selCmpt.resolve === 'global' ? 'true' : `{unit: ${unitName(model)}}`);\n  }\n};\n\nexport default single;\n","import {stringValue} from 'vega-util';\nimport {accessPathWithDatum, varName} from '../../../util';\nimport {TUPLE} from '../selection';\nimport nearest from './nearest';\nimport {TransformCompiler} from './transforms';\n\nconst inputBindings: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.type === 'single' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind !== 'scales';\n  },\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const proj = selCmpt.project;\n    const bind = selCmpt.bind;\n    const datum = nearest.has(selCmpt) ? '(item().isVoronoi ? datum.datum : datum)' : 'datum';\n\n    proj.forEach(p => {\n      const sgname = varName(`${name}_${p.field}`);\n      const hasSignal = signals.filter(s => s.name === sgname);\n      if (!hasSignal.length) {\n        signals.unshift({\n          name: sgname,\n          value: '',\n          on: [\n            {\n              events: selCmpt.events,\n              update: `datum && item().mark.marktype !== 'group' ? ${accessPathWithDatum(p.field, datum)} : null`\n            }\n          ],\n          bind: bind[p.field] || bind[p.channel] || bind\n        });\n      }\n    });\n\n    return signals;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const proj = selCmpt.project;\n    const signal = signals.filter(s => s.name === name + TUPLE)[0];\n    const fields = proj.map(p => stringValue(p.field)).join(', ');\n    const values = proj.map(p => varName(`${name}_${p.field}`));\n\n    if (values.length) {\n      signal.update = `${values.join(' && ')} ? {fields: [${fields}], values: [${values.join(', ')}]} : null`;\n    }\n\n    delete signal.value;\n    delete signal.on;\n\n    return signals;\n  }\n};\n\nexport default inputBindings;\n","import * as log from '../../../log';\nimport {isPathMark} from '../../../mark';\nimport {positionalProjections} from '../selection';\nimport {TransformCompiler} from './transforms';\n\nconst VORONOI = 'voronoi';\n\nconst nearest: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.type !== 'interval' && selCmpt.nearest;\n  },\n\n  marks: (model, selCmpt, marks) => {\n    const {x, y} = positionalProjections(selCmpt);\n    const markType = model.mark;\n    if (isPathMark(markType)) {\n      log.warn(log.message.nearestNotSupportForContinuous(markType));\n      return marks;\n    }\n\n    const cellDef = {\n      name: model.getName(VORONOI),\n      type: 'path',\n      from: {data: model.getName('marks')},\n      encode: {\n        enter: {\n          fill: {value: 'transparent'},\n          strokeWidth: {value: 0.35},\n          stroke: {value: 'transparent'},\n          isVoronoi: {value: true}\n        }\n      },\n      transform: [\n        {\n          type: 'voronoi',\n          x: {expr: x || (!x && !y) ? 'datum.datum.x || 0' : '0'},\n          y: {expr: y || (!x && !y) ? 'datum.datum.y || 0' : '0'},\n          size: [model.getSizeSignalRef('width'), model.getSizeSignalRef('height')]\n        }\n      ]\n    };\n\n    let index = 0;\n    let exists = false;\n    marks.forEach((mark, i) => {\n      const name = mark.name || '';\n      if (name === model.component.mark[0].name) {\n        index = i;\n      } else if (name.indexOf(VORONOI) >= 0) {\n        exists = true;\n      }\n    });\n\n    if (!exists) {\n      marks.splice(index + 1, 0, cellDef);\n    }\n\n    return marks;\n  }\n};\n\nexport default nearest;\n","import {SingleDefChannel} from '../../../channel';\nimport * as log from '../../../log';\nimport {SelectionDef} from '../../../selection';\nimport {keys} from '../../../util';\nimport {TimeUnitComponent, TimeUnitNode} from '../../data/timeunit';\nimport {SelectionComponent} from '../selection';\nimport {TransformCompiler} from './transforms';\n\nconst project: TransformCompiler = {\n  has: (selDef: SelectionComponent | SelectionDef) => {\n    const def = selDef as SelectionDef;\n    return def.fields !== undefined || def.encodings !== undefined;\n  },\n\n  parse: (model, selDef, selCmpt) => {\n    const channels = {};\n    const timeUnits: {[key: string]: TimeUnitComponent} = {};\n\n    // TODO: find a possible channel mapping for these fields.\n    (selDef.fields || []).forEach(field => (channels[field] = null));\n\n    (selDef.encodings || []).forEach((channel: SingleDefChannel) => {\n      const fieldDef = model.fieldDef(channel);\n      if (fieldDef) {\n        if (fieldDef.timeUnit) {\n          const tuField = model.vgField(channel);\n          channels[tuField] = channel;\n\n          // Construct TimeUnitComponents which will be combined into a\n          // TimeUnitNode. This node may need to be inserted into the\n          // dataflow if the selection is used across views that do not\n          // have these time units defined.\n          timeUnits[tuField] = {\n            as: tuField,\n            field: fieldDef.field,\n            timeUnit: fieldDef.timeUnit\n          };\n        } else {\n          channels[fieldDef.field] = channel;\n        }\n      } else {\n        log.warn(log.message.cannotProjectOnChannelWithoutField(channel));\n      }\n    });\n\n    const projection = selCmpt.project || (selCmpt.project = []);\n    for (const field in channels) {\n      if (channels.hasOwnProperty(field)) {\n        projection.push({field: field, channel: channels[field]});\n      }\n    }\n\n    const fields = selCmpt.fields || (selCmpt.fields = {});\n    projection.filter(p => p.channel).forEach(p => (fields[p.channel] = p.field));\n\n    if (keys(timeUnits).length) {\n      selCmpt.timeUnit = new TimeUnitNode(null, timeUnits);\n    }\n  }\n};\n\nexport default project;\n","import {stringValue} from 'vega-util';\nimport {Channel, X, Y} from '../../../channel';\nimport * as log from '../../../log';\nimport {hasContinuousDomain, isBinScale} from '../../../scale';\nimport {UnitModel} from '../../unit';\nimport {channelSignalName} from '../selection';\nimport {TransformCompiler} from './transforms';\n\nconst scaleBindings: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.resolve === 'global' && selCmpt.bind && selCmpt.bind === 'scales';\n  },\n\n  parse: (model, selDef, selCmpt) => {\n    const bound: Channel[] = (selCmpt.scales = []);\n\n    selCmpt.project.forEach(p => {\n      const channel = p.channel;\n      const scale = model.getScaleComponent(channel);\n      const scaleType = scale ? scale.get('type') : undefined;\n\n      if (!scale || !hasContinuousDomain(scaleType) || isBinScale(scaleType)) {\n        log.warn(log.message.SCALE_BINDINGS_CONTINUOUS);\n        return;\n      }\n\n      scale.set('domainRaw', {signal: channelSignalName(selCmpt, channel, 'data')}, true);\n      bound.push(channel);\n\n      // Bind both x/y for diag plot of repeated views.\n      if (model.repeater && model.repeater.row === model.repeater.column) {\n        const scale2 = model.getScaleComponent(channel === X ? Y : X);\n        scale2.set('domainRaw', {signal: channelSignalName(selCmpt, channel, 'data')}, true);\n      }\n    });\n  },\n\n  topLevelSignals: (model, selCmpt, signals) => {\n    // Top-level signals are only needed when coordinating composed views.\n    if (!model.parent) {\n      return signals;\n    }\n\n    const channels = selCmpt.scales.filter(channel => {\n      return !signals.filter(s => s.name === channelSignalName(selCmpt, channel, 'data')).length;\n    });\n\n    return signals.concat(\n      channels.map(channel => {\n        return {name: channelSignalName(selCmpt, channel, 'data')};\n      })\n    );\n  },\n\n  signals: (model, selCmpt, signals) => {\n    // Nested signals need only push to top-level signals when within composed views.\n    if (model.parent) {\n      selCmpt.scales.forEach(channel => {\n        const signal = signals.filter(s => s.name === channelSignalName(selCmpt, channel, 'data'))[0];\n\n        signal.push = 'outer';\n        delete signal.value;\n        delete signal.update;\n      });\n    }\n\n    return signals;\n  }\n};\n\nexport default scaleBindings;\n\nexport function domain(model: UnitModel, channel: Channel) {\n  const scale = stringValue(model.scaleName(channel));\n  return `domain(${scale})`;\n}\n","import {TUPLE, unitName} from '../selection';\nimport {TransformCompiler} from './transforms';\n\nconst TOGGLE = '_toggle';\n\nconst toggle: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.type === 'multi' && selCmpt.toggle;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    return signals.concat({\n      name: selCmpt.name + TOGGLE,\n      value: false,\n      on: [{events: selCmpt.events, update: selCmpt.toggle}]\n    });\n  },\n\n  modifyExpr: (model, selCmpt, expr) => {\n    const tpl = selCmpt.name + TUPLE;\n    const signal = selCmpt.name + TOGGLE;\n\n    return (\n      `${signal} ? null : ${tpl}, ` +\n      (selCmpt.resolve === 'global' ? `${signal} ? null : true, ` : `${signal} ? null : {unit: ${unitName(model)}}, `) +\n      `${signal} ? ${tpl} : null`\n    );\n  }\n};\n\nexport default toggle;\n","import {SelectionDef} from '../../../selection';\nimport {Dict} from '../../../util';\nimport {VgSignal} from '../../../vega.schema';\nimport {Model} from '../../model';\nimport {UnitModel} from '../../unit';\nimport {SelectionComponent} from '../selection';\n\nexport interface TransformCompiler {\n  has: (selCmpt: SelectionComponent | SelectionDef) => boolean;\n  parse?: (model: UnitModel, def: SelectionDef, selCmpt: SelectionComponent) => void;\n  signals?: (model: UnitModel, selCmpt: SelectionComponent, signals: VgSignal[]) => VgSignal[];\n  topLevelSignals?: (model: Model, selCmpt: SelectionComponent, signals: VgSignal[]) => VgSignal[];\n  modifyExpr?: (model: UnitModel, selCmpt: SelectionComponent, expr: string) => string;\n  marks?: (model: UnitModel, selCmpt: SelectionComponent, marks: any[]) => any[];\n}\n\nimport inputs from './inputs';\nimport nearest from './nearest';\nimport project from './project';\nimport scales from './scales';\nimport toggle from './toggle';\nimport translate from './translate';\nimport zoom from './zoom';\nconst compilers: Dict<TransformCompiler> = {\n  project,\n  toggle,\n  scales,\n  translate,\n  zoom,\n  inputs,\n  nearest\n};\n\nexport function forEachTransform(selCmpt: SelectionComponent, cb: (tx: TransformCompiler) => void) {\n  for (const t in compilers) {\n    if (compilers[t].has(selCmpt)) {\n      cb(compilers[t]);\n    }\n  }\n}\n","import {selector as parseSelector} from 'vega-event-selector';\nimport {ScaleChannel, X, Y} from '../../../channel';\nimport {VgSignal} from '../../../vega.schema';\nimport {UnitModel} from '../../unit';\nimport {BRUSH as INTERVAL_BRUSH} from '../interval';\nimport {channelSignalName, positionalProjections, SelectionComponent} from '../selection';\nimport scalesCompiler, {domain} from './scales';\nimport {TransformCompiler} from './transforms';\n\nconst ANCHOR = '_translate_anchor';\nconst DELTA = '_translate_delta';\n\nconst translate: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.translate;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.has(selCmpt);\n    const anchor = name + ANCHOR;\n    const {x, y} = positionalProjections(selCmpt);\n    let events = parseSelector(selCmpt.translate, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => ((e.between[0].markname = name + INTERVAL_BRUSH), e));\n    }\n\n    signals.push(\n      {\n        name: anchor,\n        value: {},\n        on: [\n          {\n            events: events.map(e => e.between[0]),\n            update:\n              '{x: x(unit), y: y(unit)' +\n              (x !== null\n                ? ', extent_x: ' +\n                  (hasScales ? domain(model, X) : `slice(${channelSignalName(selCmpt, 'x', 'visual')})`)\n                : '') +\n              (y !== null\n                ? ', extent_y: ' +\n                  (hasScales ? domain(model, Y) : `slice(${channelSignalName(selCmpt, 'y', 'visual')})`)\n                : '') +\n              '}'\n          }\n        ]\n      },\n      {\n        name: name + DELTA,\n        value: {},\n        on: [\n          {\n            events: events,\n            update: `{x: ${anchor}.x - x(unit), y: ${anchor}.y - y(unit)}`\n          }\n        ]\n      }\n    );\n\n    if (x !== null) {\n      onDelta(model, selCmpt, X, 'width', signals);\n    }\n\n    if (y !== null) {\n      onDelta(model, selCmpt, Y, 'height', signals);\n    }\n\n    return signals;\n  }\n};\n\nexport default translate;\n\nfunction onDelta(\n  model: UnitModel,\n  selCmpt: SelectionComponent,\n  channel: ScaleChannel,\n  size: 'width' | 'height',\n  signals: VgSignal[]\n) {\n  const name = selCmpt.name;\n  const hasScales = scalesCompiler.has(selCmpt);\n  const signal = signals.filter(s => {\n    return s.name === channelSignalName(selCmpt, channel, hasScales ? 'data' : 'visual');\n  })[0];\n  const anchor = name + ANCHOR;\n  const delta = name + DELTA;\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const sign = hasScales && channel === X ? '-' : ''; // Invert delta when panning x-scales.\n  const extent = `${anchor}.extent_${channel}`;\n  const offset = `${sign}${delta}.${channel} / ` + (hasScales ? `${sizeSg}` : `span(${extent})`);\n  const panFn = !hasScales\n    ? 'panLinear'\n    : scaleType === 'log'\n      ? 'panLog'\n      : scaleType === 'pow'\n        ? 'panPow'\n        : 'panLinear';\n  const update =\n    `${panFn}(${extent}, ${offset}` +\n    (hasScales && scaleType === 'pow' ? `, ${scaleCmpt.get('exponent') || 1}` : '') +\n    ')';\n\n  signal.on.push({\n    events: {signal: delta},\n    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}\n","import {selector as parseSelector} from 'vega-event-selector';\nimport {stringValue} from 'vega-util';\nimport {ScaleChannel, X, Y} from '../../../channel';\nimport {VgSignal} from '../../../vega.schema';\nimport {UnitModel} from '../../unit';\nimport {BRUSH as INTERVAL_BRUSH} from '../interval';\nimport {channelSignalName, positionalProjections, SelectionComponent} from '../selection';\nimport {default as scalesCompiler, domain} from './scales';\nimport {TransformCompiler} from './transforms';\n\nconst ANCHOR = '_zoom_anchor';\nconst DELTA = '_zoom_delta';\n\nconst zoom: TransformCompiler = {\n  has: selCmpt => {\n    return selCmpt.type === 'interval' && selCmpt.zoom;\n  },\n\n  signals: (model, selCmpt, signals) => {\n    const name = selCmpt.name;\n    const hasScales = scalesCompiler.has(selCmpt);\n    const delta = name + DELTA;\n    const {x, y} = positionalProjections(selCmpt);\n    const sx = stringValue(model.scaleName(X));\n    const sy = stringValue(model.scaleName(Y));\n    let events = parseSelector(selCmpt.zoom, 'scope');\n\n    if (!hasScales) {\n      events = events.map(e => ((e.markname = name + INTERVAL_BRUSH), e));\n    }\n\n    signals.push(\n      {\n        name: name + ANCHOR,\n        on: [\n          {\n            events: events,\n            update: !hasScales\n              ? `{x: x(unit), y: y(unit)}`\n              : '{' +\n                [sx ? `x: invert(${sx}, x(unit))` : '', sy ? `y: invert(${sy}, y(unit))` : '']\n                  .filter(expr => !!expr)\n                  .join(', ') +\n                '}'\n          }\n        ]\n      },\n      {\n        name: delta,\n        on: [\n          {\n            events: events,\n            force: true,\n            update: 'pow(1.001, event.deltaY * pow(16, event.deltaMode))'\n          }\n        ]\n      }\n    );\n\n    if (x !== null) {\n      onDelta(model, selCmpt, 'x', 'width', signals);\n    }\n\n    if (y !== null) {\n      onDelta(model, selCmpt, 'y', 'height', signals);\n    }\n\n    return signals;\n  }\n};\n\nexport default zoom;\n\nfunction onDelta(\n  model: UnitModel,\n  selCmpt: SelectionComponent,\n  channel: ScaleChannel,\n  size: 'width' | 'height',\n  signals: VgSignal[]\n) {\n  const name = selCmpt.name;\n  const hasScales = scalesCompiler.has(selCmpt);\n  const signal = signals.filter(s => {\n    return s.name === channelSignalName(selCmpt, channel, hasScales ? 'data' : 'visual');\n  })[0];\n  const sizeSg = model.getSizeSignalRef(size).signal;\n  const scaleCmpt = model.getScaleComponent(channel);\n  const scaleType = scaleCmpt.get('type');\n  const base = hasScales ? domain(model, channel) : signal.name;\n  const delta = name + DELTA;\n  const anchor = `${name}${ANCHOR}.${channel}`;\n  const zoomFn = !hasScales\n    ? 'zoomLinear'\n    : scaleType === 'log'\n      ? 'zoomLog'\n      : scaleType === 'pow'\n        ? 'zoomPow'\n        : 'zoomLinear';\n  const update =\n    `${zoomFn}(${base}, ${anchor}, ${delta}` +\n    (hasScales && scaleType === 'pow' ? `, ${scaleCmpt.get('exponent') || 1}` : '') +\n    ')';\n\n  signal.on.push({\n    events: {signal: delta},\n    update: hasScales ? update : `clampRange(${update}, 0, ${sizeSg})`\n  });\n}\n","import * as log from '../log';\nimport {duplicate, getFirstDefined, keys, stringify} from '../util';\n\n/**\n * Generic class for storing properties that are explicitly specified\n * and implicitly determined by the compiler.\n * This is important for scale/axis/legend merging as\n * we want to prioritize properties that users explicitly specified.\n */\nexport class Split<T extends object> {\n  constructor(public readonly explicit: Partial<T> = {}, public readonly implicit: Partial<T> = {}) {}\n\n  public clone() {\n    return new Split(duplicate(this.explicit), duplicate(this.implicit));\n  }\n\n  public combine(): Partial<T> {\n    // FIXME remove \"as any\".\n    // Add \"as any\" to avoid an error \"Spread types may only be created from object types\".\n    return {\n      ...(this.explicit as any), // Explicit properties comes first\n      ...(this.implicit as any)\n    };\n  }\n\n  public get<K extends keyof T>(key: K): T[K] {\n    // Explicit has higher precedence\n    return getFirstDefined(this.explicit[key], this.implicit[key]);\n  }\n\n  public getWithExplicit<K extends keyof T>(key: K): Explicit<T[K]> {\n    // Explicit has higher precedence\n    if (this.explicit[key] !== undefined) {\n      return {explicit: true, value: this.explicit[key]};\n    } else if (this.implicit[key] !== undefined) {\n      return {explicit: false, value: this.implicit[key]};\n    }\n    return {explicit: false, value: undefined};\n  }\n\n  public setWithExplicit<K extends keyof T>(key: K, value: Explicit<T[K]>) {\n    if (value.value !== undefined) {\n      this.set(key, value.value, value.explicit);\n    }\n  }\n\n  public set<K extends keyof T>(key: K, value: T[K], explicit: boolean) {\n    delete this[explicit ? 'implicit' : 'explicit'][key];\n    this[explicit ? 'explicit' : 'implicit'][key] = value;\n    return this;\n  }\n\n  public copyKeyFromSplit<S extends T>(key: keyof T, s: Split<S>) {\n    // Explicit has higher precedence\n    if (s.explicit[key] !== undefined) {\n      this.set(key, s.explicit[key], true);\n    } else if (s.implicit[key] !== undefined) {\n      this.set(key, s.implicit[key], false);\n    }\n  }\n  public copyKeyFromObject<S extends Partial<T>>(key: keyof T, s: S) {\n    // Explicit has higher precedence\n    if (s[key] !== undefined) {\n      this.set(key, s[key], true);\n    }\n  }\n\n  /**\n   * Merge split object into this split object. Properties from the other split\n   * overwrite properties from this split.\n   */\n  public copyAll(other: Split<T>) {\n    for (const key of keys(other.combine())) {\n      const val = other.getWithExplicit(key);\n      this.setWithExplicit(key, val);\n    }\n  }\n}\n\nexport interface Explicit<T> {\n  explicit: boolean;\n  value: T;\n}\n\nexport function makeExplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: true,\n    value\n  };\n}\n\nexport function makeImplicit<T>(value: T): Explicit<T> {\n  return {\n    explicit: false,\n    value\n  };\n}\n\nexport function tieBreakByComparing<S, T>(compare: (v1: T, v2: T) => number) {\n  return (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S | never,\n    propertyOf: string | number | symbol\n  ): Explicit<T> => {\n    const diff = compare(v1.value, v2.value);\n    if (diff > 0) {\n      return v1;\n    } else if (diff < 0) {\n      return v2;\n    }\n    return defaultTieBreaker<S, T>(v1, v2, property, propertyOf);\n  };\n}\n\nexport function defaultTieBreaker<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: string | number | symbol\n) {\n  if (v1.explicit && v2.explicit) {\n    log.warn(log.message.mergeConflictingProperty(property, propertyOf, v1.value, v2.value));\n  }\n  // If equal score, prefer v1.\n  return v1;\n}\n\nexport function mergeValuesWithExplicit<S, T>(\n  v1: Explicit<T>,\n  v2: Explicit<T>,\n  property: keyof S,\n  propertyOf: 'scale' | 'axis' | 'legend' | '',\n  tieBreaker: (\n    v1: Explicit<T>,\n    v2: Explicit<T>,\n    property: keyof S,\n    propertyOf: string\n  ) => Explicit<T> = defaultTieBreaker\n) {\n  if (v1 === undefined || v1.value === undefined) {\n    // For first run\n    return v2;\n  }\n\n  if (v1.explicit && !v2.explicit) {\n    return v1;\n  } else if (v2.explicit && !v1.explicit) {\n    return v2;\n  } else if (stringify(v1.value) === stringify(v2.value)) {\n    return v1;\n  } else {\n    return tieBreaker(v1, v2, property, propertyOf);\n  }\n}\n","import {Axis} from '../axis';\nimport {\n  Channel,\n  GEOPOSITION_CHANNELS,\n  NONPOSITION_SCALE_CHANNELS,\n  SCALE_CHANNELS,\n  ScaleChannel,\n  SingleDefChannel,\n  X,\n  Y\n} from '../channel';\nimport {Config} from '../config';\nimport * as vlEncoding from '../encoding';\nimport {Encoding, normalizeEncoding} from '../encoding';\nimport {ChannelDef, FieldDef, getFieldDef, hasConditionalFieldDef, isFieldDef} from '../fielddef';\nimport {Legend} from '../legend';\nimport {GEOSHAPE, isMarkDef, Mark, MarkDef} from '../mark';\nimport {Projection} from '../projection';\nimport {Domain, Scale} from '../scale';\nimport {SelectionDef} from '../selection';\nimport {LayoutSizeMixins, NormalizedUnitSpec} from '../spec';\nimport {stack, StackProperties} from '../stack';\nimport {Dict, duplicate} from '../util';\nimport {VgData, VgEncodeEntry, VgLayout, VgSignal} from '../vega.schema';\nimport {AxisIndex} from './axis/component';\nimport {parseUnitAxis} from './axis/parse';\nimport {parseData} from './data/parse';\nimport {assembleLayoutSignals} from './layoutsize/assemble';\nimport {parseUnitLayoutSize} from './layoutsize/parse';\nimport {LegendIndex} from './legend/component';\nimport {normalizeMarkDef} from './mark/init';\nimport {parseMarkGroup} from './mark/mark';\nimport {isLayerModel, Model, ModelWithField} from './model';\nimport {RepeaterValue, replaceRepeaterInEncoding} from './repeater';\nimport {ScaleIndex} from './scale/component';\nimport {\n  assembleTopLevelSignals,\n  assembleUnitSelectionData,\n  assembleUnitSelectionMarks,\n  assembleUnitSelectionSignals,\n  parseUnitSelection\n} from './selection/selection';\n\n/**\n * Internal model of Vega-Lite specification for the compiler.\n */\nexport class UnitModel extends ModelWithField {\n  public readonly type: 'unit' = 'unit';\n  public readonly markDef: MarkDef;\n  public readonly encoding: Encoding<string>;\n\n  public readonly specifiedScales: ScaleIndex = {};\n\n  public readonly stack: StackProperties;\n\n  protected specifiedAxes: AxisIndex = {};\n\n  protected specifiedLegends: LegendIndex = {};\n\n  public specifiedProjection: Projection = {};\n\n  public readonly selection: Dict<SelectionDef> = {};\n  public children: Model[] = [];\n\n  constructor(\n    spec: NormalizedUnitSpec,\n    parent: Model,\n    parentGivenName: string,\n    parentGivenSize: LayoutSizeMixins = {},\n    repeater: RepeaterValue,\n    config: Config,\n    public fit: boolean\n  ) {\n    super(spec, parent, parentGivenName, config, repeater, undefined);\n    this.initSize({\n      ...parentGivenSize,\n      ...(spec.width ? {width: spec.width} : {}),\n      ...(spec.height ? {height: spec.height} : {})\n    });\n    const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n\n    const encoding = (this.encoding = normalizeEncoding(\n      replaceRepeaterInEncoding(spec.encoding || {}, repeater),\n      mark\n    ));\n\n    this.markDef = normalizeMarkDef(spec.mark, encoding, config);\n\n    // calculate stack properties\n    this.stack = stack(mark, encoding, this.config.stack);\n    this.specifiedScales = this.initScales(mark, encoding);\n\n    this.specifiedAxes = this.initAxes(encoding);\n    this.specifiedLegends = this.initLegend(encoding);\n    this.specifiedProjection = spec.projection;\n\n    // Selections will be initialized upon parse.\n    this.selection = spec.selection;\n  }\n\n  public get hasProjection(): boolean {\n    const {encoding} = this;\n    const isGeoShapeMark = this.mark === GEOSHAPE;\n    const hasGeoPosition = encoding && GEOPOSITION_CHANNELS.some(channel => isFieldDef(encoding[channel]));\n    return isGeoShapeMark || hasGeoPosition;\n  }\n\n  /**\n   * Return specified Vega-lite scale domain for a particular channel\n   * @param channel\n   */\n  public scaleDomain(channel: ScaleChannel): Domain {\n    const scale = this.specifiedScales[channel];\n    return scale ? scale.domain : undefined;\n  }\n\n  public axis(channel: Channel): Axis {\n    return this.specifiedAxes[channel];\n  }\n\n  public legend(channel: Channel): Legend {\n    return this.specifiedLegends[channel];\n  }\n\n  private initScales(mark: Mark, encoding: Encoding<string>): ScaleIndex {\n    return SCALE_CHANNELS.reduce(\n      (scales, channel) => {\n        let fieldDef: FieldDef<string>;\n        let specifiedScale: Scale;\n\n        const channelDef = encoding[channel];\n\n        if (isFieldDef(channelDef)) {\n          fieldDef = channelDef;\n          specifiedScale = channelDef.scale;\n        } else if (hasConditionalFieldDef(channelDef)) {\n          fieldDef = channelDef.condition;\n          specifiedScale = channelDef.condition['scale'];\n        } else if (channel === 'x') {\n          fieldDef = getFieldDef(encoding.x2);\n        } else if (channel === 'y') {\n          fieldDef = getFieldDef(encoding.y2);\n        }\n\n        if (fieldDef) {\n          scales[channel] = specifiedScale || {};\n        }\n        return scales;\n      },\n      {} as ScaleIndex\n    );\n  }\n\n  private initAxes(encoding: Encoding<string>): AxisIndex {\n    return [X, Y].reduce((_axis, channel) => {\n      // Position Axis\n\n      // TODO: handle ConditionFieldDef\n      const channelDef = encoding[channel];\n      if (\n        isFieldDef(channelDef) ||\n        (channel === X && isFieldDef(encoding.x2)) ||\n        (channel === Y && isFieldDef(encoding.y2))\n      ) {\n        const axisSpec = isFieldDef(channelDef) ? channelDef.axis : null;\n\n        if (axisSpec !== null) {\n          _axis[channel] = {\n            ...axisSpec\n          };\n        }\n      }\n      return _axis;\n    }, {});\n  }\n\n  private initLegend(encoding: Encoding<string>): LegendIndex {\n    return NONPOSITION_SCALE_CHANNELS.reduce((_legend, channel) => {\n      const channelDef = encoding[channel];\n      if (channelDef) {\n        const legend = isFieldDef(channelDef)\n          ? channelDef.legend\n          : hasConditionalFieldDef(channelDef)\n            ? channelDef.condition['legend']\n            : null;\n\n        if (legend !== null && legend !== false) {\n          _legend[channel] = {...legend};\n        }\n      }\n\n      return _legend;\n    }, {});\n  }\n\n  public parseData() {\n    this.component.data = parseData(this);\n  }\n\n  public parseLayoutSize() {\n    parseUnitLayoutSize(this);\n  }\n\n  public parseSelection() {\n    this.component.selection = parseUnitSelection(this, this.selection);\n  }\n\n  public parseMarkGroup() {\n    this.component.mark = parseMarkGroup(this);\n  }\n\n  public parseAxisAndHeader() {\n    this.component.axes = parseUnitAxis(this);\n  }\n\n  public assembleSelectionTopLevelSignals(signals: any[]): VgSignal[] {\n    return assembleTopLevelSignals(this, signals);\n  }\n\n  public assembleSelectionSignals(): VgSignal[] {\n    return assembleUnitSelectionSignals(this, []);\n  }\n\n  public assembleSelectionData(data: VgData[]): VgData[] {\n    return assembleUnitSelectionData(this, data);\n  }\n\n  public assembleLayout(): VgLayout {\n    return null;\n  }\n\n  public assembleLayoutSignals(): VgSignal[] {\n    return assembleLayoutSignals(this);\n  }\n\n  public assembleMarks() {\n    let marks = this.component.mark || [];\n\n    // If this unit is part of a layer, selections should augment\n    // all in concert rather than each unit individually. This\n    // ensures correct interleaving of clipping and brushed marks.\n    if (!this.parent || !isLayerModel(this.parent)) {\n      marks = assembleUnitSelectionMarks(this, marks);\n    }\n\n    return marks.map(this.correctDataNames);\n  }\n\n  public assembleLayoutSize(): VgEncodeEntry {\n    return {\n      width: this.getSizeSignalRef('width'),\n      height: this.getSizeSignalRef('height')\n    };\n  }\n\n  protected getMapping() {\n    return this.encoding;\n  }\n\n  public toSpec(excludeConfig?: any, excludeData?: any) {\n    const encoding = duplicate(this.encoding);\n    let spec: any;\n\n    spec = {\n      mark: this.markDef,\n      encoding: encoding\n    };\n\n    if (!excludeConfig) {\n      spec.config = duplicate(this.config);\n    }\n\n    if (!excludeData) {\n      spec.data = duplicate(this.data);\n    }\n\n    // remove defaults\n    return spec;\n  }\n\n  public get mark(): Mark {\n    return this.markDef.type;\n  }\n\n  public channelHasField(channel: Channel) {\n    return vlEncoding.channelHasField(this.encoding, channel);\n  }\n\n  public fieldDef(channel: SingleDefChannel): FieldDef<string> {\n    const channelDef = this.encoding[channel] as ChannelDef<string>;\n    return getFieldDef(channelDef);\n  }\n}\n","import {isNumber, isObject} from 'vega-util';\nimport {Channel} from '../channel';\nimport {Config} from '../config';\nimport {Encoding, extractTransformsFromEncoding} from '../encoding';\nimport * as log from '../log';\nimport {isMarkDef, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedLayerSpec, NormalizedUnitSpec} from '../spec';\nimport {AggregatedFieldDef, CalculateTransform} from '../transform';\nimport {Flag, getFirstDefined, keys} from '../util';\nimport {Orient} from '../vega.schema';\nimport {\n  compositeMarkContinuousAxis,\n  compositeMarkOrient,\n  filterUnsupportedChannels,\n  GenericCompositeMarkDef,\n  makeCompositeAggregatePartFactory,\n  partLayerMixins,\n  PartsMixins\n} from './common';\n\nexport const BOXPLOT: 'boxplot' = 'boxplot';\nexport type BoxPlot = typeof BOXPLOT;\n\nexport type BoxPlotPart = 'box' | 'median' | 'outliers' | 'rule' | 'ticks';\n\nconst BOXPLOT_PART_INDEX: Flag<BoxPlotPart> = {\n  box: 1,\n  median: 1,\n  outliers: 1,\n  rule: 1,\n  ticks: 1\n};\n\nexport const BOXPLOT_PARTS = keys(BOXPLOT_PART_INDEX);\n\nexport type BoxPlotPartsMixins = PartsMixins<BoxPlotPart>;\n\nexport interface BoxPlotConfig extends BoxPlotPartsMixins {\n  /** Size of the box and median tick of a box plot */\n  size?: number;\n\n  /**\n   * The extent of the whiskers. Available options include:\n   * - `\"min-max\"`: min and max are the lower and upper whiskers respectively.\n   * - A number representing multiple of the interquartile range (Q3-Q1).  This number will be multiplied by the IQR. the product will be added to the third quartile to get the upper whisker and subtracted from the first quartile to get the lower whisker.\n   *\n   * __Default value:__ `1.5`.\n   */\n  extent?: 'min-max' | number;\n}\n\nexport type BoxPlotDef = GenericCompositeMarkDef<BoxPlot> &\n  BoxPlotConfig & {\n    /**\n     * Type of the mark.  For box plots, this should always be `\"box-plot\"`.\n     * [boxplot](https://vega.github.io/vega-lite/docs/compositemark.html#boxplot)\n     */\n    type: BoxPlot;\n\n    /**\n     * Orientation of the box plot.  This is normally automatically determined based on types of fields on x and y channels. However, an explicit `orient` be specified when the orientation is ambiguous.\n     *\n     * __Default value:__ `\"vertical\"`.\n     */\n    orient?: Orient;\n  };\n\nexport interface BoxPlotConfigMixins {\n  /**\n   * Box Config\n   */\n  boxplot?: BoxPlotConfig;\n}\n\nconst boxPlotSupportedChannels: Channel[] = ['x', 'y', 'color', 'detail', 'opacity', 'size'];\n\nexport function normalizeBoxPlot(\n  spec: GenericUnitSpec<Encoding<string>, BoxPlot | BoxPlotDef>,\n  config: Config\n): NormalizedLayerSpec {\n  spec = filterUnsupportedChannels(spec, boxPlotSupportedChannels, BOXPLOT);\n\n  // TODO: use selection\n  const {mark, encoding: _encoding, selection, projection: _p, ...outerSpec} = spec;\n  const markDef: BoxPlotDef = isMarkDef(mark) ? mark : {type: mark};\n\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (selection) {\n    log.warn(log.message.selectionNotSupported('boxplot'));\n  }\n\n  const extent = markDef.extent || config.boxplot.extent;\n  const sizeValue = getFirstDefined(markDef.size, config.boxplot.size);\n  const isMinMax = !isNumber(extent);\n\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    groupby,\n    encodingWithoutContinuousAxis,\n    tickOrient\n  } = boxParams(spec, extent, config);\n\n  const {color, size, ...encodingWithoutSizeColorAndContinuousAxis} = encodingWithoutContinuousAxis;\n\n  const makeBoxPlotPart = (sharedEncoding: Encoding<string>) => {\n    return makeCompositeAggregatePartFactory<BoxPlotPartsMixins>(\n      markDef,\n      continuousAxis,\n      continuousAxisChannelDef,\n      sharedEncoding,\n      config.boxplot\n    );\n  };\n\n  const makeBoxPlotExtent = makeBoxPlotPart(encodingWithoutSizeColorAndContinuousAxis);\n  const makeBoxPlotBox = makeBoxPlotPart(encodingWithoutContinuousAxis);\n  const makeBoxPlotMidTick = makeBoxPlotPart({...encodingWithoutSizeColorAndContinuousAxis, ...(size ? {size} : {})});\n\n  const endTick: MarkDef = {type: 'tick', color: 'black', opacity: 1, orient: tickOrient};\n\n  const bar: MarkDef = {type: 'bar', ...(sizeValue ? {size: sizeValue} : {})};\n\n  const midTick: MarkDef = {\n    type: 'tick',\n    ...(isObject(config.boxplot.median) && config.boxplot.median.color ? {color: config.boxplot.median.color} : {}),\n    ...(sizeValue ? {size: sizeValue} : {}),\n    orient: tickOrient\n  };\n\n  const boxLayer: NormalizedUnitSpec[] = [\n    ...makeBoxPlotExtent('rule', 'rule', 'lower_whisker', 'lower_box'),\n    ...makeBoxPlotExtent('rule', 'rule', 'upper_box', 'upper_whisker'),\n    ...makeBoxPlotExtent('ticks', endTick, 'lower_whisker'),\n    ...makeBoxPlotExtent('ticks', endTick, 'upper_whisker'),\n    ...makeBoxPlotBox('box', bar, 'lower_box', 'upper_box'),\n    ...makeBoxPlotMidTick('median', midTick, 'mid_box')\n  ];\n\n  let outliersLayerMixins: NormalizedUnitSpec[] = [];\n\n  if (!isMinMax) {\n    const lowerBoxExpr: string = 'datum.lower_box_' + continuousAxisChannelDef.field;\n    const upperBoxExpr: string = 'datum.upper_box_' + continuousAxisChannelDef.field;\n    const iqrExpr = `(${upperBoxExpr} - ${lowerBoxExpr})`;\n    const lowerWhiskerExpr = `${lowerBoxExpr} - ${extent} * ${iqrExpr}`;\n    const upperWhiskerExpr = `${upperBoxExpr} + ${extent} * ${iqrExpr}`;\n    const fieldExpr = `datum.${continuousAxisChannelDef.field}`;\n\n    outliersLayerMixins = partLayerMixins<BoxPlotPartsMixins>(markDef, 'outliers', config.boxplot, {\n      transform: [\n        {\n          window: boxParamsQuartiles(continuousAxisChannelDef.field),\n          frame: [null, null],\n          groupby\n        },\n        {\n          filter: `(${fieldExpr} < ${lowerWhiskerExpr}) || (${fieldExpr} > ${upperWhiskerExpr})`\n        }\n      ],\n      mark: 'point',\n      encoding: {\n        [continuousAxis]: {\n          field: continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type\n        },\n        ...encodingWithoutSizeColorAndContinuousAxis\n      }\n    });\n  }\n\n  if (outliersLayerMixins.length > 0) {\n    // tukey box plot with outliers included\n    return {\n      ...outerSpec,\n      layer: [\n        {\n          // boxplot\n          transform,\n          layer: boxLayer\n        },\n        ...outliersLayerMixins\n      ]\n    };\n  }\n  return {\n    ...outerSpec,\n    transform: (outerSpec.transform || []).concat(transform),\n    layer: boxLayer\n  };\n}\n\nfunction boxParamsQuartiles(continousAxisField: string): AggregatedFieldDef[] {\n  return [\n    {\n      op: 'q1',\n      field: continousAxisField,\n      as: 'lower_box_' + continousAxisField\n    },\n    {\n      op: 'q3',\n      field: continousAxisField,\n      as: 'upper_box_' + continousAxisField\n    }\n  ];\n}\n\nfunction boxParams(\n  spec: GenericUnitSpec<Encoding<string>, BoxPlot | BoxPlotDef>,\n  extent: 'min-max' | number,\n  config: Config\n) {\n  const orient = compositeMarkOrient(spec, BOXPLOT);\n  const {continuousAxisChannelDef, continuousAxis} = compositeMarkContinuousAxis(spec, orient, BOXPLOT);\n  const continuousFieldName: string = continuousAxisChannelDef.field;\n\n  const isMinMax = !isNumber(extent);\n  const boxplotSpecificAggregate: AggregatedFieldDef[] = [\n    ...boxParamsQuartiles(continuousFieldName),\n    {\n      op: 'median',\n      field: continuousFieldName,\n      as: 'mid_box_' + continuousFieldName\n    },\n    {\n      op: 'min',\n      field: continuousFieldName,\n      as: (isMinMax ? 'lower_whisker_' : 'min_') + continuousFieldName\n    },\n    {\n      op: 'max',\n      field: continuousFieldName,\n      as: (isMinMax ? 'upper_whisker_' : 'max_') + continuousFieldName\n    }\n  ];\n\n  const postAggregateCalculates: CalculateTransform[] = isMinMax\n    ? []\n    : [\n        {\n          calculate: `datum.upper_box_${continuousFieldName} - datum.lower_box_${continuousFieldName}`,\n          as: 'iqr_' + continuousFieldName\n        },\n        {\n          calculate: `min(datum.upper_box_${continuousFieldName} + datum.iqr_${continuousFieldName} * ${extent}, datum.max_${continuousFieldName})`,\n          as: 'upper_whisker_' + continuousFieldName\n        },\n        {\n          calculate: `max(datum.lower_box_${continuousFieldName} - datum.iqr_${continuousFieldName} * ${extent}, datum.min_${continuousFieldName})`,\n          as: 'lower_whisker_' + continuousFieldName\n        }\n      ];\n\n  const {[continuousAxis]: oldContinuousAxisChannelDef, ...oldEncodingWithoutContinuousAxis} = spec.encoding;\n\n  const {bins, timeUnits, aggregate, groupby, encoding: encodingWithoutContinuousAxis} = extractTransformsFromEncoding(\n    oldEncodingWithoutContinuousAxis,\n    config\n  );\n\n  const tickOrient: Orient = orient === 'vertical' ? 'horizontal' : 'vertical';\n\n  return {\n    transform: [\n      ...bins,\n      ...timeUnits,\n      {\n        aggregate: [...aggregate, ...boxplotSpecificAggregate],\n        groupby\n      },\n      ...postAggregateCalculates\n    ],\n    groupby,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    tickOrient\n  };\n}\n","import {isBoolean, isString} from 'vega-util';\nimport {CompositeMark, CompositeMarkDef} from '.';\nimport {Channel} from '../channel';\nimport {Encoding, reduce} from '../encoding';\nimport {Field, FieldDef, isContinuous, isFieldDef, PositionFieldDef} from '../fielddef';\nimport * as log from '../log';\nimport {ColorMixins, GenericMarkDef, isMarkDef, Mark, MarkConfig, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedUnitSpec} from '../spec';\nimport {Orient} from '../vega.schema';\n\nexport type PartsMixins<P extends string> = Partial<Record<P, boolean | MarkConfig>>;\n\nexport type GenericCompositeMarkDef<T> = GenericMarkDef<T> &\n  ColorMixins & {\n    /**\n     * Opacity of the marks.\n     */\n    opacity?: number;\n  };\n\nexport function makeCompositeAggregatePartFactory<P extends PartsMixins<any>>(\n  compositeMarkDef: GenericCompositeMarkDef<any> & P,\n  continuousAxis: 'x' | 'y',\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  sharedEncoding: Encoding<string>,\n  compositeMarkConfig: P\n) {\n  const {scale, axis} = continuousAxisChannelDef;\n\n  return (\n    partName: keyof P,\n    mark: Mark | MarkDef,\n    positionPrefix: string,\n    endPositionPrefix: string = undefined,\n    extraEncoding: Encoding<string> = {}\n  ) => {\n    const title =\n      axis && axis.title !== undefined\n        ? undefined\n        : continuousAxisChannelDef.title !== undefined\n          ? continuousAxisChannelDef.title\n          : continuousAxisChannelDef.field;\n\n    return partLayerMixins<P>(compositeMarkDef, partName, compositeMarkConfig, {\n      mark, // TODO better remove this method and just have mark as a parameter of the method\n      encoding: {\n        [continuousAxis]: {\n          field: positionPrefix + '_' + continuousAxisChannelDef.field,\n          type: continuousAxisChannelDef.type,\n          ...(title ? {title} : {}),\n          ...(scale ? {scale} : {}),\n          ...(axis ? {axis} : {})\n        },\n        ...(isString(endPositionPrefix)\n          ? {\n              [continuousAxis + '2']: {\n                field: endPositionPrefix + '_' + continuousAxisChannelDef.field,\n                type: continuousAxisChannelDef.type\n              }\n            }\n          : {}),\n        ...sharedEncoding,\n        ...extraEncoding\n      }\n    });\n  };\n}\n\nexport function partLayerMixins<P extends PartsMixins<any>>(\n  markDef: GenericCompositeMarkDef<any> & P,\n  part: keyof P,\n  compositeMarkConfig: P,\n  partBaseSpec: NormalizedUnitSpec\n): NormalizedUnitSpec[] {\n  const {color, opacity} = markDef;\n\n  const mark = markDef.type;\n\n  if (markDef[part] || (markDef[part] === undefined && compositeMarkConfig[part])) {\n    return [\n      {\n        ...partBaseSpec,\n        mark: {\n          ...(compositeMarkConfig[part] as MarkConfig),\n          ...(color ? {color} : {}),\n          ...(opacity ? {opacity} : {}),\n          ...(isMarkDef(partBaseSpec.mark) ? partBaseSpec.mark : {type: partBaseSpec.mark}),\n          style: `${mark}-${part}`,\n          ...(isBoolean(markDef[part]) ? {} : (markDef[part] as MarkConfig))\n        }\n      }\n    ];\n  }\n  return [];\n}\n\nexport function compositeMarkContinuousAxis<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<string>, CompositeMark | CompositeMarkDef>,\n  orient: Orient,\n  compositeMark: M\n) {\n  const {encoding} = spec;\n\n  let continuousAxisChannelDef: PositionFieldDef<string>;\n  let continuousAxisChannelDef2: PositionFieldDef<string>;\n  let continuousAxis: 'x' | 'y';\n\n  if (orient === 'vertical') {\n    continuousAxis = 'y';\n    continuousAxisChannelDef = encoding.y as FieldDef<string>; // Safe to cast because if y is not continuous fielddef, the orient would not be vertical.\n    continuousAxisChannelDef2 = encoding.y2 ? (encoding.y2 as FieldDef<string>) : undefined;\n  } else {\n    continuousAxis = 'x';\n    continuousAxisChannelDef = encoding.x as FieldDef<string>; // Safe to cast because if x is not continuous fielddef, the orient would not be horizontal.\n    continuousAxisChannelDef2 = encoding.x2 ? (encoding.x2 as FieldDef<string>) : undefined;\n  }\n\n  if (continuousAxisChannelDef && continuousAxisChannelDef.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate} = continuousAxisChannelDef;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    continuousAxisChannelDef = continuousAxisWithoutAggregate;\n  }\n\n  if (continuousAxisChannelDef2 && continuousAxisChannelDef2.aggregate) {\n    const {aggregate, ...continuousAxisWithoutAggregate2} = continuousAxisChannelDef2;\n    if (aggregate !== compositeMark) {\n      log.warn(log.message.errorBarContinuousAxisHasCustomizedAggregate(aggregate, compositeMark));\n    }\n    continuousAxisChannelDef2 = continuousAxisWithoutAggregate2;\n  }\n\n  return {\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    continuousAxis\n  };\n}\n\nexport function compositeMarkOrient<M extends CompositeMark>(\n  spec: GenericUnitSpec<Encoding<Field>, CompositeMark | CompositeMarkDef>,\n  compositeMark: M\n): Orient {\n  const {mark, encoding} = spec;\n\n  if (isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // x is continuous\n    if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // both x and y are continuous\n      if (encoding.x.aggregate === undefined && encoding.y.aggregate === compositeMark) {\n        return 'vertical';\n      } else if (encoding.y.aggregate === undefined && encoding.x.aggregate === compositeMark) {\n        return 'horizontal';\n      } else if (encoding.x.aggregate === compositeMark && encoding.y.aggregate === compositeMark) {\n        throw new Error('Both x and y cannot have aggregate');\n      } else {\n        if (isMarkDef(mark) && mark.orient) {\n          return mark.orient;\n        }\n\n        // default orientation = vertical\n        return 'vertical';\n      }\n    }\n\n    // x is continuous but y is not\n    return 'horizontal';\n  } else if (isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // y is continuous but x is not\n    return 'vertical';\n  } else {\n    // Neither x nor y is continuous.\n    throw new Error('Need a valid continuous axis for ' + compositeMark + 's');\n  }\n}\n\nexport function filterUnsupportedChannels<M extends CompositeMark, MD extends GenericCompositeMarkDef<M>>(\n  spec: GenericUnitSpec<Encoding<string>, M | MD>,\n  supportedChannels: Channel[],\n  compositeMark: M\n): GenericUnitSpec<Encoding<string>, M | MD> {\n  return {\n    ...spec,\n    encoding: reduce(\n      spec.encoding,\n      (newEncoding, fieldDef, channel) => {\n        if (supportedChannels.indexOf(channel) > -1) {\n          newEncoding[channel] = fieldDef;\n        } else {\n          log.warn(log.message.incompatibleChannel(channel, compositeMark));\n        }\n        return newEncoding;\n      },\n      {}\n    )\n  };\n}\n","import {Config} from '../config';\nimport {Encoding} from '../encoding';\nimport * as log from '../log';\nimport {MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {Flag, keys} from '../util';\nimport {Interpolate, Orient} from '../vega.schema';\nimport {GenericCompositeMarkDef, makeCompositeAggregatePartFactory, PartsMixins} from './common';\nimport {ErrorBarCenter, ErrorBarExtent, errorBarParams} from './errorbar';\n\nexport const ERRORBAND: 'errorband' = 'errorband';\nexport type ErrorBand = typeof ERRORBAND;\n\nexport type ErrorBandPart = 'band' | 'borders';\n\nconst ERRORBAND_PART_INDEX: Flag<ErrorBandPart> = {\n  band: 1,\n  borders: 1\n};\n\nexport const ERRORBAND_PARTS = keys(ERRORBAND_PART_INDEX);\n\nexport type ErrorBandPartsMixins = PartsMixins<ErrorBandPart>;\n\nexport interface ErrorBandConfig extends ErrorBandPartsMixins {\n  /**\n   * The center of the error band. Available options include:\n   * - `\"mean\"`: the mean of the data points.\n   * - `\"median\"`: the median of the data points.\n   *\n   * __Default value:__ `\"mean\"`.\n   * @hide\n   */\n\n  // center is not needed right now but will be added back to the schema if future features require it.\n  center?: ErrorBarCenter;\n\n  /**\n   * The extent of the band. Available options include:\n   * - `\"ci\"`: Extend the band to the confidence interval of the mean.\n   * - `\"stderr\"`: The size of band are set to the value of standard error, extending from the mean.\n   * - `\"stdev\"`: The size of band are set to the value of standard deviation, extending from the mean.\n   * - `\"iqr\"`: Extend the band to the q1 and q3.\n   *\n   * __Default value:__ `\"stderr\"`.\n   */\n  extent?: ErrorBarExtent;\n\n  /**\n   * The line interpolation method for the error band. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n   * - `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n\n  /**\n   * The tension parameter for the interpolation type of the error band.\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n}\n\nexport type ErrorBandDef = GenericCompositeMarkDef<ErrorBand> &\n  ErrorBandConfig & {\n    /**\n     * Orientation of the error band. This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n     */\n    orient?: Orient;\n  };\n\nexport interface ErrorBandConfigMixins {\n  /**\n   * ErrorBand Config\n   */\n  errorband?: ErrorBandConfig;\n}\n\nexport function normalizeErrorBand(\n  spec: GenericUnitSpec<Encoding<string>, ErrorBand | ErrorBandDef>,\n  config: Config\n): NormalizedLayerSpec {\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    markDef,\n    outerSpec\n  } = errorBarParams(spec, ERRORBAND, config);\n\n  const makeErrorBandPart = makeCompositeAggregatePartFactory<ErrorBandPartsMixins>(\n    markDef,\n    continuousAxis,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    config.errorband\n  );\n\n  const is2D = spec.encoding.x !== undefined && spec.encoding.y !== undefined;\n\n  let bandMark: MarkDef = {type: is2D ? 'area' : 'rect'};\n  let bordersMark: MarkDef = {type: is2D ? 'line' : 'rule'};\n  const interpolate = {\n    ...(markDef.interpolate ? {interpolate: markDef.interpolate} : {}),\n    ...(markDef.tension && markDef.interpolate ? {interpolate: markDef.tension} : {})\n  };\n\n  if (is2D) {\n    bandMark = {\n      ...bandMark,\n      ...interpolate\n    };\n    bordersMark = {\n      ...bordersMark,\n      ...interpolate\n    };\n  } else if (markDef.interpolate) {\n    log.warn(log.message.errorBand1DNotSupport('interpolate'));\n  } else if (markDef.tension) {\n    log.warn(log.message.errorBand1DNotSupport('tension'));\n  }\n\n  return {\n    ...outerSpec,\n    transform,\n    layer: [\n      ...makeErrorBandPart('band', bandMark, 'lower', 'upper'),\n      ...makeErrorBandPart('borders', bordersMark, 'lower'),\n      ...makeErrorBandPart('borders', bordersMark, 'upper')\n    ]\n  };\n}\n","import {Channel} from '../channel';\nimport {Config} from '../config';\nimport {Data} from '../data';\nimport {Encoding, extractTransformsFromEncoding} from '../encoding';\nimport {Field, isContinuous, isFieldDef, PositionFieldDef} from '../fielddef';\nimport * as log from '../log';\nimport {isMarkDef, MarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {TitleParams} from '../title';\nimport {AggregatedFieldDef, CalculateTransform, Transform} from '../transform';\nimport {Flag, keys} from '../util';\nimport {Orient} from '../vega.schema';\nimport {\n  compositeMarkContinuousAxis,\n  compositeMarkOrient,\n  filterUnsupportedChannels,\n  GenericCompositeMarkDef,\n  makeCompositeAggregatePartFactory,\n  PartsMixins\n} from './common';\nimport {ErrorBand, ErrorBandDef} from './errorband';\n\nexport const ERRORBAR: 'errorbar' = 'errorbar';\nexport type ErrorBar = typeof ERRORBAR;\n\nexport type ErrorBarExtent = 'ci' | 'iqr' | 'stderr' | 'stdev';\nexport type ErrorBarCenter = 'mean' | 'median';\n\nexport type ErrorBarPart = 'ticks' | 'rule';\n\nconst ERRORBAR_PART_INDEX: Flag<ErrorBarPart> = {\n  ticks: 1,\n  rule: 1\n};\n\nexport const ERRORBAR_PARTS = keys(ERRORBAR_PART_INDEX);\n\nexport type ErrorBarPartsMixins = PartsMixins<ErrorBarPart>;\n\nexport interface ErrorBarConfig extends ErrorBarPartsMixins {\n  /**\n   * The center of the errorbar. Available options include:\n   * - `\"mean\"`: the mean of the data points.\n   * - `\"median\"`: the median of the data points.\n   *\n   * __Default value:__ `\"mean\"`.\n   * @hide\n   */\n\n  // center is not needed right now but will be added back to the schema if future features require it.\n  center?: ErrorBarCenter;\n\n  /**\n   * The extent of the rule. Available options include:\n   * - `\"ci\"`: Extend the rule to the confidence interval of the mean.\n   * - `\"stderr\"`: The size of rule are set to the value of standard error, extending from the mean.\n   * - `\"stdev\"`: The size of rule are set to the value of standard deviation, extending from the mean.\n   * - `\"iqr\"`: Extend the rule to the q1 and q3.\n   *\n   * __Default value:__ `\"stderr\"`.\n   */\n  extent?: ErrorBarExtent;\n}\n\nexport type ErrorBarDef = GenericCompositeMarkDef<ErrorBar> &\n  ErrorBarConfig & {\n    /**\n     * Orientation of the error bar.  This is normally automatically determined, but can be specified when the orientation is ambiguous and cannot be automatically determined.\n     */\n    orient?: Orient;\n  };\n\nexport interface ErrorBarConfigMixins {\n  /**\n   * ErrorBar Config\n   */\n  errorbar?: ErrorBarConfig;\n}\n\nexport function normalizeErrorBar(\n  spec: GenericUnitSpec<Encoding<string>, ErrorBar | ErrorBarDef>,\n  config: Config\n): NormalizedLayerSpec {\n  const {\n    transform,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient,\n    markDef,\n    outerSpec\n  } = errorBarParams(spec, ERRORBAR, config);\n\n  const makeErrorBarPart = makeCompositeAggregatePartFactory<ErrorBarPartsMixins>(\n    markDef,\n    continuousAxis,\n    continuousAxisChannelDef,\n    encodingWithoutContinuousAxis,\n    config.errorbar\n  );\n\n  const tick: MarkDef = {type: 'tick', orient: ticksOrient};\n\n  return {\n    ...outerSpec,\n    transform,\n    layer: [\n      ...makeErrorBarPart('ticks', tick, 'lower'),\n      ...makeErrorBarPart('ticks', tick, 'upper'),\n      ...makeErrorBarPart('rule', 'rule', 'lower', 'upper')\n    ]\n  };\n}\n\nfunction errorBarOrientAndRange(\n  spec: GenericUnitSpec<Encoding<Field>, ErrorBar | ErrorBand | ErrorBarDef | ErrorBandDef>,\n  compositeMark: ErrorBar | ErrorBand\n): {\n  orient: Orient;\n  isRangedErrorBar: boolean;\n} {\n  const {encoding} = spec;\n  if (isFieldDef(encoding.x2) && isFieldDef(encoding.x) && isContinuous(encoding.x)) {\n    // having x and x2\n    if (isFieldDef(encoding.y2) && isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n      // having both x, x2 and y, y2\n      throw new Error('Cannot have both x2 and y2 with both are quantiative');\n    } else {\n      // having x, x2 but not y, y2\n      return {orient: 'horizontal', isRangedErrorBar: true};\n    }\n  } else if (isFieldDef(encoding.y2) && isFieldDef(encoding.y) && isContinuous(encoding.y)) {\n    // having y, y2 but not x, x2\n    return {orient: 'vertical', isRangedErrorBar: true};\n  }\n\n  return {\n    orient: compositeMarkOrient(spec, compositeMark),\n    isRangedErrorBar: false\n  };\n}\n\nexport const errorBarSupportedChannels: Channel[] = ['x', 'y', 'x2', 'y2', 'color', 'detail', 'opacity'];\n\nexport function errorBarParams<\n  M extends ErrorBar | ErrorBand,\n  MD extends GenericCompositeMarkDef<M> & (ErrorBarDef | ErrorBandDef)\n>(\n  spec: GenericUnitSpec<Encoding<string>, M | MD>,\n  compositeMark: M,\n  config: Config\n): {\n  transform: Transform[];\n  groupby: string[];\n  continuousAxisChannelDef: PositionFieldDef<string>;\n  continuousAxis: 'x' | 'y';\n  encodingWithoutContinuousAxis: Encoding<string>;\n  ticksOrient: Orient;\n  markDef: MD;\n  outerSpec: {\n    data?: Data;\n    title?: string | TitleParams;\n    name?: string;\n    description?: string;\n    transform?: Transform[];\n    width?: number;\n    height?: number;\n  };\n} {\n  spec = filterUnsupportedChannels<M, MD>(spec, errorBarSupportedChannels, compositeMark);\n\n  // TODO: use selection\n  const {mark, encoding, selection, projection: _p, ...outerSpec} = spec;\n  const markDef: MD = isMarkDef(mark) ? mark : ({type: mark} as MD);\n\n  // TODO(https://github.com/vega/vega-lite/issues/3702): add selection support\n  if (selection) {\n    log.warn(log.message.selectionNotSupported(compositeMark));\n  }\n\n  const {orient, isRangedErrorBar} = errorBarOrientAndRange(spec, compositeMark);\n  const {continuousAxisChannelDef, continuousAxisChannelDef2, continuousAxis} = compositeMarkContinuousAxis(\n    spec,\n    orient,\n    compositeMark\n  );\n  const {errorBarSpecificAggregate, postAggregateCalculates} = errorBarAggregationAndCalculation(\n    markDef,\n    continuousAxisChannelDef,\n    continuousAxisChannelDef2,\n    isRangedErrorBar,\n    compositeMark,\n    config\n  );\n\n  const {\n    [continuousAxis]: oldContinuousAxisChannelDef,\n    [continuousAxis + '2']: oldContinuousAxisChannelDef2,\n    ...oldEncodingWithoutContinuousAxis\n  } = encoding;\n  const {\n    bins,\n    timeUnits,\n    aggregate: oldAggregate,\n    groupby: oldGroupBy,\n    encoding: encodingWithoutContinuousAxis\n  } = extractTransformsFromEncoding(oldEncodingWithoutContinuousAxis, config);\n\n  const aggregate: AggregatedFieldDef[] = [...oldAggregate, ...errorBarSpecificAggregate];\n  const groupby: string[] = isRangedErrorBar ? [] : oldGroupBy;\n\n  return {\n    transform: [\n      ...(outerSpec.transform || []),\n      ...bins,\n      ...timeUnits,\n      ...(!aggregate.length ? [] : [{aggregate, groupby}]),\n      ...postAggregateCalculates\n    ],\n    groupby,\n    continuousAxisChannelDef,\n    continuousAxis,\n    encodingWithoutContinuousAxis,\n    ticksOrient: orient === 'vertical' ? 'horizontal' : 'vertical',\n    markDef,\n    outerSpec\n  };\n}\n\nfunction errorBarAggregationAndCalculation<\n  M extends ErrorBar | ErrorBand,\n  MD extends GenericCompositeMarkDef<M> & (ErrorBarDef | ErrorBandDef)\n>(\n  markDef: MD,\n  continuousAxisChannelDef: PositionFieldDef<string>,\n  continuousAxisChannelDef2: PositionFieldDef<string>,\n  isRangedErrorBar: boolean,\n  compositeMark: M,\n  config: Config\n): {\n  postAggregateCalculates: CalculateTransform[];\n  errorBarSpecificAggregate: AggregatedFieldDef[];\n} {\n  let errorBarSpecificAggregate: AggregatedFieldDef[] = [];\n  let postAggregateCalculates: CalculateTransform[] = [];\n  const continuousFieldName: string = continuousAxisChannelDef.field;\n\n  if (isRangedErrorBar) {\n    if (markDef.center || markDef.extent) {\n      log.warn(log.message.errorBarCenterAndExtentAreNotNeeded(markDef.center, markDef.extent));\n    }\n\n    postAggregateCalculates = [\n      {\n        calculate: `datum.${continuousFieldName}`,\n        as: `lower_` + continuousFieldName\n      },\n      {\n        calculate: `datum.${continuousAxisChannelDef2.field}`,\n        as: `upper_` + continuousFieldName\n      }\n    ];\n  } else {\n    const center: ErrorBarCenter = markDef.center\n      ? markDef.center\n      : markDef.extent\n        ? markDef.extent === 'iqr'\n          ? 'median'\n          : 'mean'\n        : config.errorbar.center;\n    const extent: ErrorBarExtent = markDef.extent ? markDef.extent : center === 'mean' ? 'stderr' : 'iqr';\n\n    if ((center === 'median') !== (extent === 'iqr')) {\n      log.warn(log.message.errorBarCenterIsUsedWithWrongExtent(center, extent, compositeMark));\n    }\n\n    if (extent === 'stderr' || extent === 'stdev') {\n      errorBarSpecificAggregate = [\n        {\n          op: extent,\n          field: continuousFieldName,\n          as: 'extent_' + continuousFieldName\n        },\n        {\n          op: center,\n          field: continuousFieldName,\n          as: 'center_' + continuousFieldName\n        }\n      ];\n\n      postAggregateCalculates = [\n        {\n          calculate: `datum.center_${continuousFieldName} + datum.extent_${continuousFieldName}`,\n          as: 'upper_' + continuousFieldName\n        },\n        {\n          calculate: `datum.center_${continuousFieldName} - datum.extent_${continuousFieldName}`,\n          as: 'lower_' + continuousFieldName\n        }\n      ];\n    } else {\n      if (markDef.center && markDef.extent) {\n        log.warn(log.message.errorBarCenterIsNotNeeded(markDef.extent, compositeMark));\n      }\n\n      errorBarSpecificAggregate = [\n        {\n          op: extent === 'ci' ? 'ci0' : 'q1',\n          field: continuousFieldName,\n          as: 'lower_' + continuousFieldName\n        },\n        {\n          op: extent === 'ci' ? 'ci1' : 'q3',\n          field: continuousFieldName,\n          as: 'upper_' + continuousFieldName\n        }\n      ];\n    }\n  }\n  return {postAggregateCalculates, errorBarSpecificAggregate};\n}\n","import {Config} from '../config';\nimport {AnyMark, isMarkDef} from '../mark';\nimport {GenericUnitSpec, NormalizedLayerSpec} from '../spec';\nimport {keys} from '../util';\nimport {BOXPLOT, BoxPlot, BOXPLOT_PARTS, BoxPlotConfigMixins, BoxPlotDef, normalizeBoxPlot} from './boxplot';\nimport {\n  ERRORBAND,\n  ErrorBand,\n  ERRORBAND_PARTS,\n  ErrorBandConfigMixins,\n  ErrorBandDef,\n  normalizeErrorBand\n} from './errorband';\nimport {ERRORBAR, ErrorBar, ERRORBAR_PARTS, ErrorBarConfigMixins, ErrorBarDef, normalizeErrorBar} from './errorbar';\n\nexport {BoxPlotConfig} from './boxplot';\nexport {ErrorBandConfigMixins} from './errorband';\nexport {ErrorBarConfigMixins} from './errorbar';\nexport type UnitNormalizer = (spec: GenericUnitSpec<any, any>, config: Config) => NormalizedLayerSpec;\n\n/**\n * Registry index for all composite mark's normalizer\n */\nconst compositeMarkRegistry: {\n  [mark: string]: {\n    normalizer: UnitNormalizer;\n    parts: string[];\n  };\n} = {};\n\nexport function add(mark: string, normalizer: UnitNormalizer, parts: string[]) {\n  compositeMarkRegistry[mark] = {normalizer, parts};\n}\n\nexport function remove(mark: string) {\n  delete compositeMarkRegistry[mark];\n}\n\nexport type CompositeMark = BoxPlot | ErrorBar | ErrorBand;\n\nexport function getAllCompositeMarks() {\n  return keys(compositeMarkRegistry);\n}\n\nexport function getCompositeMarkParts(mark: string) {\n  if (mark in compositeMarkRegistry) {\n    return compositeMarkRegistry[mark].parts;\n  }\n  throw new Error(`Unregistered composite mark ${mark}`);\n}\n\nexport type CompositeMarkDef = BoxPlotDef | ErrorBarDef | ErrorBandDef;\n\nexport type CompositeAggregate = BoxPlot | ErrorBar | ErrorBand;\n\nexport interface CompositeMarkConfigMixins extends BoxPlotConfigMixins, ErrorBarConfigMixins, ErrorBandConfigMixins {}\n\nadd(BOXPLOT, normalizeBoxPlot, BOXPLOT_PARTS);\nadd(ERRORBAR, normalizeErrorBar, ERRORBAR_PARTS);\nadd(ERRORBAND, normalizeErrorBand, ERRORBAND_PARTS);\n\n/**\n * Transform a unit spec with composite mark into a normal layer spec.\n */\nexport function normalize(\n  // This GenericUnitSpec has any as Encoding because unit specs with composite mark can have additional encoding channels.\n  spec: GenericUnitSpec<any, AnyMark>,\n  config: Config\n): NormalizedLayerSpec {\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n  if (mark in compositeMarkRegistry) {\n    const {normalizer} = compositeMarkRegistry[mark];\n    return normalizer(spec, config);\n  }\n\n  throw new Error(`Invalid mark type \"${mark}\"`);\n}\n","import {isObject} from 'vega-util';\nimport {AxisConfigMixins} from './axis';\nimport {CompositeMarkConfigMixins, getAllCompositeMarks} from './compositemark';\nimport {VL_ONLY_GUIDE_CONFIG} from './guide';\nimport {HeaderConfig} from './header';\nimport {defaultLegendConfig, LegendConfig} from './legend';\nimport * as mark from './mark';\nimport {\n  Mark,\n  MarkConfigMixins,\n  PRIMITIVE_MARKS,\n  VL_ONLY_MARK_CONFIG_PROPERTIES,\n  VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX\n} from './mark';\nimport {ProjectionConfig} from './projection';\nimport {defaultScaleConfig, ScaleConfig} from './scale';\nimport {defaultConfig as defaultSelectionConfig, SelectionConfig} from './selection';\nimport {StackOffset} from './stack';\nimport {extractTitleConfig, TitleConfig} from './title';\nimport {TopLevelProperties} from './toplevelprops';\nimport {duplicate, keys, mergeDeep} from './util';\nimport {StrokeJoin, VgMarkConfig, VgScheme} from './vega.schema';\n\nexport interface ViewConfig {\n  /**\n   * The default width of the single plot or each plot in a trellis plot when the visualization has a continuous (non-ordinal) x-scale or ordinal x-scale with `rangeStep` = `null`.\n   *\n   * __Default value:__ `200`\n   *\n   */\n  width?: number;\n\n  /**\n   * The default height of the single plot or each plot in a trellis plot when the visualization has a continuous (non-ordinal) y-scale with `rangeStep` = `null`.\n   *\n   * __Default value:__ `200`\n   *\n   */\n  height?: number;\n\n  /**\n   * Whether the view should be clipped.\n   */\n  clip?: boolean;\n\n  // FILL_STROKE_CONFIG\n  /**\n   * The fill color.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  fill?: string;\n\n  /**\n   * The fill opacity (value between [0,1]).\n   *\n   * __Default value:__ (none)\n   *\n   */\n  fillOpacity?: number;\n\n  /**\n   * The stroke color.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  stroke?: string;\n\n  /**\n   * The stroke opacity (value between [0,1]).\n   *\n   * __Default value:__ (none)\n   *\n   */\n  strokeOpacity?: number;\n\n  /**\n   * The stroke width, in pixels.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  strokeWidth?: number;\n\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  strokeDash?: number[];\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   *\n   * __Default value:__ (none)\n   *\n   */\n  strokeDashOffset?: number;\n\n  /**\n   * The stroke line join method. One of miter (default), round or bevel.\n   *\n   * __Default value:__ 'miter'\n   *\n   */\n  strokeJoin?: StrokeJoin;\n\n  /**\n   * The stroke line join method. One of miter (default), round or bevel.\n   *\n   * __Default value:__ 'miter'\n   *\n   */\n  strokeMiterLimit?: number;\n}\n\nexport const defaultViewConfig: ViewConfig = {\n  width: 200,\n  height: 200\n};\n\nexport type RangeConfigValue = (number | string)[] | VgScheme | {step: number};\n\nexport type RangeConfig = RangeConfigProps & {[name: string]: RangeConfigValue};\n\nexport interface RangeConfigProps {\n  /**\n   * Default range for _nominal_ (categorical) fields.\n   */\n  category?: string[] | VgScheme;\n\n  /**\n   * Default range for diverging _quantitative_ fields.\n   */\n  diverging?: string[] | VgScheme;\n\n  /**\n   * Default range for _quantitative_ heatmaps.\n   */\n  heatmap?: string[] | VgScheme;\n\n  /**\n   * Default range for _ordinal_ fields.\n   */\n  ordinal?: string[] | VgScheme;\n\n  /**\n   * Default range for _quantitative_ and _temporal_ fields.\n   */\n  ramp?: string[] | VgScheme;\n\n  /**\n   * Default range palette for the `shape` channel.\n   */\n  symbol?: string[];\n}\n\nexport function isVgScheme(rangeConfig: string[] | VgScheme): rangeConfig is VgScheme {\n  return rangeConfig && !!rangeConfig['scheme'];\n}\n\nexport interface VLOnlyConfig {\n  /**\n   * Default axis and legend title for count fields.\n   *\n   * __Default value:__ `'Number of Records'`.\n   *\n   * @type {string}\n   */\n  countTitle?: string;\n\n  /**\n   * Defines how Vega-Lite should handle invalid values (`null` and `NaN`).\n   * - If set to `\"filter\"` (default), all data items with null values will be skipped (for line, trail, and area marks) or filtered (for other marks).\n   * - If `null`, all data items are included. In this case, invalid values will be interpreted as zeroes.\n   */\n  invalidValues?: 'filter' | null;\n\n  /**\n   * Defines how Vega-Lite generates title for fields.  There are three possible styles:\n   * - `\"verbal\"` (Default) - displays function in a verbal style (e.g., \"Sum of field\", \"Year-month of date\", \"field (binned)\").\n   * - `\"function\"` - displays function using parentheses and capitalized texts (e.g., \"SUM(field)\", \"YEARMONTH(date)\", \"BIN(field)\").\n   * - `\"plain\"` - displays only the field name without functions (e.g., \"field\", \"date\", \"field\").\n   */\n  fieldTitle?: 'verbal' | 'functional' | 'plain';\n\n  /**\n   * D3 Number format for guide labels and text marks. For example \"s\" for SI units. Use [D3's number format pattern](https://github.com/d3/d3-format#locale_format).\n   */\n  numberFormat?: string;\n\n  /**\n   * Default time format for raw time values (without time units) in text marks, legend labels and header labels.\n   *\n   * __Default value:__ `\"%b %d, %Y\"`\n   * __Note:__ Axes automatically determine format each label automatically so this config would not affect axes.\n   */\n  timeFormat?: string;\n\n  /** Default properties for [single view plots](https://vega.github.io/vega-lite/docs/spec.html#single). */\n  view?: ViewConfig;\n\n  /**\n   * Scale configuration determines default properties for all [scales](https://vega.github.io/vega-lite/docs/scale.html). For a full list of scale configuration options, please see the [corresponding section of the scale documentation](https://vega.github.io/vega-lite/docs/scale.html#config).\n   */\n  scale?: ScaleConfig;\n\n  /** An object hash for defining default properties for each type of selections. */\n  selection?: SelectionConfig;\n\n  /** Default stack offset for stackable mark. */\n  stack?: StackOffset;\n}\n\nexport interface StyleConfigIndex {\n  [style: string]: VgMarkConfig;\n}\n\nexport interface Config\n  extends TopLevelProperties,\n    VLOnlyConfig,\n    MarkConfigMixins,\n    CompositeMarkConfigMixins,\n    AxisConfigMixins {\n  /**\n   * An object hash that defines default range arrays or schemes for using with scales.\n   * For a full list of scale range configuration options, please see the [corresponding section of the scale documentation](https://vega.github.io/vega-lite/docs/scale.html#config).\n   */\n  range?: RangeConfig;\n\n  /**\n   * Legend configuration, which determines default properties for all [legends](https://vega.github.io/vega-lite/docs/legend.html). For a full list of legend configuration options, please see the [corresponding section of in the legend documentation](https://vega.github.io/vega-lite/docs/legend.html#config).\n   */\n  legend?: LegendConfig;\n\n  /**\n   * Header configuration, which determines default properties for all [header](https://vega.github.io/vega-lite/docs/header.html). For a full list of header configuration options, please see the [corresponding section of in the header documentation](https://vega.github.io/vega-lite/docs/header.html#config).\n   */\n  header?: HeaderConfig;\n\n  /**\n   * Title configuration, which determines default properties for all [titles](https://vega.github.io/vega-lite/docs/title.html). For a full list of title configuration options, please see the [corresponding section of the title documentation](https://vega.github.io/vega-lite/docs/title.html#config).\n   */\n  title?: TitleConfig;\n\n  /**\n   * Projection configuration, which determines default properties for all [projections](https://vega.github.io/vega-lite/docs/projection.html). For a full list of projection configuration options, please see the [corresponding section of the projection documentation](https://vega.github.io/vega-lite/docs/projection.html#config).\n   */\n  projection?: ProjectionConfig;\n\n  /** An object hash that defines key-value mappings to determine default properties for marks with a given [style](https://vega.github.io/vega-lite/docs/mark.html#mark-def).  The keys represent styles names; the values have to be valid [mark configuration objects](https://vega.github.io/vega-lite/docs/mark.html#config).  */\n  style?: StyleConfigIndex;\n}\n\nexport const defaultConfig: Config = {\n  padding: 5,\n  timeFormat: '%b %d, %Y',\n  countTitle: 'Number of Records',\n\n  invalidValues: 'filter',\n\n  view: defaultViewConfig,\n\n  mark: mark.defaultMarkConfig,\n  area: {},\n  bar: mark.defaultBarConfig,\n  circle: {},\n  geoshape: {},\n  line: {},\n  point: {},\n  rect: {},\n  rule: {color: 'black'}, // Need this to override default color in mark config\n  square: {},\n  text: {color: 'black'}, // Need this to override default color in mark config\n  tick: mark.defaultTickConfig,\n  trail: {},\n\n  boxplot: {\n    size: 14,\n    extent: 1.5,\n    box: {},\n    median: {color: 'white'},\n    outliers: {},\n    rule: {},\n    ticks: null\n  },\n\n  errorbar: {\n    center: 'mean',\n    rule: true,\n    ticks: false\n  },\n\n  errorband: {\n    band: {\n      opacity: 0.3\n    },\n    borders: false\n  },\n\n  scale: defaultScaleConfig,\n\n  projection: {},\n\n  axis: {},\n  axisX: {},\n  axisY: {minExtent: 30},\n  axisLeft: {},\n  axisRight: {},\n  axisTop: {},\n  axisBottom: {},\n  axisBand: {},\n  legend: defaultLegendConfig,\n\n  selection: defaultSelectionConfig,\n  style: {},\n\n  title: {}\n};\n\nexport function initConfig(config: Config) {\n  return mergeDeep(duplicate(defaultConfig), config);\n}\n\nconst MARK_STYLES = ['view', ...PRIMITIVE_MARKS] as ('view' | Mark)[];\n\nconst VL_ONLY_CONFIG_PROPERTIES: (keyof Config)[] = [\n  'padding',\n  'numberFormat',\n  'timeFormat',\n  'countTitle',\n  'stack',\n  'scale',\n  'selection',\n  'invalidValues',\n  'overlay' as keyof Config // FIXME: Redesign and unhide this\n];\n\nconst VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {\n  view: ['width', 'height'],\n  ...VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX\n};\n\nexport function stripAndRedirectConfig(config: Config) {\n  config = duplicate(config);\n\n  for (const prop of VL_ONLY_CONFIG_PROPERTIES) {\n    delete config[prop];\n  }\n\n  // Remove Vega-Lite only axis/legend config\n  if (config.axis) {\n    for (const prop of VL_ONLY_GUIDE_CONFIG) {\n      delete config.axis[prop];\n    }\n  }\n  if (config.legend) {\n    for (const prop of VL_ONLY_GUIDE_CONFIG) {\n      delete config.legend[prop];\n    }\n  }\n\n  // Remove Vega-Lite only generic mark config\n  if (config.mark) {\n    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {\n      delete config.mark[prop];\n    }\n  }\n\n  for (const markType of MARK_STYLES) {\n    // Remove Vega-Lite-only mark config\n    for (const prop of VL_ONLY_MARK_CONFIG_PROPERTIES) {\n      delete config[markType][prop];\n    }\n\n    // Remove Vega-Lite only mark-specific config\n    const vlOnlyMarkSpecificConfigs = VL_ONLY_ALL_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX[markType];\n    if (vlOnlyMarkSpecificConfigs) {\n      for (const prop of vlOnlyMarkSpecificConfigs) {\n        delete config[markType][prop];\n      }\n    }\n\n    // Redirect mark config to config.style so that mark config only affect its own mark type\n    // without affecting other marks that share the same underlying Vega marks.\n    // For example, config.rect should not affect bar marks.\n    redirectConfig(config, markType);\n  }\n\n  for (const m of getAllCompositeMarks()) {\n    // Clean up the composite mark config as we don't need them in the output specs anymore\n    delete config[m];\n  }\n\n  // Redirect config.title -- so that title config do not\n  // affect header labels, which also uses `title` directive to implement.\n  redirectConfig(config, 'title', 'group-title');\n\n  // Remove empty config objects\n  for (const prop in config) {\n    if (isObject(config[prop]) && keys(config[prop]).length === 0) {\n      delete config[prop];\n    }\n  }\n\n  return keys(config).length > 0 ? config : undefined;\n}\n\nfunction redirectConfig(\n  config: Config,\n  prop: Mark | 'title' | 'view' | string, // string = composite mark\n  toProp?: string,\n  compositeMarkPart?: string\n) {\n  const propConfig: VgMarkConfig =\n    prop === 'title'\n      ? extractTitleConfig(config.title).mark\n      : compositeMarkPart\n        ? config[prop][compositeMarkPart]\n        : config[prop];\n\n  if (prop === 'view') {\n    toProp = 'cell'; // View's default style is \"cell\"\n  }\n\n  const style: VgMarkConfig = {\n    ...propConfig,\n    ...config.style[prop]\n  };\n  // set config.style if it is not an empty object\n  if (keys(style).length > 0) {\n    config.style[toProp || prop] = style;\n  }\n\n  if (!compositeMarkPart) {\n    // For composite mark, so don't delete the whole config yet as we have to do multiple redirections.\n    delete config[prop];\n  }\n}\n","/*\n * Constants and utilities for data.\n */\nimport {VgData} from './vega.schema';\n\nexport type ParseValue = null | string | 'string' | 'boolean' | 'date' | 'number';\n\nexport interface Parse {\n  [field: string]: ParseValue;\n}\n\nexport interface DataFormatBase {\n  /**\n   * If set to `null`, disable type inference based on the spec and only use type inference based on the data.\n   * Alternatively, a parsing directive object can be provided for explicit data types. Each property of the object corresponds to a field name, and the value to the desired data type (one of `\"number\"`, `\"boolean\"`, `\"date\"`, or null (do not parse the field)).\n   * For example, `\"parse\": {\"modified_on\": \"date\"}` parses the `modified_on` field in each input record a Date value.\n   *\n   * For `\"date\"`, we parse data based using Javascript's [`Date.parse()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).\n   * For Specific date formats can be provided (e.g., `{foo: 'date:\"%m%d%Y\"'}`), using the [d3-time-format syntax](https://github.com/d3/d3-time-format#locale_format). UTC date format parsing is supported similarly (e.g., `{foo: 'utc:\"%m%d%Y\"'}`). See more about [UTC time](https://vega.github.io/vega-lite/docs/timeunit.html#utc)\n   */\n  parse?: Parse | null;\n}\n\nexport interface CsvDataFormat extends DataFormatBase {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n   * The default format type is determined by the extension of the file URL.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: 'csv' | 'tsv';\n}\n\nexport interface DsvDataFormat extends DataFormatBase {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n   * The default format type is determined by the extension of the file URL.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: 'dsv';\n\n  /**\n   * The delimiter between records. The delimiter must be a single character (i.e., a single 16-bit code unit); so, ASCII delimiters are fine, but emoji delimiters are not.\n   *\n   * @minLength 1\n   * @maxLength 1\n   */\n  delimiter: string;\n}\n\nexport interface JsonDataFormat extends DataFormatBase {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n   * The default format type is determined by the extension of the file URL.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: 'json';\n  /**\n   * The JSON property containing the desired data.\n   * This parameter can be used when the loaded JSON file may have surrounding structure or meta-data.\n   * For example `\"property\": \"values.features\"` is equivalent to retrieving `json.values.features`\n   * from the loaded JSON object.\n   */\n  property?: string;\n}\n\nexport interface TopoDataFormat extends DataFormatBase {\n  /**\n   * Type of input data: `\"json\"`, `\"csv\"`, `\"tsv\"`, `\"dsv\"`.\n   * The default format type is determined by the extension of the file URL.\n   * If no extension is detected, `\"json\"` will be used by default.\n   */\n  type?: 'topojson';\n  /**\n   * The name of the TopoJSON object set to convert to a GeoJSON feature collection.\n   * For example, in a map of the world, there may be an object set named `\"countries\"`.\n   * Using the feature property, we can extract this set and generate a GeoJSON feature object for each country.\n   */\n  feature?: string;\n  /**\n   * The name of the TopoJSON object set to convert to mesh.\n   * Similar to the `feature` option, `mesh` extracts a named TopoJSON object set.\n   *  Unlike the `feature` option, the corresponding geo data is returned as a single, unified mesh instance, not as individual GeoJSON features.\n   * Extracting a mesh is useful for more efficiently drawing borders or other geographic elements that you do not need to associate with specific regions such as individual countries, states or counties.\n   */\n  mesh?: string;\n}\n\nexport type DataFormat = CsvDataFormat | DsvDataFormat | JsonDataFormat | TopoDataFormat;\n\nexport type DataFormatType = 'json' | 'csv' | 'tsv' | 'dsv' | 'topojson';\n\nexport type Data = UrlData | InlineData | NamedData;\n\nexport type InlineDataset = number[] | string[] | boolean[] | object[] | string | object;\n\nexport interface DataBase {\n  /**\n   * An object that specifies the format for parsing the data.\n   */\n  format?: DataFormat;\n  /**\n   * Provide a placeholder name and bind data at runtime.\n   */\n  name?: string;\n}\n\nexport interface UrlData extends DataBase {\n  /**\n   * An URL from which to load the data set. Use the `format.type` property\n   * to ensure the loaded data is correctly parsed.\n   */\n  url: string;\n}\n\nexport interface InlineData extends DataBase {\n  /**\n   * The full data set, included inline. This can be an array of objects or primitive values, an object, or a string.\n   * Arrays of primitive values are ingested as objects with a `data` property. Strings are parsed according to the specified format type.\n   */\n  values: InlineDataset;\n}\n\nexport interface NamedData extends DataBase {\n  /**\n   * Provide a placeholder name and bind data at runtime.\n   */\n  name: string;\n}\n\nexport function isUrlData(data: Partial<Data> | Partial<VgData>): data is UrlData {\n  return !!data['url'];\n}\n\nexport function isInlineData(data: Partial<Data> | Partial<VgData>): data is InlineData {\n  return !!data['values'];\n}\n\nexport function isNamedData(data: Partial<Data>): data is NamedData {\n  return !!data['name'] && !isUrlData(data) && !isInlineData(data);\n}\n\nexport type DataSourceType = 'raw' | 'main' | 'row' | 'column' | 'lookup';\n\nexport const MAIN: 'main' = 'main';\nexport const RAW: 'raw' = 'raw';\n","// DateTime definition object\n\nimport {isNumber} from 'vega-util';\nimport * as log from './log';\nimport {duplicate, keys} from './util';\n\n/*\n * A designated year that starts on Sunday.\n */\nconst SUNDAY_YEAR = 2006;\n\n/**\n * @minimum 1\n * @maximum 12\n * @TJS-type integer\n */\nexport type Month = number;\n\n/**\n * @minimum 1\n * @maximum 7\n */\nexport type Day = number;\n\n/**\n * Object for defining datetime in Vega-Lite Filter.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n * We accept string for month and day names.\n */\nexport interface DateTime {\n  /**\n   * Integer value representing the year.\n   * @TJS-type integer\n   */\n  year?: number;\n\n  /**\n   * Integer value representing the quarter of the year (from 1-4).\n   * @minimum 1\n   * @maximum 4\n   * @TJS-type integer\n   */\n  quarter?: number;\n\n  /** One of: (1) integer value representing the month from `1`-`12`. `1` represents January;  (2) case-insensitive month name (e.g., `\"January\"`);  (3) case-insensitive, 3-character short month name (e.g., `\"Jan\"`). */\n  month?: Month | string;\n\n  /**\n   * Integer value representing the date from 1-31.\n   * @minimum 1\n   * @maximum 31\n   * @TJS-type integer\n   */\n  date?: number;\n\n  /**\n   * Value representing the day of a week.  This can be one of: (1) integer value -- `1` represents Monday; (2) case-insensitive day name (e.g., `\"Monday\"`);  (3) case-insensitive, 3-character short day name (e.g., `\"Mon\"`).   <br/> **Warning:** A DateTime definition object with `day`** should not be combined with `year`, `quarter`, `month`, or `date`.\n   */\n  day?: Day | string;\n\n  /**\n   * Integer value representing the hour of a day from 0-23.\n   * @minimum 0\n   * @maximum 23\n   * @TJS-type integer\n   */\n  hours?: number;\n\n  /**\n   * Integer value representing the minute segment of time from 0-59.\n   * @minimum 0\n   * @maximum 59\n   * @TJS-type integer\n   */\n  minutes?: number;\n\n  /**\n   * Integer value representing the second segment (0-59) of a time value\n   * @minimum 0\n   * @maximum 59\n   * @TJS-type integer\n   */\n  seconds?: number;\n\n  /**\n   * Integer value representing the millisecond segment of time.\n   * @minimum 0\n   * @maximum 999\n   * @TJS-type integer\n   */\n  milliseconds?: number;\n\n  /**\n   * A boolean flag indicating if date time is in utc time. If false, the date time is in local time\n   */\n  utc?: boolean;\n}\n\n/**\n * Internal Object for defining datetime expressions.\n * This is an expression version of DateTime.\n * If both month and quarter are provided, month has higher precedence.\n * `day` cannot be combined with other date.\n */\nexport interface DateTimeExpr {\n  year?: string;\n  quarter?: string;\n  month?: string;\n  date?: string;\n  day?: string;\n  hours?: string;\n  minutes?: string;\n  seconds?: string;\n  milliseconds?: string;\n  utc?: boolean;\n}\n\nexport function isDateTime(o: any): o is DateTime {\n  return (\n    !!o &&\n    (!!o.year ||\n      !!o.quarter ||\n      !!o.month ||\n      !!o.date ||\n      !!o.day ||\n      !!o.hours ||\n      !!o.minutes ||\n      !!o.seconds ||\n      !!o.milliseconds)\n  );\n}\n\nexport const MONTHS = [\n  'january',\n  'february',\n  'march',\n  'april',\n  'may',\n  'june',\n  'july',\n  'august',\n  'september',\n  'october',\n  'november',\n  'december'\n];\nexport const SHORT_MONTHS = MONTHS.map(m => m.substr(0, 3));\n\nexport const DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nexport const SHORT_DAYS = DAYS.map(d => d.substr(0, 3));\n\nfunction normalizeQuarter(q: number | string) {\n  if (isNumber(q)) {\n    if (q > 4) {\n      log.warn(log.message.invalidTimeUnit('quarter', q));\n    }\n    // We accept 1-based quarter, so need to readjust to 0-based quarter\n    return (q - 1).toString();\n  } else {\n    // Invalid quarter\n    throw new Error(log.message.invalidTimeUnit('quarter', q));\n  }\n}\n\nfunction normalizeMonth(m: string | number) {\n  if (isNumber(m)) {\n    // We accept 1-based month, so need to readjust to 0-based month\n    return (m - 1).toString();\n  } else {\n    const lowerM = m.toLowerCase();\n    const monthIndex = MONTHS.indexOf(lowerM);\n    if (monthIndex !== -1) {\n      return monthIndex + ''; // 0 for january, ...\n    }\n    const shortM = lowerM.substr(0, 3);\n    const shortMonthIndex = SHORT_MONTHS.indexOf(shortM);\n    if (shortMonthIndex !== -1) {\n      return shortMonthIndex + '';\n    }\n    // Invalid month\n    throw new Error(log.message.invalidTimeUnit('month', m));\n  }\n}\n\nfunction normalizeDay(d: string | number) {\n  if (isNumber(d)) {\n    // mod so that this can be both 0-based where 0 = sunday\n    // and 1-based where 7=sunday\n    return (d % 7) + '';\n  } else {\n    const lowerD = d.toLowerCase();\n    const dayIndex = DAYS.indexOf(lowerD);\n    if (dayIndex !== -1) {\n      return dayIndex + ''; // 0 for january, ...\n    }\n    const shortD = lowerD.substr(0, 3);\n    const shortDayIndex = SHORT_DAYS.indexOf(shortD);\n    if (shortDayIndex !== -1) {\n      return shortDayIndex + '';\n    }\n    // Invalid day\n    throw new Error(log.message.invalidTimeUnit('day', d));\n  }\n}\n\n/**\n * Return Vega Expression for a particular date time.\n * @param d\n * @param normalize whether to normalize quarter, month, day.\n */\nexport function dateTimeExpr(d: DateTime | DateTimeExpr, normalize = false) {\n  const units: (string | number)[] = [];\n\n  if (normalize && d.day !== undefined) {\n    if (keys(d).length > 1) {\n      log.warn(log.message.droppedDay(d));\n      d = duplicate(d);\n      delete d.day;\n    }\n  }\n\n  if (d.year !== undefined) {\n    units.push(d.year);\n  } else if (d.day !== undefined) {\n    // Set year to 2006 for working with day since January 1 2006 is a Sunday\n    units.push(SUNDAY_YEAR);\n  } else {\n    units.push(0);\n  }\n\n  if (d.month !== undefined) {\n    const month = normalize ? normalizeMonth(d.month) : d.month;\n    units.push(month);\n  } else if (d.quarter !== undefined) {\n    const quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n    units.push(quarter + '*3');\n  } else {\n    units.push(0); // months start at zero in JS\n  }\n\n  if (d.date !== undefined) {\n    units.push(d.date);\n  } else if (d.day !== undefined) {\n    // HACK: Day only works as a standalone unit\n    // This is only correct because we always set year to 2006 for day\n    const day = normalize ? normalizeDay(d.day) : d.day;\n    units.push(day + '+1');\n  } else {\n    units.push(1); // Date starts at 1 in JS\n  }\n\n  // Note: can't use TimeUnit enum here as importing it will create\n  // circular dependency problem!\n  for (const timeUnit of ['hours', 'minutes', 'seconds', 'milliseconds']) {\n    if (d[timeUnit] !== undefined) {\n      units.push(d[timeUnit]);\n    } else {\n      units.push(0);\n    }\n  }\n\n  if (d.utc) {\n    return `utc(${units.join(', ')})`;\n  } else {\n    return `datetime(${units.join(', ')})`;\n  }\n}\n","import {isArray} from 'vega-util';\nimport {isAggregateOp} from './aggregate';\nimport {isBinning} from './bin';\nimport {Channel, CHANNELS, isChannel, supportMark} from './channel';\nimport {Config} from './config';\nimport {FacetMapping} from './facet';\nimport {\n  ChannelDef,\n  Field,\n  FieldDef,\n  FieldDefWithCondition,\n  FieldDefWithoutScale,\n  getFieldDef,\n  hasConditionalFieldDef,\n  isConditionalDef,\n  isFieldDef,\n  isValueDef,\n  MarkPropFieldDef,\n  normalize,\n  normalizeFieldDef,\n  OrderFieldDef,\n  PositionFieldDef,\n  TextFieldDef,\n  title,\n  ValueDef,\n  ValueDefWithCondition,\n  vgField\n} from './fielddef';\nimport * as log from './log';\nimport {Mark} from './mark';\nimport {AggregatedFieldDef, BinTransform, TimeUnitTransform} from './transform';\nimport {keys, some} from './util';\n\nexport interface Encoding<F> {\n  /**\n   * X coordinates of the marks, or width of horizontal `\"bar\"` and `\"area\"`.\n   */\n  x?: PositionFieldDef<F> | ValueDef;\n\n  /**\n   * Y coordinates of the marks, or height of vertical `\"bar\"` and `\"area\"`.\n   */\n  y?: PositionFieldDef<F> | ValueDef;\n\n  /**\n   * X2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // TODO: Ham need to add default behavior\n  x2?: FieldDefWithoutScale<F> | ValueDef;\n\n  /**\n   * Y2 coordinates for ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  // TODO: Ham need to add default behavior\n  y2?: FieldDefWithoutScale<F> | ValueDef;\n\n  /**\n   * Longitude position of geographically projected marks.\n   */\n  longitude?: FieldDefWithoutScale<F>;\n\n  /**\n   * Latitude position of geographically projected marks.\n   */\n  latitude?: FieldDefWithoutScale<F>;\n\n  /**\n   * Longitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  longitude2?: FieldDefWithoutScale<F>;\n\n  /**\n   * Latitude-2 position for geographically projected ranged `\"area\"`, `\"bar\"`, `\"rect\"`, and  `\"rule\"`.\n   */\n  latitude2?: FieldDefWithoutScale<F>;\n\n  /**\n   * Color of the marks  either fill or stroke color based on  the `filled` property of mark definition.\n   * By default, `color` represents fill color for `\"area\"`, `\"bar\"`, `\"tick\"`,\n   * `\"text\"`, `\"trail\"`, `\"circle\"`, and `\"square\"` / stroke color for `\"line\"` and `\"point\"`.\n   *\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_\n   * 1) For fine-grained control over both fill and stroke colors of the marks, please use the `fill` and `stroke` channels.  If either `fill` or `stroke` channel is specified, `color` channel will be ignored.\n   * 2) See the scale documentation for more information about customizing [color scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme).\n   */\n  color?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n  /**\n   * Fill color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_ When using `fill` channel, `color ` channel will be ignored. To customize both fill and stroke, please use `fill` and `stroke` channels (not `fill` and `color`).\n   */\n  fill?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n  /**\n   * Stroke color of the marks.\n   * __Default value:__ If undefined, the default color depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `color` property.\n   *\n   * _Note:_ When using `stroke` channel, `color ` channel will be ignored. To customize both stroke and fill, please use `stroke` and `fill` channels (not `stroke` and `color`).\n   */\n  stroke?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n  /**\n   * Opacity of the marks  either can be a value or a range.\n   *\n   * __Default value:__ If undefined, the default opacity depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#mark)'s `opacity` property.\n   */\n  opacity?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n  /**\n   * Size of the mark.\n   * - For `\"point\"`, `\"square\"` and `\"circle\"`,  the symbol size, or pixel area of the mark.\n   * - For `\"bar\"` and `\"tick\"`  the bar and tick's size.\n   * - For `\"text\"`  the text's font size.\n   * - Size is unsupported for `\"line\"`, `\"area\"`, and `\"rect\"`. (Use `\"trail\"` instead of line with varying size)\n   */\n  size?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>;\n\n  /**\n   * For `point` marks the supported values are\n   * `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`,\n   * or `\"triangle-down\"`, or else a custom SVG path string.\n   * For `geoshape` marks it should be a field definition of the geojson data\n   *\n   * __Default value:__ If undefined, the default shape depends on [mark config](https://vega.github.io/vega-lite/docs/config.html#point-config)'s `shape` property.\n   */\n  shape?: FieldDefWithCondition<MarkPropFieldDef<F>> | ValueDefWithCondition<MarkPropFieldDef<F>>; // TODO: maybe distinguish ordinal-only\n  /**\n   * Additional levels of detail for grouping data in aggregate views and\n   * in line, trail, and area marks without mapping data to a specific visual channel.\n   */\n  detail?: FieldDefWithoutScale<F> | FieldDefWithoutScale<F>[];\n\n  /**\n   * A data field to use as a unique key for data binding. When a visualizations data is updated, the key value will be used to match data elements to existing mark instances. Use a key channel to enable object constancy for transitions over dynamic data.\n   */\n  key?: FieldDefWithoutScale<F>;\n\n  /**\n   * Text of the `text` mark.\n   */\n  text?: FieldDefWithCondition<TextFieldDef<F>> | ValueDefWithCondition<TextFieldDef<F>>;\n\n  /**\n   * The tooltip text to show upon mouse hover.\n   */\n  tooltip?: FieldDefWithCondition<TextFieldDef<F>> | ValueDefWithCondition<TextFieldDef<F>> | TextFieldDef<F>[];\n\n  /**\n   * A URL to load upon mouse click.\n   */\n  href?: FieldDefWithCondition<FieldDefWithoutScale<F>> | ValueDefWithCondition<FieldDefWithoutScale<F>>;\n\n  /**\n   * Order of the marks.\n   * - For stacked marks, this `order` channel encodes [stack order](https://vega.github.io/vega-lite/docs/stack.html#order).\n   * - For line and trail marks, this `order` channel encodes order of data points in the lines. This can be useful for creating [a connected scatterplot](https://vega.github.io/vega-lite/examples/connected_scatterplot.html).  Setting `order` to `{\"value\": null}` makes the line marks use the original order in the data sources.\n   * - Otherwise, this `order` channel encodes layer order of the marks.\n   *\n   * __Note__: In aggregate plots, `order` field should be `aggregate`d to avoid creating additional aggregation grouping.\n   */\n  order?: OrderFieldDef<F> | OrderFieldDef<F>[] | ValueDef;\n}\n\nexport interface EncodingWithFacet<F> extends Encoding<F>, FacetMapping<F> {}\n\nexport function channelHasField<T>(encoding: EncodingWithFacet<T>, channel: Channel): boolean {\n  const channelDef = encoding && encoding[channel];\n  if (channelDef) {\n    if (isArray(channelDef)) {\n      return some(channelDef, fieldDef => !!fieldDef.field);\n    } else {\n      return isFieldDef(channelDef) || hasConditionalFieldDef(channelDef);\n    }\n  }\n  return false;\n}\n\nexport function isAggregate(encoding: EncodingWithFacet<Field>) {\n  return some(CHANNELS, channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      if (isArray(channelDef)) {\n        return some(channelDef, fieldDef => !!fieldDef.aggregate);\n      } else {\n        const fieldDef = getFieldDef(channelDef);\n        return fieldDef && !!fieldDef.aggregate;\n      }\n    }\n    return false;\n  });\n}\n\nexport function extractTransformsFromEncoding(oldEncoding: Encoding<string>, config: Config) {\n  const groupby: string[] = [];\n  const bins: BinTransform[] = [];\n  const timeUnits: TimeUnitTransform[] = [];\n  const aggregate: AggregatedFieldDef[] = [];\n  const encoding: Encoding<string> = {};\n\n  forEach(oldEncoding, (channelDef, channel) => {\n    if (isFieldDef(channelDef)) {\n      const transformedField = vgField(channelDef, {forAs: true});\n      if (channelDef.aggregate && isAggregateOp(channelDef.aggregate)) {\n        aggregate.push({\n          op: channelDef.aggregate,\n          field: channelDef.field,\n          as: transformedField\n        });\n      } else {\n        // Add bin or timeUnit transform if applicable\n        const bin = channelDef.bin;\n        if (isBinning(bin)) {\n          const {field} = channelDef;\n          bins.push({bin, field, as: transformedField});\n        } else if (channelDef.timeUnit) {\n          const {timeUnit, field} = channelDef;\n          timeUnits.push({timeUnit, field, as: transformedField});\n        }\n\n        // TODO(@alanbanh): make bin correct\n        groupby.push(transformedField);\n      }\n      // now the field should refer to post-transformed field instead\n      encoding[channel] = {\n        field: vgField(channelDef),\n        type: channelDef.type,\n        title: title(channelDef, config, {allowDisabling: true})\n      };\n    } else {\n      // For value def, just copy\n      encoding[channel] = oldEncoding[channel];\n    }\n  });\n\n  return {\n    bins,\n    timeUnits,\n    aggregate,\n    groupby,\n    encoding\n  };\n}\n\nexport function normalizeEncoding(encoding: Encoding<string>, mark: Mark): Encoding<string> {\n  return keys(encoding).reduce((normalizedEncoding: Encoding<string>, channel: Channel | string) => {\n    if (!isChannel(channel)) {\n      // Drop invalid channel\n      log.warn(log.message.invalidEncodingChannel(channel));\n      return normalizedEncoding;\n    }\n\n    if (!supportMark(encoding, channel, mark)) {\n      // Drop unsupported channel\n      log.warn(log.message.incompatibleChannel(channel, mark));\n      return normalizedEncoding;\n    }\n\n    // Drop line's size if the field is aggregated.\n    if (channel === 'size' && mark === 'line') {\n      const fieldDef = getFieldDef(encoding[channel]);\n      if (fieldDef && fieldDef.aggregate) {\n        log.warn(log.message.LINE_WITH_VARYING_SIZE);\n        return normalizedEncoding;\n      }\n    }\n\n    // Drop color if either fill or stroke is specified\n    if (channel === 'color' && ('fill' in encoding || 'stroke' in encoding)) {\n      log.warn(log.message.droppingColor('encoding', {fill: 'fill' in encoding, stroke: 'stroke' in encoding}));\n      return normalizedEncoding;\n    }\n\n    const channelDef = encoding[channel];\n    if (\n      channel === 'detail' ||\n      (channel === 'order' && !isArray(channelDef) && !isValueDef(channelDef)) ||\n      (channel === 'tooltip' && isArray(channelDef))\n    ) {\n      if (channelDef) {\n        // Array of fieldDefs for detail channel (or production rule)\n        normalizedEncoding[channel] = (isArray(channelDef) ? channelDef : [channelDef]).reduce(\n          (defs: FieldDef<string>[], fieldDef: FieldDef<string>) => {\n            if (!isFieldDef(fieldDef)) {\n              log.warn(log.message.emptyFieldDef(fieldDef, channel));\n            } else {\n              defs.push(normalizeFieldDef(fieldDef, channel));\n            }\n            return defs;\n          },\n          []\n        );\n      }\n    } else {\n      if (!isFieldDef(channelDef) && !isValueDef(channelDef) && !isConditionalDef(channelDef)) {\n        log.warn(log.message.emptyFieldDef(channelDef, channel));\n        return normalizedEncoding;\n      }\n      normalizedEncoding[channel] = normalize(channelDef as ChannelDef<string>, channel);\n    }\n    return normalizedEncoding;\n  }, {});\n}\n\nexport function isRanged(encoding: EncodingWithFacet<any>) {\n  return encoding && ((!!encoding.x && !!encoding.x2) || (!!encoding.y && !!encoding.y2));\n}\n\nexport function fieldDefs<T>(encoding: EncodingWithFacet<T>): FieldDef<T>[] {\n  const arr: FieldDef<T>[] = [];\n  CHANNELS.forEach(channel => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach(def => {\n        if (isFieldDef(def)) {\n          arr.push(def);\n        } else if (hasConditionalFieldDef(def)) {\n          arr.push(def.condition);\n        }\n      });\n    }\n  });\n  return arr;\n}\n\nexport function forEach(mapping: any, f: (fd: FieldDef<string>, c: Channel) => void, thisArg?: any) {\n  if (!mapping) {\n    return;\n  }\n\n  for (const channel of keys(mapping)) {\n    if (isArray(mapping[channel])) {\n      mapping[channel].forEach((channelDef: ChannelDef<string>) => {\n        f.call(thisArg, channelDef, channel);\n      });\n    } else {\n      f.call(thisArg, mapping[channel], channel);\n    }\n  }\n}\n\nexport function reduce<T, U extends {[k in Channel]?: any}>(\n  mapping: U,\n  f: (acc: any, fd: FieldDef<string>, c: Channel) => U,\n  init: T,\n  thisArg?: any\n) {\n  if (!mapping) {\n    return init;\n  }\n\n  return keys(mapping).reduce((r, channel) => {\n    const map = mapping[channel];\n    if (isArray(map)) {\n      return map.reduce((r1: T, channelDef: ChannelDef<string>) => {\n        return f.call(thisArg, r1, channelDef, channel);\n      }, r);\n    } else {\n      return f.call(thisArg, r, map, channel);\n    }\n  }, init);\n}\n","import {ChannelDef, SortableFieldDef} from './fielddef';\nimport {Header} from './header';\n\nexport interface FacetFieldDef<F> extends SortableFieldDef<F> {\n  /**\n   * An object defining properties of a facet's header.\n   */\n  header?: Header;\n}\n\nexport interface FacetMapping<F> {\n  /**\n   * Vertical facets for trellis plots.\n   */\n  row?: FacetFieldDef<F>;\n\n  /**\n   * Horizontal facets for trellis plots.\n   */\n  column?: FacetFieldDef<F>;\n}\n\nexport function isFacetFieldDef<F>(channelDef: ChannelDef<F>): channelDef is FacetFieldDef<F> {\n  return !!channelDef && !!channelDef['header'];\n}\n","// Declaration and utility for variants of a field definition object\nimport {AggregateOp} from 'vega';\nimport {isArray, isBoolean, isNumber, isString} from 'vega-util';\nimport {isAggregateOp, isCountingAggregateOp} from './aggregate';\nimport {Axis} from './axis';\nimport {autoMaxBins, BinParams, binToString, isBinned, isBinning} from './bin';\nimport {Channel, POSITION_SCALE_CHANNELS, rangeType} from './channel';\nimport {CompositeAggregate} from './compositemark';\nimport {Config} from './config';\nimport {DateTime, dateTimeExpr, isDateTime} from './datetime';\nimport {isFacetFieldDef} from './facet';\nimport {Guide, TitleMixins} from './guide';\nimport {ImputeParams} from './impute';\nimport {Legend} from './legend';\nimport * as log from './log';\nimport {LogicalOperand} from './logical';\nimport {Predicate} from './predicate';\nimport {Scale} from './scale';\nimport {Sort, SortOrder} from './sort';\nimport {StackOffset} from './stack';\nimport {\n  getLocalTimeUnit,\n  getTimeUnitParts,\n  isLocalSingleTimeUnit,\n  isUtcSingleTimeUnit,\n  normalizeTimeUnit,\n  TimeUnit\n} from './timeunit';\nimport {AggregatedFieldDef, WindowFieldDef} from './transform';\nimport {getFullName, QUANTITATIVE, Type} from './type';\nimport {contains, flatAccessWithDatum, getFirstDefined, replacePathInField, titlecase} from './util';\n\ntype Value = number | string | boolean | null;\n\n/**\n * Definition object for a constant value of an encoding channel.\n */\nexport interface ValueDef {\n  /**\n   * A constant value in visual domain (e.g., `\"red\"` / \"#0099ff\" for color, values between `0` to `1` for opacity).\n   */\n  value: Value;\n}\n\n/**\n * Generic type for conditional channelDef.\n * F defines the underlying FieldDef type.\n */\nexport type ChannelDefWithCondition<F extends FieldDef<any>> = FieldDefWithCondition<F> | ValueDefWithCondition<F>;\n\nexport type Conditional<T> = ConditionalPredicate<T> | ConditionalSelection<T>;\n\nexport type ConditionalPredicate<T> = {\n  test: LogicalOperand<Predicate>;\n} & T;\n\nexport type ConditionalSelection<T> = {\n  /**\n   * A [selection name](https://vega.github.io/vega-lite/docs/selection.html), or a series of [composed selections](https://vega.github.io/vega-lite/docs/selection.html#compose).\n   */\n  selection: LogicalOperand<string>;\n} & T;\n\nexport function isConditionalSelection<T>(c: Conditional<T>): c is ConditionalSelection<T> {\n  return c['selection'];\n}\n\nexport interface ConditionValueDefMixins {\n  /**\n   * One or more value definition(s) with a selection predicate.\n   *\n   * __Note:__ A field definition's `condition` property can only contain [value definitions](https://vega.github.io/vega-lite/docs/encoding.html#value-def)\n   * since Vega-Lite only allows at most one encoded field per encoding channel.\n   */\n  condition?: Conditional<ValueDef> | Conditional<ValueDef>[];\n}\n\n/**\n * A FieldDef with Condition<ValueDef>\n * {\n *   condition: {value: ...},\n *   field: ...,\n *   ...\n * }\n */\n\nexport type FieldDefWithCondition<F extends FieldDef<any>> = F & ConditionValueDefMixins;\n\n/**\n * A ValueDef with Condition<ValueDef | FieldDef>\n * {\n *   condition: {field: ...} | {value: ...},\n *   value: ...,\n * }\n */\nexport interface ValueDefWithCondition<F extends FieldDef<any>> {\n  /**\n   * A field definition or one or more value definition(s) with a selection predicate.\n   */\n  condition?: Conditional<F> | Conditional<ValueDef> | Conditional<ValueDef>[];\n\n  /**\n   * A constant value in visual domain.\n   */\n  value?: Value;\n}\n\n/**\n * Reference to a repeated value.\n */\nexport interface RepeatRef {\n  repeat: 'row' | 'column';\n}\n\nexport type Field = string | RepeatRef;\n\nexport function isRepeatRef(field: Field): field is RepeatRef {\n  return field && !isString(field) && 'repeat' in field;\n}\n\n/** @hide */\nexport type HiddenCompositeAggregate = CompositeAggregate;\n\nexport type Aggregate = AggregateOp | HiddenCompositeAggregate;\n\nexport interface GenericBinMixins<B> {\n  /**\n   * A flag for binning a `quantitative` field, [an object defining binning parameters](https://vega.github.io/vega-lite/docs/bin.html#params), or indicating that the data for `x` or `y` channel are binned before they are imported into Vega-Lite (`\"binned\"`).\n   *\n   * - If `true`, default [binning parameters](https://vega.github.io/vega-lite/docs/bin.html) will be applied.\n   *\n   * - To indicate that the data for the `x` (or `y`) channel are already binned, you can set the `bin` property of the `x` (or `y`) channel to `\"binned\"` and map the bin-start field to `x` (or `y`) and the bin-end field to `x2` (or `y2`). The scale and axis will be formatted similar to binning in Vega-lite.  To adjust the axis ticks based on the bin step, you can also set the axis's [`tickStep`](https://vega.github.io/vega-lite/docs/axis.html#ticks) property.\n   *\n   * __Default value:__ `false`\n   */\n  bin?: B;\n}\n\nexport type BaseBinMixins = GenericBinMixins<boolean | BinParams | 'binned'>;\nexport type BinWithoutBinnedMixins = GenericBinMixins<boolean | BinParams>;\n\nexport interface FieldDefBase<F> extends BaseBinMixins {\n  /**\n   * __Required.__ A string defining the name of the field from which to pull a data value\n   * or an object defining iterated values from the [`repeat`](https://vega.github.io/vega-lite/docs/repeat.html) operator.\n   *\n   * __Note:__ Dots (`.`) and brackets (`[` and `]`) can be used to access nested objects (e.g., `\"field\": \"foo.bar\"` and `\"field\": \"foo['bar']\"`).\n   * If field names contain dots or brackets but are not nested, you can use `\\\\` to escape dots and brackets (e.g., `\"a\\\\.b\"` and `\"a\\\\[0\\\\]\"`).\n   * See more details about escaping in the [field documentation](https://vega.github.io/vega-lite/docs/field.html).\n   *\n   * __Note:__ `field` is not required if `aggregate` is `count`.\n   */\n  field?: F;\n\n  // function\n\n  /**\n   * Time unit (e.g., `year`, `yearmonth`, `month`, `hours`) for a temporal field.\n   * or [a temporal field that gets casted as ordinal](https://vega.github.io/vega-lite/docs/type.html#cast).\n   *\n   * __Default value:__ `undefined` (None)\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Aggregation function for the field\n   * (e.g., `mean`, `sum`, `median`, `min`, `max`, `count`).\n   *\n   * __Default value:__ `undefined` (None)\n   */\n  aggregate?: Aggregate;\n}\n\nexport function toFieldDefBase(fieldDef: FieldDef<string>): FieldDefBase<string> {\n  const {field, timeUnit, bin, aggregate} = fieldDef;\n  return {\n    ...(timeUnit ? {timeUnit} : {}),\n    ...(bin ? {bin} : {}),\n    ...(aggregate ? {aggregate} : {}),\n    field\n  };\n}\n\n/**\n *  Definition object for a data field, its type and transformation of an encoding channel.\n */\nexport interface FieldDef<F> extends FieldDefBase<F>, TitleMixins {\n  /**\n   * The encoded field's type of measurement (`\"quantitative\"`, `\"temporal\"`, `\"ordinal\"`, or `\"nominal\"`).\n   * It can also be a `\"geojson\"` type for encoding ['geoshape'](https://vega.github.io/vega-lite/docs/geoshape.html).\n   */\n  // * or an initial character of the type name (`\"Q\"`, `\"T\"`, `\"O\"`, `\"N\"`).\n  // * This property is case-insensitive.\n  type: Type;\n}\n\nexport interface SortableFieldDef<F> extends FieldDef<F> {\n  /**\n   * Sort order for the encoded field.\n   *\n   * For continuous fields (quantitative or temporal), `sort` can be either `\"ascending\"` or `\"descending\"`.\n   *\n   * For discrete fields, `sort` can be one of the following:\n   * - `\"ascending\"` or `\"descending\"` -- for sorting by the values' natural order in Javascript.\n   * - [A sort field definition](https://vega.github.io/vega-lite/docs/sort.html#sort-field) for sorting by another field.\n   * - [An array specifying the field values in preferred order](https://vega.github.io/vega-lite/docs/sort.html#sort-array). In this case, the sort order will obey the values in the array, followed by any unspecified values in their original order.  For discrete time field, values in the sort array can be [date-time definition objects](types#datetime). In addition, for time units `\"month\"` and `\"day\"`, the values can be the month or day names (case insensitive) or their 3-letter initials (e.g., `\"Mon\"`, `\"Tue\"`).\n   * - `null` indicating no sort.\n   *\n   * __Default value:__ `\"ascending\"`\n   *\n   * __Note:__ `null` is not supported for `row` and `column`.\n   */\n  sort?: Sort<F>;\n}\n\nexport interface ScaleFieldDef<F> extends SortableFieldDef<F> {\n  /**\n   * An object defining properties of the channel's scale, which is the function that transforms values in the data domain (numbers, dates, strings, etc) to visual values (pixels, colors, sizes) of the encoding channels.\n   *\n   * If `null`, the scale will be [disabled and the data value will be directly encoded](https://vega.github.io/vega-lite/docs/scale.html#disable).\n   *\n   * __Default value:__ If undefined, default [scale properties](https://vega.github.io/vega-lite/docs/scale.html) are applied.\n   */\n  scale?: Scale | null;\n}\n\n/**\n * Field Def without scale (and without bin: \"binned\" support).\n */\nexport type FieldDefWithoutScale<F> = FieldDef<F> & BinWithoutBinnedMixins;\n\nexport interface PositionFieldDef<F> extends ScaleFieldDef<F> {\n  /**\n   * An object defining properties of axis's gridlines, ticks and labels.\n   * If `null`, the axis for the encoding channel will be removed.\n   *\n   * __Default value:__ If undefined, default [axis properties](https://vega.github.io/vega-lite/docs/axis.html) are applied.\n   */\n  axis?: Axis | null;\n\n  /**\n   * Type of stacking offset if the field should be stacked.\n   * `stack` is only applicable for `x` and `y` channels with continuous domains.\n   * For example, `stack` of `y` can be used to customize stacking for a vertical bar chart.\n   *\n   * `stack` can be one of the following values:\n   * - `\"zero\"`: stacking with baseline offset at zero value of the scale (for creating typical stacked [bar](https://vega.github.io/vega-lite/docs/stack.html#bar) and [area](https://vega.github.io/vega-lite/docs/stack.html#area) chart).\n   * - `\"normalize\"` - stacking with normalized domain (for creating [normalized stacked bar and area charts](https://vega.github.io/vega-lite/docs/stack.html#normalized). <br/>\n   * -`\"center\"` - stacking with center baseline (for [streamgraph](https://vega.github.io/vega-lite/docs/stack.html#streamgraph)).\n   * - `null` - No-stacking. This will produce layered [bar](https://vega.github.io/vega-lite/docs/stack.html#layered-bar-chart) and area chart.\n   *\n   * __Default value:__ `zero` for plots with all of the following conditions are true:\n   * (1) the mark is `bar` or `area`;\n   * (2) the stacked measure channel (x or y) has a linear scale;\n   * (3) At least one of non-position channels mapped to an unaggregated field that is different from x and y.  Otherwise, `null` by default.\n   */\n  stack?: StackOffset | null;\n\n  /**\n   * An object defining the properties of the Impute Operation to be applied.\n   * The field value of the other positional channel is taken as `key` of the `Impute` Operation.\n   * The field of the `color` channel if specified is used as `groupby` of the `Impute` Operation.\n   */\n  impute?: ImputeParams;\n}\n\n/**\n * Field definition of a mark property, which can contain a legend.\n */\nexport type MarkPropFieldDef<F> = ScaleFieldDef<F> &\n  BinWithoutBinnedMixins & {\n    /**\n     * An object defining properties of the legend.\n     * If `null`, the legend for the encoding channel will be removed.\n     *\n     * __Default value:__ If undefined, default [legend properties](https://vega.github.io/vega-lite/docs/legend.html) are applied.\n     */\n    legend?: Legend | null;\n  };\n\n// Detail\n\n// Order Path have no scale\n\nexport interface OrderFieldDef<F> extends FieldDefWithoutScale<F> {\n  /**\n   * The sort order. One of `\"ascending\"` (default) or `\"descending\"`.\n   */\n  sort?: SortOrder;\n}\n\nexport interface TextFieldDef<F> extends FieldDefWithoutScale<F> {\n  /**\n   * The [formatting pattern](https://vega.gFieldDefWithoutBinnedithub.io/vega-lite/docs/format.html) for a text field. If not defined, this will be determined automatically.\n   */\n  format?: string;\n}\n\nexport type ChannelDef<F> = ChannelDefWithCondition<FieldDef<F>>;\n\nexport function isConditionalDef<F>(channelDef: ChannelDef<F>): channelDef is ChannelDefWithCondition<FieldDef<F>> {\n  return !!channelDef && !!channelDef.condition;\n}\n\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\nexport function hasConditionalFieldDef<F>(\n  channelDef: ChannelDef<F>\n): channelDef is ValueDef & {condition: Conditional<FieldDef<F>>} {\n  return !!channelDef && !!channelDef.condition && !isArray(channelDef.condition) && isFieldDef(channelDef.condition);\n}\n\nexport function hasConditionalValueDef<F>(\n  channelDef: ChannelDef<F>\n): channelDef is ValueDef & {condition: Conditional<ValueDef> | Conditional<ValueDef>[]} {\n  return !!channelDef && !!channelDef.condition && (isArray(channelDef.condition) || isValueDef(channelDef.condition));\n}\n\nexport function isFieldDef<F>(\n  channelDef: ChannelDef<F>\n): channelDef is\n  | FieldDef<F>\n  | PositionFieldDef<F>\n  | ScaleFieldDef<F>\n  | MarkPropFieldDef<F>\n  | OrderFieldDef<F>\n  | TextFieldDef<F> {\n  return !!channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\n\nexport function isStringFieldDef(channelDef: ChannelDef<string | RepeatRef>): channelDef is FieldDef<string> {\n  return isFieldDef(channelDef) && isString(channelDef.field);\n}\n\nexport function isValueDef<F>(channelDef: ChannelDef<F>): channelDef is ValueDef {\n  return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;\n}\n\nexport function isScaleFieldDef<F>(channelDef: ChannelDef<F>): channelDef is ScaleFieldDef<F> {\n  return !!channelDef && (!!channelDef['scale'] || !!channelDef['sort']);\n}\n\nexport function isPositionFieldDef<F>(channelDef: ChannelDef<F>): channelDef is PositionFieldDef<F> {\n  return !!channelDef && (!!channelDef['axis'] || !!channelDef['stack'] || !!channelDef['impute']);\n}\n\nexport function isMarkPropFieldDef<F>(channelDef: ChannelDef<F>): channelDef is MarkPropFieldDef<F> {\n  return !!channelDef && !!channelDef['legend'];\n}\n\nexport function isTextFieldDef<F>(channelDef: ChannelDef<F>): channelDef is TextFieldDef<F> {\n  return !!channelDef && !!channelDef['format'];\n}\n\nexport interface FieldRefOption {\n  /** Exclude bin, aggregate, timeUnit */\n  nofn?: boolean;\n  /** Wrap the field with datum or parent (e.g., datum['...'] for Vega Expression */\n  expr?: 'datum' | 'parent';\n  /** Prepend fn with custom function prefix */\n  prefix?: string;\n  /** Append suffix to the field ref for bin (default='start') */\n  binSuffix?: 'end' | 'range' | 'mid';\n  /** Append suffix to the field ref (general) */\n  suffix?: string;\n  /**\n   * Use the field name for `as` in a transform.\n   * We will not escape nested acceses because Vega transform outputs cannot be nested.\n   */\n  forAs?: boolean;\n}\n\nfunction isOpFieldDef(\n  fieldDef: FieldDefBase<string> | WindowFieldDef | AggregatedFieldDef\n): fieldDef is WindowFieldDef | AggregatedFieldDef {\n  return !!fieldDef['op'];\n}\n\n/**\n * Get a Vega field reference from a Vega-Lite field def.\n */\nexport function vgField(\n  fieldDef: FieldDefBase<string> | WindowFieldDef | AggregatedFieldDef,\n  opt: FieldRefOption = {}\n): string {\n  let field = fieldDef.field;\n  const prefix = opt.prefix;\n  let suffix = opt.suffix;\n\n  if (isCount(fieldDef)) {\n    field = 'count_*';\n  } else {\n    let fn: string;\n\n    if (!opt.nofn) {\n      if (isOpFieldDef(fieldDef)) {\n        fn = fieldDef.op;\n      } else if (isBinning(fieldDef.bin)) {\n        fn = binToString(fieldDef.bin);\n        suffix = opt.binSuffix || '';\n      } else if (fieldDef.aggregate) {\n        fn = String(fieldDef.aggregate);\n      } else if (fieldDef.timeUnit) {\n        fn = String(fieldDef.timeUnit);\n      }\n    }\n\n    if (fn) {\n      field = field ? `${fn}_${field}` : fn;\n    }\n  }\n\n  if (suffix) {\n    field = `${field}_${suffix}`;\n  }\n\n  if (prefix) {\n    field = `${prefix}_${field}`;\n  }\n\n  if (opt.forAs) {\n    return field;\n  } else if (opt.expr) {\n    // Expression to access flattened field. No need to escape dots.\n    return flatAccessWithDatum(field, opt.expr);\n  } else {\n    // We flattened all fields so paths should have become dot.\n    return replacePathInField(field);\n  }\n}\n\nexport function isDiscrete(fieldDef: FieldDef<Field>) {\n  switch (fieldDef.type) {\n    case 'nominal':\n    case 'ordinal':\n    case 'geojson':\n      return true;\n    case 'quantitative':\n      return !!fieldDef.bin;\n    case 'temporal':\n      return false;\n  }\n  throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\n\nexport function isContinuous(fieldDef: FieldDef<Field>) {\n  return !isDiscrete(fieldDef);\n}\n\nexport function isCount(fieldDef: FieldDefBase<Field>) {\n  return fieldDef.aggregate === 'count';\n}\n\nexport type FieldTitleFormatter = (fieldDef: FieldDefBase<string>, config: Config) => string;\n\nexport function verbalTitleFormatter(fieldDef: FieldDefBase<string>, config: Config) {\n  const {field: field, bin, timeUnit, aggregate} = fieldDef;\n  if (aggregate === 'count') {\n    return config.countTitle;\n  } else if (isBinning(bin)) {\n    return `${field} (binned)`;\n  } else if (timeUnit) {\n    const units = getTimeUnitParts(timeUnit).join('-');\n    return `${field} (${units})`;\n  } else if (aggregate) {\n    return `${titlecase(aggregate)} of ${field}`;\n  }\n  return field;\n}\n\nexport function functionalTitleFormatter(fieldDef: FieldDefBase<string>, config: Config) {\n  const fn = fieldDef.aggregate || fieldDef.timeUnit || (isBinning(fieldDef.bin) && 'bin');\n  if (fn) {\n    return fn.toUpperCase() + '(' + fieldDef.field + ')';\n  } else {\n    return fieldDef.field;\n  }\n}\n\nexport const defaultTitleFormatter: FieldTitleFormatter = (fieldDef: FieldDefBase<string>, config: Config) => {\n  switch (config.fieldTitle) {\n    case 'plain':\n      return fieldDef.field;\n    case 'functional':\n      return functionalTitleFormatter(fieldDef, config);\n    default:\n      return verbalTitleFormatter(fieldDef, config);\n  }\n};\n\nlet titleFormatter = defaultTitleFormatter;\n\nexport function setTitleFormatter(formatter: FieldTitleFormatter) {\n  titleFormatter = formatter;\n}\n\nexport function resetTitleFormatter() {\n  setTitleFormatter(defaultTitleFormatter);\n}\n\nexport function title(fieldDef: FieldDef<string>, config: Config, {allowDisabling}: {allowDisabling: boolean}) {\n  const guide = getGuide(fieldDef) || {};\n  const guideTitle = guide.title;\n  if (allowDisabling) {\n    return getFirstDefined(guideTitle, fieldDef.title, defaultTitle(fieldDef, config));\n  } else {\n    return guideTitle || fieldDef.title || defaultTitle(fieldDef, config);\n  }\n}\n\nexport function getGuide(fieldDef: FieldDef<string>): Guide {\n  if (isPositionFieldDef(fieldDef) && fieldDef.axis) {\n    return fieldDef.axis;\n  } else if (isMarkPropFieldDef(fieldDef) && fieldDef.legend) {\n    return fieldDef.legend;\n  } else if (isFacetFieldDef(fieldDef) && fieldDef.header) {\n    return fieldDef.header;\n  }\n  return undefined;\n}\n\nexport function defaultTitle(fieldDef: FieldDefBase<string>, config: Config) {\n  return titleFormatter(fieldDef, config);\n}\n\nexport function format(fieldDef: FieldDef<string>) {\n  if (isTextFieldDef(fieldDef) && fieldDef.format) {\n    return fieldDef.format;\n  } else {\n    const guide = getGuide(fieldDef) || {};\n    return guide.format;\n  }\n}\n\nexport function defaultType(fieldDef: FieldDef<Field>, channel: Channel): Type {\n  if (fieldDef.timeUnit) {\n    return 'temporal';\n  }\n  if (isBinning(fieldDef.bin)) {\n    return 'quantitative';\n  }\n  switch (rangeType(channel)) {\n    case 'continuous':\n      return 'quantitative';\n    case 'discrete':\n      return 'nominal';\n    case 'flexible': // color\n      return 'nominal';\n    default:\n      return 'quantitative';\n  }\n}\n\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\nexport function getFieldDef<F>(channelDef: ChannelDef<F>): FieldDef<F> {\n  if (isFieldDef(channelDef)) {\n    return channelDef;\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return channelDef.condition;\n  }\n  return undefined;\n}\n\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nexport function normalize(channelDef: ChannelDef<string>, channel: Channel): ChannelDef<any> {\n  if (isString(channelDef) || isNumber(channelDef) || isBoolean(channelDef)) {\n    const primitiveType = isString(channelDef) ? 'string' : isNumber(channelDef) ? 'number' : 'boolean';\n    log.warn(log.message.primitiveChannelDef(channel, primitiveType, channelDef));\n    return {value: channelDef};\n  }\n\n  // If a fieldDef contains a field, we need type.\n  if (isFieldDef(channelDef)) {\n    return normalizeFieldDef(channelDef, channel);\n  } else if (hasConditionalFieldDef(channelDef)) {\n    return {\n      ...channelDef,\n      // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n      condition: normalizeFieldDef(channelDef.condition, channel) as Conditional<FieldDef<string>>\n    };\n  }\n  return channelDef;\n}\nexport function normalizeFieldDef(fieldDef: FieldDef<string>, channel: Channel) {\n  // Drop invalid aggregate\n  if (fieldDef.aggregate && !isAggregateOp(fieldDef.aggregate)) {\n    const {aggregate, ...fieldDefWithoutAggregate} = fieldDef;\n    log.warn(log.message.invalidAggregate(fieldDef.aggregate));\n    fieldDef = fieldDefWithoutAggregate;\n  }\n\n  // Normalize Time Unit\n  if (fieldDef.timeUnit) {\n    fieldDef = {\n      ...fieldDef,\n      timeUnit: normalizeTimeUnit(fieldDef.timeUnit)\n    };\n  }\n\n  // Normalize bin\n  if (isBinning(fieldDef.bin)) {\n    fieldDef = {\n      ...fieldDef,\n      bin: normalizeBin(fieldDef.bin, channel)\n    };\n  }\n\n  if (isBinned(fieldDef.bin) && !contains(POSITION_SCALE_CHANNELS, channel)) {\n    log.warn(`Channel ${channel} should not be used with \"binned\" bin`);\n  }\n\n  // Normalize Type\n  if (fieldDef.type) {\n    const fullType = getFullName(fieldDef.type);\n    if (fieldDef.type !== fullType) {\n      // convert short type to full type\n      fieldDef = {\n        ...fieldDef,\n        type: fullType\n      };\n    }\n    if (fieldDef.type !== 'quantitative') {\n      if (isCountingAggregateOp(fieldDef.aggregate)) {\n        log.warn(log.message.invalidFieldTypeForCountAggregate(fieldDef.type, fieldDef.aggregate));\n        fieldDef = {\n          ...fieldDef,\n          type: 'quantitative'\n        };\n      }\n    }\n  } else {\n    // If type is empty / invalid, then augment with default type\n    const newType = defaultType(fieldDef, channel);\n    log.warn(log.message.emptyOrInvalidFieldType(fieldDef.type, channel, newType));\n    fieldDef = {\n      ...fieldDef,\n      type: newType\n    };\n  }\n\n  const {compatible, warning} = channelCompatibility(fieldDef, channel);\n  if (!compatible) {\n    log.warn(warning);\n  }\n  return fieldDef;\n}\n\nexport function normalizeBin(bin: BinParams | boolean, channel: Channel) {\n  if (isBoolean(bin)) {\n    return {maxbins: autoMaxBins(channel)};\n  } else if (!bin.maxbins && !bin.step) {\n    return {...bin, maxbins: autoMaxBins(channel)};\n  } else {\n    return bin;\n  }\n}\n\nconst COMPATIBLE = {compatible: true};\nexport function channelCompatibility(\n  fieldDef: FieldDef<Field>,\n  channel: Channel\n): {compatible: boolean; warning?: string} {\n  const type = fieldDef.type;\n\n  if (type === 'geojson' && channel !== 'shape') {\n    return {\n      compatible: false,\n      warning: `Channel ${channel} should not be used with a geojson data.`\n    };\n  }\n\n  switch (channel) {\n    case 'row':\n    case 'column':\n      if (isContinuous(fieldDef)) {\n        return {\n          compatible: false,\n          warning: log.message.facetChannelShouldBeDiscrete(channel)\n        };\n      }\n      return COMPATIBLE;\n\n    case 'x':\n    case 'y':\n    case 'color':\n    case 'fill':\n    case 'stroke':\n    case 'text':\n    case 'detail':\n    case 'key':\n    case 'tooltip':\n    case 'href':\n      return COMPATIBLE;\n\n    case 'longitude':\n    case 'longitude2':\n    case 'latitude':\n    case 'latitude2':\n      if (type !== QUANTITATIVE) {\n        return {\n          compatible: false,\n          warning: `Channel ${channel} should be used with a quantitative field only, not ${fieldDef.type} field.`\n        };\n      }\n      return COMPATIBLE;\n\n    case 'opacity':\n    case 'size':\n    case 'x2':\n    case 'y2':\n      if (type === 'nominal' && !fieldDef['sort']) {\n        return {\n          compatible: false,\n          warning: `Channel ${channel} should not be used with an unsorted discrete field.`\n        };\n      }\n      return COMPATIBLE;\n\n    case 'shape':\n      if (fieldDef.type !== 'nominal' && fieldDef.type !== 'geojson') {\n        return {\n          compatible: false,\n          warning: 'Shape channel should be used with only either nominal or geojson data'\n        };\n      }\n      return COMPATIBLE;\n\n    case 'order':\n      if (fieldDef.type === 'nominal' && !('sort' in fieldDef)) {\n        return {\n          compatible: false,\n          warning: `Channel order is inappropriate for nominal field, which has no inherent order.`\n        };\n      }\n      return COMPATIBLE;\n  }\n  throw new Error('channelCompatability not implemented for channel ' + channel);\n}\n\nexport function isNumberFieldDef(fieldDef: FieldDef<any>) {\n  return fieldDef.type === 'quantitative' || isBinning(fieldDef.bin);\n}\n\nexport function isTimeFieldDef(fieldDef: FieldDef<any>) {\n  return fieldDef.type === 'temporal' || !!fieldDef.timeUnit;\n}\n\n/**\n * Getting a value associated with a fielddef.\n * Convert the value to Vega expression if applicable (for datetime object, or string if the field def is temporal or has timeUnit)\n */\nexport function valueExpr(\n  v: number | string | boolean | DateTime,\n  {\n    timeUnit,\n    type,\n    time,\n    undefinedIfExprNotRequired\n  }: {\n    timeUnit: TimeUnit;\n    type?: Type;\n    time?: boolean;\n    undefinedIfExprNotRequired?: boolean;\n  }\n): string {\n  let expr;\n  if (isDateTime(v)) {\n    expr = dateTimeExpr(v, true);\n  } else if (isString(v) || isNumber(v)) {\n    if (timeUnit || type === 'temporal') {\n      if (isLocalSingleTimeUnit(timeUnit)) {\n        expr = dateTimeExpr({[timeUnit]: v}, true);\n      } else if (isUtcSingleTimeUnit(timeUnit)) {\n        // FIXME is this really correct?\n        expr = valueExpr(v, {timeUnit: getLocalTimeUnit(timeUnit)});\n      } else {\n        // just pass the string to date function (which will call JS Date.parse())\n        expr = `datetime(${JSON.stringify(v)})`;\n      }\n    }\n  }\n  if (expr) {\n    return time ? `time(${expr})` : expr;\n  }\n  // number or boolean or normal string\n  return undefinedIfExprNotRequired ? undefined : JSON.stringify(v);\n}\n\n/**\n * Standardize value array -- convert each value to Vega expression if applicable\n */\nexport function valueArray(fieldDef: FieldDef<string>, values: (number | string | boolean | DateTime)[]) {\n  const {timeUnit, type} = fieldDef;\n  return values.map(v => {\n    const expr = valueExpr(v, {timeUnit, type, undefinedIfExprNotRequired: true});\n    // return signal for the expression if we need an expression\n    if (expr !== undefined) {\n      return {signal: expr};\n    }\n    // otherwise just return the original value\n    return v;\n  });\n}\n","import {ConditionValueDefMixins, ValueDef} from './fielddef';\nimport {VgEncodeChannel} from './vega.schema';\n\nexport interface TitleMixins {\n  /**\n   * A title for the field. If `null`, the title will be removed.\n   *\n   * __Default value:__  derived from the field's name and transformation function (`aggregate`, `bin` and `timeUnit`).  If the field has an aggregate function, the function is displayed as part of the title (e.g., `\"Sum of Profit\"`). If the field is binned or has a time unit applied, the applied function is shown in parentheses (e.g., `\"Profit (binned)\"`, `\"Transaction Date (year-month)\"`).  Otherwise, the title is simply the field name.\n   *\n   * __Notes__:\n   *\n   * 1) You can customize the default field title format by providing the [`fieldTitle` property in the [config](https://vega.github.io/vega-lite/docs/config.html) or [`fieldTitle` function via the `compile` function's options](https://vega.github.io/vega-lite/docs/compile.html#field-title).\n   *\n   * 2) If both field definition's `title` and axis, header, or legend `title` are defined, axis/header/legend title will be used.\n   */\n  title?: string | null;\n}\n\nexport interface Guide extends TitleMixins {\n  /**\n   * The formatting pattern for labels. This is D3's [number format pattern](https://github.com/d3/d3-format#locale_format) for quantitative fields and D3's [time format pattern](https://github.com/d3/d3-time-format#locale_format) for time field.\n   *\n   * See the [format documentation](https://vega.github.io/vega-lite/docs/format.html) for more information.\n   *\n   * __Default value:__  derived from [numberFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for quantitative fields and from [timeFormat](https://vega.github.io/vega-lite/docs/config.html#format) config for temporal fields.\n   */\n  format?: string;\n}\nexport interface VlOnlyGuideConfig {\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   *\n   * __Default value:__  `false`\n   */\n  shortTimeLabels?: boolean;\n}\n\nexport type GuideEncodingEntry = {[k in VgEncodeChannel]?: ValueDef & ConditionValueDefMixins};\n\nexport const VL_ONLY_GUIDE_CONFIG: (keyof VlOnlyGuideConfig)[] = ['shortTimeLabels'];\n","import {FontWeight, TextBaseline} from 'vega';\nimport {TitleConfig as VgTitleConfig} from 'vega';\nimport {Guide} from './guide';\n\nexport const HEADER_TITLE_PROPERTIES_MAP: {[k in keyof HeaderConfig]: keyof VgTitleConfig} = {\n  titleAnchor: 'anchor',\n  titleAngle: 'angle',\n  titleBaseline: 'baseline',\n  titleColor: 'color',\n  titleFont: 'font',\n  titleFontSize: 'fontSize',\n  titleFontWeight: 'fontWeight',\n  titleLimit: 'limit',\n  titlePadding: 'offset'\n};\n\nexport const HEADER_LABEL_PROPERTIES_MAP: {[k in keyof HeaderConfig]: keyof VgTitleConfig} = {\n  labelAngle: 'angle',\n  labelColor: 'color',\n  labelFont: 'font',\n  labelFontSize: 'fontSize',\n  labelLimit: 'limit',\n  labelPadding: 'offset'\n};\n\nexport const HEADER_TITLE_PROPERTIES = Object.keys(HEADER_TITLE_PROPERTIES_MAP);\n\nexport const HEADER_LABEL_PROPERTIES = Object.keys(HEADER_LABEL_PROPERTIES_MAP);\n\nexport interface HeaderConfig {\n  // ---------- Title ----------\n  /**\n   * The anchor position for placing the title. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.\n   *\n   * __Default value:__ `\"middle\"` for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views.\n   * `\"start\"` for other composite views.\n   *\n   * __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views.  For other composite views, `anchor` is always `\"start\"`.\n   */\n  titleAnchor?: string;\n\n  /**\n   * The rotation angle of the header title.\n   *\n   * __Default value:__ `0`.\n   *\n   * @minimum -360\n   * @maximum 360\n   */\n  titleAngle?: number;\n  /**\n   * Vertical text baseline for the header title. One of `\"top\"`, `\"bottom\"`, `\"middle\"`.\n   *\n   * __Default value:__ `\"middle\"`\n   */\n  titleBaseline?: TextBaseline;\n  /**\n   * Color of the header title, can be in hex color code or regular color name.\n   */\n  titleColor?: string;\n\n  /**\n   * Font of the header title. (e.g., `\"Helvetica Neue\"`).\n   */\n  titleFont?: string;\n\n  /**\n   * Font size of the header title.\n   *\n   * @minimum 0\n   */\n  titleFontSize?: number;\n\n  /**\n   * Font weight of the header title.\n   * This can be either a string (e.g `\"bold\"`, `\"normal\"`) or a number (`100`, `200`, `300`, ..., `900` where `\"normal\"` = `400` and `\"bold\"` = `700`).\n   */\n  titleFontWeight?: FontWeight;\n\n  /**\n   * The maximum length of the header title in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.\n   *\n   * __Default value:__ `0`, indicating no limit\n   */\n  titleLimit?: number;\n\n  /**\n   * The orthogonal distance in pixels by which to displace the title from its position along the edge of the chart.\n   *\n   * __Default value:__ `10`\n   */\n  titlePadding?: number;\n\n  // ---------- Label ----------\n  /**\n   * The rotation angle of the header labels.\n   *\n   * __Default value:__ `0` for column header, `-90` for row header.\n   *\n   * @minimum -360\n   * @maximum 360\n   */\n  labelAngle?: number;\n\n  /**\n   * The color of the header label, can be in hex color code or regular color name.\n   */\n  labelColor?: string;\n\n  /**\n   * The font of the header label.\n   */\n  labelFont?: string;\n\n  /**\n   * The font size of the header label, in pixels.\n   *\n   * @minimum 0\n   */\n  labelFontSize?: number;\n\n  /**\n   * The maximum length of the header label in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.\n   *\n   * __Default value:__ `0`, indicating no limit\n   */\n  labelLimit?: number;\n\n  /**\n   * The orthogonal distance in pixels by which to displace the title from its position along the edge of the chart.\n   *\n   * __Default value:__ `10`\n   */\n  labelPadding?: number;\n}\n\n/**\n * Headers of row / column channels for faceted plots.\n */\nexport interface Header extends HeaderConfig, Guide {}\n","import * as aggregate from './aggregate';\nimport * as axis from './axis';\nimport * as bin from './bin';\nimport * as channel from './channel';\nimport * as compositeMark from './compositemark';\nexport {TopLevelSpec} from './spec';\nexport {compile} from './compile/compile';\nexport {Config} from './config';\nimport * as config from './config';\nimport * as data from './data';\nimport * as datetime from './datetime';\nimport * as encoding from './encoding';\nimport * as facet from './facet';\nimport * as fieldDef from './fielddef';\nimport * as header from './header';\nimport * as legend from './legend';\nimport * as mark from './mark';\nimport * as scale from './scale';\nimport * as sort from './sort';\nimport * as spec from './spec';\nimport * as stack from './stack';\nimport * as timeUnit from './timeunit';\nimport * as transform from './transform';\nimport * as type from './type';\nimport * as util from './util';\nimport * as validate from './validate';\n\nimport pkg from '../package.json';\nconst version = pkg.version;\n\nexport {\n  aggregate,\n  axis,\n  bin,\n  channel,\n  compositeMark,\n  config,\n  data,\n  datetime,\n  encoding,\n  facet,\n  fieldDef,\n  header,\n  legend,\n  mark,\n  scale,\n  sort,\n  spec,\n  stack,\n  timeUnit,\n  transform,\n  type,\n  util,\n  validate,\n  version\n};\n","import {\n  Align,\n  BaseLegend,\n  FontWeight,\n  LabelOverlap,\n  Legend as VgLegend,\n  LegendConfig as VgLegendConfig,\n  LegendOrient,\n  Orientation,\n  SymbolShape,\n  TextBaseline\n} from 'vega';\nimport {DateTime} from './datetime';\nimport {Guide, GuideEncodingEntry, VlOnlyGuideConfig} from './guide';\nimport {Flag, flagKeys} from './util';\nimport {Color, VgLayoutAlign} from './vega.schema';\n\nexport type LegendConfig = LegendMixins &\n  VlOnlyGuideConfig &\n  VgLegendConfig<\n    number,\n    number,\n    string,\n    Color,\n    FontWeight,\n    Align,\n    TextBaseline,\n    VgLayoutAlign,\n    LabelOverlap,\n    SymbolShape\n  >;\n\n/**\n * Properties of a legend or boolean flag for determining whether to show it.\n */\nexport interface Legend\n  extends BaseLegend<\n      number,\n      number,\n      string,\n      Color,\n      FontWeight,\n      Align,\n      TextBaseline,\n      VgLayoutAlign,\n      LabelOverlap,\n      SymbolShape\n    >,\n    LegendMixins,\n    Guide {\n  /**\n   * Mark definitions for custom legend encoding.\n   *\n   * @hide\n   */\n  encoding?: LegendEncoding;\n\n  /**\n   * The desired number of tick values for quantitative legends.\n   */\n  tickCount?: number;\n\n  /**\n   * Explicitly set the visible legend values.\n   */\n  values?: (number | string | boolean | DateTime)[];\n\n  /**\n   * The type of the legend. Use `\"symbol\"` to create a discrete legend and `\"gradient\"` for a continuous color gradient.\n   *\n   * __Default value:__ `\"gradient\"` for non-binned quantitative fields and temporal fields; `\"symbol\"` otherwise.\n   */\n  type?: 'symbol' | 'gradient';\n\n  /**\n   * A non-positive integer indicating z-index of the legend.\n   * If zindex is 0, legend should be drawn behind all chart elements.\n   * To put them in front, use zindex = 1.\n   *\n   * @TJS-type integer\n   * @minimum 0\n   */\n  zindex?: number;\n\n  /**\n   * The direction of the legend, one of `\"vertical\"` (default) or `\"horizontal\"`.\n   */\n  direction?: Orientation;\n\n  /**\n   * The orientation of the legend, which determines how the legend is positioned within the scene. One of \"left\", \"right\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\", \"none\".\n   *\n   * __Default value:__ `\"right\"`\n   */\n  orient?: LegendOrient;\n}\n\n// Change comments to be Vega-Lite specific\ninterface LegendMixins {\n  /**\n   * The strategy to use for resolving overlap of labels in gradient legends. If `false`, no overlap reduction is attempted. If set to `true` (default) or `\"parity\"`, a strategy of removing every other label is used. If set to `\"greedy\"`, a linear scan of the labels is performed, removing any label that overlaps with the last visible label (this often works better for log-scaled axes).\n   *\n   * __Default value:__ `\"greedy\"` for `log scales otherwise `true`.\n   */\n  labelOverlap?: LabelOverlap;\n}\n\nexport interface LegendEncoding {\n  /**\n   * Custom encoding for the legend container.\n   * This can be useful for creating legend with custom x, y position.\n   */\n  legend?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for the legend title text mark.\n   */\n  title?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for legend label text marks.\n   */\n  labels?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for legend symbol marks.\n   */\n  symbols?: GuideEncodingEntry;\n\n  /**\n   * Custom encoding for legend gradient filled rect marks.\n   */\n  gradient?: GuideEncodingEntry;\n}\n\nexport const defaultLegendConfig: LegendConfig = {};\n\nconst COMMON_LEGEND_PROPERTY_INDEX: Flag<keyof (VgLegend | Legend)> = {\n  clipHeight: 1,\n  columnPadding: 1,\n  columns: 1,\n  cornerRadius: 1,\n  direction: 1,\n  fillColor: 1,\n  format: 1,\n  gradientLength: 1,\n  gradientOpacity: 1,\n  gradientStrokeColor: 1,\n  gradientStrokeWidth: 1,\n  gradientThickness: 1,\n  gridAlign: 1,\n  labelAlign: 1,\n  labelBaseline: 1,\n  labelColor: 1,\n  labelFont: 1,\n  labelFontSize: 1,\n  labelFontWeight: 1,\n  labelLimit: 1,\n  labelOffset: 1,\n  labelOpacity: 1,\n  labelOverlap: 1,\n  labelPadding: 1,\n  offset: 1,\n  orient: 1,\n  padding: 1,\n  rowPadding: 1,\n  strokeColor: 1,\n  strokeWidth: 1,\n  symbolFillColor: 1,\n  symbolOffset: 1,\n  symbolOpacity: 1,\n  symbolSize: 1,\n  symbolStrokeColor: 1,\n  symbolStrokeWidth: 1,\n  symbolType: 1,\n  tickCount: 1,\n  title: 1,\n  titleAlign: 1,\n  titleBaseline: 1,\n  titleColor: 1,\n  titleFont: 1,\n  titleFontSize: 1,\n  titleFontWeight: 1,\n  titleLimit: 1,\n  titleOpacity: 1,\n  titlePadding: 1,\n  type: 1,\n  values: 1,\n  zindex: 1\n};\n\nconst VG_LEGEND_PROPERTY_INDEX: Flag<Exclude<keyof VgLegend, 'strokeDash'>> = {\n  ...COMMON_LEGEND_PROPERTY_INDEX,\n  // channel scales\n  opacity: 1,\n  shape: 1,\n  stroke: 1,\n  fill: 1,\n  size: 1,\n  // encode\n  encode: 1\n};\n\nexport const LEGEND_PROPERTIES = flagKeys(COMMON_LEGEND_PROPERTY_INDEX);\n\nexport const VG_LEGEND_PROPERTIES = flagKeys(VG_LEGEND_PROPERTY_INDEX);\n","/**\n * Vega-Lite's singleton logger utility.\n */\n\nimport {AggregateOp} from 'vega';\nimport {logger, LoggerInterface, Warn} from 'vega-util';\nimport {Channel, GeoPositionChannel} from './channel';\nimport {CompositeMark} from './compositemark';\nimport {ErrorBarCenter, ErrorBarExtent} from './compositemark/errorbar';\nimport {DateTime, DateTimeExpr} from './datetime';\nimport {Aggregate, FieldDef} from './fielddef';\nimport {Mark} from './mark';\nimport {Projection} from './projection';\nimport {ScaleType} from './scale';\nimport {Type} from './type';\nimport {stringify} from './util';\nimport {VgSortField} from './vega.schema';\n\nexport {LoggerInterface} from 'vega-util';\n\n/**\n * Main (default) Vega Logger instance for Vega-Lite\n */\nconst main = logger(Warn);\nlet current: LoggerInterface = main;\n\n/**\n * Logger tool for checking if the code throws correct warning\n */\nexport class LocalLogger implements LoggerInterface {\n  public warns: any[] = [];\n  public infos: any[] = [];\n  public debugs: any[] = [];\n\n  public level() {\n    return this;\n  }\n\n  public warn(...args: any[]) {\n    this.warns.push(...args);\n    return this;\n  }\n\n  public info(...args: any[]) {\n    this.infos.push(...args);\n    return this;\n  }\n\n  public debug(...args: any[]) {\n    this.debugs.push(...args);\n    return this;\n  }\n}\n\nexport function wrap(f: (logger: LocalLogger) => void) {\n  return () => {\n    current = new LocalLogger();\n    f(current as LocalLogger);\n    reset();\n  };\n}\n\n/**\n * Set the singleton logger to be a custom logger\n */\nexport function set(newLogger: LoggerInterface) {\n  current = newLogger;\n  return current;\n}\n\n/**\n * Reset the main logger to use the default Vega Logger\n */\nexport function reset() {\n  current = main;\n  return current;\n}\n\nexport function warn(..._: any[]) {\n  current.warn.apply(current, arguments);\n}\n\nexport function info(..._: any[]) {\n  current.info.apply(current, arguments);\n}\n\nexport function debug(..._: any[]) {\n  current.debug.apply(current, arguments);\n}\n\n/**\n * Collection of all Vega-Lite Error Messages\n */\nexport namespace message {\n  export const INVALID_SPEC = 'Invalid spec';\n\n  // FIT\n  export const FIT_NON_SINGLE = 'Autosize \"fit\" only works for single views and layered views.';\n\n  export const CANNOT_FIX_RANGE_STEP_WITH_FIT = 'Cannot use a fixed value of \"rangeStep\" when \"autosize\" is \"fit\".';\n\n  // SELECTION\n  export function cannotProjectOnChannelWithoutField(channel: Channel) {\n    return `Cannot project a selection on encoding channel \"${channel}\", which has no field.`;\n  }\n\n  export function nearestNotSupportForContinuous(mark: string) {\n    return `The \"nearest\" transform is not supported for ${mark} marks.`;\n  }\n\n  export function selectionNotSupported(mark: CompositeMark) {\n    return `Selection not supported for ${mark} yet`;\n  }\n\n  export function selectionNotFound(name: string) {\n    return `Cannot find a selection named \"${name}\"`;\n  }\n\n  export const SCALE_BINDINGS_CONTINUOUS =\n    'Scale bindings are currently only supported for scales with unbinned, continuous domains.';\n\n  // REPEAT\n  export function noSuchRepeatedValue(field: string) {\n    return `Unknown repeated value \"${field}\".`;\n  }\n\n  // CONCAT\n  export const CONCAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in concatenated views.';\n\n  // REPEAT\n  export const REPEAT_CANNOT_SHARE_AXIS = 'Axes cannot be shared in repeated views.';\n\n  // TITLE\n  export function cannotSetTitleAnchor(type: string) {\n    return `Cannot set title \"anchor\" for a ${type} spec`;\n  }\n\n  // DATA\n  export function unrecognizedParse(p: string) {\n    return `Unrecognized parse \"${p}\".`;\n  }\n\n  export function differentParse(field: string, local: string, ancestor: string) {\n    return `An ancestor parsed field \"${field}\" as ${ancestor} but a child wants to parse the field as ${local}.`;\n  }\n\n  // TRANSFORMS\n  export function invalidTransformIgnored(transform: any) {\n    return `Ignoring an invalid transform: ${stringify(transform)}.`;\n  }\n\n  export const NO_FIELDS_NEEDS_AS =\n    'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the data from the secondary source.';\n\n  // ENCODING & FACET\n\n  export function encodingOverridden(channels: Channel[]) {\n    return `Layer's shared ${channels.join(',')} channel ${channels.length === 1 ? 'is' : 'are'} overriden`;\n  }\n  export function projectionOverridden(opt: {parentProjection: Projection; projection: Projection}) {\n    const {parentProjection, projection} = opt;\n    return `Layer's shared projection ${stringify(parentProjection)} is overridden by a child projection ${stringify(\n      projection\n    )}.`;\n  }\n\n  export function primitiveChannelDef(\n    channel: Channel,\n    type: 'string' | 'number' | 'boolean',\n    value: string | number | boolean\n  ) {\n    return `Channel ${channel} is a ${type}. Converted to {value: ${stringify(value)}}.`;\n  }\n\n  export function invalidFieldType(type: Type) {\n    return `Invalid field type \"${type}\"`;\n  }\n\n  export function nonZeroScaleUsedWithLengthMark(\n    mark: 'bar' | 'area',\n    channel: Channel,\n    opt: {scaleType?: ScaleType; zeroFalse?: boolean}\n  ) {\n    const scaleText = opt.scaleType\n      ? `${opt.scaleType} scale`\n      : opt.zeroFalse\n        ? 'scale with zero=false'\n        : 'scale with custom domain that excludes zero';\n\n    return `A ${scaleText} is used to encode ${mark}'s ${channel}. This can be misleading as the ${\n      channel === 'x' ? 'width' : 'height'\n    } of the ${mark} can be arbitrary based on the scale domain. You may want to use point mark instead.`;\n  }\n\n  export function invalidFieldTypeForCountAggregate(type: Type, aggregate: string) {\n    return `Invalid field type \"${type}\" for aggregate: \"${aggregate}\", using \"quantitative\" instead.`;\n  }\n\n  export function invalidAggregate(aggregate: AggregateOp | string) {\n    return `Invalid aggregation operator \"${aggregate}\"`;\n  }\n\n  export function emptyOrInvalidFieldType(type: Type | string, channel: Channel, newType: Type) {\n    return `Invalid field type \"${type}\" for channel \"${channel}\", using \"${newType}\" instead.`;\n  }\n  export function droppingColor(type: 'encoding' | 'property', opt: {fill?: boolean; stroke?: boolean}) {\n    const {fill, stroke} = opt;\n    return (\n      `Dropping color ${type} as the plot also has ` + (fill && stroke ? 'fill and stroke' : fill ? 'fill' : 'stroke')\n    );\n  }\n\n  export function emptyFieldDef(fieldDef: FieldDef<string>, channel: Channel) {\n    return `Dropping ${stringify(fieldDef)} from channel \"${channel}\" since it does not contain data field or value.`;\n  }\n  export function latLongDeprecated(channel: Channel, type: Type, newChannel: GeoPositionChannel) {\n    return `${channel}-encoding with type ${type} is deprecated. Replacing with ${newChannel}-encoding.`;\n  }\n\n  export const LINE_WITH_VARYING_SIZE =\n    'Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.';\n\n  export function incompatibleChannel(channel: Channel, markOrFacet: Mark | 'facet' | CompositeMark, when?: string) {\n    return `${channel} dropped as it is incompatible with \"${markOrFacet}\"${when ? ` when ${when}` : ''}.`;\n  }\n\n  export function invalidEncodingChannel(channel: string) {\n    return `${channel}-encoding is dropped as ${channel} is not a valid encoding channel.`;\n  }\n\n  export function facetChannelShouldBeDiscrete(channel: string) {\n    return `${channel} encoding should be discrete (ordinal / nominal / binned).`;\n  }\n\n  export function discreteChannelCannotEncode(channel: Channel, type: Type) {\n    return `Using discrete channel \"${channel}\" to encode \"${type}\" field can be misleading as it does not encode ${\n      type === 'ordinal' ? 'order' : 'magnitude'\n    }.`;\n  }\n\n  // Mark\n  export const BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL =\n    'Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.';\n\n  export function lineWithRange(hasX2: boolean, hasY2: boolean) {\n    const channels = hasX2 && hasY2 ? 'x2 and y2' : hasX2 ? 'x2' : 'y2';\n    return `Line mark is for continuous lines and thus cannot be used with ${channels}. We will use the rule mark (line segments) instead.`;\n  }\n\n  export function orientOverridden(original: string, actual: string) {\n    return `Specified orient \"${original}\" overridden with \"${actual}\"`;\n  }\n\n  // SCALE\n  export const CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN =\n    'custom domain scale cannot be unioned with default field-based domain';\n\n  export function cannotUseScalePropertyWithNonColor(prop: string) {\n    return `Cannot use the scale property \"${prop}\" with non-color channel.`;\n  }\n\n  export function unaggregateDomainHasNoEffectForRawField(fieldDef: FieldDef<string>) {\n    return `Using unaggregated domain with raw field has no effect (${stringify(fieldDef)}).`;\n  }\n\n  export function unaggregateDomainWithNonSharedDomainOp(aggregate: string) {\n    return `Unaggregated domain not applicable for \"${aggregate}\" since it produces values outside the origin domain of the source data.`;\n  }\n\n  export function unaggregatedDomainWithLogScale(fieldDef: FieldDef<string>) {\n    return `Unaggregated domain is currently unsupported for log scale (${stringify(fieldDef)}).`;\n  }\n\n  export function cannotApplySizeToNonOrientedMark(mark: Mark) {\n    return `Cannot apply size to non-oriented mark \"${mark}\".`;\n  }\n\n  export function rangeStepDropped(channel: Channel) {\n    return `rangeStep for \"${channel}\" is dropped as top-level ${channel === 'x' ? 'width' : 'height'} is provided.`;\n  }\n\n  export function scaleTypeNotWorkWithChannel(channel: Channel, scaleType: ScaleType, defaultScaleType: ScaleType) {\n    return `Channel \"${channel}\" does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n  }\n\n  export function scaleTypeNotWorkWithFieldDef(scaleType: ScaleType, defaultScaleType: ScaleType) {\n    return `FieldDef does not work with \"${scaleType}\" scale. We are using \"${defaultScaleType}\" scale instead.`;\n  }\n\n  export function scalePropertyNotWorkWithScaleType(scaleType: ScaleType, propName: string, channel: Channel) {\n    return `${channel}-scale's \"${propName}\" is dropped as it does not work with ${scaleType} scale.`;\n  }\n\n  export function scaleTypeNotWorkWithMark(mark: Mark, scaleType: ScaleType) {\n    return `Scale type \"${scaleType}\" does not work with mark \"${mark}\".`;\n  }\n\n  export function mergeConflictingProperty<T>(\n    property: string | number | symbol,\n    propertyOf: string | number | symbol,\n    v1: T,\n    v2: T\n  ) {\n    return `Conflicting ${propertyOf.toString()} property \"${property.toString()}\" (${stringify(v1)} and ${stringify(\n      v2\n    )}).  Using ${stringify(v1)}.`;\n  }\n\n  export function independentScaleMeansIndependentGuide(channel: Channel) {\n    return `Setting the scale to be independent for \"${channel}\" means we also have to set the guide (axis or legend) to be independent.`;\n  }\n\n  export function domainSortDropped(sort: VgSortField) {\n    return `Dropping sort property ${stringify(sort)} as unioned domains only support boolean or op 'count'.`;\n  }\n\n  export const UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains';\n\n  export const MORE_THAN_ONE_SORT =\n    'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\n\n  // AXIS\n  export const INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n\n  // STACK\n  export function cannotStackRangedMark(channel: Channel) {\n    return `Cannot stack \"${channel}\" if there is already \"${channel}2\"`;\n  }\n\n  export function cannotStackNonLinearScale(scaleType: ScaleType) {\n    return `Cannot stack non-linear scale (${scaleType})`;\n  }\n\n  export function stackNonSummativeAggregate(aggregate: string) {\n    return `Stacking is applied even though the aggregate function is non-summative (\"${aggregate}\")`;\n  }\n\n  // TIMEUNIT\n  export function invalidTimeUnit(unitName: string, value: string | number) {\n    return `Invalid ${unitName}: ${stringify(value)}`;\n  }\n\n  export function dayReplacedWithDate(fullTimeUnit: string) {\n    return `Time unit \"${fullTimeUnit}\" is not supported. We are replacing it with ${fullTimeUnit.replace(\n      'day',\n      'date'\n    )}.`;\n  }\n\n  export function droppedDay(d: DateTime | DateTimeExpr) {\n    return `Dropping day from datetime ${stringify(d)} as day cannot be combined with other units.`;\n  }\n\n  export function errorBarCenterAndExtentAreNotNeeded(center: ErrorBarCenter, extent: ErrorBarExtent) {\n    return `${extent ? 'extent ' : ''}${extent && center ? 'and ' : ''}${center ? 'center ' : ''}${\n      extent && center ? 'are ' : 'is '\n    }not needed when data are aggregated.`;\n  }\n\n  export function errorBarCenterIsUsedWithWrongExtent(\n    center: ErrorBarCenter,\n    extent: ErrorBarExtent,\n    mark: 'errorbar' | 'errorband'\n  ) {\n    return `${center} is not usually used with ${extent} for ${mark}.`;\n  }\n\n  export function errorBarContinuousAxisHasCustomizedAggregate(aggregate: Aggregate, compositeMark: CompositeMark) {\n    return `Continuous axis should not have customized aggregation function ${aggregate}; ${compositeMark} already agregates the axis.`;\n  }\n\n  export function errorBarCenterIsNotNeeded(extent: ErrorBarExtent, mark: 'errorbar' | 'errorband') {\n    return `Center is not needed to be specified in ${mark} when extent is ${extent}.`;\n  }\n\n  export function errorBand1DNotSupport(property: 'interpolate' | 'tension') {\n    return `1D error band does not support ${property}`;\n  }\n\n  // CHANNEL\n  export function channelRequiredForBinned(channel: Channel) {\n    return `Channel ${channel} is required for \"binned\" bin`;\n  }\n\n  export function domainRequiredForThresholdScale(channel: Channel) {\n    return `Domain for ${channel} is required for threshold scale`;\n  }\n}\n","export type LogicalOperand<T> = LogicalNot<T> | LogicalAnd<T> | LogicalOr<T> | T;\n\nexport interface LogicalOr<T> {\n  or: LogicalOperand<T>[];\n}\n\nexport interface LogicalAnd<T> {\n  and: LogicalOperand<T>[];\n}\n\nexport interface LogicalNot<T> {\n  not: LogicalOperand<T>;\n}\n\nexport function isLogicalOr(op: LogicalOperand<any>): op is LogicalOr<any> {\n  return !!op.or;\n}\n\nexport function isLogicalAnd(op: LogicalOperand<any>): op is LogicalAnd<any> {\n  return !!op.and;\n}\n\nexport function isLogicalNot(op: LogicalOperand<any>): op is LogicalNot<any> {\n  return !!op.not;\n}\n\nexport function forEachLeaf<T>(op: LogicalOperand<T>, fn: (op: T) => void) {\n  if (isLogicalNot(op)) {\n    forEachLeaf(op.not, fn);\n  } else if (isLogicalAnd(op)) {\n    for (const subop of op.and) {\n      forEachLeaf(subop, fn);\n    }\n  } else if (isLogicalOr(op)) {\n    for (const subop of op.or) {\n      forEachLeaf(subop, fn);\n    }\n  } else {\n    fn(op);\n  }\n}\n\nexport function normalizeLogicalOperand<T>(op: LogicalOperand<T>, normalizer: (o: T) => T): LogicalOperand<T> {\n  if (isLogicalNot(op)) {\n    return {not: normalizeLogicalOperand(op.not, normalizer)};\n  } else if (isLogicalAnd(op)) {\n    return {and: op.and.map(o => normalizeLogicalOperand(o, normalizer))};\n  } else if (isLogicalOr(op)) {\n    return {or: op.or.map(o => normalizeLogicalOperand(o, normalizer))};\n  } else {\n    return normalizer(op);\n  }\n}\n","import {toSet} from 'vega-util';\nimport {CompositeMark, CompositeMarkDef} from './compositemark/index';\nimport {contains, flagKeys} from './util';\nimport {VgMarkConfig} from './vega.schema';\n\nexport namespace Mark {\n  export const AREA: 'area' = 'area';\n  export const BAR: 'bar' = 'bar';\n  export const LINE: 'line' = 'line';\n  export const POINT: 'point' = 'point';\n  export const RECT: 'rect' = 'rect';\n  export const RULE: 'rule' = 'rule';\n  export const TEXT: 'text' = 'text';\n  export const TICK: 'tick' = 'tick';\n  export const TRAIL: 'trail' = 'trail';\n  export const CIRCLE: 'circle' = 'circle';\n  export const SQUARE: 'square' = 'square';\n  export const GEOSHAPE: 'geoshape' = 'geoshape';\n}\n\n/**\n * All types of primitive marks.\n */\nexport type Mark =\n  | typeof Mark.AREA\n  | typeof Mark.BAR\n  | typeof Mark.LINE\n  | typeof Mark.TRAIL\n  | typeof Mark.POINT\n  | typeof Mark.TEXT\n  | typeof Mark.TICK\n  | typeof Mark.RECT\n  | typeof Mark.RULE\n  | typeof Mark.CIRCLE\n  | typeof Mark.SQUARE\n  | typeof Mark.GEOSHAPE;\n\nexport const AREA = Mark.AREA;\nexport const BAR = Mark.BAR;\nexport const LINE = Mark.LINE;\nexport const POINT = Mark.POINT;\nexport const TEXT = Mark.TEXT;\nexport const TICK = Mark.TICK;\nexport const TRAIL = Mark.TRAIL;\nexport const RECT = Mark.RECT;\nexport const RULE = Mark.RULE;\nexport const GEOSHAPE = Mark.GEOSHAPE;\n\nexport const CIRCLE = Mark.CIRCLE;\nexport const SQUARE = Mark.SQUARE;\n\n// Using mapped type to declare index, ensuring we always have all marks when we add more.\nconst MARK_INDEX: {[M in Mark]: 1} = {\n  area: 1,\n  bar: 1,\n  line: 1,\n  point: 1,\n  text: 1,\n  tick: 1,\n  trail: 1,\n  rect: 1,\n  geoshape: 1,\n  rule: 1,\n  circle: 1,\n  square: 1\n};\n\nexport function isMark(m: string): m is Mark {\n  return !!MARK_INDEX[m];\n}\n\nexport function isPathMark(m: Mark | CompositeMark): m is 'line' | 'area' | 'trail' {\n  return contains(['line', 'area', 'trail'], m);\n}\n\nexport const PRIMITIVE_MARKS = flagKeys(MARK_INDEX);\n\nexport interface ColorMixins {\n  /**\n   * Default color.  Note that `fill` and `stroke` have higher precedence than `color` and will override `color`.\n   *\n   * __Default value:__ <span style=\"color: #4682b4;\">&#9632;</span> `\"#4682b4\"`\n   *\n   * __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n   */\n  color?: string;\n}\n\nexport interface TooltipContent {\n  content: 'encoding' | 'data';\n}\n\nexport interface MarkConfig extends ColorMixins, VgMarkConfig {\n  // ========== VL-Specific ==========\n\n  /**\n   * Whether the mark's color should be used as fill color instead of stroke color.\n   *\n   * __Default value:__ `true` for all marks except `point` and `false` for `point`.\n   *\n   * __Applicable for:__ `bar`, `point`, `circle`, `square`, and `area` marks.\n   *\n   * __Note:__ This property cannot be used in a [style config](https://vega.github.io/vega-lite/docs/mark.html#style-config).\n   *\n   */\n  filled?: boolean;\n\n  // ========== Overriding Vega ==========\n\n  /**\n   * The tooltip text string to show upon mouse hover or an object defining which fields should the tooltip be derived from.\n   *\n   * - If `tooltip` is `{\"content\": \"encoding\"}`, then all fields from `encoding` will be used.\n   * - If `tooltip` is `{\"content\": \"data\"}`, then all fields that appear in the highlighted data point will be used.\n   */\n  tooltip?: string | TooltipContent;\n\n  /**\n   * Default size for marks.\n   * - For `point`/`circle`/`square`, this represents the pixel area of the marks. For example: in the case of circles, the radius is determined in part by the square root of the size value.\n   * - For `bar`, this represents the band size of the bar, in pixels.\n   * - For `text`, this represents the font size, in pixels.\n   *\n   * __Default value:__ `30` for point, circle, square marks; `rangeStep` - 1 for bar marks with discrete dimensions; `5` for bar marks with continuous dimensions; `11` for text marks.\n   *\n   * @minimum 0\n   */\n  size?: number;\n}\n\nexport interface BarBinSpacingMixins {\n  /**\n   * Offset between bars for binned field.  Ideal value for this is either 0 (Preferred by statisticians) or 1 (Vega-Lite Default, D3 example style).\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   */\n  binSpacing?: number;\n}\n\nexport type AnyMark = CompositeMark | CompositeMarkDef | Mark | MarkDef;\n\nexport function isMarkDef(mark: AnyMark): mark is MarkDef | CompositeMarkDef {\n  return mark['type'];\n}\n\nconst PRIMITIVE_MARK_INDEX = toSet(PRIMITIVE_MARKS);\n\nexport function isPrimitiveMark(mark: CompositeMark | CompositeMarkDef | Mark | MarkDef): mark is Mark {\n  const markType = isMarkDef(mark) ? mark.type : mark;\n  return markType in PRIMITIVE_MARK_INDEX;\n}\n\nexport const STROKE_CONFIG = [\n  'stroke',\n  'strokeWidth',\n  'strokeDash',\n  'strokeDashOffset',\n  'strokeOpacity',\n  'strokeJoin',\n  'strokeMiterLimit'\n];\n\nexport const FILL_CONFIG = ['fill', 'fillOpacity'];\n\nexport const FILL_STROKE_CONFIG = [].concat(STROKE_CONFIG, FILL_CONFIG);\n\nexport const VL_ONLY_MARK_CONFIG_PROPERTIES: (keyof MarkConfig)[] = ['filled', 'color', 'tooltip'];\n\nexport const VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX: {\n  [k in typeof PRIMITIVE_MARKS[0]]?: (keyof MarkConfigMixins[k])[]\n} = {\n  area: ['line', 'point'],\n  bar: ['binSpacing', 'continuousBandSize', 'discreteBandSize'],\n  line: ['point'],\n  text: ['shortTimeLabels'],\n  tick: ['bandSize', 'thickness']\n};\n\nexport const defaultMarkConfig: MarkConfig = {\n  color: '#4c78a8',\n  tooltip: {content: 'encoding'}\n};\n\nexport interface MarkConfigMixins {\n  /** Mark Config */\n  mark?: MarkConfig;\n\n  // MARK-SPECIFIC CONFIGS\n  /** Area-Specific Config */\n  area?: AreaConfig;\n\n  /** Bar-Specific Config */\n  bar?: BarConfig;\n\n  /** Circle-Specific Config */\n  circle?: MarkConfig;\n\n  /** Line-Specific Config */\n  line?: LineConfig;\n\n  /** Point-Specific Config */\n  point?: MarkConfig;\n\n  /** Rect-Specific Config */\n  rect?: MarkConfig;\n\n  /** Rule-Specific Config */\n  rule?: MarkConfig;\n\n  /** Square-Specific Config */\n  square?: MarkConfig;\n\n  /** Text-Specific Config */\n  text?: TextConfig;\n\n  /** Tick-Specific Config */\n  tick?: TickConfig;\n\n  /** Trail-Specific Config */\n  trail?: LineConfig;\n\n  /** Geoshape-Specific Config */\n  geoshape?: MarkConfig;\n}\n\nexport interface BarConfig extends BarBinSpacingMixins, MarkConfig {\n  /**\n   * The default size of the bars on continuous scales.\n   *\n   * __Default value:__ `5`\n   *\n   * @minimum 0\n   */\n  continuousBandSize?: number;\n\n  /**\n   * The default size of the bars with discrete dimensions.  If unspecified, the default size is  `bandSize-1`,\n   * which provides 1 pixel offset between bars.\n   * @minimum 0\n   */\n  discreteBandSize?: number;\n}\n\nexport type OverlayMarkDef = MarkConfig & MarkDefMixins;\n\nexport interface PointOverlayMixins {\n  /**\n   * A flag for overlaying points on top of line or area marks, or an object defining the properties of the overlayed points.\n   *\n   * - If this property is `\"transparent\"`, transparent points will be used (for enhancing tooltips and selections).\n   *\n   * - If this property is an empty object (`{}`) or `true`, filled points with default properties will be used.\n   *\n   * - If this property is `false`, no points would be automatically added to line or area marks.\n   *\n   * __Default value:__ `false`.\n   */\n  point?: boolean | OverlayMarkDef | 'transparent';\n}\n\nexport interface LineConfig extends MarkConfig, PointOverlayMixins {}\n\nexport interface LineOverlayMixins {\n  /**\n   * A flag for overlaying line on top of area marks, or an object defining the properties of the overlayed lines.\n   *\n   * - If this value is an empty object (`{}`) or `true`, lines with default properties will be used.\n   *\n   * - If this value is `false`, no lines would be automatically added to area marks.\n   *\n   * __Default value:__ `false`.\n   */\n  line?: boolean | OverlayMarkDef;\n}\n\nexport interface AreaConfig extends MarkConfig, PointOverlayMixins, LineOverlayMixins {}\n\nexport interface TickThicknessMixins {\n  /**\n   * Thickness of the tick mark.\n   *\n   * __Default value:__  `1`\n   *\n   * @minimum 0\n   */\n  thickness?: number;\n}\n\nexport interface GenericMarkDef<M> {\n  /**\n   * The mark type. This could a primitive mark type\n   * (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"geoshape\"`, `\"rule\"`, and `\"text\"`)\n   * or a composite mark type (`\"boxplot\"`, `\"errorband\"`, `\"errorbar\"`).\n   */\n  type: M;\n}\n\nexport interface MarkDefMixins {\n  /**\n   * A string or array of strings indicating the name of custom styles to apply to the mark. A style is a named collection of mark property defaults defined within the [style configuration](https://vega.github.io/vega-lite/docs/mark.html#style-config). If style is an array, later styles will override earlier styles. Any [mark properties](https://vega.github.io/vega-lite/docs/encoding.html#mark-prop) explicitly defined within the `encoding` will override a style default.\n   *\n   * __Default value:__ The mark's name.  For example, a bar mark will have style `\"bar\"` by default.\n   * __Note:__ Any specified style will augment the default style. For example, a bar mark with `\"style\": \"foo\"` will receive from `config.style.bar` and `config.style.foo` (the specified style `\"foo\"` has higher precedence).\n   */\n  style?: string | string[];\n\n  /**\n   * Whether a mark be clipped to the enclosing groups width and height.\n   */\n  clip?: boolean;\n\n  // Offset properties should not be a part of config\n\n  /**\n   * Offset for x-position.\n   */\n  xOffset?: number;\n\n  /**\n   * Offset for y-position.\n   */\n  yOffset?: number;\n\n  /**\n   * Offset for x2-position.\n   */\n  x2Offset?: number;\n\n  /**\n   * Offset for y2-position.\n   */\n  y2Offset?: number;\n}\n\n// Point/Line OverlayMixins are only for area, line, and trail but we don't want to declare multiple types of MarkDef\n\n// Point/Line OverlayMixins are only for area, line, and trail but we don't want to declare multiple types of MarkDef\nexport interface MarkDef\n  extends GenericMarkDef<Mark>,\n    BarBinSpacingMixins,\n    MarkConfig,\n    PointOverlayMixins,\n    LineOverlayMixins,\n    TickThicknessMixins,\n    MarkDefMixins {\n  /**\n   * The mark type.\n   * One of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"geoshape\"`, `\"rule\"`, and `\"text\"`.\n   */\n  type: Mark;\n}\n\nexport const defaultBarConfig: BarConfig = {\n  binSpacing: 1,\n  continuousBandSize: 5\n};\n\nexport interface TextConfig extends MarkConfig {\n  /**\n   * Whether month names and weekday names should be abbreviated.\n   */\n  shortTimeLabels?: boolean;\n}\n\nexport interface TickConfig extends MarkConfig, TickThicknessMixins {\n  /**\n   * The width of the ticks.\n   *\n   * __Default value:__  2/3 of rangeStep.\n   * @minimum 0\n   */\n  bandSize?: number;\n}\n\nexport const defaultTickConfig: TickConfig = {\n  thickness: 1\n};\n","import {isObject} from 'vega-util';\nimport {COLUMN, ROW, X, X2, Y, Y2} from './channel';\nimport * as compositeMark from './compositemark';\nimport {Config} from './config';\nimport {channelHasField, Encoding, isRanged} from './encoding';\nimport {Field, RepeatRef} from './fielddef';\nimport * as log from './log';\nimport {\n  AnyMark,\n  AreaConfig,\n  isMarkDef,\n  isPathMark,\n  isPrimitiveMark,\n  LineConfig,\n  Mark,\n  MarkConfig,\n  MarkDef\n} from './mark';\nimport {Projection} from './projection';\nimport {\n  CompositeUnitSpec,\n  ExtendedLayerSpec,\n  FacetedCompositeUnitSpec,\n  GenericFacetSpec,\n  GenericHConcatSpec,\n  GenericRepeatSpec,\n  GenericSpec,\n  GenericUnitSpec,\n  GenericVConcatSpec,\n  isFacetSpec,\n  isHConcatSpec,\n  isLayerSpec,\n  isRepeatSpec,\n  isUnitSpec,\n  isVConcatSpec,\n  NormalizedConcatSpec,\n  NormalizedFacetSpec,\n  NormalizedLayerSpec,\n  NormalizedRepeatSpec,\n  NormalizedSpec,\n  NormalizedUnitSpec,\n  TopLevel,\n  TopLevelSpec\n} from './spec';\nimport {stack} from './stack';\nimport {duplicate, keys, omit, pick} from './util';\n\nexport function normalizeTopLevelSpec(\n  spec: TopLevelSpec | GenericSpec<CompositeUnitSpec, ExtendedLayerSpec> | FacetedCompositeUnitSpec,\n  config: Config\n): TopLevel<NormalizedSpec> {\n  return normalize(spec, config);\n}\n\n/**\n * Decompose extended unit specs into composition of pure unit specs.\n */\nfunction normalize(\n  spec: GenericSpec<CompositeUnitSpec, ExtendedLayerSpec> | FacetedCompositeUnitSpec,\n  config: Config\n): NormalizedSpec {\n  if (isFacetSpec(spec)) {\n    return normalizeFacet(spec, config);\n  }\n  if (isLayerSpec(spec)) {\n    return normalizeLayer(spec, config);\n  }\n  if (isRepeatSpec(spec)) {\n    return normalizeRepeat(spec, config);\n  }\n  if (isVConcatSpec(spec)) {\n    return normalizeVConcat(spec, config);\n  }\n  if (isHConcatSpec(spec)) {\n    return normalizeHConcat(spec, config);\n  }\n  if (isUnitSpec(spec)) {\n    const hasRow = channelHasField(spec.encoding, ROW);\n    const hasColumn = channelHasField(spec.encoding, COLUMN);\n\n    if (hasRow || hasColumn) {\n      return normalizeFacetedUnit(spec, config);\n    }\n    return normalizeNonFacetUnit(spec, config);\n  }\n  throw new Error(log.message.INVALID_SPEC);\n}\n\nfunction normalizeFacet(\n  spec: GenericFacetSpec<CompositeUnitSpec, ExtendedLayerSpec>,\n  config: Config\n): NormalizedFacetSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    // TODO: remove \"any\" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760\n    spec: normalize(subspec, config) as any\n  };\n}\n\nfunction mergeEncoding(opt: {parentEncoding: Encoding<any>; encoding: Encoding<any>}): Encoding<any> {\n  const {parentEncoding, encoding} = opt;\n  if (parentEncoding && encoding) {\n    const overriden = keys(parentEncoding).reduce((o, key) => {\n      if (encoding[key]) {\n        o.push(key);\n      }\n      return o;\n    }, []);\n\n    if (overriden.length > 0) {\n      log.warn(log.message.encodingOverridden(overriden));\n    }\n  }\n\n  const merged = {\n    ...(parentEncoding || {}),\n    ...(encoding || {})\n  };\n  return keys(merged).length > 0 ? merged : undefined;\n}\n\nfunction mergeProjection(opt: {parentProjection: Projection; projection: Projection}) {\n  const {parentProjection, projection} = opt;\n  if (parentProjection && projection) {\n    log.warn(log.message.projectionOverridden({parentProjection, projection}));\n  }\n  return projection || parentProjection;\n}\n\nfunction normalizeLayer(\n  spec: ExtendedLayerSpec,\n  config: Config,\n  parentEncoding?: Encoding<string | RepeatRef>,\n  parentProjection?: Projection\n): NormalizedLayerSpec {\n  const {layer, encoding, projection, ...rest} = spec;\n  const mergedEncoding = mergeEncoding({parentEncoding, encoding});\n  const mergedProjection = mergeProjection({parentProjection, projection});\n  return {\n    ...rest,\n    layer: layer.map(subspec => {\n      if (isLayerSpec(subspec)) {\n        return normalizeLayer(subspec, config, mergedEncoding, mergedProjection);\n      }\n      return normalizeNonFacetUnit(subspec, config, mergedEncoding, mergedProjection);\n    })\n  };\n}\n\nfunction normalizeRepeat(\n  spec: GenericRepeatSpec<CompositeUnitSpec, ExtendedLayerSpec>,\n  config: Config\n): NormalizedRepeatSpec {\n  const {spec: subspec, ...rest} = spec;\n  return {\n    ...rest,\n    spec: normalize(subspec, config)\n  };\n}\n\nfunction normalizeVConcat(\n  spec: GenericVConcatSpec<CompositeUnitSpec, ExtendedLayerSpec>,\n  config: Config\n): NormalizedConcatSpec {\n  const {vconcat: vconcat, ...rest} = spec;\n  return {\n    ...rest,\n    vconcat: vconcat.map(subspec => normalize(subspec, config))\n  };\n}\n\nfunction normalizeHConcat(\n  spec: GenericHConcatSpec<CompositeUnitSpec, ExtendedLayerSpec>,\n  config: Config\n): NormalizedConcatSpec {\n  const {hconcat: hconcat, ...rest} = spec;\n  return {\n    ...rest,\n    hconcat: hconcat.map(subspec => normalize(subspec, config))\n  };\n}\n\nfunction normalizeFacetedUnit(spec: FacetedCompositeUnitSpec, config: Config): NormalizedFacetSpec {\n  // New encoding in the inside spec should not contain row / column\n  // as row/column should be moved to facet\n  const {row: row, column: column, ...encoding} = spec.encoding;\n\n  // Mark and encoding should be moved into the inner spec\n  const {mark, width, projection, height, selection, encoding: _, ...outerSpec} = spec;\n\n  return {\n    ...outerSpec,\n    facet: {\n      ...(row ? {row} : {}),\n      ...(column ? {column} : {})\n    },\n    spec: normalizeNonFacetUnit(\n      {\n        ...(projection ? {projection} : {}),\n        mark,\n        ...(width ? {width} : {}),\n        ...(height ? {height} : {}),\n        encoding,\n        ...(selection ? {selection} : {})\n      },\n      config\n    )\n  };\n}\n\nfunction isNonFacetUnitSpecWithPrimitiveMark(\n  spec: GenericUnitSpec<Encoding<Field>, AnyMark>\n): spec is GenericUnitSpec<Encoding<Field>, Mark> {\n  return isPrimitiveMark(spec.mark);\n}\n\nfunction getPointOverlay(markDef: MarkDef, markConfig: LineConfig, encoding: Encoding<Field>): MarkConfig {\n  if (markDef.point === 'transparent') {\n    return {opacity: 0};\n  } else if (markDef.point) {\n    // truthy : true or object\n    return isObject(markDef.point) ? markDef.point : {};\n  } else if (markDef.point !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.point || encoding.shape) {\n      // enable point overlay if config[mark].point is truthy or if encoding.shape is provided\n      return isObject(markConfig.point) ? markConfig.point : {};\n    }\n    // markDef.point is defined as falsy\n    return null;\n  }\n}\n\nfunction getLineOverlay(markDef: MarkDef, markConfig: AreaConfig): MarkConfig {\n  if (markDef.line) {\n    // true or object\n    return markDef.line === true ? {} : markDef.line;\n  } else if (markDef.line !== undefined) {\n    // false or null\n    return null;\n  } else {\n    // undefined (not disabled)\n    if (markConfig.line) {\n      // enable line overlay if config[mark].line is truthy\n      return markConfig.line === true ? {} : markConfig.line;\n    }\n    // markDef.point is defined as falsy\n    return null;\n  }\n}\n\nfunction normalizeNonFacetUnit(\n  spec: GenericUnitSpec<Encoding<Field>, AnyMark>,\n  config: Config,\n  parentEncoding?: Encoding<string | RepeatRef>,\n  parentProjection?: Projection\n): NormalizedUnitSpec | NormalizedLayerSpec {\n  const {encoding, projection} = spec;\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n\n  // merge parent encoding / projection first\n  if (parentEncoding || parentProjection) {\n    const mergedProjection = mergeProjection({parentProjection, projection});\n    const mergedEncoding = mergeEncoding({parentEncoding, encoding});\n    return normalizeNonFacetUnit(\n      {\n        ...spec,\n        ...(mergedProjection ? {projection: mergedProjection} : {}),\n        ...(mergedEncoding ? {encoding: mergedEncoding} : {})\n      },\n      config\n    );\n  }\n\n  if (isNonFacetUnitSpecWithPrimitiveMark(spec)) {\n    // TODO: thoroughly test\n    if (isRanged(encoding)) {\n      return normalizeRangedUnit(spec);\n    }\n\n    if (mark === 'line' && (encoding.x2 || encoding.y2)) {\n      log.warn(log.message.lineWithRange(!!encoding.x2, !!encoding.y2));\n\n      return normalizeNonFacetUnit(\n        {\n          mark: 'rule',\n          ...spec\n        },\n        config,\n        parentEncoding,\n        parentProjection\n      );\n    }\n\n    if (isPathMark(mark)) {\n      return normalizePathOverlay(spec, config);\n    }\n\n    return spec; // Nothing to normalize\n  } else {\n    return compositeMark.normalize(spec, config);\n  }\n}\n\nfunction normalizeRangedUnit(spec: NormalizedUnitSpec) {\n  const hasX = channelHasField(spec.encoding, X);\n  const hasY = channelHasField(spec.encoding, Y);\n  const hasX2 = channelHasField(spec.encoding, X2);\n  const hasY2 = channelHasField(spec.encoding, Y2);\n  if ((hasX2 && !hasX) || (hasY2 && !hasY)) {\n    const normalizedSpec = duplicate(spec);\n    if (hasX2 && !hasX) {\n      normalizedSpec.encoding.x = normalizedSpec.encoding.x2;\n      delete normalizedSpec.encoding.x2;\n    }\n    if (hasY2 && !hasY) {\n      normalizedSpec.encoding.y = normalizedSpec.encoding.y2;\n      delete normalizedSpec.encoding.y2;\n    }\n\n    return normalizedSpec;\n  }\n  return spec;\n}\n\nfunction dropLineAndPoint(markDef: MarkDef): MarkDef | Mark {\n  const {point: _point, line: _line, ...mark} = markDef;\n\n  return keys(mark).length > 1 ? mark : mark.type;\n}\n\nfunction normalizePathOverlay(spec: NormalizedUnitSpec, config: Config = {}): NormalizedLayerSpec | NormalizedUnitSpec {\n  // _ is used to denote a dropped property of the unit spec\n  // which should not be carried over to the layer spec\n  const {selection, projection, encoding, mark, ...outerSpec} = spec;\n  const markDef = isMarkDef(mark) ? mark : {type: mark};\n\n  const pointOverlay = getPointOverlay(markDef, config[markDef.type], encoding);\n  const lineOverlay = markDef.type === 'area' && getLineOverlay(markDef, config[markDef.type]);\n\n  if (!pointOverlay && !lineOverlay) {\n    return {\n      ...spec,\n      // Do not include point / line overlay in the normalize spec\n      mark: dropLineAndPoint(markDef)\n    };\n  }\n\n  const layer: NormalizedUnitSpec[] = [\n    {\n      ...(selection ? {selection} : {}),\n      // Do not include point / line overlay in the normalize spec\n      mark: dropLineAndPoint({\n        ...markDef,\n        // make area mark translucent by default\n        // TODO: extract this 0.7 to be shared with default opacity for point/tick/...\n        ...(markDef.type === 'area' ? {opacity: 0.7} : {})\n      }),\n      // drop shape from encoding as this might be used to trigger point overlay\n      encoding: omit(encoding, ['shape'])\n    }\n  ];\n\n  // FIXME: determine rules for applying selections.\n\n  // Need to copy stack config to overlayed layer\n  const stackProps = stack(markDef, encoding, config ? config.stack : undefined);\n\n  let overlayEncoding = encoding;\n  if (stackProps) {\n    const {fieldChannel: stackFieldChannel, offset} = stackProps;\n    overlayEncoding = {\n      ...encoding,\n      [stackFieldChannel]: {\n        ...encoding[stackFieldChannel],\n        ...(offset ? {stack: offset} : {})\n      }\n    };\n  }\n\n  if (lineOverlay) {\n    layer.push({\n      ...(projection ? {projection} : {}),\n      mark: {\n        type: 'line',\n        ...pick(markDef, ['clip', 'interpolate', 'tension']),\n        ...lineOverlay\n      },\n      encoding: overlayEncoding\n    });\n  }\n  if (pointOverlay) {\n    layer.push({\n      ...(projection ? {projection} : {}),\n      mark: {\n        type: 'point',\n        opacity: 1,\n        filled: true,\n        ...pick(markDef, ['clip']),\n        ...pointOverlay\n      },\n      encoding: overlayEncoding\n    });\n  }\n\n  return {\n    ...outerSpec,\n    layer\n  };\n}\n","import {isArray, isString} from 'vega-util';\nimport {DataFlowNode} from './compile/data/dataflow';\nimport {Model} from './compile/model';\nimport {selectionPredicate} from './compile/selection/selection';\nimport {DateTime} from './datetime';\nimport {valueExpr, vgField} from './fielddef';\nimport {LogicalOperand} from './logical';\nimport {fieldExpr as timeUnitFieldExpr, normalizeTimeUnit, TimeUnit} from './timeunit';\nimport {logicalExpr} from './util';\n\nexport type Predicate =\n  // a) FieldPredicate (but we don't type FieldFilter here so the schema has no nesting\n  // and thus the documentation shows all of the types clearly)\n  | FieldEqualPredicate\n  | FieldRangePredicate\n  | FieldOneOfPredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate\n  | FieldValidPredicate\n  // b) Selection Predicate\n  | SelectionPredicate\n  // c) Vega Expression string\n  | string;\n\nexport type FieldPredicate =\n  | FieldEqualPredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate\n  | FieldRangePredicate\n  | FieldOneOfPredicate\n  | FieldValidPredicate;\n\nexport interface SelectionPredicate {\n  /**\n   * Filter using a selection name.\n   */\n  selection: LogicalOperand<string>;\n}\n\nexport function isSelectionPredicate(predicate: LogicalOperand<Predicate>): predicate is SelectionPredicate {\n  return predicate && predicate['selection'];\n}\n\nexport interface FieldPredicateBase {\n  // TODO: support aggregate\n\n  /**\n   * Time unit for the field to be filtered.\n   */\n  timeUnit?: TimeUnit;\n\n  /**\n   * Field to be filtered.\n   */\n  field: string;\n}\n\nexport interface FieldEqualPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be equal to.\n   */\n  equal: string | number | boolean | DateTime;\n}\n\nexport function isFieldEqualPredicate(predicate: any): predicate is FieldEqualPredicate {\n  return predicate && !!predicate.field && predicate.equal !== undefined;\n}\n\nexport interface FieldLTPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be less than.\n   */\n  lt: string | number | DateTime;\n}\n\nexport function isFieldLTPredicate(predicate: any): predicate is FieldLTPredicate {\n  return predicate && !!predicate.field && predicate.lt !== undefined;\n}\n\nexport interface FieldLTEPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be less than or equals to.\n   */\n  lte: string | number | DateTime;\n}\n\nexport function isFieldLTEPredicate(predicate: any): predicate is FieldLTEPredicate {\n  return predicate && !!predicate.field && predicate.lte !== undefined;\n}\n\nexport interface FieldGTPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be greater than.\n   */\n  gt: string | number | DateTime;\n}\n\nexport function isFieldGTPredicate(predicate: any): predicate is FieldGTPredicate {\n  return predicate && !!predicate.field && predicate.gt !== undefined;\n}\n\nexport interface FieldGTEPredicate extends FieldPredicateBase {\n  /**\n   * The value that the field should be greater than or equals to.\n   */\n  gte: string | number | DateTime;\n}\n\nexport function isFieldGTEPredicate(predicate: any): predicate is FieldGTEPredicate {\n  return predicate && !!predicate.field && predicate.gte !== undefined;\n}\n\nexport interface FieldRangePredicate extends FieldPredicateBase {\n  /**\n   * An array of inclusive minimum and maximum values\n   * for a field value of a data item to be included in the filtered data.\n   * @maxItems 2\n   * @minItems 2\n   */\n  range: (number | DateTime | null)[];\n}\n\nexport function isFieldRangePredicate(predicate: any): predicate is FieldRangePredicate {\n  if (predicate && predicate.field) {\n    if (isArray(predicate.range) && predicate.range.length === 2) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface FieldOneOfPredicate extends FieldPredicateBase {\n  /**\n   * A set of values that the `field`'s value should be a member of,\n   * for a data item included in the filtered data.\n   */\n  oneOf: string[] | number[] | boolean[] | DateTime[];\n}\n\nexport interface FieldValidPredicate extends FieldPredicateBase {\n  /**\n   * If set to true the field's value has to be valid, meaning both not `null` and not [`NaN`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).\n   */\n  valid: boolean;\n}\n\nexport function isFieldOneOfPredicate(predicate: any): predicate is FieldOneOfPredicate {\n  return (\n    predicate && !!predicate.field && (isArray(predicate.oneOf) || isArray(predicate.in)) // backward compatibility\n  );\n}\n\nexport function isFieldValidPredicate(predicate: any): predicate is FieldValidPredicate {\n  return predicate && !!predicate.field && predicate.valid !== undefined;\n}\n\nexport function isFieldPredicate(\n  predicate: Predicate\n): predicate is\n  | FieldOneOfPredicate\n  | FieldEqualPredicate\n  | FieldRangePredicate\n  | FieldLTPredicate\n  | FieldGTPredicate\n  | FieldLTEPredicate\n  | FieldGTEPredicate {\n  return (\n    isFieldOneOfPredicate(predicate) ||\n    isFieldEqualPredicate(predicate) ||\n    isFieldRangePredicate(predicate) ||\n    isFieldLTPredicate(predicate) ||\n    isFieldGTPredicate(predicate) ||\n    isFieldLTEPredicate(predicate) ||\n    isFieldGTEPredicate(predicate)\n  );\n}\n\n/**\n * Converts a predicate into an expression.\n */\n// model is only used for selection filters.\nexport function expression(model: Model, filterOp: LogicalOperand<Predicate>, node?: DataFlowNode): string {\n  return logicalExpr(filterOp, (predicate: Predicate) => {\n    if (isString(predicate)) {\n      return predicate;\n    } else if (isSelectionPredicate(predicate)) {\n      return selectionPredicate(model, predicate.selection, node);\n    } else {\n      // Filter Object\n      return fieldFilterExpression(predicate);\n    }\n  });\n}\n\nfunction predicateValueExpr(v: number | string | boolean | DateTime, timeUnit: TimeUnit) {\n  return valueExpr(v, {timeUnit, time: true});\n}\n\nfunction predicateValuesExpr(vals: (number | string | boolean | DateTime)[], timeUnit: TimeUnit) {\n  return vals.map(v => predicateValueExpr(v, timeUnit));\n}\n\n// This method is used by Voyager.  Do not change its behavior without changing Voyager.\nexport function fieldFilterExpression(predicate: FieldPredicate, useInRange = true) {\n  const {field, timeUnit} = predicate;\n  const fieldExpr = timeUnit\n    ? // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.\n      // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline\n      // TODO: support utc\n      'time(' + timeUnitFieldExpr(timeUnit, field) + ')'\n    : vgField(predicate, {expr: 'datum'});\n\n  if (isFieldEqualPredicate(predicate)) {\n    return fieldExpr + '===' + predicateValueExpr(predicate.equal, timeUnit);\n  } else if (isFieldLTPredicate(predicate)) {\n    const upper = predicate.lt;\n    return `${fieldExpr}<${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTPredicate(predicate)) {\n    const lower = predicate.gt;\n    return `${fieldExpr}>${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldLTEPredicate(predicate)) {\n    const upper = predicate.lte;\n    return `${fieldExpr}<=${predicateValueExpr(upper, timeUnit)}`;\n  } else if (isFieldGTEPredicate(predicate)) {\n    const lower = predicate.gte;\n    return `${fieldExpr}>=${predicateValueExpr(lower, timeUnit)}`;\n  } else if (isFieldOneOfPredicate(predicate)) {\n    return `indexof([${predicateValuesExpr(predicate.oneOf, timeUnit).join(',')}], ${fieldExpr}) !== -1`;\n  } else if (isFieldValidPredicate(predicate)) {\n    return predicate.valid ? `${fieldExpr}!==null&&!isNaN(${fieldExpr})` : `${fieldExpr}===null||isNaN(${fieldExpr})`;\n  } else if (isFieldRangePredicate(predicate)) {\n    const lower = predicate.range[0];\n    const upper = predicate.range[1];\n\n    if (lower !== null && upper !== null && useInRange) {\n      return (\n        'inrange(' +\n        fieldExpr +\n        ', [' +\n        predicateValueExpr(lower, timeUnit) +\n        ', ' +\n        predicateValueExpr(upper, timeUnit) +\n        '])'\n      );\n    }\n\n    const exprs = [];\n    if (lower !== null) {\n      exprs.push(`${fieldExpr} >= ${predicateValueExpr(lower, timeUnit)}`);\n    }\n    if (upper !== null) {\n      exprs.push(`${fieldExpr} <= ${predicateValueExpr(upper, timeUnit)}`);\n    }\n\n    return exprs.length > 0 ? exprs.join(' && ') : 'true';\n  }\n\n  /* istanbul ignore next: it should never reach here */\n  throw new Error(`Invalid field predicate: ${JSON.stringify(predicate)}`);\n}\n\nexport function normalizePredicate(f: Predicate): Predicate {\n  if (isFieldPredicate(f) && f.timeUnit) {\n    return {\n      ...f,\n      timeUnit: normalizeTimeUnit(f.timeUnit)\n    };\n  }\n  return f;\n}\n","import {VgProjectionType} from './vega.schema';\n\nexport type ProjectionType = VgProjectionType;\n\nexport interface Projection {\n  /**\n   * The cartographic projection to use. This value is case-insensitive, for example `\"albers\"` and `\"Albers\"` indicate the same projection type. You can find all valid projection types [in the documentation](https://vega.github.io/vega-lite/docs/projection.html#projection-types).\n   *\n   * __Default value:__ `mercator`\n   */\n  type?: ProjectionType;\n\n  /**\n   * Sets the projections clipping circle radius to the specified angle in degrees. If `null`, switches to [antimeridian](http://bl.ocks.org/mbostock/3788999) cutting rather than small-circle clipping.\n   */\n  clipAngle?: number;\n\n  /**\n   * Sets the projections viewport clip extent to the specified bounds in pixels. The extent bounds are specified as an array `[[x0, y0], [x1, y1]]`, where `x0` is the left-side of the viewport, `y0` is the top, `x1` is the right and `y1` is the bottom. If `null`, no viewport clipping is performed.\n   */\n  clipExtent?: number[][];\n\n  /**\n   * Sets the projections center to the specified center, a two-element array of longitude and latitude in degrees.\n   *\n   * __Default value:__ `[0, 0]`\n   */\n  center?: number[];\n\n  /**\n   * Sets the projections three-axis rotation to the specified angles, which must be a two- or three-element array of numbers [`lambda`, `phi`, `gamma`] specifying the rotation angles in degrees about each spherical axis. (These correspond to yaw, pitch and roll.)\n   *\n   * __Default value:__ `[0, 0, 0]`\n   */\n  rotate?: number[];\n\n  /**\n   * Sets the threshold for the projections [adaptive resampling](http://bl.ocks.org/mbostock/3795544) to the specified value in pixels. This value corresponds to the [DouglasPeucker distance](http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm). If precision is not specified, returns the projections current resampling precision which defaults to `0.5  0.70710`.\n   */\n  precision?: string;\n\n  /* The following properties are all supported for specific types of projections. Consult the d3-geo-projection library for more information: https://github.com/d3/d3-geo-projection */\n  coefficient?: number;\n  distance?: number;\n  fraction?: number;\n  lobes?: number;\n  parallel?: number;\n  radius?: number;\n  ratio?: number;\n  spacing?: number;\n  tilt?: number;\n}\n\n/**\n * Any property of Projection can be in config\n */\nexport type ProjectionConfig = Projection;\n\nexport const PROJECTION_PROPERTIES: (keyof Projection)[] = [\n  'type',\n  'clipAngle',\n  'clipExtent',\n  'center',\n  'rotate',\n  'precision',\n  'coefficient',\n  'distance',\n  'fraction',\n  'lobes',\n  'parallel',\n  'radius',\n  'ratio',\n  'spacing',\n  'tilt'\n];\n","import {toSet} from 'vega-util';\nimport {BinParams} from './bin';\nimport {Channel, CHANNELS, isColorChannel} from './channel';\nimport {DateTime} from './datetime';\nimport * as log from './log';\nimport {Type, TYPE_INDEX} from './type';\nimport {contains, Flag, flagKeys, keys} from './util';\nimport {ScaleInterpolate, ScaleInterpolateParams} from './vega.schema';\n\nexport namespace ScaleType {\n  // Continuous - Quantitative\n  export const LINEAR: 'linear' = 'linear';\n  export const BIN_LINEAR: 'bin-linear' = 'bin-linear';\n  export const LOG: 'log' = 'log';\n  export const POW: 'pow' = 'pow';\n  export const SQRT: 'sqrt' = 'sqrt';\n  // Continuous - Time\n  export const TIME: 'time' = 'time';\n  export const UTC: 'utc' = 'utc';\n  // sequential\n  export const SEQUENTIAL: 'sequential' = 'sequential';\n\n  // Quantile, Quantize, threshold\n  export const QUANTILE: 'quantile' = 'quantile';\n  export const QUANTIZE: 'quantize' = 'quantize';\n  export const THRESHOLD: 'threshold' = 'threshold';\n\n  export const ORDINAL: 'ordinal' = 'ordinal';\n  export const BIN_ORDINAL: 'bin-ordinal' = 'bin-ordinal';\n  export const POINT: 'point' = 'point';\n  export const BAND: 'band' = 'band';\n}\n\nexport type ScaleType =\n  | typeof ScaleType.LINEAR\n  | typeof ScaleType.BIN_LINEAR\n  | typeof ScaleType.LOG\n  | typeof ScaleType.POW\n  | typeof ScaleType.SQRT\n  | typeof ScaleType.TIME\n  | typeof ScaleType.UTC\n  | typeof ScaleType.SEQUENTIAL\n  | typeof ScaleType.QUANTILE\n  | typeof ScaleType.QUANTIZE\n  | typeof ScaleType.THRESHOLD\n  | typeof ScaleType.ORDINAL\n  | typeof ScaleType.BIN_ORDINAL\n  | typeof ScaleType.POINT\n  | typeof ScaleType.BAND;\n\n/**\n * Index for scale categories -- only scale of the same categories can be merged together.\n * Current implementation is trying to be conservative and avoid merging scale type that might not work together\n */\nconst SCALE_CATEGORY_INDEX: {\n  // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n  [k in ScaleType]: ScaleType | 'numeric' | 'ordinal-position' | 'discretizing'\n} = {\n  linear: 'numeric',\n  log: 'numeric',\n  pow: 'numeric',\n  sqrt: 'numeric',\n  'bin-linear': 'bin-linear', // TODO: should bin-linear support merging with other\n  time: 'time',\n  utc: 'time',\n  sequential: 'sequential',\n  ordinal: 'ordinal',\n  'bin-ordinal': 'bin-ordinal', // TODO: should bin-ordinal support merging with other\n  point: 'ordinal-position',\n  band: 'ordinal-position',\n  quantile: 'discretizing',\n  quantize: 'discretizing',\n  threshold: 'discretizing'\n};\n\nexport const SCALE_TYPES = keys(SCALE_CATEGORY_INDEX) as ScaleType[];\n\n/**\n * Whether the two given scale types can be merged together.\n */\nexport function scaleCompatible(scaleType1: ScaleType, scaleType2: ScaleType) {\n  const scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];\n  const scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];\n  return (\n    scaleCategory1 === scaleCategory2 ||\n    (scaleCategory1 === 'ordinal-position' && scaleCategory2 === 'time') ||\n    (scaleCategory2 === 'ordinal-position' && scaleCategory1 === 'time')\n  );\n}\n\n/**\n * Index for scale precedence -- high score = higher priority for merging.\n */\nconst SCALE_PRECEDENCE_INDEX: {\n  // Using Mapped Type to declare type (https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types)\n  [k in ScaleType]: number\n} = {\n  // numeric\n  linear: 0,\n  log: 1,\n  pow: 1,\n  sqrt: 1,\n  // time\n  time: 0,\n  utc: 0,\n  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data\n  point: 10,\n  band: 11, // band has higher precedence as it is better for interaction\n  // non grouped types\n  'bin-linear': 0,\n  sequential: 0,\n  ordinal: 0,\n  'bin-ordinal': 0,\n  quantile: 0,\n  quantize: 0,\n  threshold: 0\n};\n\n/**\n * Return scale categories -- only scale of the same categories can be merged together.\n */\nexport function scaleTypePrecedence(scaleType: ScaleType): number {\n  return SCALE_PRECEDENCE_INDEX[scaleType];\n}\n\nexport const CONTINUOUS_TO_CONTINUOUS_SCALES: ScaleType[] = [\n  'linear',\n  'bin-linear',\n  'log',\n  'pow',\n  'sqrt',\n  'time',\n  'utc'\n];\nconst CONTINUOUS_TO_CONTINUOUS_INDEX = toSet(CONTINUOUS_TO_CONTINUOUS_SCALES);\n\nexport const CONTINUOUS_TO_DISCRETE_SCALES: ScaleType[] = ['quantile', 'quantize', 'threshold'];\nconst CONTINUOUS_TO_DISCRETE_INDEX = toSet(CONTINUOUS_TO_DISCRETE_SCALES);\n\nexport const CONTINUOUS_DOMAIN_SCALES: ScaleType[] = CONTINUOUS_TO_CONTINUOUS_SCALES.concat([\n  'sequential',\n  'quantile',\n  'quantize',\n  'threshold'\n]);\nconst CONTINUOUS_DOMAIN_INDEX = toSet(CONTINUOUS_DOMAIN_SCALES);\n\nexport const DISCRETE_DOMAIN_SCALES: ScaleType[] = ['ordinal', 'bin-ordinal', 'point', 'band'];\nconst DISCRETE_DOMAIN_INDEX = toSet(DISCRETE_DOMAIN_SCALES);\n\nconst BIN_SCALES_INDEX = toSet(['bin-linear', 'bin-ordinal']);\n\nexport const TIME_SCALE_TYPES: ScaleType[] = ['time', 'utc'];\n\nexport function hasDiscreteDomain(type: ScaleType): type is 'ordinal' | 'bin-ordinal' | 'point' | 'band' {\n  return type in DISCRETE_DOMAIN_INDEX;\n}\n\nexport function isBinScale(type: ScaleType): type is 'bin-linear' | 'bin-ordinal' {\n  return type in BIN_SCALES_INDEX;\n}\n\nexport function hasContinuousDomain(\n  type: ScaleType\n): type is 'linear' | 'log' | 'pow' | 'sqrt' | 'time' | 'utc' | 'sequential' | 'quantile' | 'quantize' | 'threshold' {\n  return type in CONTINUOUS_DOMAIN_INDEX;\n}\n\nexport function isContinuousToContinuous(type: ScaleType): type is 'linear' | 'log' | 'pow' | 'sqrt' | 'time' | 'utc' {\n  return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\n\nexport function isContinuousToDiscrete(type: ScaleType): type is 'quantile' | 'quantize' | 'threshold' {\n  return type in CONTINUOUS_TO_DISCRETE_INDEX;\n}\n\nexport type NiceTime = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';\n\nexport interface ScaleConfig {\n  /**\n   * If true, rounds numeric output values to integers.\n   * This can be helpful for snapping to the pixel grid.\n   * (Only available for `x`, `y`, and `size` scales.)\n   */\n  round?: boolean;\n\n  /**\n   * If true, values that exceed the data domain are clamped to either the minimum or maximum range value\n   */\n  clamp?: boolean;\n  /**\n   *  Default range step for `x` band and point scales of text marks.\n   *\n   * __Default value:__ `90`\n   *\n   *  @minimum 0\n   */\n  textXRangeStep?: number; // FIXME: consider if we will rename this \"tableColumnWidth\"\n\n  /**\n   * Default range step for band and point scales of (1) the `y` channel\n   * and (2) the `x` channel when the mark is not `text`.\n   *\n   * __Default value:__ `21`\n   *\n   * @minimum 0\n   */\n  rangeStep?: number | null;\n\n  /**\n   * Default inner padding for `x` and `y` band-ordinal scales.\n   *\n   * __Default value:__ `0.1`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  bandPaddingInner?: number;\n\n  /**\n   * Default outer padding for `x` and `y` band-ordinal scales.\n   * If not specified, by default, band scale's paddingOuter is paddingInner/2.\n   * @minimum 0\n   * @maximum 1\n   */\n  bandPaddingOuter?: number;\n\n  /**\n   * Default padding for continuous scales.\n   *\n   * __Default:__ `5` for continuous x-scale of a vertical bar and continuous y-scale of a horizontal bar.; `0` otherwise.\n   *\n   * @minimum 0\n   */\n  continuousPadding?: number;\n\n  /**\n   * Default outer padding for `x` and `y` point-ordinal scales.\n   *\n   * __Default value:__ `0.5`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  pointPadding?: number;\n\n  /**\n   * Use the source data range before aggregation as scale domain instead of aggregated data for aggregate axis.\n   *\n   * This is equivalent to setting `domain` to `\"unaggregate\"` for aggregated _quantitative_ fields by default.\n   *\n   * This property only works with aggregate functions that produce values within the raw data domain (`\"mean\"`, `\"average\"`, `\"median\"`, `\"q1\"`, `\"q3\"`, `\"min\"`, `\"max\"`). For other aggregations that produce values outside of the raw data domain (e.g. `\"count\"`, `\"sum\"`), this property is ignored.\n   *\n   * __Default value:__ `false`\n   */\n  useUnaggregatedDomain?: boolean;\n\n  // nice should depends on type (quantitative or temporal), so\n  // let's not make a config.\n\n  // Configs for Range\n\n  /**\n   * The default max value for mapping quantitative fields to bar's size/bandSize.\n   *\n   * If undefined (default), we will use the scale's `rangeStep` - 1.\n   * @minimum 0\n   */\n  maxBandSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to bar and tick's size/bandSize scale with zero=false.\n   *\n   * __Default value:__ `2`\n   *\n   * @minimum 0\n   */\n  minBandSize?: number;\n\n  /**\n   * The default max value for mapping quantitative fields to text's size/fontSize.\n   *\n   * __Default value:__ `40`\n   *\n   * @minimum 0\n   */\n  maxFontSize?: number;\n\n  /**\n   * The default min value for mapping quantitative fields to tick's size/fontSize scale with zero=false\n   *\n   * __Default value:__ `8`\n   *\n   * @minimum 0\n   */\n  minFontSize?: number;\n\n  /**\n   * Default minimum opacity for mapping a field to opacity.\n   *\n   * __Default value:__ `0.3`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  minOpacity?: number;\n\n  /**\n   * Default max opacity for mapping a field to opacity.\n   *\n   * __Default value:__ `0.8`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  maxOpacity?: number;\n\n  /**\n   * Default minimum value for point size scale with zero=false.\n   *\n   * __Default value:__ `9`\n   *\n   * @minimum 0\n   */\n  minSize?: number;\n\n  /**\n   * Default max value for point size scale.\n   * @minimum 0\n   */\n  maxSize?: number;\n\n  /**\n   * Default minimum strokeWidth for the scale of strokeWidth for rule and line marks and of size for trail marks with zero=false.\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   */\n  minStrokeWidth?: number;\n\n  /**\n   * Default max strokeWidth for the scale of strokeWidth for rule and line marks and of size for trail marks.\n   *\n   * __Default value:__ `4`\n   *\n   * @minimum 0\n   */\n  maxStrokeWidth?: number;\n\n  /**\n   * Default range cardinality for [`quantile`](https://vega.github.io/vega-lite/docs/scale.html#quantile) scale.\n   *\n   * __Default value:__ `4`\n   *\n   * @minimum 0\n   */\n  quantileCount?: number;\n\n  /**\n   * Default range cardinality for [`quantize`](https://vega.github.io/vega-lite/docs/scale.html#quantize) scale.\n   *\n   * __Default value:__ `4`\n   *\n   * @minimum 0\n   */\n  quantizeCount?: number;\n}\n\nexport const defaultScaleConfig = {\n  textXRangeStep: 90,\n  rangeStep: 21,\n  pointPadding: 0.5,\n  bandPaddingInner: 0.1,\n  facetSpacing: 16,\n\n  minBandSize: 2,\n\n  minFontSize: 8,\n  maxFontSize: 40,\n\n  minOpacity: 0.3,\n  maxOpacity: 0.8,\n\n  // FIXME: revise if these *can* become ratios of rangeStep\n  minSize: 9, // Point size is area. For square point, 9 = 3 pixel ^ 2, not too small!\n\n  minStrokeWidth: 1,\n  maxStrokeWidth: 4,\n  quantileCount: 4,\n  quantizeCount: 4\n};\n\nexport interface SchemeParams {\n  /**\n   * A color scheme name for sequential/ordinal scales (e.g., `\"category10\"` or `\"viridis\"`).\n   *\n   * For the full list of supported schemes, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.\n   */\n  name: string;\n\n  /**\n   * For sequential and diverging schemes only, determines the extent of the color range to use. For example `[0.2, 1]` will rescale the color scheme such that color values in the range _[0, 0.2)_ are excluded from the scheme.\n   */\n  extent?: number[];\n\n  /**\n   * The number of colors to use in the scheme. This can be useful for scale types such as `\"quantize\"`, which use the length of the scale range to determine the number of discrete bins for the scale domain.\n   */\n  count?: number;\n}\n\nexport type SelectionDomain =\n  | {\n      /**\n       * The name of a selection.\n       */\n      selection: string;\n      /**\n       * The field name to extract selected values for, when a selection is [projected](https://vega.github.io/vega-lite/docs/project.html)\n       * over multiple fields or encodings.\n       */\n      field?: string;\n    }\n  | {\n      /**\n       * The name of a selection.\n       */\n      selection: string;\n      /**\n       * The encoding channel to extract selected values for, when a selection is [projected](https://vega.github.io/vega-lite/docs/project.html)\n       * over multiple fields or encodings.\n       */\n      encoding?: string;\n    };\n\nexport type Domain = number[] | string[] | boolean[] | DateTime[] | 'unaggregated' | SelectionDomain;\nexport type Scheme = string | SchemeParams;\n\nexport type Range = number[] | string[] | string;\n\nexport function isExtendedScheme(scheme: string | SchemeParams): scheme is SchemeParams {\n  return scheme && !!scheme['name'];\n}\n\nexport function isSelectionDomain(domain: Domain): domain is SelectionDomain {\n  return domain && domain['selection'];\n}\n\nexport interface Scale {\n  /**\n   * The type of scale.  Vega-Lite supports the following categories of scale types:\n   *\n   * 1) [**Continuous Scales**](https://vega.github.io/vega-lite/docs/scale.html#continuous) -- mapping continuous domains to continuous output ranges ([`\"linear\"`](https://vega.github.io/vega-lite/docs/scale.html#linear), [`\"pow\"`](https://vega.github.io/vega-lite/docs/scale.html#pow), [`\"sqrt\"`](https://vega.github.io/vega-lite/docs/scale.html#sqrt), [`\"log\"`](https://vega.github.io/vega-lite/docs/scale.html#log), [`\"time\"`](https://vega.github.io/vega-lite/docs/scale.html#time), [`\"utc\"`](https://vega.github.io/vega-lite/docs/scale.html#utc), [`\"sequential\"`](https://vega.github.io/vega-lite/docs/scale.html#sequential)).\n   *\n   * 2) [**Discrete Scales**](https://vega.github.io/vega-lite/docs/scale.html#discrete) -- mapping discrete domains to discrete ([`\"ordinal\"`](https://vega.github.io/vega-lite/docs/scale.html#ordinal)) or continuous ([`\"band\"`](https://vega.github.io/vega-lite/docs/scale.html#band) and [`\"point\"`](https://vega.github.io/vega-lite/docs/scale.html#point)) output ranges.\n   *\n   * 3) [**Discretizing Scales**](https://vega.github.io/vega-lite/docs/scale.html#discretizing) -- mapping continuous domains to discrete output ranges ([`\"bin-linear\"`](https://vega.github.io/vega-lite/docs/scale.html#bin-linear), [`\"bin-ordinal\"`](https://vega.github.io/vega-lite/docs/scale.html#bin-ordinal), [`\"quantile\"`](https://vega.github.io/vega-lite/docs/scale.html#quantile), [`\"quantize\"`](https://vega.github.io/vega-lite/docs/scale.html#quantize) and [`\"threshold\"`](https://vega.github.io/vega-lite/docs/scale.html#threshold).\n   *\n   * __Default value:__ please see the [scale type table](https://vega.github.io/vega-lite/docs/scale.html#type).\n   */\n  type?: ScaleType;\n\n  /**\n   * Customized domain values.\n   *\n   * For _quantitative_ fields, `domain` can take the form of a two-element array with minimum and maximum values.  [Piecewise scales](https://vega.github.io/vega-lite/docs/scale.html#piecewise) can be created by providing a `domain` with more than two entries.\n   * If the input field is aggregated, `domain` can also be a string value `\"unaggregated\"`, indicating that the domain should include the raw data values prior to the aggregation.\n   *\n   * For _temporal_ fields, `domain` can be a two-element array minimum and maximum values, in the form of either timestamps or the [DateTime definition objects](https://vega.github.io/vega-lite/docs/types.html#datetime).\n   *\n   * For _ordinal_ and _nominal_ fields, `domain` can be an array that lists valid input values.\n   *\n   * The `selection` property can be used to [interactively determine](https://vega.github.io/vega-lite/docs/selection.html#scale-domains) the scale domain.\n   */\n  domain?: number[] | string[] | boolean[] | DateTime[] | 'unaggregated' | SelectionDomain;\n\n  // Hide because we might not really need this.\n  /**\n   * If true, reverses the order of the scale range.\n   * __Default value:__ `false`.\n   *\n   * @hide\n   */\n  reverse?: boolean;\n\n  /**\n   * The range of the scale. One of:\n   *\n   * - A string indicating a [pre-defined named scale range](https://vega.github.io/vega-lite/docs/scale.html#range-config) (e.g., example, `\"symbol\"`, or `\"diverging\"`).\n   *\n   * - For [continuous scales](https://vega.github.io/vega-lite/docs/scale.html#continuous), two-element array indicating  minimum and maximum values, or an array with more than two entries for specifying a [piecewise scale](https://vega.github.io/vega-lite/docs/scale.html#piecewise).\n   *\n   * - For [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) and [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales, an array of desired output values.\n   *\n   * __Notes:__\n   *\n   * 1) For [sequential](https://vega.github.io/vega-lite/docs/scale.html#sequential), [ordinal](https://vega.github.io/vega-lite/docs/scale.html#ordinal), and discretizing color scales, you can also specify a color [`scheme`](https://vega.github.io/vega-lite/docs/scale.html#scheme) instead of `range`.\n   *\n   * 2) Any directly specified `range` for `x` and `y` channels will be ignored. Range can be customized via the view's corresponding [size](https://vega.github.io/vega-lite/docs/size.html) (`width` and `height`) or via [range steps and paddings properties](#range-step) for [band](#band) and [point](#point) scales.\n   */\n  range?: number[] | string[] | string;\n\n  // ordinal\n  /**\n   * The distance between the starts of adjacent bands or points in [band](https://vega.github.io/vega-lite/docs/scale.html#band) and [point](https://vega.github.io/vega-lite/docs/scale.html#point) scales.\n   *\n   * If `rangeStep` is `null` or if the view contains the scale's corresponding [size](https://vega.github.io/vega-lite/docs/size.html) (`width` for `x` scales and `height` for `y` scales), `rangeStep` will be automatically determined to fit the size of the view.\n   *\n   * __Default value:__  derived the [scale config](https://vega.github.io/vega-lite/docs/config.html#scale-config)'s `textXRangeStep` (`90` by default) for x-scales of `text` marks and `rangeStep` (`21` by default) for x-scales of other marks and y-scales.\n   *\n   * __Warning__: If `rangeStep` is `null` and the cardinality of the scale's domain is higher than `width` or `height`, the rangeStep might become less than one pixel and the mark might not appear correctly.\n   *\n   * @minimum 0\n   */\n  rangeStep?: number | null;\n\n  /**\n   * A string indicating a color [scheme](https://vega.github.io/vega-lite/docs/scale.html#scheme) name (e.g., `\"category10\"` or `\"viridis\"`) or a [scheme parameter object](https://vega.github.io/vega-lite/docs/scale.html#scheme-params).\n   *\n   * Discrete color schemes may be used with [discrete](https://vega.github.io/vega-lite/docs/scale.html#discrete) or [discretizing](https://vega.github.io/vega-lite/docs/scale.html#discretizing) scales. Continuous color schemes are intended for use with [sequential](https://vega.github.io/vega-lite/docs/scales.html#sequential) scales.\n   *\n   * For the full list of supported schemes, please refer to the [Vega Scheme](https://vega.github.io/vega/docs/schemes/#reference) reference.\n   */\n  scheme?: string | SchemeParams;\n\n  /**\n   * If `true`, rounds numeric output values to integers. This can be helpful for snapping to the pixel grid.\n   *\n   * __Default value:__ `false`.\n   */\n  round?: boolean;\n\n  /**\n   * For _[continuous](https://vega.github.io/vega-lite/docs/scale.html#continuous)_ scales, expands the scale domain to accommodate the specified number of pixels on each of the scale range. The scale range must represent pixels for this parameter to function as intended. Padding adjustment is performedpriorto all other adjustments, including the effects of thezero,nice,domainMin, anddomainMaxproperties.\n   *\n   * For _[band](https://vega.github.io/vega-lite/docs/scale.html#band)_ scales, shortcut for setting `paddingInner` and `paddingOuter` to the same value.\n   *\n   * For _[point](https://vega.github.io/vega-lite/docs/scale.html#point)_ scales, alias for `paddingOuter`.\n   *\n   * __Default value:__ For _continuous_ scales, derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `continuousPadding`.\n   * For _band and point_ scales, see `paddingInner` and `paddingOuter`.\n   *\n   * @minimum 0\n   */\n  padding?: number;\n\n  /**\n   * The inner padding (spacing) within each band step of band scales, as a fraction of the step size. This value must lie in the range [0,1].\n   *\n   * For point scale, this property is invalid as point scales do not have internal band widths (only step sizes between bands).\n   *\n   * __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingInner`.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  paddingInner?: number;\n\n  /**\n   * The outer padding (spacing) at the ends of the range of band and point scales,\n   * as a fraction of the step size. This value must lie in the range [0,1].\n   *\n   * __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/scale.html#config)'s `bandPaddingOuter` for band scales and `pointPadding` for point scales.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  paddingOuter?: number;\n\n  // typical\n  /**\n   * If `true`, values that exceed the data domain are clamped to either the minimum or maximum range value\n   *\n   * __Default value:__ derived from the [scale config](https://vega.github.io/vega-lite/docs/config.html#scale-config)'s `clamp` (`true` by default).\n   */\n  clamp?: boolean;\n\n  /**\n   * Extending the domain so that it starts and ends on nice round values. This method typically modifies the scales domain, and may only extend the bounds to the nearest round value. Nicing is useful if the domain is computed from data and may be irregular. For example, for a domain of _[0.201479, 0.996679]_, a nice domain might be _[0.2, 1.0]_.\n   *\n   * For quantitative scales such as linear, `nice` can be either a boolean flag or a number. If `nice` is a number, it will represent a desired tick count. This allows greater control over the step size used to extend the bounds, guaranteeing that the returned ticks will exactly cover the domain.\n   *\n   * For temporal fields with time and utc scales, the `nice` value can be a string indicating the desired time interval. Legal values are `\"millisecond\"`, `\"second\"`, `\"minute\"`, `\"hour\"`, `\"day\"`, `\"week\"`, `\"month\"`, and `\"year\"`. Alternatively, `time` and `utc` scales can accept an object-valued interval specifier of the form `{\"interval\": \"month\", \"step\": 3}`, which includes a desired number of interval steps. Here, the domain would snap to quarter (Jan, Apr, Jul, Oct) boundaries.\n   *\n   * __Default value:__ `true` for unbinned _quantitative_ fields; `false` otherwise.\n   *\n   */\n  nice?: boolean | number | NiceTime | {interval: string; step: number};\n\n  /**\n   * The logarithm base of the `log` scale (default `10`).\n   */\n  base?: number;\n\n  /**\n   * The exponent of the `pow` scale.\n   */\n  exponent?: number;\n\n  /**\n   * If `true`, ensures that a zero baseline value is included in the scale domain.\n   *\n   * __Default value:__ `true` for x and y channels if the quantitative field is not binned and no custom `domain` is provided; `false` otherwise.\n   *\n   * __Note:__ Log, time, and utc scales do not support `zero`.\n   */\n  zero?: boolean;\n\n  /**\n   * The interpolation method for range values. By default, a general interpolator for numbers, dates, strings and colors (in HCL space) is used. For color ranges, this property allows interpolation in alternative color spaces. Legal values include `rgb`, `hsl`, `hsl-long`, `lab`, `hcl`, `hcl-long`, `cubehelix` and `cubehelix-long` ('-long' variants use longer paths in polar coordinate spaces). If object-valued, this property accepts an object with a string-valued _type_ property and an optional numeric _gamma_ property applicable to rgb and cubehelix interpolators. For more, see the [d3-interpolate documentation](https://github.com/d3/d3-interpolate).\n   *\n   * * __Default value:__ `hcl`\n   *\n   * __Note:__ Sequential scales do not support `interpolate` as they have a fixed interpolator.  Since Vega-Lite uses sequential scales for quantitative fields by default, you have to set the scale `type` to other quantitative scale type such as `\"linear\"` to customize `interpolate`.\n   */\n  interpolate?: ScaleInterpolate | ScaleInterpolateParams;\n}\n\nconst SCALE_PROPERTY_INDEX: Flag<keyof Scale> = {\n  type: 1,\n  domain: 1,\n  range: 1,\n  rangeStep: 1,\n  scheme: 1,\n  // Other properties\n  reverse: 1,\n  round: 1,\n  // quantitative / time\n  clamp: 1,\n  nice: 1,\n  // quantitative\n  base: 1,\n  exponent: 1,\n  interpolate: 1,\n  zero: 1, // zero depends on domain\n  // band/point\n  padding: 1,\n  paddingInner: 1,\n  paddingOuter: 1\n};\n\nexport const SCALE_PROPERTIES = flagKeys(SCALE_PROPERTY_INDEX);\n\nconst {\n  type,\n  domain,\n  range,\n  rangeStep,\n  scheme,\n  ...NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX\n} = SCALE_PROPERTY_INDEX;\n\nexport const NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = flagKeys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);\n\nexport const SCALE_TYPE_INDEX = generateScaleTypeIndex();\n\nexport function scaleTypeSupportProperty(scaleType: ScaleType, propName: keyof Scale) {\n  switch (propName) {\n    case 'type':\n    case 'domain':\n    case 'reverse':\n    case 'range':\n      return true;\n    case 'scheme':\n      return contains(['sequential', 'ordinal', 'bin-ordinal', 'quantile', 'quantize', 'threshold'], scaleType);\n    case 'interpolate':\n      return contains(['linear', 'bin-linear', 'pow', 'log', 'sqrt', 'utc', 'time'], scaleType);\n    case 'round':\n      return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n    case 'padding':\n      return isContinuousToContinuous(scaleType) || contains(['point', 'band'], scaleType);\n    case 'paddingOuter':\n    case 'rangeStep':\n      return contains(['point', 'band'], scaleType);\n    case 'paddingInner':\n      return scaleType === 'band';\n    case 'clamp':\n      return isContinuousToContinuous(scaleType) || scaleType === 'sequential';\n    case 'nice':\n      return isContinuousToContinuous(scaleType) || scaleType === 'sequential' || (scaleType as any) === 'quantize';\n    case 'exponent':\n      return scaleType === 'pow';\n    case 'base':\n      return scaleType === 'log';\n    case 'zero':\n      return (\n        hasContinuousDomain(scaleType) &&\n        !contains(\n          [\n            'log', // log scale cannot have zero value\n            'time',\n            'utc', // zero is not meaningful for time\n            'bin-linear', // binning should not automatically add zero\n            'threshold', // threshold requires custom domain so zero does not matter\n            'quantile' // quantile depends on distribution so zero does not matter\n          ],\n          scaleType\n        )\n      );\n  }\n  /* istanbul ignore next: should never reach here*/\n  throw new Error(`Invalid scale property ${propName}.`);\n}\n\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nexport function channelScalePropertyIncompatability(channel: Channel, propName: keyof Scale): string {\n  switch (propName) {\n    case 'interpolate':\n    case 'scheme':\n      if (!isColorChannel(channel)) {\n        return log.message.cannotUseScalePropertyWithNonColor(channel);\n      }\n      return undefined;\n    case 'type':\n    case 'domain':\n    case 'range':\n    case 'base':\n    case 'exponent':\n    case 'nice':\n    case 'padding':\n    case 'paddingInner':\n    case 'paddingOuter':\n    case 'rangeStep':\n    case 'reverse':\n    case 'round':\n    case 'clamp':\n    case 'zero':\n      return undefined; // GOOD!\n  }\n  /* istanbul ignore next: it should never reach here */\n  throw new Error(`Invalid scale property \"${propName}\".`);\n}\n\nexport function scaleTypeSupportDataType(\n  specifiedType: ScaleType,\n  fieldDefType: Type,\n  bin: boolean | BinParams | 'binned'\n): boolean {\n  if (contains([Type.ORDINAL, Type.NOMINAL], fieldDefType)) {\n    return specifiedType === undefined || hasDiscreteDomain(specifiedType);\n  } else if (fieldDefType === Type.TEMPORAL) {\n    return contains([ScaleType.TIME, ScaleType.UTC, ScaleType.SEQUENTIAL, undefined], specifiedType);\n  } else if (fieldDefType === Type.QUANTITATIVE) {\n    if (bin) {\n      return contains([ScaleType.BIN_LINEAR, ScaleType.BIN_ORDINAL, ScaleType.LINEAR], specifiedType);\n    }\n    return contains(\n      [\n        ScaleType.LOG,\n        ScaleType.POW,\n        ScaleType.SQRT,\n        ScaleType.QUANTILE,\n        ScaleType.QUANTIZE,\n        ScaleType.THRESHOLD,\n        ScaleType.LINEAR,\n        ScaleType.SEQUENTIAL,\n        undefined\n      ],\n      specifiedType\n    );\n  }\n\n  return true;\n}\n\nexport function channelSupportScaleType(channel: Channel, scaleType: ScaleType): boolean {\n  switch (channel) {\n    case Channel.X:\n    case Channel.Y:\n      return isContinuousToContinuous(scaleType) || contains(['band', 'point'], scaleType);\n    case Channel.SIZE: // TODO: size and opacity can support ordinal with more modification\n    case Channel.OPACITY:\n      // Although it generally doesn't make sense to use band with size and opacity,\n      // it can also work since we use band: 0.5 to get midpoint.\n      return (\n        isContinuousToContinuous(scaleType) ||\n        isContinuousToDiscrete(scaleType) ||\n        contains(['band', 'point'], scaleType)\n      );\n    case Channel.COLOR:\n    case Channel.FILL:\n    case Channel.STROKE:\n      return scaleType !== 'band'; // band does not make sense with color\n    case Channel.SHAPE:\n      return scaleType === 'ordinal'; // shape = lookup only\n  }\n  /* istanbul ignore next: it should never reach here */\n  return false;\n}\n\nexport function getSupportedScaleType(channel: Channel, fieldDefType: Type, bin?: boolean) {\n  return SCALE_TYPE_INDEX[generateScaleTypeIndexKey(channel, fieldDefType, bin)];\n}\n\nexport interface ScaleTypeIndex {\n  [channel: string]: ScaleType[];\n}\n\n// generates ScaleTypeIndex where keys are encoding channels and values are list of valid ScaleTypes\nfunction generateScaleTypeIndex() {\n  const index: ScaleTypeIndex = {};\n  for (const channel of CHANNELS) {\n    for (const fieldDefType of keys(TYPE_INDEX)) {\n      for (const scaleType of SCALE_TYPES) {\n        for (const bin of [false, true]) {\n          const key = generateScaleTypeIndexKey(channel, fieldDefType, bin);\n          if (channelSupportScaleType(channel, scaleType) && scaleTypeSupportDataType(scaleType, fieldDefType, bin)) {\n            index[key] = index[key] || [];\n            index[key].push(scaleType);\n          }\n        }\n      }\n    }\n  }\n  return index;\n}\n\nfunction generateScaleTypeIndexKey(channel: Channel, fieldDefType: Type, bin: boolean) {\n  const key = channel + '_' + fieldDefType;\n  return bin ? key + '_bin' : key;\n}\n","import {SingleDefChannel} from './channel';\nimport {VgBinding, VgEventStream} from './vega.schema';\n\nexport const SELECTION_ID = '_vgsid_';\nexport type SelectionType = 'single' | 'multi' | 'interval';\nexport type SelectionResolution = 'global' | 'union' | 'intersect';\n\nexport interface BaseSelectionDef {\n  /**\n   * A [Vega event stream](https://vega.github.io/vega/docs/event-streams/) (object or selector) that triggers the selection.\n   * For interval selections, the event stream must specify a [start and end](https://vega.github.io/vega/docs/event-streams/#between-filters).\n   */\n  on?: VgEventStream;\n  /**\n   * With layered and multi-view displays, a strategy that determines how\n   * selections' data queries are resolved when applied in a filter transform,\n   * conditional encoding rule, or scale domain.\n   *\n   */\n  resolve?: SelectionResolution;\n\n  // TODO(https://github.com/vega/vega-lite/issues/2596).\n  // predicate?: string;\n  // domain?: SelectionDomain;\n\n  // Transforms\n\n  /**\n   * An array of encoding channels. The corresponding data field values\n   * must match for a data tuple to fall within the selection.\n   */\n  encodings?: SingleDefChannel[];\n\n  /**\n   * An array of field names whose values must match for a data tuple to\n   * fall within the selection.\n   */\n  fields?: string[];\n\n  /**\n   * By default, all data values are considered to lie within an empty selection.\n   * When set to `none`, empty selections contain no data values.\n   */\n  empty?: 'all' | 'none';\n}\n\nexport interface SingleSelectionConfig extends BaseSelectionDef {\n  /**\n   * Establish a two-way binding between a single selection and input elements\n   * (also known as dynamic query widgets). A binding takes the form of\n   * Vega's [input element binding definition](https://vega.github.io/vega/docs/signals/#bind)\n   * or can be a mapping between projected field/encodings and binding definitions.\n   *\n   * See the [bind transform](https://vega.github.io/vega-lite/docs/bind.html) documentation for more information.\n   */\n  bind?: VgBinding | {[key: string]: VgBinding};\n\n  /**\n   * When true, an invisible voronoi diagram is computed to accelerate discrete\n   * selection. The data value _nearest_ the mouse cursor is added to the selection.\n   *\n   * See the [nearest transform](https://vega.github.io/vega-lite/docs/nearest.html) documentation for more information.\n   */\n  nearest?: boolean;\n}\n\nexport interface MultiSelectionConfig extends BaseSelectionDef {\n  /**\n   * Controls whether data values should be toggled or only ever inserted into\n   * multi selections. Can be `true`, `false` (for insertion only), or a\n   * [Vega expression](https://vega.github.io/vega/docs/expressions/).\n   *\n   * __Default value:__ `true`, which corresponds to `event.shiftKey` (i.e.,\n   * data values are toggled when a user interacts with the shift-key pressed).\n   *\n   * See the [toggle transform](https://vega.github.io/vega-lite/docs/toggle.html) documentation for more information.\n   */\n  toggle?: string | boolean;\n\n  /**\n   * When true, an invisible voronoi diagram is computed to accelerate discrete\n   * selection. The data value _nearest_ the mouse cursor is added to the selection.\n   *\n   * See the [nearest transform](https://vega.github.io/vega-lite/docs/nearest.html) documentation for more information.\n   */\n  nearest?: boolean;\n}\n\nexport interface BrushConfig {\n  /**\n   * The fill color of the interval mark.\n   *\n   * __Default value:__ `#333333`\n   *\n   */\n  fill?: string;\n  /**\n   * The fill opacity of the interval mark (a value between 0 and 1).\n   *\n   * __Default value:__ `0.125`\n   */\n  fillOpacity?: number;\n  /**\n   * The stroke color of the interval mark.\n   *\n   * __Default value:__ `#ffffff`\n   */\n  stroke?: string;\n  /**\n   * The stroke opacity of the interval mark (a value between 0 and 1).\n   */\n  strokeOpacity?: number;\n  /**\n   * The stroke width of the interval mark.\n   */\n  strokeWidth?: number;\n  /**\n   * An array of alternating stroke and space lengths,\n   * for creating dashed or dotted lines.\n   */\n  strokeDash?: number[];\n  /**\n   * The offset (in pixels) with which to begin drawing the stroke dash array.\n   */\n  strokeDashOffset?: number;\n}\n\nexport interface IntervalSelectionConfig extends BaseSelectionDef {\n  /**\n   * When truthy, allows a user to interactively move an interval selection\n   * back-and-forth. Can be `true`, `false` (to disable panning), or a\n   * [Vega event stream definition](https://vega.github.io/vega/docs/event-streams/)\n   * which must include a start and end event to trigger continuous panning.\n   *\n   * __Default value:__ `true`, which corresponds to\n   * `[mousedown, window:mouseup] > window:mousemove!` which corresponds to\n   * clicks and dragging within an interval selection to reposition it.\n   */\n  translate?: string | boolean;\n\n  /**\n   * When truthy, allows a user to interactively resize an interval selection.\n   * Can be `true`, `false` (to disable zooming), or a [Vega event stream\n   * definition](https://vega.github.io/vega/docs/event-streams/). Currently,\n   * only `wheel` events are supported.\n   *\n   *\n   * __Default value:__ `true`, which corresponds to `wheel!`.\n   */\n  zoom?: string | boolean;\n\n  /**\n   * Establishes a two-way binding between the interval selection and the scales\n   * used within the same view. This allows a user to interactively pan and\n   * zoom the view.\n   */\n  bind?: 'scales';\n\n  /**\n   * An interval selection also adds a rectangle mark to depict the\n   * extents of the interval. The `mark` property can be used to customize the\n   * appearance of the mark.\n   */\n  mark?: BrushConfig;\n}\n\nexport interface SingleSelection extends SingleSelectionConfig {\n  type: 'single';\n}\n\nexport interface MultiSelection extends MultiSelectionConfig {\n  type: 'multi';\n}\n\nexport interface IntervalSelection extends IntervalSelectionConfig {\n  type: 'interval';\n}\n\nexport type SelectionDef = SingleSelection | MultiSelection | IntervalSelection;\n\nexport interface SelectionConfig {\n  /**\n   * The default definition for a [`single`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All properties and transformations\n   *  for a single selection definition (except `type`) may be specified here.\n   *\n   * For instance, setting `single` to `{\"on\": \"dblclick\"}` populates single selections on double-click by default.\n   */\n  single?: SingleSelectionConfig;\n  /**\n   * The default definition for a [`multi`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All properties and transformations\n   * for a multi selection definition (except `type`) may be specified here.\n   *\n   * For instance, setting `multi` to `{\"toggle\": \"event.altKey\"}` adds additional values to\n   * multi selections when clicking with the alt-key pressed by default.\n   */\n  multi?: MultiSelectionConfig;\n  /**\n   * The default definition for an [`interval`](https://vega.github.io/vega-lite/docs/selection.html#type) selection. All properties and transformations\n   * for an interval selection definition (except `type`) may be specified here.\n   *\n   * For instance, setting `interval` to `{\"translate\": false}` disables the ability to move\n   * interval selections by default.\n   */\n  interval?: IntervalSelectionConfig;\n}\n\nexport const defaultConfig: SelectionConfig = {\n  single: {\n    on: 'click',\n    fields: [SELECTION_ID],\n    resolve: 'global',\n    empty: 'all'\n  },\n  multi: {\n    on: 'click',\n    fields: [SELECTION_ID],\n    toggle: 'event.shiftKey',\n    resolve: 'global',\n    empty: 'all'\n  },\n  interval: {\n    on: '[mousedown, window:mouseup] > window:mousemove!',\n    encodings: ['x', 'y'],\n    translate: '[mousedown, window:mouseup] > window:mousemove!',\n    zoom: 'wheel!',\n    mark: {fill: '#333', fillOpacity: 0.125, stroke: 'white'},\n    resolve: 'global'\n  }\n};\n","import {AggregateOp} from 'vega';\nimport {isArray} from 'vega-util';\nimport {DateTime} from './datetime';\nimport {VgComparatorOrder} from './vega.schema';\n\nexport type SortOrder = VgComparatorOrder | null;\n\n/**\n * A sort definition for transform\n */\nexport interface SortField {\n  /**\n   * The name of the field to sort.\n   */\n  field: string;\n\n  /**\n   * Whether to sort the field in ascending or descending order.\n   */\n  order?: VgComparatorOrder;\n}\n\n/**\n * A sort definition for sorting a discrete scale in an encoding field definition.\n */\n\nexport interface EncodingSortField<F> {\n  /**\n   * The data [field](https://vega.github.io/vega-lite/docs/field.html) to sort by.\n   *\n   * __Default value:__ If unspecified, defaults to the field specified in the outer data reference.\n   */\n  field?: F;\n  /**\n   * An [aggregate operation](https://vega.github.io/vega-lite/docs/aggregate.html#ops) to perform on the field prior to sorting (e.g., `\"count\"`, `\"mean\"` and `\"median\"`).\n   * This property is required in cases where the sort field and the data reference field do not match.\n   * The input data objects will be aggregated, grouped by the encoded data field.\n   *\n   * For a full list of operations, please see the documentation for [aggregate](https://vega.github.io/vega-lite/docs/aggregate.html#ops).\n   */\n  op: AggregateOp;\n\n  /**\n   * The sort order. One of `\"ascending\"` (default), `\"descending\"`, or `null` (no not sort).\n   */\n  order?: SortOrder;\n}\n\nexport type Sort<F> = number[] | string[] | boolean[] | DateTime[] | SortOrder | EncodingSortField<F> | null;\n\nexport function isSortField<F>(sort: Sort<F>): sort is EncodingSortField<F> {\n  return !!sort && (sort['op'] === 'count' || !!sort['field']) && !!sort['op'];\n}\n\nexport function isSortArray<F>(sort: Sort<F>): sort is number[] | string[] | boolean[] | DateTime[] {\n  return !!sort && isArray(sort);\n}\n","import {Config} from './config';\nimport {Data} from './data';\nimport * as vlEncoding from './encoding';\nimport {Encoding, EncodingWithFacet} from './encoding';\nimport {FacetMapping} from './facet';\nimport {Field, FieldDef, RepeatRef} from './fielddef';\nimport {AnyMark, isPrimitiveMark, Mark, MarkDef} from './mark';\nimport {Projection} from './projection';\nimport {Repeat} from './repeat';\nimport {Resolve} from './resolve';\nimport {SelectionDef} from './selection';\nimport {stack} from './stack';\nimport {TitleParams} from './title';\nimport {ConcatLayout, GenericCompositionLayout, TopLevelProperties} from './toplevelprops';\nimport {Transform} from './transform';\nimport {Dict, hash, vals} from './util';\n\nexport type TopLevel<S extends BaseSpec> = S &\n  TopLevelProperties & {\n    /**\n     * URL to [JSON schema](http://json-schema.org/) for a Vega-Lite specification. Unless you have a reason to change this, use `https://vega.github.io/schema/vega-lite/v2.json`. Setting the `$schema` property allows automatic validation and autocomplete in editors that support JSON schema.\n     * @format uri\n     */\n    $schema?: string;\n\n    /**\n     * Vega-Lite configuration object.  This property can only be defined at the top-level of a specification.\n     */\n    config?: Config;\n  };\n\nexport type BaseSpec = Partial<DataMixins> & {\n  /**\n   * Title for the plot.\n   */\n  title?: string | TitleParams;\n\n  /**\n   * Name of the visualization for later reference.\n   */\n  name?: string;\n\n  /**\n   * Description of this mark for commenting purpose.\n   */\n  description?: string;\n\n  /**\n   * An object describing the data source\n   */\n  data?: Data;\n\n  /**\n   * An array of data transformations such as filter and new field calculation.\n   */\n  transform?: Transform[];\n};\n\nexport interface DataMixins {\n  /**\n   * An object describing the data source\n   */\n  data: Data;\n}\n\n// TODO(https://github.com/vega/vega-lite/issues/2503): Make this generic so we can support some form of top-down sizing.\nexport interface LayoutSizeMixins {\n  /**\n   * The width of a visualization.\n   *\n   * __Default value:__ This will be determined by the following rules:\n   *\n   * - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type is `\"fit\"` or its x-channel has a [continuous scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the width will be the value of [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - For x-axis with a band or point scale: if [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value or unspecified, the width is [determined by the range step, paddings, and the cardinality of the field mapped to x-channel](https://vega.github.io/vega-lite/docs/scale.html#band).   Otherwise, if the `rangeStep` is `null`, the width will be the value of [`config.view.width`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - If no field is mapped to `x` channel, the `width` will be the value of [`config.scale.textXRangeStep`](https://vega.github.io/vega-lite/docs/size.html#default-width-and-height) for `text` mark and the value of `rangeStep` for other marks.\n   *\n   * __Note:__ For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the width of a single view.\n   *\n   * __See also:__ The documentation for [width and height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.\n   */\n  width?: number;\n\n  /**\n   * The height of a visualization.\n   *\n   * __Default value:__\n   * - If a view's [`autosize`](https://vega.github.io/vega-lite/docs/size.html#autosize) type is `\"fit\"` or its y-channel has a [continuous scale](https://vega.github.io/vega-lite/docs/scale.html#continuous), the height will be the value of [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - For y-axis with a band or point scale: if [`rangeStep`](https://vega.github.io/vega-lite/docs/scale.html#band) is a numeric value or unspecified, the height is [determined by the range step, paddings, and the cardinality of the field mapped to y-channel](https://vega.github.io/vega-lite/docs/scale.html#band). Otherwise, if the `rangeStep` is `null`, the height will be the value of [`config.view.height`](https://vega.github.io/vega-lite/docs/spec.html#config).\n   * - If no field is mapped to `y` channel, the `height` will be the value of `rangeStep`.\n   *\n   * __Note__: For plots with [`row` and `column` channels](https://vega.github.io/vega-lite/docs/encoding.html#facet), this represents the height of a single view.\n   *\n   * __See also:__ The documentation for [width and height](https://vega.github.io/vega-lite/docs/size.html) contains more examples.\n   */\n  height?: number;\n}\n\nexport interface GenericUnitSpec<E extends Encoding<any>, M> extends BaseSpec, LayoutSizeMixins {\n  /**\n   * A string describing the mark type (one of `\"bar\"`, `\"circle\"`, `\"square\"`, `\"tick\"`, `\"line\"`,\n   * `\"area\"`, `\"point\"`, `\"rule\"`, `\"geoshape\"`, and `\"text\"`) or a [mark definition object](https://vega.github.io/vega-lite/docs/mark.html#mark-def).\n   */\n  mark: M;\n\n  /**\n   * A key-value mapping between encoding channels and definition of fields.\n   */\n  encoding?: E;\n\n  /**\n   * An object defining properties of geographic projection, which will be applied to `shape` path for `\"geoshape\"` marks\n   * and to `latitude` and `\"longitude\"` channels for other marks.\n   */\n  projection?: Projection;\n\n  /**\n   * A key-value mapping between selection names and definitions.\n   */\n  selection?: {[name: string]: SelectionDef};\n}\n\nexport type NormalizedUnitSpec = GenericUnitSpec<Encoding<string | RepeatRef>, Mark | MarkDef>;\n\n/**\n * Unit spec that can have a composite mark.\n */\nexport type CompositeUnitSpec = GenericUnitSpec<Encoding<string | RepeatRef>, AnyMark>;\n\n/**\n * Unit spec that can have a composite mark and row or column channels.\n */\nexport type FacetedCompositeUnitSpec = GenericUnitSpec<EncodingWithFacet<string | RepeatRef>, AnyMark>;\n\nexport interface GenericLayerSpec<U extends GenericUnitSpec<any, any>> extends BaseSpec, LayoutSizeMixins {\n  /**\n   * Layer or single view specifications to be layered.\n   *\n   * __Note__: Specifications inside `layer` cannot use `row` and `column` channels as layering facet specifications is not allowed.\n   */\n  layer: (GenericLayerSpec<U> | U)[];\n\n  /**\n   * Scale, axis, and legend resolutions for layers.\n   */\n  resolve?: Resolve;\n}\n\n/**\n * Layer Spec with encoding and projection\n */\nexport interface ExtendedLayerSpec extends GenericLayerSpec<CompositeUnitSpec> {\n  /**\n   * A shared key-value mapping between encoding channels and definition of fields in the underlying layers.\n   */\n  encoding?: Encoding<string | RepeatRef>;\n\n  /**\n   * An object defining properties of the geographic projection shared by underlying layers.\n   */\n  projection?: Projection;\n}\n\nexport type NormalizedLayerSpec = GenericLayerSpec<NormalizedUnitSpec>;\n\nexport interface GenericFacetSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>>\n  extends BaseSpec,\n    GenericCompositionLayout {\n  /**\n   * An object that describes mappings between `row` and `column` channels and their field definitions.\n   */\n  facet: FacetMapping<string | RepeatRef>;\n\n  /**\n   * A specification of the view that gets faceted.\n   */\n  spec: L | U;\n  // TODO: replace this with GenericSpec<U> once we support all cases;\n\n  /**\n   * Scale, axis, and legend resolutions for facets.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedFacetSpec = GenericFacetSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport interface GenericRepeatSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>>\n  extends BaseSpec,\n    GenericCompositionLayout {\n  /**\n   * An object that describes what fields should be repeated into views that are laid out as a `row` or `column`.\n   */\n  repeat: Repeat;\n\n  spec: GenericSpec<U, L>;\n\n  /**\n   * Scale and legend resolutions for repeated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedRepeatSpec = GenericRepeatSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport interface GenericVConcatSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>>\n  extends BaseSpec,\n    ConcatLayout {\n  /**\n   * A list of views that should be concatenated and put into a column.\n   */\n  vconcat: (GenericSpec<U, L>)[];\n\n  /**\n   * Scale, axis, and legend resolutions for vertically concatenated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport interface GenericHConcatSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>>\n  extends BaseSpec,\n    ConcatLayout {\n  /**\n   * A list of views that should be concatenated and put into a row.\n   */\n  hconcat: (GenericSpec<U, L>)[];\n\n  /**\n   * Scale, axis, and legend resolutions for horizontally concatenated charts.\n   */\n  resolve?: Resolve;\n}\n\nexport type NormalizedConcatSpec =\n  | GenericVConcatSpec<NormalizedUnitSpec, NormalizedLayerSpec>\n  | GenericHConcatSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport type GenericSpec<U extends GenericUnitSpec<any, any>, L extends GenericLayerSpec<any>> =\n  | U\n  | L\n  | GenericFacetSpec<U, L>\n  | GenericRepeatSpec<U, L>\n  | GenericVConcatSpec<U, L>\n  | GenericHConcatSpec<U, L>;\n\nexport type NormalizedSpec = GenericSpec<NormalizedUnitSpec, NormalizedLayerSpec>;\n\nexport type TopLevelFacetedUnitSpec = TopLevel<FacetedCompositeUnitSpec> & DataMixins;\nexport type TopLevelFacetSpec = TopLevel<GenericFacetSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>> & DataMixins;\n\nexport type TopLevelSpec =\n  | TopLevelFacetedUnitSpec\n  | TopLevelFacetSpec\n  | TopLevel<ExtendedLayerSpec>\n  | TopLevel<GenericRepeatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>\n  | TopLevel<GenericVConcatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>\n  | TopLevel<GenericHConcatSpec<FacetedCompositeUnitSpec, ExtendedLayerSpec>>;\n\n/* Custom type guards */\n\nexport function isFacetSpec(spec: BaseSpec): spec is GenericFacetSpec<any, any> {\n  return spec['facet'] !== undefined;\n}\n\nexport function isUnitSpec(spec: BaseSpec): spec is FacetedCompositeUnitSpec | NormalizedUnitSpec {\n  return !!spec['mark'];\n}\n\nexport function isLayerSpec(spec: BaseSpec): spec is GenericLayerSpec<any> {\n  return spec['layer'] !== undefined;\n}\n\nexport function isRepeatSpec(spec: BaseSpec): spec is GenericRepeatSpec<any, any> {\n  return spec['repeat'] !== undefined;\n}\n\nexport function isConcatSpec(spec: BaseSpec): spec is GenericVConcatSpec<any, any> | GenericHConcatSpec<any, any> {\n  return isVConcatSpec(spec) || isHConcatSpec(spec);\n}\n\nexport function isVConcatSpec(spec: BaseSpec): spec is GenericVConcatSpec<any, any> {\n  return spec['vconcat'] !== undefined;\n}\n\nexport function isHConcatSpec(spec: BaseSpec): spec is GenericHConcatSpec<any, any> {\n  return spec['hconcat'] !== undefined;\n}\n\nexport {normalizeTopLevelSpec as normalize} from './normalize';\n\n// TODO: add vl.spec.validate & move stuff from vl.validate to here\n\n/* Accumulate non-duplicate fieldDefs in a dictionary */\nfunction accumulate(dict: any, defs: FieldDef<Field>[]): any {\n  defs.forEach(fieldDef => {\n    // Consider only pure fieldDef properties (ignoring scale, axis, legend)\n    const pureFieldDef = ['field', 'type', 'value', 'timeUnit', 'bin', 'aggregate'].reduce((f, key) => {\n      if (fieldDef[key] !== undefined) {\n        f[key] = fieldDef[key];\n      }\n      return f;\n    }, {});\n    const key = hash(pureFieldDef);\n    dict[key] = dict[key] || fieldDef;\n  });\n  return dict;\n}\n\n/* Recursively get fieldDefs from a spec, returns a dictionary of fieldDefs */\nfunction fieldDefIndex<T>(spec: GenericSpec<any, any>, dict: Dict<FieldDef<T>> = {}): Dict<FieldDef<T>> {\n  // FIXME(https://github.com/vega/vega-lite/issues/2207): Support fieldDefIndex for repeat\n  if (isLayerSpec(spec)) {\n    spec.layer.forEach(layer => {\n      if (isUnitSpec(layer)) {\n        accumulate(dict, vlEncoding.fieldDefs(layer.encoding));\n      } else {\n        fieldDefIndex(layer, dict);\n      }\n    });\n  } else if (isFacetSpec(spec)) {\n    accumulate(dict, vlEncoding.fieldDefs(spec.facet));\n    fieldDefIndex(spec.spec, dict);\n  } else if (isRepeatSpec(spec)) {\n    fieldDefIndex(spec.spec, dict);\n  } else if (isConcatSpec(spec)) {\n    const childSpec = isVConcatSpec(spec) ? spec.vconcat : spec.hconcat;\n    childSpec.forEach(child => fieldDefIndex(child, dict));\n  } else {\n    // Unit Spec\n    accumulate(dict, vlEncoding.fieldDefs(spec.encoding));\n  }\n  return dict;\n}\n\n/* Returns all non-duplicate fieldDefs in a spec in a flat array */\nexport function fieldDefs(spec: GenericSpec<any, any>): FieldDef<any>[] {\n  return vals(fieldDefIndex(spec));\n}\n\nexport function isStacked(spec: TopLevel<FacetedCompositeUnitSpec>, config?: Config): boolean {\n  config = config || spec.config;\n  if (isPrimitiveMark(spec.mark)) {\n    return stack(spec.mark, spec.encoding, config ? config.stack : undefined) !== null;\n  }\n  return false;\n}\n","import {isArray} from 'vega-util';\nimport {SUM_OPS} from './aggregate';\nimport {NONPOSITION_CHANNELS, NonPositionChannel, X, X2, Y2} from './channel';\nimport {channelHasField, Encoding} from './encoding';\nimport {Field, FieldDef, getFieldDef, isFieldDef, isStringFieldDef, PositionFieldDef, vgField} from './fielddef';\nimport * as log from './log';\nimport {AREA, BAR, CIRCLE, isMarkDef, isPathMark, LINE, Mark, MarkDef, POINT, RULE, SQUARE, TEXT, TICK} from './mark';\nimport {ScaleType} from './scale';\nimport {contains, Flag, getFirstDefined} from './util';\n\nexport type StackOffset = 'zero' | 'center' | 'normalize';\n\nconst STACK_OFFSET_INDEX: Flag<StackOffset> = {\n  zero: 1,\n  center: 1,\n  normalize: 1\n};\n\nexport function isStackOffset(s: string): s is StackOffset {\n  return !!STACK_OFFSET_INDEX[s];\n}\n\nexport interface StackProperties {\n  /** Dimension axis of the stack. */\n  groupbyChannel: 'x' | 'y';\n\n  /** Measure axis of the stack. */\n  fieldChannel: 'x' | 'y';\n\n  /** Stack-by fields e.g., color, detail */\n  stackBy: {\n    fieldDef: FieldDef<string>;\n    channel: NonPositionChannel;\n  }[];\n\n  /**\n   * See `\"stack\"` property of Position Field Def.\n   */\n  offset: StackOffset;\n\n  /**\n   * Whether this stack will produce impute transform\n   */\n  impute: boolean;\n}\n\nexport const STACKABLE_MARKS = [BAR, AREA, RULE, POINT, CIRCLE, SQUARE, LINE, TEXT, TICK];\nexport const STACK_BY_DEFAULT_MARKS = [BAR, AREA];\n\nfunction potentialStackedChannel(encoding: Encoding<Field>): 'x' | 'y' | undefined {\n  const xDef = encoding.x;\n  const yDef = encoding.y;\n\n  if (isFieldDef(xDef) && isFieldDef(yDef)) {\n    if (xDef.type === 'quantitative' && yDef.type === 'quantitative') {\n      if (xDef.stack) {\n        return 'x';\n      } else if (yDef.stack) {\n        return 'y';\n      }\n      // if there is no explicit stacking, only apply stack if there is only one aggregate for x or y\n      if (!!xDef.aggregate !== !!yDef.aggregate) {\n        return xDef.aggregate ? 'x' : 'y';\n      }\n    } else if (xDef.type === 'quantitative') {\n      return 'x';\n    } else if (yDef.type === 'quantitative') {\n      return 'y';\n    }\n  } else if (isFieldDef(xDef) && xDef.type === 'quantitative') {\n    return 'x';\n  } else if (isFieldDef(yDef) && yDef.type === 'quantitative') {\n    return 'y';\n  }\n  return undefined;\n}\n\n// Note: CompassQL uses this method and only pass in required properties of each argument object.\n// If required properties change, make sure to update CompassQL.\nexport function stack(m: Mark | MarkDef, encoding: Encoding<Field>, stackConfig: StackOffset): StackProperties {\n  const mark = isMarkDef(m) ? m.type : m;\n  // Should have stackable mark\n  if (!contains(STACKABLE_MARKS, mark)) {\n    return null;\n  }\n\n  const fieldChannel = potentialStackedChannel(encoding);\n  if (!fieldChannel) {\n    return null;\n  }\n\n  const stackedFieldDef = encoding[fieldChannel] as PositionFieldDef<string>;\n  const stackedField = isStringFieldDef(stackedFieldDef) ? vgField(stackedFieldDef, {}) : undefined;\n\n  const dimensionChannel = fieldChannel === 'x' ? 'y' : 'x';\n  const dimensionDef = encoding[dimensionChannel];\n  const dimensionField = isStringFieldDef(dimensionDef) ? vgField(dimensionDef, {}) : undefined;\n\n  // Should have grouping level of detail that is different from the dimension field\n  const stackBy = NONPOSITION_CHANNELS.reduce((sc, channel) => {\n    if (channelHasField(encoding, channel)) {\n      const channelDef = encoding[channel];\n      (isArray(channelDef) ? channelDef : [channelDef]).forEach(cDef => {\n        const fieldDef = getFieldDef(cDef);\n        if (fieldDef.aggregate) {\n          return;\n        }\n\n        // Check whether the channel's field is identical to x/y's field or if the channel is a repeat\n        const f = isStringFieldDef(fieldDef) ? vgField(fieldDef, {}) : undefined;\n        if (\n          // if fielddef is a repeat, just include it in the stack by\n          !f ||\n          // otherwise, the field must be different from x and y fields.\n          (f !== dimensionField && f !== stackedField)\n        ) {\n          sc.push({channel, fieldDef});\n        }\n      });\n    }\n    return sc;\n  }, []);\n\n  if (stackBy.length === 0) {\n    return null;\n  }\n\n  // Automatically determine offset\n  let offset: StackOffset;\n  if (stackedFieldDef.stack !== undefined) {\n    offset = stackedFieldDef.stack;\n  } else if (contains(STACK_BY_DEFAULT_MARKS, mark)) {\n    // Bar and Area with sum ops are automatically stacked by default\n    offset = getFirstDefined(stackConfig, 'zero');\n  } else {\n    offset = stackConfig;\n  }\n\n  if (!offset || !isStackOffset(offset)) {\n    return null;\n  }\n\n  // warn when stacking non-linear\n  if (stackedFieldDef.scale && stackedFieldDef.scale.type && stackedFieldDef.scale.type !== ScaleType.LINEAR) {\n    log.warn(log.message.cannotStackNonLinearScale(stackedFieldDef.scale.type));\n  }\n\n  // Check if it is a ranged mark\n  if (channelHasField(encoding, fieldChannel === X ? X2 : Y2)) {\n    if (stackedFieldDef.stack !== undefined) {\n      log.warn(log.message.cannotStackRangedMark(fieldChannel));\n    }\n    return null;\n  }\n\n  // Warn if stacking summative aggregate\n  if (stackedFieldDef.aggregate && !contains(SUM_OPS, stackedFieldDef.aggregate)) {\n    log.warn(log.message.stackNonSummativeAggregate(stackedFieldDef.aggregate));\n  }\n\n  return {\n    groupbyChannel: dimensionDef ? dimensionChannel : undefined,\n    fieldChannel,\n    impute: isPathMark(mark),\n    stackBy,\n    offset\n  };\n}\n","import {DateTimeExpr, dateTimeExpr} from './datetime';\nimport * as log from './log';\nimport {accessPathWithDatum, Flag, flagKeys} from './util';\n\nexport namespace TimeUnit {\n  export const YEAR: 'year' = 'year';\n  export const MONTH: 'month' = 'month';\n  export const DAY: 'day' = 'day';\n  export const DATE: 'date' = 'date';\n  export const HOURS: 'hours' = 'hours';\n  export const MINUTES: 'minutes' = 'minutes';\n  export const SECONDS: 'seconds' = 'seconds';\n  export const MILLISECONDS: 'milliseconds' = 'milliseconds';\n  export const YEARMONTH: 'yearmonth' = 'yearmonth';\n  export const YEARMONTHDATE: 'yearmonthdate' = 'yearmonthdate';\n  export const YEARMONTHDATEHOURS: 'yearmonthdatehours' = 'yearmonthdatehours';\n  export const YEARMONTHDATEHOURSMINUTES: 'yearmonthdatehoursminutes' = 'yearmonthdatehoursminutes';\n  export const YEARMONTHDATEHOURSMINUTESSECONDS: 'yearmonthdatehoursminutesseconds' =\n    'yearmonthdatehoursminutesseconds';\n\n  // MONTHDATE always include 29 February since we use year 0th (which is a leap year);\n  export const MONTHDATE: 'monthdate' = 'monthdate';\n  export const HOURSMINUTES: 'hoursminutes' = 'hoursminutes';\n  export const HOURSMINUTESSECONDS: 'hoursminutesseconds' = 'hoursminutesseconds';\n  export const MINUTESSECONDS: 'minutesseconds' = 'minutesseconds';\n  export const SECONDSMILLISECONDS: 'secondsmilliseconds' = 'secondsmilliseconds';\n  export const QUARTER: 'quarter' = 'quarter';\n  export const YEARQUARTER: 'yearquarter' = 'yearquarter';\n  export const QUARTERMONTH: 'quartermonth' = 'quartermonth';\n  export const YEARQUARTERMONTH: 'yearquartermonth' = 'yearquartermonth';\n  export const UTCYEAR: 'utcyear' = 'utcyear';\n  export const UTCMONTH: 'utcmonth' = 'utcmonth';\n  export const UTCDAY: 'utcday' = 'utcday';\n  export const UTCDATE: 'utcdate' = 'utcdate';\n  export const UTCHOURS: 'utchours' = 'utchours';\n  export const UTCMINUTES: 'utcminutes' = 'utcminutes';\n  export const UTCSECONDS: 'utcseconds' = 'utcseconds';\n  export const UTCMILLISECONDS: 'utcmilliseconds' = 'utcmilliseconds';\n  export const UTCYEARMONTH: 'utcyearmonth' = 'utcyearmonth';\n  export const UTCYEARMONTHDATE: 'utcyearmonthdate' = 'utcyearmonthdate';\n  export const UTCYEARMONTHDATEHOURS: 'utcyearmonthdatehours' = 'utcyearmonthdatehours';\n  export const UTCYEARMONTHDATEHOURSMINUTES: 'utcyearmonthdatehoursminutes' = 'utcyearmonthdatehoursminutes';\n  export const UTCYEARMONTHDATEHOURSMINUTESSECONDS: 'utcyearmonthdatehoursminutesseconds' =\n    'utcyearmonthdatehoursminutesseconds';\n\n  // MONTHDATE always include 29 February since we use year 0th (which is a leap year);\n  export const UTCMONTHDATE: 'utcmonthdate' = 'utcmonthdate';\n  export const UTCHOURSMINUTES: 'utchoursminutes' = 'utchoursminutes';\n  export const UTCHOURSMINUTESSECONDS: 'utchoursminutesseconds' = 'utchoursminutesseconds';\n  export const UTCMINUTESSECONDS: 'utcminutesseconds' = 'utcminutesseconds';\n  export const UTCSECONDSMILLISECONDS: 'utcsecondsmilliseconds' = 'utcsecondsmilliseconds';\n  export const UTCQUARTER: 'utcquarter' = 'utcquarter';\n  export const UTCYEARQUARTER: 'utcyearquarter' = 'utcyearquarter';\n  export const UTCQUARTERMONTH: 'utcquartermonth' = 'utcquartermonth';\n  export const UTCYEARQUARTERMONTH: 'utcyearquartermonth' = 'utcyearquartermonth';\n}\n\nexport type LocalSingleTimeUnit =\n  | typeof TimeUnit.YEAR\n  | typeof TimeUnit.QUARTER\n  | typeof TimeUnit.MONTH\n  | typeof TimeUnit.DAY\n  | typeof TimeUnit.DATE\n  | typeof TimeUnit.HOURS\n  | typeof TimeUnit.MINUTES\n  | typeof TimeUnit.SECONDS\n  | typeof TimeUnit.MILLISECONDS;\n\n/** Time Unit that only corresponds to only one part of Date objects. */\nconst LOCAL_SINGLE_TIMEUNIT_INDEX: Flag<LocalSingleTimeUnit> = {\n  year: 1,\n  quarter: 1,\n  month: 1,\n  day: 1,\n  date: 1,\n  hours: 1,\n  minutes: 1,\n  seconds: 1,\n  milliseconds: 1\n};\n\nexport const TIMEUNIT_PARTS = flagKeys(LOCAL_SINGLE_TIMEUNIT_INDEX);\n\nexport function isLocalSingleTimeUnit(timeUnit: string): timeUnit is LocalSingleTimeUnit {\n  return !!LOCAL_SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\n\nexport type UtcSingleTimeUnit =\n  | typeof TimeUnit.UTCYEAR\n  | typeof TimeUnit.UTCQUARTER\n  | typeof TimeUnit.UTCMONTH\n  | typeof TimeUnit.UTCDAY\n  | typeof TimeUnit.UTCDATE\n  | typeof TimeUnit.UTCHOURS\n  | typeof TimeUnit.UTCMINUTES\n  | typeof TimeUnit.UTCSECONDS\n  | typeof TimeUnit.UTCMILLISECONDS;\n\nconst UTC_SINGLE_TIMEUNIT_INDEX: Flag<UtcSingleTimeUnit> = {\n  utcyear: 1,\n  utcquarter: 1,\n  utcmonth: 1,\n  utcday: 1,\n  utcdate: 1,\n  utchours: 1,\n  utcminutes: 1,\n  utcseconds: 1,\n  utcmilliseconds: 1\n};\n\nexport function isUtcSingleTimeUnit(timeUnit: string): timeUnit is UtcSingleTimeUnit {\n  return !!UTC_SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\n\nexport type SingleTimeUnit = LocalSingleTimeUnit | UtcSingleTimeUnit;\n\nexport type LocalMultiTimeUnit =\n  // Local Time\n  | typeof TimeUnit.YEARQUARTER\n  | typeof TimeUnit.YEARQUARTERMONTH\n  | typeof TimeUnit.YEARMONTH\n  | typeof TimeUnit.YEARMONTHDATE\n  | typeof TimeUnit.YEARMONTHDATEHOURS\n  | typeof TimeUnit.YEARMONTHDATEHOURSMINUTES\n  | typeof TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS\n  | typeof TimeUnit.QUARTERMONTH\n  | typeof TimeUnit.MONTHDATE\n  | typeof TimeUnit.HOURSMINUTES\n  | typeof TimeUnit.HOURSMINUTESSECONDS\n  | typeof TimeUnit.MINUTESSECONDS\n  | typeof TimeUnit.SECONDSMILLISECONDS;\n\nconst LOCAL_MULTI_TIMEUNIT_INDEX: Flag<LocalMultiTimeUnit> = {\n  yearquarter: 1,\n  yearquartermonth: 1,\n\n  yearmonth: 1,\n  yearmonthdate: 1,\n  yearmonthdatehours: 1,\n  yearmonthdatehoursminutes: 1,\n  yearmonthdatehoursminutesseconds: 1,\n\n  quartermonth: 1,\n\n  monthdate: 1,\n\n  hoursminutes: 1,\n  hoursminutesseconds: 1,\n\n  minutesseconds: 1,\n\n  secondsmilliseconds: 1\n};\n\nexport type UtcMultiTimeUnit =\n  | typeof TimeUnit.UTCYEARQUARTER\n  | typeof TimeUnit.UTCYEARQUARTERMONTH\n  | typeof TimeUnit.UTCYEARMONTH\n  | typeof TimeUnit.UTCYEARMONTHDATE\n  | typeof TimeUnit.UTCYEARMONTHDATEHOURS\n  | typeof TimeUnit.UTCYEARMONTHDATEHOURSMINUTES\n  | typeof TimeUnit.UTCYEARMONTHDATEHOURSMINUTESSECONDS\n  | typeof TimeUnit.UTCQUARTERMONTH\n  | typeof TimeUnit.UTCMONTHDATE\n  | typeof TimeUnit.UTCHOURSMINUTES\n  | typeof TimeUnit.UTCHOURSMINUTESSECONDS\n  | typeof TimeUnit.UTCMINUTESSECONDS\n  | typeof TimeUnit.UTCSECONDSMILLISECONDS;\n\nconst UTC_MULTI_TIMEUNIT_INDEX: Flag<UtcMultiTimeUnit> = {\n  utcyearquarter: 1,\n  utcyearquartermonth: 1,\n\n  utcyearmonth: 1,\n  utcyearmonthdate: 1,\n  utcyearmonthdatehours: 1,\n  utcyearmonthdatehoursminutes: 1,\n  utcyearmonthdatehoursminutesseconds: 1,\n\n  utcquartermonth: 1,\n\n  utcmonthdate: 1,\n\n  utchoursminutes: 1,\n  utchoursminutesseconds: 1,\n\n  utcminutesseconds: 1,\n\n  utcsecondsmilliseconds: 1\n};\n\nexport type MultiTimeUnit = LocalMultiTimeUnit | UtcMultiTimeUnit;\n\nexport type LocalTimeUnit = LocalSingleTimeUnit | LocalMultiTimeUnit;\nexport type UtcTimeUnit = UtcSingleTimeUnit | UtcMultiTimeUnit;\n\nconst UTC_TIMEUNIT_INDEX: Flag<UtcTimeUnit> = {\n  ...UTC_SINGLE_TIMEUNIT_INDEX,\n  ...UTC_MULTI_TIMEUNIT_INDEX\n};\n\nexport function isUTCTimeUnit(t: string): t is UtcTimeUnit {\n  return !!UTC_TIMEUNIT_INDEX[t];\n}\n\nexport function getLocalTimeUnit(t: UtcTimeUnit): LocalTimeUnit {\n  return t.substr(3) as LocalTimeUnit;\n}\n\nexport type TimeUnit = SingleTimeUnit | MultiTimeUnit;\n\nconst TIMEUNIT_INDEX: Flag<TimeUnit> = {\n  ...LOCAL_SINGLE_TIMEUNIT_INDEX,\n  ...UTC_SINGLE_TIMEUNIT_INDEX,\n  ...LOCAL_MULTI_TIMEUNIT_INDEX,\n  ...UTC_MULTI_TIMEUNIT_INDEX\n};\n\nexport const TIMEUNITS = flagKeys(TIMEUNIT_INDEX);\n\nexport function isTimeUnit(t: string): t is TimeUnit {\n  return !!TIMEUNIT_INDEX[t];\n}\n\ntype DateMethodName = keyof Date;\n\nconst SET_DATE_METHOD: Record<LocalSingleTimeUnit, DateMethodName> = {\n  year: 'setFullYear',\n  month: 'setMonth',\n  date: 'setDate',\n  hours: 'setHours',\n  minutes: 'setMinutes',\n  seconds: 'setSeconds',\n  milliseconds: 'setMilliseconds',\n  // Day and quarter have their own special cases\n  quarter: null,\n  day: null\n};\n\n/**\n * Converts a date to only have the measurements relevant to the specified unit\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\n * Note: the base date is Jan 01 1900 00:00:00\n */\nexport function convert(unit: TimeUnit, date: Date): Date {\n  const isUTC = isUTCTimeUnit(unit);\n  const result: Date = isUTC\n    ? // start with uniform date\n      new Date(Date.UTC(0, 0, 1, 0, 0, 0, 0))\n    : new Date(0, 0, 1, 0, 0, 0, 0);\n  for (const timeUnitPart of TIMEUNIT_PARTS) {\n    if (containsTimeUnit(unit, timeUnitPart)) {\n      switch (timeUnitPart) {\n        case TimeUnit.DAY:\n          throw new Error(\"Cannot convert to TimeUnits containing 'day'\");\n        case TimeUnit.QUARTER: {\n          const {getDateMethod, setDateMethod} = dateMethods('month', isUTC);\n          // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\n          result[setDateMethod](Math.floor(date[getDateMethod]() / 3) * 3);\n          break;\n        }\n        default:\n          const {getDateMethod, setDateMethod} = dateMethods(timeUnitPart, isUTC);\n          result[setDateMethod](date[getDateMethod]());\n      }\n    }\n  }\n  return result;\n}\n\nfunction dateMethods(singleUnit: SingleTimeUnit, isUtc: boolean) {\n  const rawSetDateMethod = SET_DATE_METHOD[singleUnit];\n  const setDateMethod = isUtc ? 'setUTC' + rawSetDateMethod.substr(3) : rawSetDateMethod;\n  const getDateMethod = 'get' + (isUtc ? 'UTC' : '') + rawSetDateMethod.substr(3);\n  return {setDateMethod, getDateMethod};\n}\n\nexport function getTimeUnitParts(timeUnit: TimeUnit) {\n  return TIMEUNIT_PARTS.reduce((parts, part) => {\n    if (containsTimeUnit(timeUnit, part)) {\n      return parts.concat(part);\n    }\n    return parts;\n  }, []);\n}\n\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\nexport function containsTimeUnit(fullTimeUnit: TimeUnit, timeUnit: TimeUnit) {\n  const index = fullTimeUnit.indexOf(timeUnit);\n  return (\n    index > -1 && (timeUnit !== TimeUnit.SECONDS || index === 0 || fullTimeUnit.charAt(index - 1) !== 'i') // exclude milliseconds\n  );\n}\n\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nexport function fieldExpr(fullTimeUnit: TimeUnit, field: string): string {\n  const fieldRef = accessPathWithDatum(field);\n\n  const utc = isUTCTimeUnit(fullTimeUnit) ? 'utc' : '';\n  function func(timeUnit: TimeUnit) {\n    if (timeUnit === TimeUnit.QUARTER) {\n      // quarter starting at 0 (0,3,6,9).\n      return `(${utc}quarter(${fieldRef})-1)`;\n    } else {\n      return `${utc}${timeUnit}(${fieldRef})`;\n    }\n  }\n\n  const d = TIMEUNIT_PARTS.reduce(\n    (dateExpr: DateTimeExpr, tu: TimeUnit) => {\n      if (containsTimeUnit(fullTimeUnit, tu)) {\n        dateExpr[tu] = func(tu);\n      }\n      return dateExpr;\n    },\n    {} as {[key in SingleTimeUnit]: string}\n  );\n\n  return dateTimeExpr(d);\n}\n\n/**\n * returns the signal expression used for axis labels for a time unit\n */\nexport function formatExpression(\n  timeUnit: TimeUnit,\n  field: string,\n  shortTimeLabels: boolean,\n  isUTCScale: boolean\n): string {\n  if (!timeUnit) {\n    return undefined;\n  }\n\n  const dateComponents: string[] = [];\n  let expression = '';\n  const hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);\n\n  if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n    // special expression for quarter as prefix\n    expression = `'Q' + quarter(${field})`;\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n    // By default use short month name\n    dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');\n  }\n\n  if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n    dateComponents.push(shortTimeLabels ? '%a' : '%A');\n  } else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n    dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year\n  }\n\n  if (hasYear) {\n    dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n  }\n\n  const timeComponents: string[] = [];\n\n  if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n    timeComponents.push('%H');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n    timeComponents.push('%M');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n    timeComponents.push('%S');\n  }\n  if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n    timeComponents.push('%L');\n  }\n\n  const dateTimeComponents: string[] = [];\n  if (dateComponents.length > 0) {\n    dateTimeComponents.push(dateComponents.join(' '));\n  }\n  if (timeComponents.length > 0) {\n    dateTimeComponents.push(timeComponents.join(':'));\n  }\n\n  if (dateTimeComponents.length > 0) {\n    if (expression) {\n      // Add space between quarter and main time format\n      expression += ` + ' ' + `;\n    }\n\n    // We only use utcFormat for utc scale\n    // For utc time units, the data is already converted as a part of timeUnit transform.\n    // Thus, utc time units should use timeFormat to avoid shifting the time twice.\n    if (isUTCScale) {\n      expression += `utcFormat(${field}, '${dateTimeComponents.join(' ')}')`;\n    } else {\n      expression += `timeFormat(${field}, '${dateTimeComponents.join(' ')}')`;\n    }\n  }\n\n  // If expression is still an empty string, return undefined instead.\n  return expression || undefined;\n}\n\nexport function normalizeTimeUnit(timeUnit: TimeUnit): TimeUnit {\n  if (timeUnit !== 'day' && timeUnit.indexOf('day') >= 0) {\n    log.warn(log.message.dayReplacedWithDate(timeUnit));\n    return timeUnit.replace('day', 'date') as TimeUnit;\n  }\n  return timeUnit;\n}\n","import {Align, BaseTitle, FontWeight, TextBaseline, TextEncodeEntry, TitleAnchor, TitleFrame} from 'vega';\nimport {Color, VgMarkConfig} from './vega.schema';\n\ntype BaseTitleNoSignals = BaseTitle<number, string, Color, FontWeight, Align, TextBaseline, TitleFrame, TitleAnchor>;\n\nexport type TitleConfig = BaseTitleNoSignals;\n\nexport interface TitleBase extends BaseTitleNoSignals {\n  /**\n   * The anchor position for placing the title. One of `\"start\"`, `\"middle\"`, or `\"end\"`. For example, with an orientation of top these anchor positions map to a left-, center-, or right-aligned title.\n   *\n   * __Default value:__ `\"middle\"` for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views.\n   * `\"start\"` for other composite views.\n   *\n   * __Note:__ [For now](https://github.com/vega/vega-lite/issues/2875), `anchor` is only customizable only for [single](https://vega.github.io/vega-lite/docs/spec.html) and [layered](https://vega.github.io/vega-lite/docs/layer.html) views.  For other composite views, `anchor` is always `\"start\"`.\n   */\n  anchor?: TitleAnchor;\n\n  /**\n   * A [mark style property](https://vega.github.io/vega-lite/docs/config.html#style) to apply to the title text mark.\n   *\n   * __Default value:__ `\"group-title\"`.\n   */\n  style?: string | string[];\n\n  /**\n   * \tThe integer z-index indicating the layering of the title group relative to other axis, mark and legend groups.\n   *\n   * __Default value:__ `0`.\n   *\n   * @TJS-type integer\n   * @minimum 0\n   */\n  zindex?: number;\n\n  /**\n   * Mark definitions for custom axis encoding.\n   *\n   * @hide\n   */\n  encoding?: TextEncodeEntry;\n}\n\nexport interface TitleParams extends TitleBase {\n  /**\n   * The title text.\n   */\n  text: string;\n}\n\nexport function extractTitleConfig(\n  titleConfig: TitleConfig\n): {\n  mark: VgMarkConfig;\n  nonMark: BaseTitleNoSignals;\n} {\n  const {\n    // These are non-mark title config that need to be hardcoded\n    anchor,\n    frame,\n    offset,\n    orient,\n    // color needs to be redirect to fill\n    color,\n    // The rest are mark config.\n    ...titleMarkConfig\n  } = titleConfig;\n\n  const mark: VgMarkConfig = {\n    ...titleMarkConfig,\n    ...(color ? {fill: color} : {})\n  };\n\n  const nonMark: BaseTitleNoSignals = {\n    ...(anchor ? {anchor} : {}),\n    ...(offset ? {offset} : {}),\n    ...(orient ? {orient} : {})\n  };\n\n  return {mark, nonMark};\n}\n","import {isString} from 'vega-util';\n\nimport {InlineDataset} from './data';\nimport * as log from './log';\nimport {Dict} from './util';\nimport {RowCol, VgLayoutAlign} from './vega.schema';\n\n/**\n * @minimum 0\n */\nexport type Padding = number | {top?: number; bottom?: number; left?: number; right?: number};\n\nexport type Datasets = Dict<InlineDataset>;\n\nexport interface TopLevelProperties {\n  /**\n   * CSS color property to use as the background of visualization.\n   *\n   * __Default value:__ none (transparent)\n   */\n  background?: string;\n\n  /**\n   * The default visualization padding, in pixels, from the edge of the visualization canvas to the data rectangle.  If a number, specifies padding for all sides.\n   * If an object, the value should have the format `{\"left\": 5, \"top\": 5, \"right\": 5, \"bottom\": 5}` to specify padding for each side of the visualization.\n   *\n   * __Default value__: `5`\n   */\n  padding?: Padding;\n\n  /**\n   * Sets how the visualization size should be determined. If a string, should be one of `\"pad\"`, `\"fit\"` or `\"none\"`.\n   * Object values can additionally specify parameters for content sizing and automatic resizing.\n   * `\"fit\"` is only supported for single and layered views that don't use `rangeStep`.\n   *\n   * __Default value__: `pad`\n   */\n  autosize?: AutosizeType | AutoSizeParams;\n\n  /**\n   * A global data store for named datasets. This is a mapping from names to inline datasets.\n   * This can be an array of objects or primitive values or a string. Arrays of primitive values are ingested as objects with a `data` property.\n   */\n  datasets?: Datasets;\n}\n\nexport interface BoundsMixins {\n  /**\n   * The bounds calculation method to use for determining the extent of a sub-plot. One of `full` (the default) or `flush`.\n   *\n   * - If set to `full`, the entire calculated bounds (including axes, title, and legend) will be used.\n   * - If set to `flush`, only the specified width and height values for the sub-view will be used. The `flush` setting can be useful when attempting to place sub-plots without axes or legends into a uniform grid structure.\n   *\n   * __Default value:__ `\"full\"`\n   */\n\n  bounds?: 'full' | 'flush';\n}\n\n/**\n * Base layout mixins for V/HConcatSpec.\n * Concat layout should not have RowCol<T> generic fo its property.\n */\nexport interface ConcatLayout extends BoundsMixins {\n  /**\n   * Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n   *\n   * __Default value:__ `false`\n   */\n  center?: boolean;\n\n  /**\n   * The spacing in pixels between sub-views of the concat operator.\n   *\n   * __Default value__: `10`\n   */\n  spacing?: number;\n}\n\n/**\n * Base layout for FacetSpec and RepeatSpec.\n * This is named \"GenericComposition\" layout as ConcatLayout is a GenericCompositionLayout too\n * (but _not_ vice versa).\n */\nexport interface GenericCompositionLayout extends BoundsMixins {\n  /**\n   * The alignment to apply to grid rows and columns.\n   * The supported string values are `\"all\"`, `\"each\"`, and `\"none\"`.\n   *\n   * - For `\"none\"`, a flow layout will be used, in which adjacent subviews are simply placed one after the other.\n   * - For `\"each\"`, subviews will be aligned into a clean grid structure, but each row or column may be of variable size.\n   * - For `\"all\"`, subviews will be aligned and each row or column will be sized identically based on the maximum observed size. String values for this property will be applied to both grid rows and columns.\n   *\n   * Alternatively, an object value of the form `{\"row\": string, \"column\": string}` can be used to supply different alignments for rows and columns.\n   *\n   * __Default value:__ `\"all\"`.\n   */\n  align?: VgLayoutAlign | RowCol<VgLayoutAlign>;\n\n  /**\n   * Boolean flag indicating if subviews should be centered relative to their respective rows or columns.\n   *\n   * An object value of the form `{\"row\": boolean, \"column\": boolean}` can be used to supply different centering values for rows and columns.\n   *\n   * __Default value:__ `false`\n   */\n  center?: boolean | RowCol<boolean>;\n\n  /**\n   * The spacing in pixels between sub-views of the composition operator.\n   * An object of the form `{\"row\": number, \"column\": number}` can be used to set\n   * different spacing values for rows and columns.\n   *\n   * __Default value__: `10`\n   */\n  spacing?: number | RowCol<number>;\n}\n\nexport function extractCompositionLayout(layout: GenericCompositionLayout): GenericCompositionLayout {\n  const {align = undefined, center = undefined, bounds = undefined, spacing = undefined} = layout || {};\n  return {align, bounds, center, spacing};\n}\n\nexport type AutosizeType = 'pad' | 'fit' | 'none';\n\nexport interface AutoSizeParams {\n  /**\n   * The sizing format type. One of `\"pad\"`, `\"fit\"` or `\"none\"`. See the [autosize type](https://vega.github.io/vega-lite/docs/size.html#autosize) documentation for descriptions of each.\n   *\n   * __Default value__: `\"pad\"`\n   */\n  type?: AutosizeType;\n\n  /**\n   * A boolean flag indicating if autosize layout should be re-calculated on every view update.\n   *\n   * __Default value__: `false`\n   */\n  resize?: boolean;\n\n  /**\n   * Determines how size calculation should be performed, one of `\"content\"` or `\"padding\"`. The default setting (`\"content\"`) interprets the width and height settings as the data rectangle (plotting) dimensions, to which padding is then added. In contrast, the `\"padding\"` setting includes the padding within the view size calculations, such that the width and height settings indicate the **total** intended size of the view.\n   *\n   * __Default value__: `\"content\"`\n   */\n  contains?: 'content' | 'padding';\n}\n\nfunction _normalizeAutoSize(autosize: AutosizeType | AutoSizeParams) {\n  return isString(autosize) ? {type: autosize} : autosize || {};\n}\n\nexport function normalizeAutoSize(\n  topLevelAutosize: AutosizeType | AutoSizeParams,\n  configAutosize: AutosizeType | AutoSizeParams,\n  isUnitOrLayer: boolean = true\n): AutoSizeParams {\n  const autosize: AutoSizeParams = {\n    type: 'pad',\n    ..._normalizeAutoSize(configAutosize),\n    ..._normalizeAutoSize(topLevelAutosize)\n  };\n\n  if (autosize.type === 'fit') {\n    if (!isUnitOrLayer) {\n      log.warn(log.message.FIT_NON_SINGLE);\n      autosize.type = 'pad';\n    }\n  }\n\n  return autosize;\n}\n\nconst TOP_LEVEL_PROPERTIES: (keyof TopLevelProperties)[] = [\n  'background',\n  'padding',\n  'datasets'\n  // We do not include \"autosize\" here as it is supported by only unit and layer specs and thus need to be normalized\n];\n\nexport function extractTopLevelProperties<T extends TopLevelProperties>(t: T) {\n  return TOP_LEVEL_PROPERTIES.reduce((o, p) => {\n    if (t && t[p] !== undefined) {\n      o[p] = t[p];\n    }\n    return o;\n  }, {});\n}\n","import {AggregateOp} from 'vega';\nimport {BinParams} from './bin';\nimport {Data} from './data';\nimport {ImputeParams} from './impute';\nimport {LogicalOperand, normalizeLogicalOperand} from './logical';\nimport {normalizePredicate, Predicate} from './predicate';\nimport {SortField} from './sort';\nimport {TimeUnit} from './timeunit';\n\nexport interface FilterTransform {\n  /**\n   * The `filter` property must be one of the predicate definitions:\n   *\n   * 1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string,\n   * where `datum` can be used to refer to the current data object\n   *\n   * 2) one of the field predicates: [`equal`](https://vega.github.io/vega-lite/docs/filter.html#equal-predicate),\n   * [`lt`](https://vega.github.io/vega-lite/docs/filter.html#lt-predicate),\n   * [`lte`](https://vega.github.io/vega-lite/docs/filter.html#lte-predicate),\n   * [`gt`](https://vega.github.io/vega-lite/docs/filter.html#gt-predicate),\n   * [`gte`](https://vega.github.io/vega-lite/docs/filter.html#gte-predicate),\n   * [`range`](https://vega.github.io/vega-lite/docs/filter.html#range-predicate),\n   * or [`oneOf`](https://vega.github.io/vega-lite/docs/filter.html#one-of-predicate).\n   *\n   * 3) a [selection predicate](https://vega.github.io/vega-lite/docs/filter.html#selection-predicate)\n   *\n   * 4) a logical operand that combines (1), (2), or (3).\n   */\n  // TODO: https://github.com/vega/vega-lite/issues/2901\n  filter: LogicalOperand<Predicate>;\n}\n\nexport function isFilter(t: Transform): t is FilterTransform {\n  return t['filter'] !== undefined;\n}\n\nexport interface CalculateTransform {\n  /**\n   * A [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string. Use the variable `datum` to refer to the current data object.\n   */\n  calculate: string;\n\n  /**\n   * The field for storing the computed formula value.\n   */\n  as: string;\n}\n\nexport interface BinTransform {\n  /**\n   * An object indicating bin properties, or simply `true` for using default bin parameters.\n   */\n  bin: boolean | BinParams;\n\n  /**\n   * The data field to bin.\n   */\n  field: string;\n\n  /**\n   * The output fields at which to write the start and end bin values.\n   */\n  as: string | string[];\n}\n\nexport interface TimeUnitTransform {\n  /**\n   * The timeUnit.\n   */\n  timeUnit: TimeUnit;\n\n  /**\n   * The data field to apply time unit.\n   */\n  field: string;\n\n  /**\n   * The output field to write the timeUnit value.\n   */\n  as: string;\n}\n\nexport interface AggregateTransform {\n  /**\n   * Array of objects that define fields to aggregate.\n   */\n  aggregate: AggregatedFieldDef[];\n\n  /**\n   * The data fields to group by. If not specified, a single group containing all data objects will be used.\n   */\n  groupby?: string[];\n}\n\nexport interface AggregatedFieldDef {\n  /**\n   * The aggregation operations to apply to the fields, such as sum, average or count.\n   * See the [full list of supported aggregation operations](https://vega.github.io/vega-lite/docs/aggregate.html#ops)\n   * for more information.\n   */\n  op: AggregateOp;\n\n  /**\n   * The data field for which to compute aggregate function. This is required for all aggregation operations except `\"count\"`.\n   */\n  field?: string;\n\n  /**\n   * The output field names to use for each aggregated field.\n   */\n  as: string;\n}\n\nexport interface StackTransform {\n  /**\n   * The field which is stacked.\n   */\n  stack: string;\n  /**\n   * The data fields to group by.\n   */\n  groupby: string[];\n  /**\n   * Mode for stacking marks.\n   * __Default value:__ `\"zero\"`\n   */\n  offset?: 'zero' | 'center' | 'normalize';\n  /**\n   * Field that determines the order of leaves in the stacked charts.\n   */\n  sort?: SortField[];\n  /**\n   * Output field names. This can be either a string or an array of strings with\n   * two elements denoting the name for the fields for stack start and stack end\n   * respectively.\n   * If a single string(eg.\"val\") is provided, the end field will be \"val_end\".\n   */\n  as: string | string[];\n}\n\nexport type WindowOnlyOp =\n  | 'row_number'\n  | 'rank'\n  | 'dense_rank'\n  | 'percent_rank'\n  | 'cume_dist'\n  | 'ntile'\n  | 'lag'\n  | 'lead'\n  | 'first_value'\n  | 'last_value'\n  | 'nth_value';\n\nexport interface WindowFieldDef {\n  /**\n   * The window or aggregation operations to apply within a window, including `rank`, `lead`, `sum`, `average` or `count`. See the list of all supported operations [here](https://vega.github.io/vega-lite/docs/window.html#ops).\n   */\n  op: AggregateOp | WindowOnlyOp;\n\n  /**\n   * Parameter values for the window functions. Parameter values can be omitted for operations that do not accept a parameter.\n   *\n   * See the list of all supported operations and their parameters [here](https://vega.github.io/vega-lite/docs/transforms/window.html).\n   */\n  param?: number;\n\n  /**\n   * The data field for which to compute the aggregate or window function. This can be omitted for window functions that do not operate over a field such as `count`, `rank`, `dense_rank`.\n   */\n  field?: string;\n\n  /**\n   * The output name for the window operation.\n   */\n  as: string;\n}\n\nexport interface WindowTransform {\n  /**\n   * The definition of the fields in the window, and what calculations to use.\n   */\n  window: WindowFieldDef[];\n\n  /**\n   * A frame specification as a two-element array indicating how the sliding window should proceed. The array entries should either be a number indicating the offset from the current data object, or null to indicate unbounded rows preceding or following the current data object. The default value is `[null, 0]`, indicating that the sliding window includes the current object and all preceding objects. The value `[-5, 5]` indicates that the window should include five objects preceding and five objects following the current object. Finally, `[null, null]` indicates that the window frame should always include all data objects. The only operators affected are the aggregation operations and the `first_value`, `last_value`, and `nth_value` window operations. The other window operations are not affected by this.\n   *\n   * __Default value:__:  `[null, 0]` (includes the current object and all preceding objects)\n   */\n  frame?: (null | number)[];\n\n  /**\n   * Indicates if the sliding window frame should ignore peer values. (Peer values are those considered identical by the sort criteria). The default is false, causing the window frame to expand to include all peer values. If set to true, the window frame will be defined by offset values only. This setting only affects those operations that depend on the window frame, namely aggregation operations and the first_value, last_value, and nth_value window operations.\n   *\n   * __Default value:__ `false`\n   */\n  ignorePeers?: boolean;\n\n  /**\n   * The data fields for partitioning the data objects into separate windows. If unspecified, all data points will be in a single group.\n   */\n  groupby?: string[];\n\n  /**\n   * A sort field definition for sorting data objects within a window. If two data objects are considered equal by the comparator, they are considered peer values of equal rank. If sort is not specified, the order is undefined: data objects are processed in the order they are observed and none are considered peers (the ignorePeers parameter is ignored and treated as if set to `true`).\n   */\n  sort?: SortField[];\n}\n\nexport interface ImputeSequence {\n  /**\n   * The starting value of the sequence.\n   * __Default value:__ `0`\n   */\n  start?: number;\n  /**\n   * The ending value(exclusive) of the sequence.\n   */\n  stop: number;\n  /**\n   * The step value between sequence entries.\n   * __Default value:__ `1` or `-1` if `stop < start`\n   */\n  step?: number;\n}\n\nexport function isImputeSequence(t: ImputeSequence | any[] | undefined): t is ImputeSequence {\n  return t && t['start'] !== undefined && t['stop'] !== undefined;\n}\n\nexport interface ImputeTransform extends ImputeParams {\n  /**\n   * The data field for which the missing values should be imputed.\n   */\n  impute: string;\n\n  /**\n   * A key field that uniquely identifies data objects within a group.\n   * Missing key values (those occurring in the data but not in the current group) will be imputed.\n   */\n  key: string;\n\n  /**\n   * An optional array of fields by which to group the values.\n   * Imputation will then be performed on a per-group basis.\n   */\n  groupby?: string[];\n}\n\nexport interface FlattenTransform {\n  /**\n   * An array of one or more data fields containing arrays to flatten.\n   * If multiple fields are specified, their array values should have a parallel structure, ideally with the same length.\n   * If the lengths of parallel arrays do not match,\n   * the longest array will be used with `null` values added for missing entries.\n   */\n  flatten: string[];\n\n  /**\n   * The output field names for extracted array values.\n   *\n   * __Default value:__ The field name of the corresponding array field\n   */\n  as?: string[];\n}\n\nexport interface SampleTransform {\n  /**\n   * The maximum number of data objects to include in the sample.\n   *\n   * __Default value:__ `1000`\n   */\n  sample: number;\n}\n\nexport interface LookupData {\n  /**\n   * Secondary data source to lookup in.\n   */\n  data: Data;\n  /**\n   * Key in data to lookup.\n   */\n  key: string;\n  /**\n   * Fields in foreign data to lookup.\n   * If not specified, the entire object is queried.\n   */\n  fields?: string[];\n}\n\nexport interface LookupTransform {\n  /**\n   * Key in primary data source.\n   */\n  lookup: string;\n\n  /**\n   * Secondary data reference.\n   */\n  from: LookupData;\n\n  /**\n   * The field or fields for storing the computed formula value.\n   * If `from.fields` is specified, the transform will use the same names for `as`.\n   * If `from.fields` is not specified, `as` has to be a string and we put the whole object into the data under the specified name.\n   */\n  as?: string | string[];\n\n  /**\n   * The default value to use if lookup fails.\n   *\n   * __Default value:__ `null`\n   */\n  default?: string;\n}\n\nexport interface FoldTransform {\n  /**\n   * An array of data fields indicating the properties to fold.\n   */\n  fold: string[];\n\n  /**\n   * The output field names for the key and value properties produced by the fold transform.\n   * __Default value:__ `[\"key\", \"value\"]`\n   */\n  as?: [string, string];\n}\n\nexport function isLookup(t: Transform): t is LookupTransform {\n  return t['lookup'] !== undefined;\n}\n\nexport function isSample(t: Transform): t is SampleTransform {\n  return t['sample'] !== undefined;\n}\n\nexport function isWindow(t: Transform): t is WindowTransform {\n  return t['window'] !== undefined;\n}\n\nexport function isFlatten(t: Transform): t is FlattenTransform {\n  return t['flatten'] !== undefined;\n}\nexport function isCalculate(t: Transform): t is CalculateTransform {\n  return t['calculate'] !== undefined;\n}\n\nexport function isBin(t: Transform): t is BinTransform {\n  return !!t['bin'];\n}\n\nexport function isImpute(t: Transform): t is ImputeTransform {\n  return t['impute'] !== undefined;\n}\n\nexport function isTimeUnit(t: Transform): t is TimeUnitTransform {\n  return t['timeUnit'] !== undefined;\n}\n\nexport function isAggregate(t: Transform): t is AggregateTransform {\n  return t['aggregate'] !== undefined;\n}\n\nexport function isStack(t: Transform): t is StackTransform {\n  return t['stack'] !== undefined;\n}\n\nexport function isFold(t: Transform): t is FoldTransform {\n  return t['fold'] !== undefined;\n}\n\nexport type Transform =\n  | FilterTransform\n  | CalculateTransform\n  | LookupTransform\n  | BinTransform\n  | TimeUnitTransform\n  | ImputeTransform\n  | AggregateTransform\n  | WindowTransform\n  | StackTransform\n  | FlattenTransform\n  | FoldTransform\n  | SampleTransform;\n\nexport function normalizeTransform(transform: Transform[]) {\n  return transform.map(t => {\n    if (isFilter(t)) {\n      return {\n        filter: normalizeLogicalOperand(t.filter, normalizePredicate)\n      };\n    }\n    return t;\n  });\n}\n","import {Flag} from './util';\n/** Constants and utilities for data type */\n/** Data type based on level of measurement */\n\nexport namespace Type {\n  export const QUANTITATIVE: 'quantitative' = 'quantitative';\n  export const ORDINAL: 'ordinal' = 'ordinal';\n  export const TEMPORAL: 'temporal' = 'temporal';\n  export const NOMINAL: 'nominal' = 'nominal';\n\n  export const GEOJSON: 'geojson' = 'geojson';\n}\n\nexport type Type =\n  | typeof Type.QUANTITATIVE\n  | typeof Type.ORDINAL\n  | typeof Type.TEMPORAL\n  | typeof Type.NOMINAL\n  | typeof Type.GEOJSON;\n\nexport const TYPE_INDEX: Flag<Type> = {\n  quantitative: 1,\n  ordinal: 1,\n  temporal: 1,\n  nominal: 1,\n  geojson: 1\n};\n\nexport function isType(t: any): t is Type {\n  return !!TYPE_INDEX[t];\n}\n\nexport const QUANTITATIVE = Type.QUANTITATIVE;\nexport const ORDINAL = Type.ORDINAL;\nexport const TEMPORAL = Type.TEMPORAL;\nexport const NOMINAL = Type.NOMINAL;\n\nexport const GEOJSON = Type.GEOJSON;\n\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nexport function getFullName(type: Type | string): Type {\n  if (type) {\n    type = type.toLowerCase();\n    switch (type) {\n      case 'q':\n      case QUANTITATIVE:\n        return 'quantitative';\n      case 't':\n      case TEMPORAL:\n        return 'temporal';\n      case 'o':\n      case ORDINAL:\n        return 'ordinal';\n      case 'n':\n      case NOMINAL:\n        return 'nominal';\n      case GEOJSON:\n        return 'geojson';\n    }\n  }\n  // If we get invalid input, return undefined type.\n  return undefined;\n}\n","import stableStringify from 'json-stable-stringify';\nimport {isArray, isNumber, isString, splitAccessPath, stringValue} from 'vega-util';\nimport {isLogicalAnd, isLogicalNot, isLogicalOr, LogicalOperand} from './logical';\n\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = {'a': 1, 'b': '2', 'c': 3};\n * pick(object, ['a', 'c']);\n * //  {'a': 1, 'c': 3}\n *\n */\nexport function pick<T extends object, K extends keyof T>(obj: T, props: K[]): Pick<T, K> {\n  const copy: any = {};\n  for (const prop of props) {\n    if (obj.hasOwnProperty(prop)) {\n      copy[prop] = obj[prop];\n    }\n  }\n  return copy;\n}\n\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nexport function omit<T extends object, K extends keyof T>(obj: T, props: K[]): Omit<T, K> {\n  const copy = {...(obj as any)};\n  for (const prop of props) {\n    delete copy[prop];\n  }\n  return copy;\n}\n\n/**\n * Converts any object into a string representation that can be consumed by humans.\n */\nexport const stringify = stableStringify;\n\n/**\n * Converts any object into a string of limited size, or a number.\n */\nexport function hash(a: any): string | number {\n  if (isNumber(a)) {\n    return a;\n  }\n\n  const str = isString(a) ? a : stableStringify(a);\n\n  // short strings can be used as hash directly, longer strings are hashed to reduce memory usage\n  if (str.length < 100) {\n    return str;\n  }\n\n  // from http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/\n  let h = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    h = (h << 5) - h + char;\n    h = h & h; // Convert to 32bit integer\n  }\n  return h;\n}\n\nexport function contains<T>(array: T[], item: T) {\n  return array.indexOf(item) > -1;\n}\n\n/** Returns the array without the elements in item */\nexport function without<T>(array: T[], excludedItems: T[]) {\n  return array.filter(item => !contains(excludedItems, item));\n}\n\nexport function union<T>(array: T[], other: T[]) {\n  return array.concat(without(other, array));\n}\n\n/**\n * Returns true if any item returns true.\n */\nexport function some<T>(arr: T[], f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k < arr.length; k++) {\n    if (f(arr[k], k, i++)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Returns true if all items return true.\n */\nexport function every<T>(arr: T[], f: (d: T, k?: any, i?: any) => boolean) {\n  let i = 0;\n  for (let k = 0; k < arr.length; k++) {\n    if (!f(arr[k], k, i++)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function flatten(arrays: any[]) {\n  return [].concat.apply([], arrays);\n}\n\n/**\n * recursively merges src into dest\n */\nexport function mergeDeep<T>(dest: T, ...src: Partial<T>[]): T {\n  for (const s of src) {\n    dest = deepMerge_(dest, s);\n  }\n  return dest;\n}\n\n// recursively merges src into dest\nfunction deepMerge_(dest: any, src: any) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (const p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || isArray(src[p]) || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = mergeDeep(isArray(src[p].constructor) ? [] : {}, src[p]);\n    } else {\n      mergeDeep(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n\nexport function unique<T>(values: T[], f: (item: T) => string | number): T[] {\n  const results: any[] = [];\n  const u = {};\n  let v: string | number;\n  for (const val of values) {\n    v = f(val);\n    if (v in u) {\n      continue;\n    }\n    u[v] = 1;\n    results.push(val);\n  }\n  return results;\n}\n\nexport interface Dict<T> {\n  [key: string]: T;\n}\n\nexport type StringSet = Dict<true>;\n\n/**\n * Returns true if the two dictionaries disagree. Applies only to defined values.\n */\nexport function differ<T>(dict: Dict<T>, other: Dict<T>) {\n  for (const key in dict) {\n    if (dict.hasOwnProperty(key)) {\n      if (other[key] && dict[key] && other[key] !== dict[key]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function hasIntersection(a: StringSet, b: StringSet) {\n  for (const key in a) {\n    if (key in b) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isNumeric(num: string | number) {\n  return !isNaN(num as any);\n}\n\nexport function differArray<T>(array: T[], other: T[]) {\n  if (array.length !== other.length) {\n    return true;\n  }\n\n  array.sort();\n  other.sort();\n\n  for (let i = 0; i < array.length; i++) {\n    if (other[i] !== array[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// This is a stricter version of Object.keys but with better types. See https://github.com/Microsoft/TypeScript/pull/12253#issuecomment-263132208\nexport const keys = Object.keys as <T>(o: T) => (Extract<keyof T, string>)[];\n\nexport function vals<T>(x: {[key: string]: T}): T[] {\n  const _vals: T[] = [];\n  for (const k in x) {\n    if (x.hasOwnProperty(k)) {\n      _vals.push(x[k]);\n    }\n  }\n  return _vals;\n}\n\n// Using mapped type to declare a collect of flags for a string literal type S\n// https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types\nexport type Flag<S extends string> = {[K in S]: 1};\n\nexport function flagKeys<S extends string>(f: Flag<S>): S[] {\n  return keys(f) as S[];\n}\n\nexport function duplicate<T>(obj: T): T {\n  return JSON.parse(JSON.stringify(obj));\n}\n\nexport function isBoolean(b: any): b is boolean {\n  return b === true || b === false;\n}\n\n/**\n * Convert a string into a valid variable name\n */\nexport function varName(s: string): string {\n  // Replace non-alphanumeric characters (anything besides a-zA-Z0-9_) with _\n  const alphanumericS = s.replace(/\\W/g, '_');\n\n  // Add _ if the string has leading numbers.\n  return (s.match(/^\\d+/) ? '_' : '') + alphanumericS;\n}\n\nexport function logicalExpr<T>(op: LogicalOperand<T>, cb: (...args: any[]) => string): string {\n  if (isLogicalNot(op)) {\n    return '!(' + logicalExpr(op.not, cb) + ')';\n  } else if (isLogicalAnd(op)) {\n    return '(' + op.and.map((and: LogicalOperand<T>) => logicalExpr(and, cb)).join(') && (') + ')';\n  } else if (isLogicalOr(op)) {\n    return '(' + op.or.map((or: LogicalOperand<T>) => logicalExpr(or, cb)).join(') || (') + ')';\n  } else {\n    return cb(op);\n  }\n}\n\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Delete nested property of an object, and delete the ancestors of the property if they become empty.\n */\nexport function deleteNestedProperty(obj: any, orderedProps: string[]) {\n  if (orderedProps.length === 0) {\n    return true;\n  }\n  const prop = orderedProps.shift();\n  if (deleteNestedProperty(obj[prop], orderedProps)) {\n    delete obj[prop];\n  }\n  return Object.keys(obj).length === 0;\n}\n\nexport function titlecase(s: string) {\n  return s.charAt(0).toUpperCase() + s.substr(1);\n}\n\n/**\n * Converts a path to an access path with datum.\n * @param path The field name.\n * @param datum The string to use for `datum`.\n */\nexport function accessPathWithDatum(path: string, datum = 'datum') {\n  const pieces = splitAccessPath(path);\n  const prefixes = [];\n  for (let i = 1; i <= pieces.length; i++) {\n    const prefix = `[${pieces\n      .slice(0, i)\n      .map(stringValue)\n      .join('][')}]`;\n    prefixes.push(`${datum}${prefix}`);\n  }\n  return prefixes.join(' && ');\n}\n\n/**\n * Return access with datum to the flattened field.\n *\n * @param path The field name.\n * @param datum The string to use for `datum`.\n */\nexport function flatAccessWithDatum(path: string, datum: 'datum' | 'parent' = 'datum') {\n  return `${datum}[${stringValue(splitAccessPath(path).join('.'))}]`;\n}\n\n/**\n * Replaces path accesses with access to non-nested field.\n * For example, `foo[\"bar\"].baz` becomes `foo\\\\.bar\\\\.baz`.\n */\nexport function replacePathInField(path: string) {\n  return `${splitAccessPath(path)\n    .map(p => p.replace('.', '\\\\.'))\n    .join('\\\\.')}`;\n}\n\n/**\n * Remove path accesses with access from field.\n * For example, `foo[\"bar\"].baz` becomes `foo.bar.baz`.\n */\nexport function removePathFromField(path: string) {\n  return `${splitAccessPath(path).join('.')}`;\n}\n\n/**\n * Count the depth of the path. Returns 1 for fields that are not nested.\n */\nexport function accessPathDepth(path: string) {\n  if (!path) {\n    return 0;\n  }\n  return splitAccessPath(path).length;\n}\n\n/**\n * This is a replacement for chained || for numeric properties or properties that respect null so that 0 will be included.\n */\nexport function getFirstDefined<T>(...args: T[]): T {\n  for (const arg of args) {\n    if (arg !== undefined) {\n      return arg;\n    }\n  }\n  return undefined;\n}\n","import {toSet} from 'vega-util';\nimport {isMarkDef} from './mark';\nimport {BAR} from './mark';\nimport {FacetedCompositeUnitSpec} from './spec';\n\n// TODO: move to vl.spec.validator?\nexport interface RequiredChannelMap {\n  [mark: string]: string[];\n}\n\n/**\n * Required Encoding Channels for each mark type\n */\nexport const DEFAULT_REQUIRED_CHANNEL_MAP: RequiredChannelMap = {\n  text: ['text'],\n  line: ['x', 'y'],\n  trail: ['x', 'y'],\n  area: ['x', 'y']\n};\n\nexport interface SupportedChannelMap {\n  [mark: string]: {\n    [channel: string]: boolean;\n  };\n}\n\n/**\n * Supported Encoding Channel for each mark type\n */\nexport const DEFAULT_SUPPORTED_CHANNEL_TYPE: SupportedChannelMap = {\n  bar: toSet(['row', 'column', 'x', 'y', 'size', 'color', 'fill', 'stroke', 'detail']),\n  line: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'color', 'detail']),\n  trail: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'color', 'detail', 'size']),\n  area: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'detail']),\n  tick: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'detail']),\n  circle: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail']),\n  square: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail']),\n  point: toSet(['row', 'column', 'x', 'y', 'color', 'fill', 'stroke', 'size', 'detail', 'shape']),\n  geoshape: toSet(['row', 'column', 'color', 'fill', 'stroke', 'detail', 'shape']),\n  text: toSet(['row', 'column', 'size', 'color', 'fill', 'stroke', 'text']) // TODO(#724) revise\n};\n\n// TODO: consider if we should add validate method and\n// requires ZSchema in the main vega-lite repo\n\n/**\n * Further check if encoding mapping of a spec is invalid and\n * return error if it is invalid.\n *\n * This checks if\n * (1) all the required encoding channels for the mark type are specified\n * (2) all the specified encoding channels are supported by the mark type\n * @param  {[type]} spec [description]\n * @param  {RequiredChannelMap = DefaultRequiredChannelMap}  requiredChannelMap\n * @param  {SupportedChannelMap = DefaultSupportedChannelMap} supportedChannelMap\n * @return {String} Return one reason why the encoding is invalid,\n *                  or null if the encoding is valid.\n */\nexport function getEncodingMappingError(\n  spec: FacetedCompositeUnitSpec,\n  requiredChannelMap: RequiredChannelMap = DEFAULT_REQUIRED_CHANNEL_MAP,\n  supportedChannelMap: SupportedChannelMap = DEFAULT_SUPPORTED_CHANNEL_TYPE\n) {\n  const mark = isMarkDef(spec.mark) ? spec.mark.type : spec.mark;\n  const encoding = spec.encoding;\n  const requiredChannels = requiredChannelMap[mark];\n  const supportedChannels = supportedChannelMap[mark];\n\n  for (const i in requiredChannels) {\n    // all required channels are in encoding`\n    if (!(requiredChannels[i] in encoding)) {\n      return 'Missing encoding channel \"' + requiredChannels[i] + '\" for mark \"' + mark + '\"';\n    }\n  }\n\n  for (const channel in encoding) {\n    // all channels in encoding are supported\n    if (!supportedChannels[channel]) {\n      return 'Encoding channel \"' + channel + '\" is not supported by mark type \"' + mark + '\"';\n    }\n  }\n\n  if (mark === BAR && !encoding.x && !encoding.y) {\n    return 'Missing both x and y for bar';\n  }\n\n  return null;\n}\n","import {\n  AggregateOp,\n  Align,\n  Field as VgField,\n  FlattenTransform as VgFlattenTransform,\n  FoldTransform as VgFoldTransform,\n  FontStyle,\n  FontWeight,\n  SampleTransform as VgSampleTransform,\n  SignalRef,\n  SortField,\n  TextBaseline,\n  UnionSortField\n} from 'vega';\nimport {isArray} from 'vega-util';\nimport {BaseBin} from './bin';\nimport {NiceTime, ScaleType} from './scale';\nimport {StackOffset} from './stack';\nimport {WindowOnlyOp} from './transform';\nimport {Flag, flagKeys} from './util';\n\nexport {SignalRef as VgSignalRef, SortField as VgSortField, UnionSortField as VgUnionSortField};\n\nexport type Color = string;\n\nexport interface VgData {\n  name: string;\n  source?: string;\n  values?: any;\n  format?: {\n    type?: string;\n    parse?: string | object;\n    property?: string;\n    feature?: string;\n    mesh?: string;\n  };\n  url?: string;\n  transform?: VgTransform[];\n}\n\nexport interface VgDataRef {\n  data: string;\n  field: VgField;\n  sort?: SortField;\n}\n\nexport function isSignalRef(o: any): o is SignalRef {\n  return !!o['signal'];\n}\n\nexport type VgEventStream = any;\n\n// TODO: add type of value (Make it VgValueRef<T> {value?:T ...})\nexport interface VgValueRef {\n  value?: number | string | boolean;\n  field?:\n    | string\n    | {\n        datum?: string;\n        group?: string;\n        parent?: string;\n      };\n  signal?: string;\n  scale?: string; // TODO: object\n  mult?: number;\n  offset?: number | VgValueRef;\n  band?: boolean | number | VgValueRef;\n}\n\n// TODO: add vg prefix\nexport interface DataRefUnionDomain {\n  fields: (any[] | VgDataRef | SignalRef)[];\n  sort?: UnionSortField;\n}\n\nexport interface VgFieldRefUnionDomain {\n  data: string;\n  fields: VgField[];\n  sort?: UnionSortField;\n}\n\nexport interface VgScheme {\n  scheme: string;\n  extent?: number[];\n  count?: number;\n}\nexport type VgRange = string | VgDataRef | (number | string | VgDataRef | SignalRef)[] | VgScheme | VgRangeStep;\n\nexport interface VgRangeStep {\n  step: number | SignalRef;\n}\nexport function isVgRangeStep(range: VgRange): range is VgRangeStep {\n  return !!range['step'];\n}\n\n// Domains that are not a union of domains\nexport type VgNonUnionDomain = any[] | VgDataRef | SignalRef;\nexport type VgDomain = VgNonUnionDomain | DataRefUnionDomain | VgFieldRefUnionDomain;\n\nexport type VgMarkGroup = any;\n\nexport type VgProjectionType =\n  | 'albers'\n  | 'albersUsa'\n  | 'azimuthalEqualArea'\n  | 'azimuthalEquidistant'\n  | 'conicConformal'\n  | 'conicEqualArea'\n  | 'conicEquidistant'\n  | 'equirectangular'\n  | 'gnomonic'\n  | 'mercator'\n  | 'orthographic'\n  | 'stereographic'\n  | 'transverseMercator';\n\nexport interface VgProjection {\n  /*\n   * The name of the projection.\n   */\n  name: string;\n  /*\n   * The type of the projection.\n   */\n  type?: VgProjectionType;\n  /*\n   * The clip angle of the projection.\n   */\n  clipAngle?: number;\n  /*\n   * Sets the projections viewport clip extent to the specified bounds in pixels\n   */\n  clipExtent?: number[][];\n  /*\n   * Sets the projections scale factor to the specified value\n   */\n  scale?: number;\n  /*\n   * The translation of the projection.\n   */\n  translate?: number[];\n  /*\n   * The center of the projection.\n   */\n  center?: number[];\n  /**\n   * The rotation of the projection.\n   */\n  rotate?: number[];\n  /*\n   * The desired precision of the projection.\n   */\n  precision?: string;\n  /*\n   * GeoJSON data to which the projection should attempt to automatically fit the translate and scale parameters..\n   */\n  fit?: SignalRef | object | any[];\n  /*\n   * Used in conjunction with fit, provides the pixel area to which the projection should be automatically fit.\n   */\n  extent?: SignalRef | number[][];\n  /*\n   * Used in conjunction with fit, provides the width and height in pixels of the area to which the projection should be automatically fit.\n   */\n  size?: SignalRef | (number | SignalRef)[];\n\n  /* The following properties are all supported for specific types of projections. Consult the d3-geo-projection library for more information: https://github.com/d3/d3-geo-projection */\n  coefficient?: number;\n  distance?: number;\n  fraction?: number;\n  lobes?: number;\n  parallel?: number;\n  radius?: number;\n  ratio?: number;\n  spacing?: number;\n  tilt?: number;\n}\n\nexport interface VgScale {\n  name: string;\n  type: ScaleType;\n  domain: VgDomain;\n  domainRaw?: SignalRef;\n  range: VgRange;\n\n  clamp?: boolean;\n  base?: number;\n  exponent?: number;\n  interpolate?: ScaleInterpolate | ScaleInterpolateParams;\n  nice?: boolean | number | NiceTime | {interval: string; step: number};\n  padding?: number;\n  paddingInner?: number;\n  paddingOuter?: number;\n  reverse?: boolean;\n  round?: boolean;\n  zero?: boolean;\n}\n\nexport type ScaleInterpolate = 'rgb' | 'lab' | 'hcl' | 'hsl' | 'hsl-long' | 'hcl-long' | 'cubehelix' | 'cubehelix-long';\n\nexport interface ScaleInterpolateParams {\n  type: 'rgb' | 'cubehelix' | 'cubehelix-long';\n  gamma?: number;\n}\n\nexport type VgLayoutAlign = 'none' | 'each' | 'all';\n\nexport interface RowCol<T> {\n  row?: T;\n  column?: T;\n}\n\nexport interface VgLayout {\n  center?: boolean | RowCol<boolean>;\n  padding?: number | RowCol<number>;\n  headerBand?: number | RowCol<number>;\n  footerBand?: number | RowCol<number>;\n  offset?:\n    | number\n    | {\n        rowHeader?: number;\n        rowFooter?: number;\n        rowTitle?: number;\n        columnHeader?: number;\n        columnFooter?: number;\n        columnTitle?: number;\n      };\n  bounds?: 'full' | 'flush';\n  columns?: number | {signal: string};\n  align?: VgLayoutAlign | RowCol<VgLayoutAlign>;\n}\n\nexport function isDataRefUnionedDomain(domain: VgDomain): domain is DataRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && !('data' in domain);\n  }\n  return false;\n}\n\nexport function isFieldRefUnionDomain(domain: VgDomain): domain is VgFieldRefUnionDomain {\n  if (!isArray(domain)) {\n    return 'fields' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isDataRefDomain(domain: VgDomain): domain is VgDataRef {\n  if (!isArray(domain)) {\n    return 'field' in domain && 'data' in domain;\n  }\n  return false;\n}\n\nexport function isSignalRefDomain(domain: VgDomain): domain is SignalRef {\n  if (!isArray(domain)) {\n    return 'signal' in domain;\n  }\n  return false;\n}\n\nexport interface VgEventHandler {\n  events: string[] | SignalRef;\n  update?: string;\n  encode?: string;\n  force?: boolean;\n  between?: any[];\n}\n\nexport interface VgSignal {\n  name: string;\n  bind?: string;\n  description?: string;\n  on?: VgEventHandler[];\n  update?: string;\n  react?: boolean;\n  value?: string | number | boolean | {} | SignalRef;\n  // only for nested signals\n  push?: string;\n}\n\nexport type VgEncodeChannel =\n  | 'x'\n  | 'x2'\n  | 'xc'\n  | 'width'\n  | 'y'\n  | 'y2'\n  | 'yc'\n  | 'height'\n  | 'opacity'\n  | 'fill'\n  | 'fillOpacity'\n  | 'stroke'\n  | 'strokeWidth'\n  | 'strokeCap'\n  | 'strokeOpacity'\n  | 'strokeDash'\n  | 'strokeDashOffset'\n  | 'strokeMiterLimit'\n  | 'strokeJoin'\n  | 'cursor'\n  | 'clip'\n  | 'size'\n  | 'shape'\n  | 'path'\n  | 'innerRadius'\n  | 'outerRadius'\n  | 'startAngle'\n  | 'endAngle'\n  | 'interpolate'\n  | 'tension'\n  | 'orient'\n  | 'url'\n  | 'align'\n  | 'baseline'\n  | 'text'\n  | 'dir'\n  | 'ellipsis'\n  | 'limit'\n  | 'dx'\n  | 'dy'\n  | 'radius'\n  | 'theta'\n  | 'angle'\n  | 'font'\n  | 'fontSize'\n  | 'fontWeight'\n  | 'fontStyle'\n  | 'tooltip'\n  | 'href'\n  | 'cursor'\n  | 'defined'\n  | 'cornerRadius';\nexport type VgEncodeEntry = {[k in VgEncodeChannel]?: VgValueRef | (VgValueRef & {test?: string})[]};\n\n// TODO: make export interface VgEncodeEntry {\n//   x?: VgValueRef<number>\n//   y?: VgValueRef<number>\n//  ...\n//   color?: VgValueRef<string>\n//  ...\n// }\n\nexport interface VgBinTransform extends BaseBin {\n  type: 'bin';\n  extent?: number[] | {signal: string};\n  field: string;\n  as: string[];\n  signal?: string;\n}\n\nexport interface VgExtentTransform {\n  type: 'extent';\n  field: string;\n  signal: string;\n}\n\nexport interface VgFormulaTransform {\n  type: 'formula';\n  as: string;\n  expr: string;\n}\n\nexport interface VgFilterTransform {\n  type: 'filter';\n  expr: string;\n}\n\nexport interface VgAggregateTransform {\n  type: 'aggregate';\n  groupby?: VgField[];\n  fields?: VgField[];\n  ops?: AggregateOp[];\n  as?: string[];\n  cross?: boolean;\n  drop?: boolean;\n}\n\nexport interface VgCollectTransform {\n  type: 'collect';\n  sort: VgSort;\n}\n\nexport interface VgLookupTransform {\n  type: 'lookup';\n  from: string;\n  key: string;\n  fields: string[];\n  values?: string[];\n  as?: string[];\n  default?: string;\n}\n\nexport interface VgStackTransform {\n  type: 'stack';\n  offset?: StackOffset;\n  groupby: string[];\n  field: string;\n  sort: VgSort;\n  as: string[];\n}\n\nexport interface VgIdentifierTransform {\n  type: 'identifier';\n  as: string;\n}\n\nexport type VgTransform =\n  | VgBinTransform\n  | VgExtentTransform\n  | VgFormulaTransform\n  | VgAggregateTransform\n  | VgFilterTransform\n  | VgFlattenTransform\n  | VgImputeTransform\n  | VgStackTransform\n  | VgCollectTransform\n  | VgLookupTransform\n  | VgIdentifierTransform\n  | VgGeoPointTransform\n  | VgGeoJSONTransform\n  | VgWindowTransform\n  | VgFoldTransform\n  | VgSampleTransform;\n\nexport interface VgGeoPointTransform {\n  type: 'geopoint';\n  projection: string; // projection name\n  fields: VgField[];\n  as?: string[];\n}\n\nexport interface VgGeoShapeTransform {\n  type: 'geoshape';\n  projection: string; // projection name\n  field?: VgField;\n  as?: string;\n}\n\nexport interface VgGeoJSONTransform {\n  type: 'geojson';\n  fields?: VgField[];\n  geojson?: VgField;\n  signal: string;\n}\n\nexport type VgPostEncodingTransform = VgGeoShapeTransform;\n\nexport type VgGuideEncode = any; // TODO: replace this (See guideEncode in Vega Schema)\n\nexport type VgSort =\n  | {\n      field: string;\n      order?: VgComparatorOrder;\n    }\n  | {\n      field: string[];\n      order?: (VgComparatorOrder)[];\n    };\n\nexport type ImputeMethod = 'value' | 'median' | 'max' | 'min' | 'mean';\n\nexport interface VgImputeTransform {\n  type: 'impute';\n  groupby?: string[];\n  field: string;\n  key: string;\n  keyvals?: any[] | SignalRef;\n  method?: ImputeMethod;\n  value?: any;\n}\n\nexport interface VgCheckboxBinding {\n  input: 'checkbox';\n  element?: string;\n}\n\nexport interface VgRadioBinding {\n  input: 'radio';\n  options: string[];\n  element?: string;\n}\n\nexport interface VgSelectBinding {\n  input: 'select';\n  options: string[];\n  element?: string;\n}\n\nexport interface VgRangeBinding {\n  input: 'range';\n  min?: number;\n  max?: number;\n  step?: number;\n  element?: string;\n}\n\nexport interface VgGenericBinding {\n  input: string;\n  element?: string;\n}\n\nexport type VgBinding = VgCheckboxBinding | VgRadioBinding | VgSelectBinding | VgRangeBinding | VgGenericBinding;\n\nexport type Interpolate =\n  | 'linear'\n  | 'linear-closed'\n  | 'step'\n  | 'step-before'\n  | 'step-after'\n  | 'basis'\n  | 'basis-open'\n  | 'basis-closed'\n  | 'cardinal'\n  | 'cardinal-open'\n  | 'cardinal-closed'\n  | 'bundle'\n  | 'monotone';\nexport type Orient = 'horizontal' | 'vertical';\nexport type Cursor =\n  | 'auto'\n  | 'default'\n  | 'none'\n  | 'context-menu'\n  | 'help'\n  | 'pointer'\n  | 'progress'\n  | 'wait'\n  | 'cell'\n  | 'crosshair'\n  | 'text'\n  | 'vertical-text'\n  | 'alias'\n  | 'copy'\n  | 'move'\n  | 'no-drop'\n  | 'not-allowed'\n  | 'e-resize'\n  | 'n-resize'\n  | 'ne-resize'\n  | 'nw-resize'\n  | 's-resize'\n  | 'se-resize'\n  | 'sw-resize'\n  | 'w-resize'\n  | 'ew-resize'\n  | 'ns-resize'\n  | 'nesw-resize'\n  | 'nwse-resize'\n  | 'col-resize'\n  | 'row-resize'\n  | 'all-scroll'\n  | 'zoom-in'\n  | 'zoom-out'\n  | 'grab'\n  | 'grabbing';\nexport type StrokeCap = 'butt' | 'round' | 'square';\nexport type StrokeJoin = 'miter' | 'round' | 'bevel';\nexport type Dir = 'ltr' | 'rtl';\n\nexport interface VgMarkConfig {\n  /**\n   * Default Fill Color.  This has higher precedence than `config.color`\n   *\n   * __Default value:__ (None)\n   *\n   */\n  fill?: string;\n\n  /**\n   * Default Stroke Color.  This has higher precedence than `config.color`\n   *\n   * __Default value:__ (None)\n   *\n   */\n  stroke?: string;\n\n  // ---------- Opacity ----------\n  /**\n   * The overall opacity (value between [0,1]).\n   *\n   * __Default value:__ `0.7` for non-aggregate plots with `point`, `tick`, `circle`, or `square` marks or layered `bar` charts and `1` otherwise.\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  opacity?: number;\n\n  /**\n   * The fill opacity (value between [0,1]).\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  fillOpacity?: number;\n\n  /**\n   * The stroke opacity (value between [0,1]).\n   *\n   * __Default value:__ `1`\n   *\n   * @minimum 0\n   * @maximum 1\n   */\n  strokeOpacity?: number;\n\n  // ---------- Stroke Style ----------\n  /**\n   * The stroke width, in pixels.\n   *\n   * @minimum 0\n   */\n  strokeWidth?: number;\n\n  /**\n   * The stroke cap for line ending style. One of `\"butt\"`, `\"round\"`, or `\"square\"`.\n   *\n   * __Default value:__ `\"square\"`\n   */\n  strokeCap?: StrokeCap;\n\n  /**\n   * An array of alternating stroke, space lengths for creating dashed or dotted lines.\n   */\n  strokeDash?: number[];\n\n  /**\n   * The offset (in pixels) into which to begin drawing with the stroke dash array.\n   */\n  strokeDashOffset?: number;\n\n  /**\n   * The stroke line join method. One of `\"miter\"`, `\"round\"` or `\"bevel\"`.\n   *\n   * __Default value:__ `\"miter\"`\n   */\n  strokeJoin?: StrokeJoin;\n\n  /**\n   * The miter limit at which to bevel a line join.\n   */\n  strokeMiterLimit?: number;\n\n  // ---------- Orientation: Bar, Tick, Line, Area ----------\n  /**\n   * The orientation of a non-stacked bar, tick, area, and line charts.\n   * The value is either horizontal (default) or vertical.\n   * - For bar, rule and tick, this determines whether the size of the bar and tick\n   * should be applied to x or y dimension.\n   * - For area, this property determines the orient property of the Vega output.\n   * - For line and trail marks, this property determines the sort order of the points in the line\n   * if `config.sortLineBy` is not specified.\n   * For stacked charts, this is always determined by the orientation of the stack;\n   * therefore explicitly specified value will be ignored.\n   */\n  orient?: Orient;\n\n  // ---------- Interpolation: Line / area ----------\n  /**\n   * The line interpolation method to use for line and area marks. One of the following:\n   * - `\"linear\"`: piecewise linear segments, as in a polyline.\n   * - `\"linear-closed\"`: close the linear segments to form a polygon.\n   * - `\"step\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"step-before\"`: alternate between vertical and horizontal segments, as in a step function.\n   * - `\"step-after\"`: alternate between horizontal and vertical segments, as in a step function.\n   * - `\"basis\"`: a B-spline, with control point duplication on the ends.\n   * - `\"basis-open\"`: an open B-spline; may not intersect the start or end.\n   * - `\"basis-closed\"`: a closed B-spline, as in a loop.\n   * - `\"cardinal\"`: a Cardinal spline, with control point duplication on the ends.\n   * - `\"cardinal-open\"`: an open Cardinal spline; may not intersect the start or end, but will intersect other control points.\n   * - `\"cardinal-closed\"`: a closed Cardinal spline, as in a loop.\n   * - `\"bundle\"`: equivalent to basis, except the tension parameter is used to straighten the spline.\n   * - `\"monotone\"`: cubic interpolation that preserves monotonicity in y.\n   */\n  interpolate?: Interpolate;\n  /**\n   * Depending on the interpolation type, sets the tension parameter (for line and area marks).\n   * @minimum 0\n   * @maximum 1\n   */\n  tension?: number;\n\n  /**\n   * The default symbol shape to use. One of: `\"circle\"` (default), `\"square\"`, `\"cross\"`, `\"diamond\"`, `\"triangle-up\"`, or `\"triangle-down\"`, or a custom SVG path.\n   *\n   * __Default value:__ `\"circle\"`\n   *\n   */\n  shape?: string;\n\n  /**\n   * The pixel area each the point/circle/square.\n   * For example: in the case of circles, the radius is determined in part by the square root of the size value.\n   *\n   * __Default value:__ `30`\n   *\n   * @minimum 0\n   */\n  size?: number;\n\n  // Text / Label Mark Config\n\n  /**\n   * The horizontal alignment of the text. One of `\"left\"`, `\"right\"`, `\"center\"`.\n   */\n  align?: Align;\n\n  /**\n   * The rotation angle of the text, in degrees.\n   * @minimum 0\n   * @maximum 360\n   */\n  angle?: number;\n\n  /**\n   * The vertical alignment of the text. One of `\"top\"`, `\"middle\"`, `\"bottom\"`.\n   *\n   * __Default value:__ `\"middle\"`\n   *\n   */\n  baseline?: TextBaseline;\n\n  /**\n   * The direction of the text. One of `\"ltr\"` (left-to-right) or `\"rtl\"` (right-to-left). This property determines on which side is truncated in response to the limit parameter.\n   *\n   * __Default value:__ `\"ltr\"`\n   */\n  dir?: Dir;\n\n  /**\n   * The horizontal offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.\n   */\n  dx?: number;\n\n  /**\n   * The vertical offset, in pixels, between the text label and its anchor point. The offset is applied after rotation by the _angle_ property.\n   */\n  dy?: number;\n\n  /**\n   * Polar coordinate radial offset, in pixels, of the text label from the origin determined by the `x` and `y` properties.\n   * @minimum 0\n   */\n  radius?: number;\n\n  /**\n   * The maximum length of the text mark in pixels. The text value will be automatically truncated if the rendered size exceeds the limit.\n   *\n   * __Default value:__ `0`, indicating no limit\n   */\n  limit?: number;\n\n  /**\n   * The ellipsis string for text truncated in response to the limit parameter.\n   *\n   * __Default value:__ `\"\"`\n   */\n  ellipsis?: string;\n\n  /**\n   * Polar coordinate angle, in radians, of the text label from the origin determined by the `x` and `y` properties. Values for `theta` follow the same convention of `arc` mark `startAngle` and `endAngle` properties: angles are measured in radians, with `0` indicating \"north\".\n   */\n  theta?: number;\n\n  /**\n   * The typeface to set the text in (e.g., `\"Helvetica Neue\"`).\n   */\n  font?: string;\n\n  /**\n   * The font size, in pixels.\n   * @minimum 0\n   *\n   * __Default value:__ `11`\n   */\n  fontSize?: number;\n\n  /**\n   * The font style (e.g., `\"italic\"`).\n   */\n  fontStyle?: FontStyle;\n  /**\n   * The font weight.\n   * This can be either a string (e.g `\"bold\"`, `\"normal\"`) or a number (`100`, `200`, `300`, ..., `900` where `\"normal\"` = `400` and `\"bold\"` = `700`).\n   */\n  fontWeight?: FontWeight;\n\n  /**\n   * Placeholder text if the `text` channel is not specified\n   */\n  text?: string;\n\n  /**\n   * A URL to load upon mouse click. If defined, the mark acts as a hyperlink.\n   *\n   * @format uri\n   */\n  href?: string;\n\n  /**\n   * The mouse cursor used over the mark. Any valid [CSS cursor type](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#Values) can be used.\n   */\n  cursor?: Cursor;\n\n  /**\n   * The tooltip text to show upon mouse hover.\n   */\n  tooltip?: any;\n\n  // ---------- Corner Radius: Bar, Tick, Rect ----------\n\n  /**\n   * The radius in pixels of rounded rectangle corners.\n   *\n   * __Default value:__ `0`\n   */\n  cornerRadius?: number;\n}\n\nconst VG_MARK_CONFIG_INDEX: Flag<keyof VgMarkConfig> = {\n  opacity: 1,\n  fill: 1,\n  fillOpacity: 1,\n  stroke: 1,\n  strokeCap: 1,\n  strokeWidth: 1,\n  strokeOpacity: 1,\n  strokeDash: 1,\n  strokeDashOffset: 1,\n  strokeJoin: 1,\n  strokeMiterLimit: 1,\n  size: 1,\n  shape: 1,\n  interpolate: 1,\n  tension: 1,\n  orient: 1,\n  align: 1,\n  baseline: 1,\n  text: 1,\n  dir: 1,\n  dx: 1,\n  dy: 1,\n  ellipsis: 1,\n  limit: 1,\n  radius: 1,\n  theta: 1,\n  angle: 1,\n  font: 1,\n  fontSize: 1,\n  fontWeight: 1,\n  fontStyle: 1,\n  cursor: 1,\n  href: 1,\n  tooltip: 1,\n  cornerRadius: 1\n  // commented below are vg channel that do not have mark config.\n  // 'x'|'x2'|'xc'|'width'|'y'|'y2'|'yc'|'height'\n  // clip: 1,\n  // endAngle: 1,\n  // innerRadius: 1,\n  // outerRadius: 1,\n  // path: 1,\n  // startAngle: 1,\n  // url: 1,\n};\n\nexport const VG_MARK_CONFIGS = flagKeys(VG_MARK_CONFIG_INDEX);\n\nexport type VgComparatorOrder = 'ascending' | 'descending';\n\nexport interface VgComparator {\n  field?: string | string[];\n  order?: VgComparatorOrder | VgComparatorOrder[];\n}\n\nexport interface VgWindowTransform {\n  type: 'window';\n  params?: number[];\n  as?: string[];\n  ops?: (AggregateOp | WindowOnlyOp)[];\n  fields?: string[];\n  frame?: number[];\n  ignorePeers?: boolean;\n  groupby?: string[];\n  sort?: VgComparator;\n}\n","export {\n  default as loader\n} from './src/loader';\n\nexport {\n  default as read\n} from './src/read';\n\nexport {\n  inferType,\n  inferTypes,\n  typeParsers\n} from './src/type';\n\nexport {\n  default as formats\n} from './src/formats/index';\n","import {dsvFormat} from 'd3-dsv';\nimport {extend, stringValue} from 'vega-util';\n\nexport function delimitedFormat(delimiter) {\n  return function(data, format) {\n    var delim = {delimiter: delimiter};\n    return dsv(data, format ? extend(format, delim) : delim);\n  };\n}\n\nexport default function dsv(data, format) {\n  if (format.header) {\n    data = format.header\n      .map(stringValue)\n      .join(format.delimiter) + '\\n' + data;\n  }\n  return dsvFormat(format.delimiter).parse(data+'');\n}\n","import {default as dsv, delimitedFormat} from './dsv';\nimport json from './json';\nimport topojson from './topojson';\n\nvar formats = {\n  dsv: dsv,\n  csv: delimitedFormat(','),\n  tsv: delimitedFormat('\\t'),\n  json: json,\n  topojson: topojson\n};\n\nexport default function(name, format) {\n  if (arguments.length > 1) {\n    formats[name] = format;\n    return this;\n  } else {\n    return formats.hasOwnProperty(name) ? formats[name] : null;\n  }\n}\n","import {field, identity, isFunction, isObject} from 'vega-util';\n\nfunction isBuffer(_) {\n  return (typeof Buffer === 'function' && isFunction(Buffer.isBuffer))\n    ? Buffer.isBuffer(_) : false;\n}\n\nexport default function(data, format) {\n  var prop = (format && format.property) ? field(format.property) : identity;\n  return isObject(data) && !isBuffer(data)\n    ? parseJSON(prop(data))\n    : prop(JSON.parse(data));\n}\n\nfunction parseJSON(data, format) {\n  return (format && format.copy)\n    ? JSON.parse(JSON.stringify(data))\n    : data;\n}\n","import json from './json';\nimport {feature, mesh} from 'topojson-client';\nimport {error} from 'vega-util';\n\nexport default function(data, format) {\n  var method, object, property;\n  data = json(data, format);\n\n  method = (format && (property = format.feature)) ? feature\n    : (format && (property = format.mesh)) ? mesh\n    : error('Missing TopoJSON feature or mesh parameter.');\n\n  object = (object = data.objects[property])\n    ? method(data, object)\n    : error('Invalid TopoJSON object: ' + property);\n\n  return object && object.features || [object];\n}\n","import {extend, isFunction, stringValue} from 'vega-util';\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n/**\n * Creates a new loader instance that provides methods for requesting files\n * from either the network or disk, and for sanitizing request URIs.\n * @param {object} [options] - Optional default loading options to use.\n * @return {object} - A new loader instance.\n */\nexport default function(options) {\n  return {\n    options: options || {},\n    sanitize: sanitize,\n    load: load,\n    file: file,\n    http: http\n  };\n}\n\n/**\n * Load an external resource, typically either from the web or from the local\n * filesystem. This function uses {@link sanitize} to first sanitize the uri,\n * then calls either {@link http} (for web requests) or {@link file} (for\n * filesystem loading).\n * @param {string} uri - The resource indicator (e.g., URL or filename).\n * @param {object} [options] - Optional loading options. These options will\n *   override any existing default options.\n * @return {Promise} - A promise that resolves to the loaded content.\n */\nfunction load(uri, options) {\n  var loader = this;\n  return loader.sanitize(uri, options)\n    .then(function(opt) {\n      var url = opt.href;\n      return opt.localFile\n        ? loader.file(url)\n        : loader.http(url, options);\n    });\n}\n\n/**\n * URI sanitizer function.\n * @param {string} uri - The uri (url or filename) to sanity check.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to an object containing\n *  sanitized uri data, or rejects it the input uri is deemed invalid.\n *  The properties of the resolved object are assumed to be\n *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be\n *  provided by the 'href' property of the returned object.\n */\nfunction sanitize(uri, options) {\n  options = extend({}, this.options, options);\n\n  return new Promise(function(accept, reject) {\n    var result = {href: null},\n        isFile, hasProtocol, loadFile, base;\n\n    if (uri == null || typeof uri !== 'string') {\n      reject('Sanitize failure, invalid URI: ' + stringValue(uri));\n      return;\n    }\n\n    hasProtocol = protocol_re.test(uri);\n\n    // if relative url (no protocol/host), prepend baseURL\n    if ((base = options.baseURL) && !hasProtocol) {\n      // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n      if (!startsWith(uri, '/') && base[base.length-1] !== '/') {\n        uri = '/' + uri;\n      }\n      uri = base + uri;\n    }\n\n    // should we load from file system?\n    loadFile = (isFile = startsWith(uri, fileProtocol))\n      || options.mode === 'file'\n      || options.mode !== 'http' && !hasProtocol && fs();\n\n    if (isFile) {\n      // strip file protocol\n      uri = uri.slice(fileProtocol.length);\n    } else if (startsWith(uri, '//')) {\n      if (options.defaultProtocol === 'file') {\n        // if is file, strip protocol and set loadFile flag\n        uri = uri.slice(2);\n        loadFile = true;\n      } else {\n        // if relative protocol (starts with '//'), prepend default protocol\n        uri = (options.defaultProtocol || 'http') + ':' + uri;\n      }\n    }\n\n    // set non-enumerable mode flag to indicate local file load\n    Object.defineProperty(result, 'localFile', {value: !!loadFile});\n\n    // set uri\n    result.href = uri;\n\n    // set default result target, if specified\n    if (options.target) {\n      result.target = options.target + '';\n    }\n\n    // return\n    accept(result);\n  });\n}\n\n/**\n * HTTP request loader.\n * @param {string} url - The url to request.\n * @param {object} options - An options hash.\n * @return {Promise} - A promise that resolves to the file contents.\n */\nfunction http(url, options) {\n  return request(url, extend({}, this.options.http, options))\n    .then(function(response) {\n      if (!response.ok) throw response.status + '' + response.statusText;\n      return response.text();\n    });\n}\n\n/**\n * File system loader.\n * @param {string} filename - The file system path to load.\n * @return {Promise} - A promise that resolves to the file contents.\n */\nfunction file(filename) {\n  return new Promise(function(accept, reject) {\n    var f = fs();\n    f ? f.readFile(filename, function(error, data) {\n          if (error) reject(error);\n          else accept(data);\n        })\n      : reject('No file system access for ' + filename);\n  });\n}\n\nfunction request(url, init) {\n  var f = typeof fetch === 'function' ? fetch : require('node-fetch');\n  return f ? f(url, init) : Promise.reject('No fetch method available.');\n}\n\nfunction fs() {\n  var fs = typeof require === 'function' && require('fs');\n  return fs && isFunction(fs.readFile) ? fs : null;\n}\n\nfunction startsWith(string, query) {\n  return string == null ? false : string.lastIndexOf(query, 0) === 0;\n}\n","import {inferTypes, typeParsers} from './type';\nimport formats from './formats/index';\nimport {error} from 'vega-util';\nimport {timeParse, utcParse} from 'd3-time-format';\n\nexport default function(data, schema, dateParse) {\n  schema = schema || {};\n\n  var reader = formats(schema.type || 'json');\n  if (!reader) error('Unknown data format type: ' + schema.type);\n\n  data = reader(data, schema);\n  if (schema.parse) parse(data, schema.parse, dateParse);\n\n  if (data.hasOwnProperty('columns')) delete data.columns;\n  return data;\n}\n\nfunction parse(data, types, dateParse) {\n  if (!data.length) return; // early exit for empty data\n\n  dateParse = dateParse || timeParse;\n\n  var fields = data.columns || Object.keys(data[0]),\n      parsers, datum, field, i, j, n, m;\n\n  if (types === 'auto') types = inferTypes(data, fields);\n\n  fields = Object.keys(types);\n  parsers = fields.map(function(field) {\n    var type = types[field],\n        parts, pattern;\n\n    if (type && (type.indexOf('date:') === 0 || type.indexOf('utc:') === 0)) {\n      parts = type.split(/:(.+)?/, 2);  // split on first :\n      pattern = parts[1];\n\n      if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n          (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n        pattern = pattern.slice(1, -1);\n      }\n\n      return parts[0] === 'utc' ? utcParse(pattern) : dateParse(pattern);\n    }\n\n    if (!typeParsers[type]) {\n      throw Error('Illegal format pattern: ' + field + ':' + type);\n    }\n\n    return typeParsers[type];\n  });\n\n  for (i=0, n=data.length, m=fields.length; i<n; ++i) {\n    datum = data[i];\n    for (j=0; j<m; ++j) {\n      field = fields[j];\n      datum[field] = parsers[j](datum[field]);\n    }\n  }\n}\n","import {identity, toBoolean, toDate, toNumber, toString} from 'vega-util';\n\nexport var typeParsers = {\n  boolean: toBoolean,\n  integer: toNumber,\n  number:  toNumber,\n  date:    toDate,\n  string:  toString,\n  unknown: identity\n};\n\nvar typeTests = [\n  isBoolean,\n  isInteger,\n  isNumber,\n  isDate\n];\n\nvar typeList = [\n  'boolean',\n  'integer',\n  'number',\n  'date'\n];\n\nexport function inferType(values, field) {\n  if (!values || !values.length) return 'unknown';\n\n  var value, i, j, t = 0,\n      n = values.length,\n      m = typeTests.length,\n      a = typeTests.map(function(_, i) { return i + 1; });\n\n  for (i=0, n=values.length; i<n; ++i) {\n    value = field ? values[i][field] : values[i];\n    for (j=0; j<m; ++j) {\n      if (a[j] && isValid(value) && !typeTests[j](value)) {\n        a[j] = 0;\n        ++t;\n        if (t === typeTests.length) return 'string';\n      }\n    }\n  }\n\n  t = a.reduce(function(u, v) { return u === 0 ? v : u; }, 0) - 1;\n  return typeList[t];\n}\n\nexport function inferTypes(data, fields) {\n  return fields.reduce(function(types, field) {\n    types[field] = inferType(data, field);\n    return types;\n  }, {});\n}\n\n// -- Type Checks ----\n\nfunction isValid(_) {\n  return _ != null && _ === _;\n}\n\nfunction isBoolean(_) {\n  return _ === 'true' || _ === 'false' || _ === true || _ === false;\n}\n\nfunction isDate(_) {\n  return !isNaN(Date.parse(_));\n}\n\nfunction isNumber(_) {\n  return !isNaN(+_) && !(_ instanceof Date);\n}\n\nfunction isInteger(_) {\n  return isNumber(_) && (_=+_) === ~~_;\n}\n","export {default as parse} from './src/parse';\nexport {default as config} from './src/config';\n\nexport {default as signal} from './src/parsers/signal';\nexport {default as signalUpdates} from './src/parsers/signal-updates';\nexport {default as stream} from './src/parsers/stream';\n\nexport {\n  codeGenerator,\n  functionContext,\n  expressionFunction\n} from './src/parsers/expression/codegen';\n\nexport {\n  MarkRole,\n  FrameRole,\n  ScopeRole,\n  AxisRole,\n  AxisDomainRole,\n  AxisGridRole,\n  AxisLabelRole,\n  AxisTickRole,\n  AxisTitleRole,\n  LegendRole,\n  LegendEntryRole,\n  LegendLabelRole,\n  LegendSymbolRole,\n  LegendTitleRole\n} from './src/parsers/marks/roles';\n\nexport {default as Scope} from './src/Scope';\nexport {default as DataScope} from './src/DataScope';\n\nexport {formatDefaultLocale as formatLocale} from 'd3-format';\nexport {timeFormatDefaultLocale as timeFormatLocale} from 'd3-time-format';\n","import {entry, ref, keyFieldRef, aggrField, sortKey} from './util';\nimport {Aggregate, Collect} from './transforms';\nimport {isString} from 'vega-util';\n\nexport default function DataScope(scope, input, output, values, aggr) {\n  this.scope = scope;   // parent scope object\n  this.input = input;   // first operator in pipeline (tuple input)\n  this.output = output; // last operator in pipeline (tuple output)\n  this.values = values; // operator for accessing tuples (but not tuple flow)\n\n  // last aggregate in transform pipeline\n  this.aggregate = aggr;\n\n  // lookup table of field indices\n  this.index = {};\n}\n\nDataScope.fromEntries = function(scope, entries) {\n  var n = entries.length,\n      i = 1,\n      input  = entries[0],\n      values = entries[n-1],\n      output = entries[n-2],\n      aggr = null;\n\n  // add operator entries to this scope, wire up pulse chain\n  scope.add(entries[0]);\n  for (; i<n; ++i) {\n    entries[i].params.pulse = ref(entries[i-1]);\n    scope.add(entries[i]);\n    if (entries[i].type === 'aggregate') aggr = entries[i];\n  }\n\n  return new DataScope(scope, input, output, values, aggr);\n};\n\nvar prototype = DataScope.prototype;\n\nprototype.countsRef = function(scope, field, sort) {\n  var ds = this,\n      cache = ds.counts || (ds.counts = {}),\n      k = fieldKey(field), v, a, p;\n\n  if (k != null) {\n    scope = ds.scope;\n    v = cache[k];\n  }\n\n  if (!v) {\n    p = {\n      groupby: scope.fieldRef(field, 'key'),\n      pulse: ref(ds.output)\n    };\n    if (sort && sort.field) addSortField(scope, p, sort);\n    a = scope.add(Aggregate(p));\n    v = scope.add(Collect({pulse: ref(a)}));\n    v = {agg: a, ref: ref(v)};\n    if (k != null) cache[k] = v;\n  } else if (sort && sort.field) {\n    addSortField(scope, v.agg.params, sort);\n  }\n\n  return v.ref;\n};\n\nfunction fieldKey(field) {\n  return isString(field) ? field : null;\n}\n\nfunction addSortField(scope, p, sort) {\n  var as = aggrField(sort.op, sort.field), s;\n\n  if (p.ops) {\n    for (var i=0, n=p.as.length; i<n; ++i) {\n      if (p.as[i] === as) return;\n    }\n  } else {\n    p.ops = ['count'];\n    p.fields = [null];\n    p.as = ['count'];\n  }\n  if (sort.op) {\n    p.ops.push((s=sort.op.signal) ? scope.signalRef(s) : sort.op);\n    p.fields.push(scope.fieldRef(sort.field));\n    p.as.push(as);\n  }\n}\n\nfunction cache(scope, ds, name, optype, field, counts, index) {\n  var cache = ds[name] || (ds[name] = {}),\n      sort = sortKey(counts),\n      k = fieldKey(field), v, op;\n\n  if (k != null) {\n    scope = ds.scope;\n    k = k + (sort ? '|' + sort : '');\n    v = cache[k];\n  }\n\n  if (!v) {\n    var params = counts\n      ? {field: keyFieldRef, pulse: ds.countsRef(scope, field, counts)}\n      : {field: scope.fieldRef(field), pulse: ref(ds.output)};\n    if (sort) params.sort = scope.sortRef(counts);\n    op = scope.add(entry(optype, undefined, params));\n    if (index) ds.index[field] = op;\n    v = ref(op);\n    if (k != null) cache[k] = v;\n  }\n  return v;\n}\n\nprototype.tuplesRef = function() {\n  return ref(this.values);\n};\n\nprototype.extentRef = function(scope, field) {\n  return cache(scope, this, 'extent', 'extent', field, false);\n};\n\nprototype.domainRef = function(scope, field) {\n  return cache(scope, this, 'domain', 'values', field, false);\n};\n\nprototype.valuesRef = function(scope, field, sort) {\n  return cache(scope, this, 'vals', 'values', field, sort || true);\n};\n\nprototype.lookupRef = function(scope, field) {\n  return cache(scope, this, 'lookup', 'tupleindex', field, false);\n};\n\nprototype.indataRef = function(scope, field) {\n  return cache(scope, this, 'indata', 'tupleindex', field, true, true);\n};\n","import DataScope from './DataScope';\nimport {\n  aggrField, Ascending, compareRef, Entry,\n  fieldRef, keyRef, tupleidRef, isSignal, operator, ref\n} from './util';\nimport parseExpression from './parsers/expression';\nimport {Compare, Expression, Field, Key, Projection, Proxy, Scale, Sieve} from './transforms';\nimport {array, error, extend, isArray, isString, isObject, peek, stringValue} from 'vega-util';\n\nexport default function Scope(config) {\n  this.config = config;\n\n  this.bindings = [];\n  this.field = {};\n  this.signals = {};\n  this.lambdas = {};\n  this.scales = {};\n  this.events = {};\n  this.data = {};\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n  this.background = null;\n  this.eventConfig = null;\n\n  this._id = 0;\n  this._subid = 0;\n  this._nextsub = [0];\n\n  this._parent = [];\n  this._encode = [];\n  this._lookup = [];\n  this._markpath = [];\n}\n\nfunction Subscope(scope) {\n  this.config = scope.config;\n\n  this.field = Object.create(scope.field);\n  this.signals = Object.create(scope.signals);\n  this.lambdas = Object.create(scope.lambdas);\n  this.scales = Object.create(scope.scales);\n  this.events = Object.create(scope.events);\n  this.data = Object.create(scope.data);\n\n  this.streams = [];\n  this.updates = [];\n  this.operators = [];\n\n  this._id = 0;\n  this._subid = ++scope._nextsub[0];\n  this._nextsub = scope._nextsub;\n\n  this._parent = scope._parent.slice();\n  this._encode = scope._encode.slice();\n  this._lookup = scope._lookup.slice();\n  this._markpath = scope._markpath;\n}\n\nvar prototype = Scope.prototype = Subscope.prototype;\n\n// ----\n\nprototype.fork = function() {\n  return new Subscope(this);\n};\n\nprototype.isSubscope = function() {\n  return this._subid > 0;\n};\n\nprototype.toRuntime = function() {\n  this.finish();\n  return {\n    background:  this.background,\n    operators:   this.operators,\n    streams:     this.streams,\n    updates:     this.updates,\n    bindings:    this.bindings,\n    eventConfig: this.eventConfig\n  };\n};\n\nprototype.id = function() {\n  return (this._subid ? this._subid + ':' : 0) + this._id++;\n};\n\nprototype.add = function(op) {\n  this.operators.push(op);\n  op.id = this.id();\n  // if pre-registration references exist, resolve them now\n  if (op.refs) {\n    op.refs.forEach(function(ref) { ref.$ref = op.id; });\n    op.refs = null;\n  }\n  return op;\n};\n\nprototype.proxy = function(op) {\n  var vref = op instanceof Entry ? ref(op) : op;\n  return this.add(Proxy({value: vref}));\n};\n\nprototype.addStream = function(stream) {\n  this.streams.push(stream);\n  stream.id = this.id();\n  return stream;\n};\n\nprototype.addUpdate = function(update) {\n  this.updates.push(update);\n  return update;\n};\n\n// Apply metadata\nprototype.finish = function() {\n  var name, ds;\n\n  // annotate root\n  if (this.root) this.root.root = true;\n\n  // annotate signals\n  for (name in this.signals) {\n    this.signals[name].signal = name;\n  }\n\n  // annotate scales\n  for (name in this.scales) {\n    this.scales[name].scale = name;\n  }\n\n  // annotate data sets\n  function annotate(op, name, type) {\n    var data, list;\n    if (op) {\n      data = op.data || (op.data = {});\n      list = data[name] || (data[name] = []);\n      list.push(type);\n    }\n  }\n  for (name in this.data) {\n    ds = this.data[name];\n    annotate(ds.input,  name, 'input');\n    annotate(ds.output, name, 'output');\n    annotate(ds.values, name, 'values');\n    for (var field in ds.index) {\n      annotate(ds.index[field], name, 'index:' + field);\n    }\n  }\n\n  return this;\n};\n\n// ----\n\nprototype.pushState = function(encode, parent, lookup) {\n  this._encode.push(ref(this.add(Sieve({pulse: encode}))));\n  this._parent.push(parent);\n  this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);\n  this._markpath.push(-1);\n};\n\nprototype.popState = function() {\n  this._encode.pop();\n  this._parent.pop();\n  this._lookup.pop();\n  this._markpath.pop();\n};\n\nprototype.parent = function() {\n  return peek(this._parent);\n};\n\nprototype.encode = function() {\n  return peek(this._encode);\n};\n\nprototype.lookup = function() {\n  return peek(this._lookup);\n};\n\nprototype.markpath = function() {\n  var p = this._markpath;\n  return ++p[p.length-1];\n};\n\n// ----\n\nprototype.fieldRef = function(field, name) {\n  if (isString(field)) return fieldRef(field, name);\n  if (!field.signal) {\n    error('Unsupported field reference: ' + stringValue(field));\n  }\n\n  var s = field.signal,\n      f = this.field[s],\n      params;\n\n  if (!f) {\n    params = {name: this.signalRef(s)};\n    if (name) params.as = name;\n    this.field[s] = f = ref(this.add(Field(params)));\n  }\n  return f;\n};\n\nprototype.compareRef = function(cmp, stable) {\n  function check(_) {\n    if (isSignal(_)) {\n      signal = true;\n      return ref(sig[_.signal]);\n    } else {\n      return _;\n    }\n  }\n\n  var sig = this.signals,\n      signal = false,\n      fields = array(cmp.field).map(check),\n      orders = array(cmp.order).map(check);\n\n  if (stable) {\n    fields.push(tupleidRef);\n  }\n\n  return signal\n    ? ref(this.add(Compare({fields: fields, orders: orders})))\n    : compareRef(fields, orders);\n};\n\nprototype.keyRef = function(fields, flat) {\n  function check(_) {\n    if (isSignal(_)) {\n      signal = true;\n      return ref(sig[_.signal]);\n    } else {\n      return _;\n    }\n  }\n\n  var sig = this.signals,\n      signal = false;\n  fields = array(fields).map(check);\n\n  return signal\n    ? ref(this.add(Key({fields: fields, flat: flat})))\n    : keyRef(fields, flat);\n};\n\nprototype.sortRef = function(sort) {\n  if (!sort) return sort;\n\n  // including id ensures stable sorting\n  var a = [aggrField(sort.op, sort.field), tupleidRef],\n      o = sort.order || Ascending;\n\n  return o.signal\n    ? ref(this.add(Compare({\n        fields: a,\n        orders: [o = this.signalRef(o.signal), o]\n      })))\n    : compareRef(a, [o, o]);\n};\n\n// ----\n\nprototype.event = function(source, type) {\n  var key = source + ':' + type;\n  if (!this.events[key]) {\n    var id = this.id();\n    this.streams.push({\n      id: id,\n      source: source,\n      type: type\n    });\n    this.events[key] = id;\n  }\n  return this.events[key];\n};\n\n// ----\n\nprototype.addSignal = function(name, value) {\n  if (this.signals.hasOwnProperty(name)) {\n    error('Duplicate signal name: ' + stringValue(name));\n  }\n  var op = value instanceof Entry ? value : this.add(operator(value));\n  return this.signals[name] = op;\n};\n\nprototype.getSignal = function(name) {\n  if (!this.signals[name]) {\n    error('Unrecognized signal name: ' + stringValue(name));\n  }\n  return this.signals[name];\n};\n\nprototype.signalRef = function(s) {\n  if (this.signals[s]) {\n    return ref(this.signals[s]);\n  } else if (!this.lambdas.hasOwnProperty(s)) {\n    this.lambdas[s] = this.add(operator(null));\n  }\n  return ref(this.lambdas[s]);\n};\n\nprototype.parseLambdas = function() {\n  var code = Object.keys(this.lambdas);\n  for (var i=0, n=code.length; i<n; ++i) {\n    var s = code[i],\n        e = parseExpression(s, this),\n        op = this.lambdas[s];\n    op.params = e.$params;\n    op.update = e.$expr;\n  }\n};\n\nprototype.property = function(spec) {\n  return spec && spec.signal ? this.signalRef(spec.signal) : spec;\n};\n\nprototype.objectProperty = function(spec) {\n  return (!spec || !isObject(spec)) ? spec\n    : this.signalRef(spec.signal || propertyLambda(spec));\n};\n\nfunction propertyLambda(spec) {\n  return (isArray(spec) ? arrayLambda : objectLambda)(spec);\n}\n\nfunction arrayLambda(array) {\n  var code = '[',\n      i = 0,\n      n = array.length,\n      value;\n\n  for (; i<n; ++i) {\n    value = array[i];\n    code += (i > 0 ? ',' : '')\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + ']';\n}\n\nfunction objectLambda(obj) {\n  var code = '{',\n      i = 0,\n      key, value;\n\n  for (key in obj) {\n    value = obj[key];\n    code += (++i > 1 ? ',' : '')\n      + stringValue(key) + ':'\n      + (isObject(value)\n        ? (value.signal || propertyLambda(value))\n        : stringValue(value));\n  }\n  return code + '}';\n}\n\nprototype.exprRef = function(code, name) {\n  var params = {expr: parseExpression(code, this)};\n  if (name) params.expr.$name = name;\n  return ref(this.add(Expression(params)));\n}\n\nprototype.addBinding = function(name, bind) {\n  if (!this.bindings) {\n    error('Nested signals do not support binding: ' + stringValue(name));\n  }\n  this.bindings.push(extend({signal: name}, bind));\n};\n\n// ----\n\nprototype.addScaleProj = function(name, transform) {\n  if (this.scales.hasOwnProperty(name)) {\n    error('Duplicate scale or projection name: ' + stringValue(name));\n  }\n  this.scales[name] = this.add(transform);\n};\n\nprototype.addScale = function(name, params) {\n  this.addScaleProj(name, Scale(params));\n};\n\nprototype.addProjection = function(name, params) {\n  this.addScaleProj(name, Projection(params));\n};\n\nprototype.getScale = function(name) {\n  if (!this.scales[name]) {\n    error('Unrecognized scale name: ' + stringValue(name));\n  }\n  return this.scales[name];\n};\n\nprototype.projectionRef =\nprototype.scaleRef = function(name) {\n  return ref(this.getScale(name));\n};\n\nprototype.projectionType =\nprototype.scaleType = function(name) {\n  return this.getScale(name).params.type;\n};\n\n// ----\n\nprototype.addData = function(name, dataScope) {\n  if (this.data.hasOwnProperty(name)) {\n    error('Duplicate data set name: ' + stringValue(name));\n  }\n  return (this.data[name] = dataScope);\n};\n\nprototype.getData = function(name) {\n  if (!this.data[name]) {\n    error('Undefined data set name: ' + stringValue(name));\n  }\n  return this.data[name];\n};\n\nprototype.addDataPipeline = function(name, entries) {\n  if (this.data.hasOwnProperty(name)) {\n    error('Duplicate data set name: ' + stringValue(name));\n  }\n  return this.addData(name, DataScope.fromEntries(this, entries));\n};\n","import {extend, isArray, isObject} from 'vega-util';\n\nexport default function(configs) {\n  var output = defaults();\n  (configs || []).forEach(function(config) {\n    var key, value, style;\n    if (config) {\n      for (key in config) {\n        if (key === 'style') {\n          style = output.style || (output.style = {});\n          for (key in config.style) {\n            style[key] = extend(style[key] || {}, config.style[key]);\n          }\n        } else {\n          value = config[key];\n          output[key] = isObject(value) && !isArray(value)\n            ? extend(isObject(output[key]) ? output[key] : {}, value)\n            : value;\n        }\n      }\n    }\n  });\n  return output;\n}\n\nvar defaultFont = 'sans-serif',\n    defaultSymbolSize = 30,\n    defaultStrokeWidth = 2,\n    defaultColor = '#4c78a8',\n    black = \"#000\",\n    gray = '#888',\n    lightGray = '#ddd';\n\n/**\n * Standard configuration defaults for Vega specification parsing.\n * Users can provide their own (sub-)set of these default values\n * by passing in a config object to the top-level parse method.\n */\nfunction defaults() {\n  return {\n    // default padding around visualization\n    padding: 0,\n\n    // default for automatic sizing; options: \"none\", \"pad\", \"fit\"\n    // or provide an object (e.g., {\"type\": \"pad\", \"resize\": true})\n    autosize: 'pad',\n\n    // default view background color\n    // covers the entire view component\n    background: null,\n\n    // default event handling configuration\n    // preventDefault for view-sourced event types except 'wheel'\n    events: {\n      defaults: {allow: ['wheel']}\n    },\n\n    // defaults for top-level group marks\n    // accepts mark properties (fill, stroke, etc)\n    // covers the data rectangle within group width/height\n    group: null,\n\n    // defaults for basic mark types\n    // each subset accepts mark properties (fill, stroke, etc)\n    mark: null,\n    arc: { fill: defaultColor },\n    area: { fill: defaultColor },\n    image: null,\n    line: {\n      stroke: defaultColor,\n      strokeWidth: defaultStrokeWidth\n    },\n    path: { stroke: defaultColor },\n    rect: { fill: defaultColor },\n    rule: { stroke: black },\n    shape: { stroke: defaultColor },\n    symbol: {\n      fill: defaultColor,\n      size: 64\n    },\n    text: {\n      fill: black,\n      font: defaultFont,\n      fontSize: 11\n    },\n\n    // style definitions\n    style: {\n      // axis & legend labels\n      \"guide-label\": {\n        fill: black,\n        font: defaultFont,\n        fontSize: 10\n      },\n      // axis & legend titles\n      \"guide-title\": {\n        fill: black,\n        font: defaultFont,\n        fontSize: 11,\n        fontWeight: 'bold'\n      },\n      // headers, including chart title\n      \"group-title\": {\n        fill: black,\n        font: defaultFont,\n        fontSize: 13,\n        fontWeight: 'bold'\n      },\n      // defaults for styled point marks in Vega-Lite\n      point: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'circle'\n      },\n      circle: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth\n      },\n      square: {\n        size: defaultSymbolSize,\n        strokeWidth: defaultStrokeWidth,\n        shape: 'square'\n      },\n      // defaults for styled group marks in Vega-Lite\n      cell: {\n        fill: 'transparent',\n        stroke: lightGray\n      }\n    },\n\n    // defaults for axes\n    axis: {\n      minExtent: 0,\n      maxExtent: 200,\n      bandPosition: 0.5,\n      domain: true,\n      domainWidth: 1,\n      domainColor: gray,\n      grid: false,\n      gridWidth: 1,\n      gridColor: lightGray,\n      labels: true,\n      labelAngle: 0,\n      labelLimit: 180,\n      labelPadding: 2,\n      ticks: true,\n      tickColor: gray,\n      tickOffset: 0,\n      tickRound: true,\n      tickSize: 5,\n      tickWidth: 1,\n      titleAlign: 'center',\n      titlePadding: 4\n    },\n\n    // correction for centering bias\n    axisBand: {\n      tickOffset: -1\n    },\n\n    // defaults for legends\n    legend: {\n      orient: 'right',\n      offset: 18,\n      padding: 0,\n      gridAlign: 'each',\n      columnPadding: 10,\n      rowPadding: 2,\n      symbolDirection: 'vertical',\n      gradientDirection: 'vertical',\n      gradientLength: 200,\n      gradientThickness: 16,\n      gradientStrokeColor: lightGray,\n      gradientStrokeWidth: 0,\n      gradientLabelOffset: 2,\n      labelAlign: 'left',\n      labelBaseline: 'middle',\n      labelLimit: 160,\n      labelOffset: 4,\n      labelOverlap: true,\n      symbolType: 'circle',\n      symbolSize: 100,\n      symbolOffset: 0,\n      symbolStrokeWidth: 1.5,\n      symbolBaseFillColor: 'transparent',\n      symbolBaseStrokeColor: gray,\n      titleAlign: 'left',\n      titleBaseline: 'top',\n      titleLimit: 180,\n      titlePadding: 5\n    },\n\n    // defaults for group title\n    title: {\n      orient: 'top',\n      anchor: 'middle',\n      offset: 4\n    },\n\n    // defaults for scale ranges\n    range: {\n      category: {\n        scheme: 'tableau10'\n      },\n      ordinal: {\n        scheme: 'blues',\n        extent: [0.2, 1]\n      },\n      heatmap: {\n        scheme: 'viridis'\n      },\n      ramp: {\n        scheme: 'blues',\n        extent: [0.2, 1]\n      },\n      diverging: {\n        scheme: 'blueorange'\n      },\n      symbol: [\n        'circle',\n        'square',\n        'triangle-up',\n        'cross',\n        'diamond',\n        'triangle-right',\n        'triangle-down',\n        'triangle-left'\n      ]\n    }\n  };\n}\n","import parseView from './parsers/view';\nimport Scope from './Scope';\nimport defaults from './config';\nimport {error, isObject} from 'vega-util';\n\nexport default function(spec, config) {\n  if (!isObject(spec)) error('Input Vega specification must be an object.');\n  return parseView(spec, new Scope(defaults([config, spec.config])))\n    .toRuntime();\n}\n","import {isObject} from 'vega-util';\n\nexport default function(spec, config) {\n  spec = spec || config.autosize;\n  if (isObject(spec)) {\n    return spec;\n  } else {\n    spec = spec || 'pad';\n    return {type: spec};\n  }\n}\n","import axisConfig from './guides/axis-config';\nimport axisDomain from './guides/axis-domain';\nimport axisGrid from './guides/axis-grid';\nimport axisTicks from './guides/axis-ticks';\nimport axisLabels from './guides/axis-labels';\nimport axisTitle from './guides/axis-title';\nimport guideGroup from './guides/guide-group';\nimport {lookup} from './guides/guide-util';\nimport {AxisRole} from './marks/roles';\nimport parseMark from './mark';\nimport {encoder, extendEncode} from './encode/encode-util';\nimport {Skip} from './guides/constants';\nimport {ref, value} from '../util';\nimport {Collect, AxisTicks} from '../transforms';\n\nexport default function(spec, scope) {\n  var config = axisConfig(spec, scope),\n      encode = spec.encode || {},\n      axisEncode = encode.axis || {},\n      name = axisEncode.name || undefined,\n      interactive = axisEncode.interactive,\n      style = axisEncode.style,\n      datum, dataRef, ticksRef, size, group, children;\n\n  // single-element data source for axis group\n  datum = {\n    orient: spec.orient,\n    ticks:  !!lookup('ticks',  spec, config),\n    labels: !!lookup('labels', spec, config),\n    grid:   !!lookup('grid',   spec, config),\n    domain: !!lookup('domain', spec, config),\n    title:  !!value(spec.title, false)\n  };\n  dataRef = ref(scope.add(Collect({}, [datum])));\n\n  // encoding properties for axis group item\n  axisEncode = extendEncode({\n    update: {\n      range:        {signal: 'abs(span(range(\"' + spec.scale + '\")))'},\n      offset:       encoder(value(spec.offset, 0)),\n      position:     encoder(value(spec.position, 0)),\n      titlePadding: encoder(lookup('titlePadding', spec, config)),\n      minExtent:    encoder(lookup('minExtent', spec, config)),\n      maxExtent:    encoder(lookup('maxExtent', spec, config))\n    }\n  }, encode.axis, Skip);\n\n  // data source for axis ticks\n  ticksRef = ref(scope.add(AxisTicks({\n    scale:  scope.scaleRef(spec.scale),\n    extra:  scope.property(lookup('tickExtra', spec, config)),\n    count:  scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // generate axis marks\n  children = [];\n\n  // include axis gridlines if requested\n  if (datum.grid) {\n    children.push(axisGrid(spec, config, encode.grid, ticksRef));\n  }\n\n  // include axis ticks if requested\n  if (datum.ticks) {\n    size = lookup('tickSize', spec, config);\n    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size));\n  }\n\n  // include axis labels if requested\n  if (datum.labels) {\n    size = datum.ticks ? size : 0;\n    children.push(axisLabels(spec, config, encode.labels, ticksRef, size));\n  }\n\n  // include axis domain path if requested\n  if (datum.domain) {\n    children.push(axisDomain(spec, config, encode.domain, dataRef));\n  }\n\n  // include axis title if defined\n  if (datum.title) {\n    children.push(axisTitle(spec, config, encode.title, dataRef));\n  }\n\n  // build axis specification\n  group = guideGroup(AxisRole, style, name, dataRef, interactive, axisEncode, children);\n  if (spec.zindex) group.zindex = spec.zindex;\n\n  // parse axis specification\n  return parseMark(group, scope);\n}\n","import parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport {hasSignal, ref} from '../util';\nimport {Collect, Load, Relay, Sieve} from '../transforms';\nimport {array} from 'vega-util';\n\nexport default function parseData(data, scope) {\n  var transforms = [];\n\n  if (data.transform) {\n    data.transform.forEach(function(tx) {\n      transforms.push(parseTransform(tx, scope));\n    });\n  }\n\n  if (data.on) {\n    data.on.forEach(function(on) {\n      parseTrigger(on, scope, data.name);\n    });\n  }\n\n  scope.addDataPipeline(data.name, analyze(data, scope, transforms));\n}\n\n/**\n * Analyze a data pipeline, add needed operators.\n */\nfunction analyze(data, scope, ops) {\n  // POSSIBLE TODOs:\n  // - error checking for treesource on tree operators (BUT what if tree is upstream?)\n  // - this is local analysis, perhaps some tasks better for global analysis...\n\n  var output = [],\n      source = null,\n      modify = false,\n      generate = false,\n      upstream, i, n, t, m;\n\n  if (data.values) {\n    // hard-wired input data set\n    output.push(source = collect({\n      $ingest: data.values,\n      $format: data.format\n    }));\n  } else if (data.url) {\n    // load data from external source\n    // if either url or format has signal, use dynamic loader\n    // otherwise, request load upon dataflow init\n    source = (hasSignal(data.url) || hasSignal(data.format))\n      ? {$load: ref(scope.add(load(scope, data, source)))}\n      : {$request: data.url, $format: data.format};\n    output.push(source = collect(source));\n  } else if (data.source) {\n    // derives from one or more other data sets\n    source = upstream = array(data.source).map(function(d) {\n      return ref(scope.getData(d).output);\n    });\n    output.push(null); // populate later\n  }\n\n  // scan data transforms, add collectors as needed\n  for (i=0, n=ops.length; i<n; ++i) {\n    t = ops[i];\n    m = t.metadata;\n\n    if (!source && !m.source) {\n      output.push(source = collect());\n    }\n    output.push(t);\n\n    if (m.generates) generate = true;\n    if (m.modifies && !generate) modify = true;\n\n    if (m.source) source = t;\n    else if (m.changes) source = null;\n  }\n\n  if (upstream) {\n    n = upstream.length - 1;\n    output[0] = Relay({\n      derive: modify,\n      pulse: n ? upstream : upstream[0]\n    });\n    if (modify || n) {\n      // collect derived and multi-pulse tuples\n      output.splice(1, 0, collect());\n    }\n  }\n\n  if (!source) output.push(collect());\n  output.push(Sieve({}));\n  return output;\n}\n\nfunction collect(values) {\n  var s = Collect({}, values);\n  s.metadata = {source: true};\n  return s;\n}\n\nfunction load(scope, data) {\n  return Load({\n    url:    scope.property(data.url),\n    format: scope.objectProperty(data.format)\n  });\n}\n","import adjustSpatial from './encode/adjust-spatial';\nimport entry from './encode/entry';\nimport rule from './encode/rule';\nimport set from './encode/set';\nimport {isArray} from 'vega-util';\n\nexport default function parseEncode(encode, marktype, params, scope) {\n  var fields = {},\n      code = 'var o=item,datum=o.datum,$;',\n      channel, enc, value;\n\n  for (channel in encode) {\n    enc = encode[channel];\n    if (isArray(enc)) { // rule\n      code += rule(channel, enc, scope, params, fields);\n    } else {\n      value = entry(channel, enc, scope, params, fields);\n      code += set('o', channel, value);\n    }\n  }\n\n  code += adjustSpatial(encode, marktype);\n  code += 'return 1;';\n\n  return {\n    $expr:   code,\n    $fields: Object.keys(fields),\n    $output: Object.keys(encode)\n  };\n}\n","import {toSet} from 'vega-util';\n\nvar Skip = toSet(['rule']),\n    Swap = toSet(['group', 'image', 'rect']);\n\nexport default function(encode, marktype) {\n  var code = '';\n\n  if (Skip[marktype]) return code;\n\n  if (encode.x2) {\n    if (encode.x) {\n      if (Swap[marktype]) {\n        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n      }\n      code += 'o.width=o.x2-o.x;';\n    } else {\n      code += 'o.x=o.x2-(o.width||0);';\n    }\n  }\n\n  if (encode.xc) {\n    code += 'o.x=o.xc-(o.width||0)/2;';\n  }\n\n  if (encode.y2) {\n    if (encode.y) {\n      if (Swap[marktype]) {\n        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n      }\n      code += 'o.height=o.y2-o.y;';\n    } else {\n      code += 'o.y=o.y2-(o.height||0);';\n    }\n  }\n\n  if (encode.yc) {\n    code += 'o.y=o.yc-(o.height||0)/2;';\n  }\n\n  return code;\n}\n","import entry from './entry';\n\nexport default function(enc, scope, params, fields) {\n  function color(type, x, y, z) {\n    var a = entry(null, x, scope, params, fields),\n        b = entry(null, y, scope, params, fields),\n        c = entry(null, z, scope, params, fields);\n    return 'this.' + type + '(' + [a, b, c].join(',') + ').toString()';\n  }\n\n  return (enc.c) ? color('hcl', enc.h, enc.c, enc.l)\n    : (enc.h || enc.s) ? color('hsl', enc.h, enc.s, enc.l)\n    : (enc.l || enc.a) ? color('lab', enc.l, enc.a, enc.b)\n    : (enc.r || enc.g || enc.b) ? color('rgb', enc.r, enc.g, enc.b)\n    : null;\n}\n","import parseEncode from '../encode';\nimport {FrameRole, MarkRole} from '../marks/roles';\nimport {array, extend, isArray, isObject} from 'vega-util';\n\nexport function encoder(_) {\n  return isObject(_) ? extend({}, _) : {value: _};\n}\n\nexport function addEncode(object, name, value, set) {\n  if (value != null) {\n    if (isObject(value) && !isArray(value)) {\n      object.update[name] = value;\n    } else {\n      object[set || 'enter'][name] = {value: value};\n    }\n    // object[name] = isObject(value) && !isArray(value) ? value : {value: value};\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function extendEncode(encode, extra, skip) {\n  for (var name in extra) {\n    if (skip && skip.hasOwnProperty(name)) continue;\n    encode[name] = extend(encode[name] || {}, extra[name]);\n  }\n  return encode;\n}\n\nexport function encoders(encode, type, role, style, scope, params) {\n  var enc, key;\n  params = params || {};\n  params.encoders = {$encode: (enc = {})};\n\n  encode = applyDefaults(encode, type, role, style, scope.config);\n\n  for (key in encode) {\n    enc[key] = parseEncode(encode[key], type, params, scope);\n  }\n\n  return params;\n}\n\nfunction applyDefaults(encode, type, role, style, config) {\n  var enter = {}, key, skip, props;\n\n  // ignore legend and axis\n  if (role == 'legend' || String(role).indexOf('axis') === 0) {\n    role = null;\n  }\n\n  // resolve mark config\n  props = role === FrameRole ? config.group\n    : (role === MarkRole) ? extend({}, config.mark, config[type])\n    : null;\n\n  for (key in props) {\n    // do not apply defaults if relevant fields are defined\n    skip = has(key, encode)\n      || (key === 'fill' || key === 'stroke')\n      && (has('fill', encode) || has('stroke', encode));\n\n    if (!skip) enter[key] = defaultEncode(props[key]);\n  }\n\n  // resolve styles, apply with increasing precedence\n  array(style).forEach(function(name) {\n    var props = config.style && config.style[name];\n    for (var key in props) {\n      if (!has(key, encode)) {\n        enter[key] = defaultEncode(props[key]);\n      }\n    }\n  });\n\n  encode = extend({}, encode); // defensive copy\n  encode.enter = extend(enter, encode.enter);\n\n  return encode;\n}\n\nfunction defaultEncode(value) {\n  return value && value.signal\n    ? {signal: value.signal}\n    : {value: value};\n}\n\nexport function has(key, encode) {\n  return encode && (\n    (encode.enter && encode.enter[key]) ||\n    (encode.update && encode.update[key])\n  );\n}\n","import color from './color';\nimport field from './field';\nimport scale from './scale';\nimport gradient from './gradient';\nimport property from './property';\nimport expression from './expression';\nimport {stringValue} from 'vega-util';\n\nexport default function(channel, enc, scope, params, fields) {\n  if (enc.gradient != null) {\n    return gradient(enc, scope, params, fields);\n  }\n\n  var value = enc.signal ? expression(enc.signal, scope, params, fields)\n    : enc.color ? color(enc.color, scope, params, fields)\n    : enc.field != null ? field(enc.field, scope, params, fields)\n    : enc.value !== undefined ? stringValue(enc.value)\n    : undefined;\n\n  if (enc.scale != null) {\n    value = scale(enc, value, scope, params, fields);\n  }\n\n  if (value === undefined) {\n    value = null;\n  }\n\n  if (enc.exponent != null) {\n    value = 'Math.pow(' + value + ','\n      + property(enc.exponent, scope, params, fields) + ')';\n  }\n\n  if (enc.mult != null) {\n    value += '*' + property(enc.mult, scope, params, fields);\n  }\n\n  if (enc.offset != null) {\n    value += '+' + property(enc.offset, scope, params, fields);\n  }\n\n  if (enc.round) {\n    value = 'Math.round(' + value + ')';\n  }\n\n  return value;\n}\n","import expression from '../expression';\nimport {extend} from 'vega-util';\n\nexport default function(code, scope, params, fields) {\n  var expr = expression(code, scope);\n  expr.$fields.forEach(function(name) { fields[name] = 1; });\n  extend(params, expr.$params);\n  return expr.$expr;\n}\n","import expression from './expression';\nimport {error, isString, isObject, splitAccessPath, stringValue} from 'vega-util';\n\nexport default function(ref, scope, params, fields) {\n  return resolve(isObject(ref) ? ref : {datum: ref}, scope, params, fields);\n}\n\nfunction resolve(ref, scope, params, fields) {\n  var object, level, field;\n\n  if (ref.signal) {\n    object = 'datum';\n    field = expression(ref.signal, scope, params, fields);\n  } else if (ref.group || ref.parent) {\n    level = Math.max(1, ref.level || 1);\n    object = 'item';\n\n    while (level-- > 0) {\n      object += '.mark.group';\n    }\n\n    if (ref.parent) {\n      field = ref.parent;\n      object += '.datum';\n    } else {\n      field = ref.group;\n    }\n  } else if (ref.datum) {\n    object = 'datum';\n    field = ref.datum;\n  } else {\n    error('Invalid field reference: ' + stringValue(ref));\n  }\n\n  if (!ref.signal) {\n    if (isString(field)) {\n      fields[field] = 1; // TODO review field tracking?\n      field = splitAccessPath(field).map(stringValue).join('][');\n    } else {\n      field = resolve(field, scope, params, fields);\n    }\n  }\n\n  return object + '[' + field + ']';\n}\n","import {getScale} from './scale';\nimport {stringValue} from 'vega-util';\n\nexport default function(enc, scope, params, fields) {\n  return 'this.gradient('\n    + getScale(enc.gradient, scope, params, fields)\n    + ',' + stringValue(enc.start)\n    + ',' + stringValue(enc.stop)\n    + ',' + stringValue(enc.count)\n    + ')';\n}\n","import entry from './entry';\nimport {isObject} from 'vega-util';\n\nexport default function(property, scope, params, fields) {\n  return isObject(property)\n      ? '(' + entry(null, property, scope, params, fields) + ')'\n      : property;\n}\n","import entry from './entry';\nimport set from './set';\nimport expression from './expression';\nimport {peek} from 'vega-util';\n\nexport default function(channel, rules, scope, params, fields) {\n  var code = '';\n\n  rules.forEach(function(rule) {\n    var value = entry(channel, rule, scope, params, fields);\n    code += rule.test\n      ? expression(rule.test, scope, params, fields) + '?' + value + ':'\n      : value;\n  });\n\n  // if no else clause, terminate with null (vega/vega#1366)\n  if (peek(code) === ':') {\n    code += 'null';\n  }\n\n  return set('o', channel, code);\n}\n","import expression from './expression';\nimport field from './field';\nimport {scalePrefix} from '../expression/prefixes';\nimport {isString, stringValue} from 'vega-util';\n\nexport default function(enc, value, scope, params, fields) {\n  var scale = getScale(enc.scale, scope, params, fields),\n      interp, func, flag;\n\n  if (enc.range != null) {\n    // pull value from scale range\n    interp = +enc.range;\n    func = scale + '.range()';\n    value = (interp === 0) ? (func + '[0]')\n      : '($=' + func + ',' + ((interp === 1) ? '$[$.length-1]'\n      : '$[0]+' + interp + '*($[$.length-1]-$[0])') + ')';\n  } else {\n    // run value through scale and/or pull scale bandwidth\n    if (value !== undefined) value = scale + '(' + value + ')';\n\n    if (enc.band && (flag = hasBandwidth(enc.scale, scope))) {\n      func = scale + '.bandwidth';\n      interp = +enc.band;\n      interp = func + '()' + (interp===1 ? '' : '*' + interp);\n\n      // if we don't know the scale type, check for bandwidth\n      if (flag < 0) interp = '(' + func + '?' + interp + ':0)';\n\n      value = (value ? value + '+' : '') + interp;\n\n      if (enc.extra) {\n        // include logic to handle extraneous elements\n        value = '(datum.extra?' + scale + '(datum.extra.value):' + value + ')';\n      }\n    }\n\n    if (value == null) value = '0';\n  }\n\n  return value;\n}\n\nfunction hasBandwidth(name, scope) {\n  if (!isString(name)) return -1;\n  var type = scope.scaleType(name);\n  return type === 'band' || type === 'point' ? 1 : 0;\n}\n\nexport function getScale(name, scope, params, fields) {\n  var scaleName;\n\n  if (isString(name)) {\n    // direct scale lookup; add scale as parameter\n    scaleName = scalePrefix + name;\n    if (!params.hasOwnProperty(scaleName)) {\n      params[scaleName] = scope.scaleRef(name);\n    }\n    scaleName = stringValue(scaleName);\n  } else {\n    // indirect scale lookup; add all scales as parameters\n    for (scaleName in scope.scales) {\n      params[scalePrefix + scaleName] = scope.scaleRef(scaleName);\n    }\n    scaleName = stringValue(scalePrefix) + '+'\n      + (name.signal\n        ? '(' + expression(name.signal, scope, params, fields) + ')'\n        : field(name, scope, params, fields));\n  }\n\n  return '_[' + scaleName + ']';\n}\n","import {stringValue} from 'vega-util';\n\nexport default function(obj, key, value) {\n  return obj + '[' + stringValue(key) + ']=' + value + ';';\n}\n","import {codeGenerator, codegenParams} from './expression/codegen';\nimport {parse} from 'vega-expression';\nimport {error, isString, stringValue} from 'vega-util';\n\nexport var signalPrefix = '$';\n\nexport default function(expr, scope, preamble) {\n  var params = {}, ast, gen;\n\n  // parse the expression to an abstract syntax tree (ast)\n  try {\n    expr = isString(expr) ? expr : (stringValue(expr) + '');\n    ast = parse(expr);\n  } catch (err) {\n    error('Expression parse error: ' + expr);\n  }\n\n  // analyze ast function calls for dependencies\n  ast.visit(function visitor(node) {\n    if (node.type !== 'CallExpression') return;\n    var name = node.callee.name,\n        visit = codegenParams.visitors[name];\n    if (visit) visit(name, node.arguments, scope, params);\n  });\n\n  // perform code generation\n  gen = codeGenerator(ast);\n\n  // collect signal dependencies\n  gen.globals.forEach(function(name) {\n    var signalName = signalPrefix + name;\n    if (!params.hasOwnProperty(signalName) && scope.getSignal(name)) {\n      params[signalName] = scope.signalRef(name);\n    }\n  });\n\n  // return generated expression code and dependencies\n  return {\n    $expr:   preamble ? preamble + 'return(' + gen.code + ');' : gen.code,\n    $fields: gen.fields,\n    $params: params\n  };\n}\n","/**\n * Return an array with minimum and maximum values, in the\n * form [min, max]. Ignores null, undefined, and NaN values.\n */\nexport function extent(array) {\n  var i = 0, n, v, min, max;\n\n  if (array && (n = array.length)) {\n    // find first valid value\n    for (v = array[i]; v == null || v !== v; v = array[++i]);\n    min = max = v;\n\n    // visit all other values\n    for (; i<n; ++i) {\n      v = array[i];\n      // skip null/undefined; NaN will fail all comparisons\n      if (v != null) {\n        if (v < min) min = v;\n        if (v > max) max = v;\n      }\n    }\n  }\n\n  return [min, max];\n}\n\n/**\n * Predicate that returns true if the value lies within the span\n * of the given range. The left and right flags control the use\n * of inclusive (true) or exclusive (false) comparisons.\n */\nexport function inrange(value, range, left, right) {\n  var r0 = range[0], r1 = range[range.length-1], t;\n  if (r0 > r1) {\n    t = r0;\n    r0 = r1;\n    r1 = t;\n  }\n  left = left === undefined || left;\n  right = right === undefined || right;\n\n  return (left ? r0 <= value : r0 < value) &&\n    (right ? value <= r1 : value < r1);\n}\n\n/**\n * Span-preserving range clamp. If the span of the input range is less\n * than (max - min) and an endpoint exceeds either the min or max value,\n * the range is translated such that the span is preserved and one\n * endpoint touches the boundary of the min/max range.\n * If the span exceeds (max - min), the range [min, max] is returned.\n */\nexport function clampRange(range, min, max) {\n  var lo = range[0],\n      hi = range[1],\n      span;\n\n  if (hi < lo) {\n    span = hi;\n    hi = lo;\n    lo = span;\n  }\n  span = hi - lo;\n\n  return span >= (max - min)\n    ? [min, max]\n    : [\n        (lo = Math.min(Math.max(lo, min), max - span)),\n        lo + span\n      ];\n}\n\n/**\n * Return the numerical span of an array: the difference between\n * the last and first values.\n */\nexport function span(array) {\n  return (array[array.length-1] - array[0]) || 0;\n}\n","export var Literal = 'Literal';\nexport var Identifier = 'Identifier';\n","import {isTuple} from 'vega-dataflow';\nimport {codegen, constants, functions} from 'vega-expression';\nimport {random} from 'vega-statistics';\nimport {\n  isArray, isBoolean, isDate, isNumber, isObject, isRegExp, isString,\n  panLinear, panLog, panPow, zoomLinear, zoomLog, zoomPow,\n  toBoolean, toDate, toNumber, toString,\n  pad, peek, stringValue, truncate\n} from 'vega-util';\nimport {rgb, lab, hcl, hsl} from 'd3-color';\nimport {range as sequence} from 'd3-array';\n\nimport {\n  format, utcFormat, timeFormat, utcParse, timeParse,\n  monthFormat, monthAbbrevFormat,\n  dayFormat, dayAbbrevFormat\n} from './format';\nimport {extent, inrange, clampRange, span} from './arrays';\nimport {quarter, utcquarter} from './quarter';\nimport {warn, info, debug} from './log';\nimport inScope from './inscope';\nimport {pinchDistance, pinchAngle} from './pinch';\nimport {containerSize, screen, windowSize} from './window';\nimport flush from './flush';\nimport merge from './merge';\nimport {range, domain, bandwidth, bandspace, copy, scale, invert, scaleVisitor} from './scale';\nimport scaleGradient from './scale-gradient';\nimport {geoArea, geoBounds, geoCentroid} from './geo';\nimport {geoShape, pathShape} from './shape';\nimport {data, indata, setdata, dataVisitor, indataVisitor} from './data';\nimport {treePath, treeAncestors} from './tree';\nimport encode from './encode';\nimport modify from './modify';\nimport {vlSelectionTest, vlSelectionResolve, vlSelectionVisitor} from './selection';\nimport {vlPoint, vlPointDomain, vlMultiVisitor, vlInterval, vlIntervalDomain} from './selection.deprecated';\n\n// Expression function context object\nexport var functionContext = {\n  random: function() { return random(); }, // override default\n  isArray: isArray,\n  isBoolean: isBoolean,\n  isDate: isDate,\n  isNumber: isNumber,\n  isObject: isObject,\n  isRegExp: isRegExp,\n  isString: isString,\n  isTuple: isTuple,\n  toBoolean: toBoolean,\n  toDate: toDate,\n  toNumber: toNumber,\n  toString: toString,\n  pad: pad,\n  peek: peek,\n  truncate: truncate,\n  rgb: rgb,\n  lab: lab,\n  hcl: hcl,\n  hsl: hsl,\n  sequence: sequence,\n  format: format,\n  utcFormat: utcFormat,\n  utcParse: utcParse,\n  timeFormat: timeFormat,\n  timeParse: timeParse,\n  monthFormat: monthFormat,\n  monthAbbrevFormat: monthAbbrevFormat,\n  dayFormat: dayFormat,\n  dayAbbrevFormat: dayAbbrevFormat,\n  quarter: quarter,\n  utcquarter: utcquarter,\n  warn: warn,\n  info: info,\n  debug: debug,\n  extent: extent,\n  inScope: inScope,\n  clampRange: clampRange,\n  pinchDistance: pinchDistance,\n  pinchAngle: pinchAngle,\n  screen: screen,\n  containerSize: containerSize,\n  windowSize: windowSize,\n  span: span,\n  merge: merge,\n  flush: flush,\n  bandspace: bandspace,\n  inrange: inrange,\n  setdata: setdata,\n  pathShape: pathShape,\n  panLinear: panLinear,\n  panLog: panLog,\n  panPow: panPow,\n  zoomLinear: zoomLinear,\n  zoomLog: zoomLog,\n  zoomPow: zoomPow,\n  encode: encode,\n  modify: modify\n};\n\nvar eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'], // event functions\n    eventPrefix = 'event.vega.', // event function prefix\n    thisPrefix = 'this.', // function context prefix\n    astVisitors = {}; // AST visitors for dependency analysis\n\nexport function expressionFunction(name, fn, visitor) {\n  if (arguments.length === 1) {\n    return functionContext[name];\n  }\n\n  // register with the functionContext\n  functionContext[name] = fn;\n\n  // if there is an astVisitor register that, too\n  if (visitor) astVisitors[name] = visitor;\n\n  // if the code generator has already been initialized,\n  // we need to also register the function with it\n  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;\n  return this;\n}\n\n// register expression functions with ast visitors\nexpressionFunction('bandwidth', bandwidth, scaleVisitor);\nexpressionFunction('copy', copy, scaleVisitor);\nexpressionFunction('domain', domain, scaleVisitor);\nexpressionFunction('range', range, scaleVisitor);\nexpressionFunction('invert', invert, scaleVisitor);\nexpressionFunction('scale', scale, scaleVisitor);\nexpressionFunction('gradient', scaleGradient, scaleVisitor);\nexpressionFunction('geoArea', geoArea, scaleVisitor);\nexpressionFunction('geoBounds', geoBounds, scaleVisitor);\nexpressionFunction('geoCentroid', geoCentroid, scaleVisitor);\nexpressionFunction('geoShape', geoShape, scaleVisitor);\nexpressionFunction('indata', indata, indataVisitor);\nexpressionFunction('data', data, dataVisitor);\nexpressionFunction('treePath', treePath, dataVisitor);\nexpressionFunction('treeAncestors', treeAncestors, dataVisitor);\n\n// Vega-Lite selection functions.\nexpressionFunction('vlSelectionTest', vlSelectionTest, vlSelectionVisitor);\nexpressionFunction('vlSelectionResolve', vlSelectionResolve, vlSelectionVisitor);\n\n// Deprecated selection functions kept around to avoid a major version bump.\nexpressionFunction('vlSingle', vlPoint, dataVisitor);\nexpressionFunction('vlSingleDomain', vlPointDomain, dataVisitor);\nexpressionFunction('vlMulti', vlPoint, vlMultiVisitor);\nexpressionFunction('vlMultiDomain', vlPointDomain, vlMultiVisitor);\nexpressionFunction('vlInterval', vlInterval, dataVisitor);\nexpressionFunction('vlIntervalDomain', vlIntervalDomain, dataVisitor);\n\n// Build expression function registry\nfunction buildFunctions(codegen) {\n  var fn = functions(codegen);\n  eventFunctions.forEach(function(name) { fn[name] = eventPrefix + name; });\n  for (var name in functionContext) { fn[name] = thisPrefix + name; }\n  return fn;\n}\n\n// Export code generator and parameters\nexport var codegenParams = {\n  blacklist:  ['_'],\n  whitelist:  ['datum', 'event', 'item'],\n  fieldvar:   'datum',\n  globalvar:  function(id) { return '_[' + stringValue('$' + id) + ']'; },\n  functions:  buildFunctions,\n  constants:  constants,\n  visitors:   astVisitors\n};\n\nexport var codeGenerator = codegen(codegenParams);\n","import {Literal} from './ast';\nimport {dataPrefix, indexPrefix} from './prefixes';\nimport {error, truthy} from 'vega-util';\n\nexport function data(name) {\n  var data = this.context.data[name];\n  return data ? data.values.value : [];\n}\n\nexport function dataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) {\n    error('First argument to data functions must be a string literal.');\n  }\n\n  var data = args[0].value,\n      dataName = dataPrefix + data;\n\n  if (!params.hasOwnProperty(dataName)) {\n    params[dataName] = scope.getData(data).tuplesRef();\n  }\n}\n\nexport function indata(name, field, value) {\n  var index = this.context.data[name]['index:' + field],\n      entry = index ? index.value.get(value) : undefined;\n  return entry ? entry.count : entry;\n}\n\nexport function indataVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n  if (args[1].type !== Literal) error('Second argument to indata must be a string literal.');\n\n  var data = args[0].value,\n      field = args[1].value,\n      indexName = indexPrefix + field;\n\n  if (!params.hasOwnProperty(indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n}\n\nexport function setdata(name, tuples) {\n  var df = this.context.dataflow,\n      data = this.context.data[name],\n      input = data.input;\n\n  df.pulse(input, df.changeset().remove(truthy).insert(tuples));\n  return 1;\n}\n","export default function(item, name, retval) {\n  if (item) {\n    var df = this.context.dataflow,\n        target = item.mark.source;\n    df.pulse(target, df.changeset().encode(item, name));\n  }\n  return retval !== undefined ? retval : item;\n}\n","import {peek} from 'vega-util';\n\nexport default function(range, value, threshold, left, right, center) {\n  if (!threshold && threshold !== 0) return center;\n\n  var a = range[0],\n      b = peek(range),\n      t = +threshold,\n      l, r;\n\n  // swap endpoints if range is reversed\n  if (b < a) {\n    l = a; a = b; b = l;\n  }\n\n  // compare value to endpoints\n  l = Math.abs(value - a);\n  r = Math.abs(b - value);\n\n  // adjust if value within threshold distance of endpoint\n  return l < r && l <= t ? left : r <= t ? right : center;\n}\n","import {format as d3_format} from 'd3-format';\nimport {\n  timeFormat as d3_timeFormat,\n  timeParse as d3_timeParse,\n  utcFormat as d3_utcFormat,\n  utcParse as d3_utcParse\n} from 'd3-time-format';\n\nvar formatCache = {};\n\nfunction formatter(type, method, specifier) {\n  var k = type + ':' + specifier,\n      e = formatCache[k];\n  if (!e || e[0] !== method) {\n    formatCache[k] = (e = [method, method(specifier)]);\n  }\n  return e[1];\n}\n\nexport function format(_, specifier) {\n  return formatter('format', d3_format, specifier)(_);\n}\n\nexport function timeFormat(_, specifier) {\n  return formatter('timeFormat', d3_timeFormat, specifier)(_);\n}\n\nexport function utcFormat(_, specifier) {\n  return formatter('utcFormat', d3_utcFormat, specifier)(_);\n}\n\nexport function timeParse(_, specifier) {\n  return formatter('timeParse', d3_timeParse, specifier)(_);\n}\n\nexport function utcParse(_, specifier) {\n  return formatter('utcParse', d3_utcParse, specifier)(_);\n}\n\nvar dateObj = new Date(2000, 0, 1);\n\nfunction time(month, day, specifier) {\n  dateObj.setMonth(month);\n  dateObj.setDate(day);\n  return timeFormat(dateObj, specifier);\n}\n\nexport function monthFormat(month) {\n  return time(month, 1, '%B');\n}\n\nexport function monthAbbrevFormat(month) {\n  return time(month, 1, '%b');\n}\n\nexport function dayFormat(day) {\n  return time(0, 2 + day, '%A');\n}\n\nexport function dayAbbrevFormat(day) {\n  return time(0, 2 + day, '%a');\n}\n","import {\n  geoArea as area,\n  geoBounds as bounds,\n  geoCentroid as centroid\n} from 'd3-geo';\nimport {getScale} from './scale';\n\nfunction geoMethod(methodName, globalMethod) {\n  return function(projection, geojson, group) {\n    if (projection) {\n      // projection defined, use it\n      var p = getScale(projection, (group || this).context);\n      return p && p.path[methodName](geojson);\n    } else {\n      // projection undefined, use global method\n      return globalMethod(geojson);\n    }\n  };\n}\n\nexport var geoArea = geoMethod('area', area);\nexport var geoBounds = geoMethod('bounds', bounds);\nexport var geoCentroid = geoMethod('centroid', centroid);\n","export default function(item) {\n  var group = this.context.group,\n      value = false;\n\n  if (group) while (item) {\n    if (item === group) { value = true; break; }\n    item = item.mark.group;\n  }\n  return value;\n}\n","function log(df, method, args) {\n  try {\n    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));\n  } catch (err) {\n    df.warn(err);\n  }\n  return args[args.length-1];\n}\n\nexport function warn() {\n  return log(this.context.dataflow, 'warn', arguments);\n}\n\nexport function info() {\n  return log(this.context.dataflow, 'info', arguments);\n}\n\nexport function debug() {\n  return log(this.context.dataflow, 'debug', arguments);\n}\n","import {extend} from 'vega-util';\n\nexport default function() {\n  var args = [].slice.call(arguments);\n  args.unshift({});\n  return extend.apply(null, args);\n}\n","import {isTuple} from 'vega-dataflow';\nimport {isArray, truthy} from 'vega-util';\n\nfunction equal(a, b) {\n  return a === b || a !== a && b !== b ? true\n    : isArray(a) && isArray(b) && a.length === b.length ? equalArray(a, b)\n    : false;\n}\n\nfunction equalArray(a, b) {\n  for (var i=0, n=a.length; i<n; ++i) {\n    if (!equal(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nfunction removePredicate(props) {\n  return function(_) {\n    for (var key in props) {\n      if (!equal(_[key], props[key])) return false;\n    }\n    return true;\n  };\n}\n\nexport default function(name, insert, remove, toggle, modify, values) {\n  var df = this.context.dataflow,\n      data = this.context.data[name],\n      input = data.input,\n      changes = data.changes,\n      stamp = df.stamp(),\n      predicate, key;\n\n  if (df._trigger === false || !(input.value.length || insert || toggle)) {\n    // nothing to do!\n    return 0;\n  }\n\n  if (!changes || changes.stamp < stamp) {\n    data.changes = (changes = df.changeset());\n    changes.stamp = stamp;\n    df.runAfter(function() {\n      data.modified = true;\n      df.pulse(input, changes).run();\n    }, true, 1);\n  }\n\n  if (remove) {\n    predicate = remove === true ? truthy\n      : (isArray(remove) || isTuple(remove)) ? remove\n      : removePredicate(remove);\n    changes.remove(predicate);\n  }\n\n  if (insert) {\n    changes.insert(insert);\n  }\n\n  if (toggle) {\n    predicate = removePredicate(toggle);\n    if (input.value.some(predicate)) {\n      changes.remove(predicate);\n    } else {\n      changes.insert(toggle);\n    }\n  }\n\n  if (modify) {\n    for (key in values) {\n      changes.modify(modify, key, values[key]);\n    }\n  }\n\n  return 1;\n}\n","export function pinchDistance(event) {\n  var t = event.touches,\n      dx = t[0].clientX - t[1].clientX,\n      dy = t[0].clientY - t[1].clientY;\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nexport function pinchAngle(event) {\n  var t = event.touches;\n  return Math.atan2(\n    t[0].clientY - t[1].clientY,\n    t[0].clientX - t[1].clientX\n  );\n}\n","export var indexPrefix  = '@';\nexport var scalePrefix  = '%';\nexport var dataPrefix   = ':';\n","export function quarter(date) {\n  return 1 + ~~(new Date(date).getMonth() / 3);\n}\n\nexport function utcquarter(date) {\n  return 1 + ~~(new Date(date).getUTCMonth() / 3);\n}\n","import {getScale} from './scale';\nimport {Gradient} from 'vega-scenegraph';\nimport {scaleFraction} from 'vega-scale';\nimport {peek} from 'vega-util';\n\nexport default function(scale, p0, p1, count, group) {\n  scale = getScale(scale, (group || this).context);\n\n  var gradient = Gradient(p0, p1),\n      stops = scale.domain(),\n      min = stops[0],\n      max = peek(stops),\n      fraction = scaleFraction(scale, min, max);\n\n  if (scale.ticks) {\n    stops = scale.ticks(+count || 15);\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== peek(stops)) stops.push(max);\n  }\n\n  for (var i=0, n=stops.length; i<n; ++i) {\n    gradient.stop(fraction(stops[i]), scale(stops[i]));\n  }\n\n  return gradient;\n}\n","import {Literal, Identifier} from './ast';\nimport {scalePrefix} from './prefixes';\nimport {bandSpace} from 'vega-scale';\nimport {isArray, isFunction, isString} from 'vega-util';\n\nexport function getScale(name, ctx) {\n  var s;\n  return isFunction(name) ? name\n    : isString(name) ? (s = ctx.scales[name]) && s.value\n    : undefined;\n}\n\nfunction addScaleDependency(scope, params, name) {\n  var scaleName = scalePrefix + name;\n  if (!params.hasOwnProperty(scaleName)) {\n    try {\n      params[scaleName] = scope.scaleRef(name);\n    } catch (err) {\n      // TODO: error handling? warning?\n    }\n  }\n}\n\nexport function scaleVisitor(name, args, scope, params) {\n  if (args[0].type === Literal) {\n    // add scale dependency\n    addScaleDependency(scope, params, args[0].value);\n  }\n  else if (args[0].type === Identifier) {\n    // indirect scale lookup; add all scales as parameters\n    for (name in scope.scales) {\n      addScaleDependency(scope, params, name);\n    }\n  }\n}\n\nexport function range(name, group) {\n  var s = getScale(name, (group || this).context);\n  return s && s.range ? s.range() : [];\n}\n\nexport function domain(name, group) {\n  var s = getScale(name, (group || this).context);\n  return s ? s.domain() : [];\n}\n\nexport function bandwidth(name, group) {\n  var s = getScale(name, (group || this).context);\n  return s && s.bandwidth ? s.bandwidth() : 0;\n}\n\nexport function bandspace(count, paddingInner, paddingOuter) {\n  return bandSpace(count || 0, paddingInner || 0, paddingOuter || 0);\n}\n\nexport function copy(name, group) {\n  var s = getScale(name, (group || this).context);\n  return s ? s.copy() : undefined;\n}\n\nexport function scale(name, value, group) {\n  var s = getScale(name, (group || this).context);\n  return s ? s(value) : undefined;\n}\n\nexport function invert(name, range, group) {\n  var s = getScale(name, (group || this).context);\n  return !s ? undefined\n    : isArray(range) ? (s.invertRange || s.invert)(range)\n    : (s.invert || s.invertExtent)(range);\n}\n","import {inrange} from './arrays';\nimport {Literal} from './ast';\nimport {dataVisitor} from './data';\nimport {indexPrefix} from './prefixes';\nimport {error, field, isNumber, isString, isDate, toNumber} from 'vega-util';\n\nvar BIN = 'bin_',\n    INTERSECT = 'intersect',\n    UNION = 'union',\n    UNIT_INDEX = 'index:unit';\n\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      getter = entry.getter || (entry.getter = []),\n      n = fields.length,\n      i = 0, dval;\n\n  for (; i<n; ++i) {\n    getter[i] = getter[i] || field(fields[i]);\n    dval = getter[i](datum);\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (entry[BIN + fields[i]]) {\n      if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n      if (!inrange(dval, values[i], true, false)) return false;\n    } else if (dval !== values[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// TODO: revisit date coercion?\n// have selections populate with consistent types upon write?\n\nfunction testInterval(datum, entry) {\n  var ivals = entry.intervals,\n      n = ivals.length,\n      i = 0,\n      getter, extent, value;\n\n  for (; i<n; ++i) {\n    extent = ivals[i].extent;\n    getter = ivals[i].getter || (ivals[i].getter = field(ivals[i].field));\n    value = getter(datum);\n    if (!extent || extent[0] === extent[1]) return false;\n    if (isDate(value)) value = toNumber(value);\n    if (isDate(extent[0])) extent = ivals[i].extent = extent.map(toNumber);\n    if (isNumber(extent[0]) && !inrange(value, extent)) return false;\n    else if (isString(extent[0]) && extent.indexOf(value) < 0) return false;\n  }\n\n  return true;\n}\n\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @param {function(object,object):boolean} test - A boolean-valued test\n *   predicate for determining selection status within a single unit chart.\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\nfunction vlSelection(name, datum, op, test) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === INTERSECT,\n      n = entries.length,\n      i = 0,\n      entry, miss, count, unit, b;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit=entry.unit] || 0;\n\n      // if we've already matched this unit, skip.\n      if (count === -1) continue;\n\n      b = test(datum, entry);\n      miss[unit] = b ? -1 : ++count;\n\n      // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = test(datum, entry);\n\n      // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n      if (intersect ^ b) return b;\n    }\n  }\n\n  // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n  return n && intersect;\n}\n\n// Assumes point selection tuples are of the form:\n// {unit: string, encodings: array<string>, fields: array<string>, values: array<*>, bins: object}\nexport function vlPoint(name, datum, op) {\n  return vlSelection.call(this, name, datum, op, testPoint);\n}\n\n// Assumes interval selection typles are of the form:\n// {unit: string, intervals: array<{encoding: string, field:string, extent:array<number>}>}\nexport function vlInterval(name, datum, op) {\n  return vlSelection.call(this, name, datum, op, testInterval);\n}\n\nexport function vlMultiVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n\n  var data = args[0].value,\n      // vlMulti, vlMultiDomain have different # of params, but op is always last.\n      op = args.length >= 2 && args[args.length-1].value,\n      field = 'unit',\n      indexName = indexPrefix + field;\n\n  if (op === INTERSECT && !params.hasOwnProperty(indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n\n  dataVisitor(name, args, scope, params);\n}\n\n/**\n * Materializes a point selection as a scale domain.\n * @param {string} name - The name of the dataset representing the selection.\n * @param {string} [encoding] - A particular encoding channel to materialize.\n * @param {string} [field] - A particular field to materialize.\n * @param {string} [op='intersect'] - The set operation for combining selections.\n * One of 'intersect' (default) or 'union'.\n * @returns {array} An array of values to serve as a scale domain.\n */\nexport function vlPointDomain(name, encoding, field, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      entry = entries[0],\n      i = 0, n, index, values, continuous, units;\n\n  if (!entry) return undefined;\n\n  for (n = encoding ? entry.encodings.length : entry.fields.length; i<n; ++i) {\n    if ((encoding && entry.encodings[i] === encoding) ||\n        (field && entry.fields[i] === field)) {\n      index = i;\n      continuous = entry[BIN + entry.fields[i]];\n      break;\n    }\n  }\n\n  // multi selections union within the same unit and intersect across units.\n  // if we've got only one unit, enforce union for more efficient materialization.\n  if (unitIdx && unitIdx.size === 1) {\n    op = UNION;\n  }\n\n  if (unitIdx && op === INTERSECT) {\n    units = entries.reduce(function(acc, entry) {\n      var u = acc[entry.unit] || (acc[entry.unit] = []);\n      u.push({unit: entry.unit, value: entry.values[index]});\n      return acc;\n    }, {});\n\n    values = Object.keys(units).map(function(unit) {\n      return {\n        unit: unit,\n        value: continuous\n          ? continuousDomain(units[unit], UNION)\n          : discreteDomain(units[unit], UNION)\n      };\n    });\n  } else {\n    values = entries.map(function(entry) {\n      return {unit: entry.unit, value: entry.values[index]};\n    });\n  }\n\n  return continuous ? continuousDomain(values, op) : discreteDomain(values, op);\n}\n\n/**\n * Materializes an interval selection as a scale domain.\n * @param {string} name - The name of the dataset representing the selection.\n * @param {string} [encoding] - A particular encoding channel to materialize.\n * @param {string} [field] - A particular field to materialize.\n * @param {string} [op='union'] - The set operation for combining selections.\n * One of 'intersect' or 'union' (default).\n * @returns {array} An array of values to serve as a scale domain.\n */\nexport function vlIntervalDomain(name, encoding, field, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      entry = entries[0],\n      i = 0, n, interval, index, values, discrete;\n\n  if (!entry) return undefined;\n\n  for (n = entry.intervals.length; i<n; ++i) {\n    interval = entry.intervals[i];\n    if ((encoding && interval.encoding === encoding) ||\n        (field && interval.field === field)) {\n      if (!interval.extent) return undefined;\n      index = i;\n      discrete = interval.extent.length > 2;\n      break;\n    }\n  }\n\n  values = entries.reduce(function(acc, entry) {\n    var extent = entry.intervals[index].extent,\n        value = discrete\n           ? extent.map(function (d) { return {unit: entry.unit, value: d}; })\n           : {unit: entry.unit, value: extent};\n\n    if (discrete) {\n      acc.push.apply(acc, value);\n    } else {\n      acc.push(value);\n    }\n    return acc;\n  }, []);\n\n\n  return discrete ? discreteDomain(values, op) : continuousDomain(values, op);\n}\n\nfunction discreteDomain(entries, op) {\n  var units = {}, count = 0,\n      values = {}, domain = [],\n      i = 0, n = entries.length,\n      entry, unit, v, key;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n    unit  = entry.unit;\n    key   = entry.value;\n\n    if (!units[unit]) units[unit] = ++count;\n    if (!(v = values[key])) {\n      values[key] = v = {value: key, units: {}, count: 0};\n    }\n    if (!v.units[unit]) v.units[unit] = ++v.count;\n  }\n\n  for (key in values) {\n    v = values[key];\n    if (op === INTERSECT && v.count !== count) continue;\n    domain.push(v.value);\n  }\n\n  return domain.length ? domain : undefined;\n}\n\nfunction continuousDomain(entries, op) {\n  var merge = op === INTERSECT ? intersectInterval : unionInterval,\n      i = 0, n = entries.length,\n      extent, domain, lo, hi;\n\n  for (; i<n; ++i) {\n    extent = entries[i].value;\n    if (isDate(extent[0])) extent = extent.map(toNumber);\n    lo = extent[0];\n    hi = extent[1];\n    if (lo > hi) {\n      hi = extent[0];\n      lo = extent[1];\n    }\n    domain = domain ? merge(domain, lo, hi) : [lo, hi];\n  }\n\n  return domain && domain.length && (+domain[0] !== +domain[1])\n    ? domain\n    : undefined;\n}\n\nfunction unionInterval(domain, lo, hi) {\n  if (domain[0] > lo) domain[0] = lo;\n  if (domain[1] < hi) domain[1] = hi;\n  return domain;\n}\n\nfunction intersectInterval(domain, lo, hi) {\n  if (hi < domain[0] || domain[1] < lo) {\n    return [];\n  } else {\n    if (domain[0] < lo) domain[0] = lo;\n    if (domain[1] > hi) domain[1] = hi;\n  }\n  return domain;\n}\n","import {inrange} from './arrays';\nimport {Literal} from './ast';\nimport {dataVisitor} from './data';\nimport {indexPrefix} from './prefixes';\nimport {array, error, field, isArray, isDate, toNumber} from 'vega-util';\n\nvar TYPE_ENUM = 'E',\n    TYPE_RANGE_INC = 'R',\n    TYPE_RANGE_EXC = 'R-E',\n    TYPE_RANGE_LE = 'R-LE',\n    TYPE_RANGE_RE = 'R-RE',\n    INTERSECT = 'intersect',\n    UNION = 'union',\n    UNIT_INDEX = 'index:unit';\n\n// TODO: revisit date coercion?\nfunction testPoint(datum, entry) {\n  var fields = entry.fields,\n      values = entry.values,\n      n = fields.length,\n      i = 0, dval, f;\n\n  for (; i<n; ++i) {\n    f = fields[i];\n    f.getter = field.getter || field(f.field);\n    dval = f.getter(datum);\n\n    if (isDate(dval)) dval = toNumber(dval);\n    if (isDate(values[i])) values[i] = toNumber(values[i]);\n    if (isDate(values[i][0])) values[i] = values[i].map(toNumber);\n\n    if (f.type === TYPE_ENUM) {\n      // Enumerated fields can either specify individual values (single/multi selections)\n      // or an array of values (interval selections).\n      if(isArray(values[i]) ? values[i].indexOf(dval) < 0 : dval !== values[i]) {\n        return false;\n      }\n    } else {\n      if (f.type === TYPE_RANGE_INC) {\n        if (!inrange(dval, values[i])) return false;\n      } else if (f.type === TYPE_RANGE_RE) {\n        // Discrete selection of bins test within the range [bin_start, bin_end).\n        if (!inrange(dval, values[i], true, false)) return false;\n      } else if (f.type === TYPE_RANGE_EXC) { // 'R-E'/'R-LE' included for completeness.\n        if (!inrange(dval, values[i], false, false)) return false;\n      } else if (f.type === TYPE_RANGE_LE) {\n        if (!inrange(dval, values[i], false, true)) return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Tests if a tuple is contained within an interactive selection.\n * @param {string} name - The name of the data set representing the selection.\n *                 Tuples in the dataset are of the form\n *                 {unit: string, fields: array<fielddef>, values: array<*>}.\n *                 Fielddef is of the form\n *                 {field: string, channel: string, type: 'E' | 'R'} where\n *                 'type' identifies whether tuples in the dataset enumerate\n *                 values for the field, or specify a continuous range.\n * @param {object} datum - The tuple to test for inclusion.\n * @param {string} op - The set operation for combining selections.\n *   One of 'intersect' or 'union' (default).\n * @return {boolean} - True if the datum is in the selection, false otherwise.\n */\nexport function vlSelectionTest(name, datum, op) {\n  var data = this.context.data[name],\n      entries = data ? data.values.value : [],\n      unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,\n      intersect = op === INTERSECT,\n      n = entries.length,\n      i = 0,\n      entry, miss, count, unit, b;\n\n  for (; i<n; ++i) {\n    entry = entries[i];\n\n    if (unitIdx && intersect) {\n      // multi selections union within the same unit and intersect across units.\n      miss = miss || {};\n      count = miss[unit=entry.unit] || 0;\n\n      // if we've already matched this unit, skip.\n      if (count === -1) continue;\n\n      b = testPoint(datum, entry);\n      miss[unit] = b ? -1 : ++count;\n\n      // if we match and there are no other units return true\n      // if we've missed against all tuples in this unit return false\n      if (b && unitIdx.size === 1) return true;\n      if (!b && count === unitIdx.get(unit).count) return false;\n    } else {\n      b = testPoint(datum, entry);\n\n      // if we find a miss and we do require intersection return false\n      // if we find a match and we don't require intersection return true\n      if (intersect ^ b) return b;\n    }\n  }\n\n  // if intersecting and we made it here, then we saw no misses\n  // if not intersecting, then we saw no matches\n  // if no active selections, return false\n  return n && intersect;\n}\n\nexport function vlSelectionVisitor(name, args, scope, params) {\n  if (args[0].type !== Literal) error('First argument to indata must be a string literal.');\n\n  var data = args[0].value,\n      op = args.length >= 2 && args[args.length-1].value,\n      field = 'unit',\n      indexName = indexPrefix + field;\n\n  if (op === INTERSECT && !params.hasOwnProperty(indexName)) {\n    params[indexName] = scope.getData(data).indataRef(scope, field);\n  }\n\n  dataVisitor(name, args, scope, params);\n}\n\n/**\n * Resolves selection for use as a scale domain or reads via the API.\n * @param {string} name - The name of the dataset representing the selection\n * @param {string} [op='union'] - The set operation for combining selections.\n *                 One of 'intersect' or 'union' (default).\n * @returns {object} An object of selected fields and values.\n */\nexport function vlSelectionResolve(name, op) {\n  var data = this.context.data[name],\n    entries = data ? data.values.value : [],\n    resolved = {}, types = {},\n    entry, fields, values, unit, field, res, resUnit, type, union,\n    n = entries.length, i = 0, j, m;\n\n  // First union all entries within the same unit.\n  for (; i < n; ++i) {\n    entry = entries[i];\n    unit = entry.unit;\n    fields = entry.fields;\n    values = entry.values;\n\n    for (j = 0, m = fields.length; j < m; ++j) {\n      field = fields[j];\n      res = resolved[field.field] || (resolved[field.field] = {});\n      resUnit = res[unit] || (res[unit] = []);\n      types[field.field] = type = field.type.charAt(0);\n      union = ops[type + '_union'];\n      res[unit] = union(resUnit, array(values[j]));\n    }\n  }\n\n  // Then resolve fields across units as per the op.\n  op = op || UNION;\n  Object.keys(resolved).forEach(function (field) {\n    resolved[field] = Object.keys(resolved[field])\n      .map(function (unit) { return resolved[field][unit]; })\n      .reduce(function (acc, curr) {\n        return acc === undefined ? curr :\n          ops[types[field] + '_' + op](acc, curr);\n      });\n  });\n\n  return resolved;\n}\n\nvar ops = {\n  'E_union': function (base, value) {\n    if (!base.length) return value;\n\n    var i = 0, n = value.length;\n    for (; i<n; ++i) if (base.indexOf(value[i]) < 0) base.push(value[i]);\n    return base;\n  },\n\n  'E_intersect': function (base, value) {\n    return !base.length ? value :\n      base.filter(function (v) { return value.indexOf(v) >= 0; });\n  },\n\n  'R_union': function (base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (base[0] > lo) base[0] = lo;\n    if (base[1] < hi) base[1] = hi;\n    return base;\n  },\n\n  'R_intersect': function (base, value) {\n    var lo = toNumber(value[0]), hi = toNumber(value[1]);\n    if (lo > hi) {\n      lo = value[1];\n      hi = value[0];\n    }\n\n    if (!base.length) return [lo, hi];\n    if (hi < base[0] || base[1] < lo) {\n      return [];\n    } else {\n      if (base[0] < lo) base[0] = lo;\n      if (base[1] > hi) base[1] = hi;\n    }\n    return base;\n  }\n}\n","import {getScale} from './scale';\nimport {pathParse, pathRender} from 'vega-scenegraph';\n\nexport function geoShape(projection, geojson, group) {\n  var p = getScale(projection, (group || this).context);\n  return function(context) {\n    return p ? p.path.context(context)(geojson) : '';\n  }\n}\n\nexport function pathShape(path) {\n  var p = null;\n  return function(context) {\n    return context\n      ? pathRender(context, (p = p || pathParse(path)))\n      : path;\n  };\n}\n","import {data} from './data';\n\nvar EMPTY = {};\n\nfunction datum(d) { return d.data; }\n\nfunction treeNodes(name, context) {\n  var tree = data.call(context, name);\n  return tree.root && tree.root.lookup || EMPTY;\n}\n\nexport function treePath(name, source, target) {\n  var nodes = treeNodes(name, this),\n      s = nodes[source],\n      t = nodes[target];\n  return s && t ? s.path(t).map(datum) : undefined;\n}\n\nexport function treeAncestors(name, node) {\n  var n = treeNodes(name, this)[node];\n  return n ? n.ancestors().map(datum) : undefined;\n}\n","var _window = (typeof window !== 'undefined' && window) || null;\n\nexport function screen() {\n  return _window ? _window.screen : {};\n}\n\nexport function windowSize() {\n  return _window\n    ? [_window.innerWidth, _window.innerHeight]\n    : [undefined, undefined];\n}\n\nexport function containerSize() {\n  var view = this.context.dataflow,\n      el = view.container && view.container();\n  return el\n    ? [el.clientWidth, el.clientHeight]\n    : [undefined, undefined];\n}\n","import {Top, Bottom} from './constants';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scope) {\n  var config = scope.config,\n      orient = spec.orient,\n      xy = (orient === Top || orient === Bottom) ? config.axisX : config.axisY,\n      or = config['axis' + orient[0].toUpperCase() + orient.slice(1)],\n      band = scope.scaleType(spec.scale) === 'band' && config.axisBand;\n\n  return (xy || or || band)\n    ? extend({}, config.axis, xy, or, band)\n    : config.axis;\n}","import {Top, Bottom} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisDomainRole} from '../marks/roles';\nimport {addEncode} from '../encode/encode-util';\n\nexport default function(spec, config, userEncode, dataRef) {\n  var orient = spec.orient,\n      zero = {value: 0},\n      encode, enter, update, u, u2, v;\n\n  encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: {value: 1}\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncode(encode, 'stroke',        lookup('domainColor', spec, config));\n  addEncode(encode, 'strokeWidth',   lookup('domainWidth', spec, config));\n  addEncode(encode, 'strokeOpacity', lookup('domainOpacity', spec, config));\n\n  if (orient === Top || orient === Bottom) {\n    u = 'x';\n    v = 'y';\n  } else {\n    u = 'y';\n    v = 'x';\n  }\n  u2 = u + '2';\n\n  enter[v] = zero;\n  update[u] = enter[u] = position(spec, 0);\n  update[u2] = enter[u2] = position(spec, 1);\n\n  return guideMark(RuleMark, AxisDomainRole, null, null, dataRef, encode, userEncode);\n}\n\nfunction position(spec, pos) {\n  return {scale: spec.scale, range: pos};\n}\n","import {Left, Top, Bottom, Value} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisGridRole} from '../marks/roles';\nimport {addEncode} from '../encode/encode-util';\n\nexport default function(spec, config, userEncode, dataRef) {\n  var orient = spec.orient,\n      vscale = spec.gridScale,\n      sign = (orient === Left || orient === Top) ? 1 : -1,\n      offset = sign * spec.offset || 0,\n      zero = {value: 0},\n      encode, enter, exit, update, tickPos, u, v, v2, s;\n\n  encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: {value: 1}\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncode(encode, 'stroke',        lookup('gridColor', spec, config));\n  addEncode(encode, 'strokeDash',    lookup('gridDash', spec, config));\n  addEncode(encode, 'strokeOpacity', lookup('gridOpacity', spec, config));\n  addEncode(encode, 'strokeWidth',   lookup('gridWidth', spec, config));\n\n  tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   lookup('bandPosition', spec, config),\n    round:  lookup('tickRound', spec, config),\n    extra:  lookup('tickExtra', spec, config),\n    offset: lookup('tickOffset', spec, config)\n  };\n\n  if (orient === Top || orient === Bottom) {\n    u = 'x';\n    v = 'y';\n    s = 'height';\n  } else {\n    u = 'y';\n    v = 'x';\n    s = 'width';\n  }\n  v2 = v + '2';\n\n  update[u] = enter[u] = exit[u] = tickPos;\n\n  if (vscale) {\n    enter[v] = {scale: vscale, range: 0, mult: sign, offset: offset};\n    update[v2] = enter[v2] = {scale: vscale, range: 1, mult: sign, offset: offset};\n  } else {\n    enter[v] = {value: offset};\n    update[v2] = enter[v2] = {signal: s, mult: sign, offset: offset};\n  }\n\n  return guideMark(RuleMark, AxisGridRole, null, Value, dataRef, encode, userEncode);\n}\n","import {Top, Bottom, Left, Right, Label, Value, GuideLabelStyle} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisLabelRole} from '../marks/roles';\nimport {addEncode, encoder} from '../encode/encode-util';\nimport {deref} from '../../util';\n\nfunction flushExpr(scale, threshold, a, b, c) {\n  return {\n    signal: 'flush(range(\"' + scale + '\"), '\n      + 'scale(\"' + scale + '\", datum.value), '\n      + threshold + ',' + a + ',' + b + ',' + c + ')'\n  };\n}\n\nexport default function(spec, config, userEncode, dataRef, size) {\n  var orient = spec.orient,\n      sign = (orient === Left || orient === Top) ? -1 : 1,\n      isXAxis = (orient === Top || orient === Bottom),\n      scale = spec.scale,\n      flush = deref(lookup('labelFlush', spec, config)),\n      flushOffset = deref(lookup('labelFlushOffset', spec, config)),\n      flushOn = flush === 0 || !!flush,\n      labelAlign = lookup('labelAlign', spec, config),\n      labelBaseline = lookup('labelBaseline', spec, config),\n      zero = {value: 0},\n      encode, enter, tickSize, tickPos, align, baseline, offset, bound, overlap;\n\n  tickSize = encoder(size);\n  tickSize.mult = sign;\n  tickSize.offset = encoder(lookup('labelPadding', spec, config) || 0);\n  tickSize.offset.mult = sign;\n\n  tickPos = {\n    scale:  scale,\n    field:  Value,\n    band:   0.5,\n    offset: lookup('tickOffset', spec, config)\n  };\n\n  if (isXAxis) {\n    align = labelAlign || (flushOn\n      ? flushExpr(scale, flush, '\"left\"', '\"right\"', '\"center\"')\n      : 'center');\n    baseline = labelBaseline || (orient === Top ? 'bottom' : 'top');\n    offset = !labelAlign;\n  } else {\n\n    align = labelAlign || (orient === Right ? 'left' : 'right');\n    baseline = labelBaseline || (flushOn\n      ? flushExpr(scale, flush, '\"top\"', '\"bottom\"', '\"middle\"')\n      : 'middle');\n    offset = !labelBaseline;\n  }\n\n  offset = offset && flushOn && flushOffset\n    ? flushExpr(scale, flush, '-' + flushOffset, flushOffset, 0)\n    : null;\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: isXAxis ? tickPos : tickSize,\n      y: isXAxis ? tickSize : tickPos\n    },\n    update: {\n      opacity: {value: 1},\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero,\n      x: enter.x,\n      y: enter.y\n    }\n  };\n\n  addEncode(encode, isXAxis ? 'dx' : 'dy', offset);\n  addEncode(encode, 'align',       align);\n  addEncode(encode, 'baseline',    baseline);\n  addEncode(encode, 'angle',       lookup('labelAngle', spec, config));\n  addEncode(encode, 'fill',        lookup('labelColor', spec, config));\n  addEncode(encode, 'font',        lookup('labelFont', spec, config));\n  addEncode(encode, 'fontSize',    lookup('labelFontSize', spec, config));\n  addEncode(encode, 'fontWeight',  lookup('labelFontWeight', spec, config));\n  addEncode(encode, 'limit',       lookup('labelLimit', spec, config));\n  addEncode(encode, 'fillOpacity', lookup('labelOpacity', spec, config));\n  bound   = lookup('labelBound', spec, config);\n  overlap = lookup('labelOverlap', spec, config);\n\n  spec = guideMark(TextMark, AxisLabelRole, GuideLabelStyle, Value, dataRef, encode, userEncode);\n\n  // if overlap method or bound defined, request label overlap removal\n  if (overlap || bound) {\n    spec.overlap = {\n      method: overlap,\n      order:  'datum.index',\n      bound:  bound ? {scale: scale, orient: orient, tolerance: bound} : null\n    };\n  }\n\n  return spec;\n}\n","import {Top, Left, Bottom, Value} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {RuleMark} from '../marks/marktypes';\nimport {AxisTickRole} from '../marks/roles';\nimport {addEncode, encoder} from '../encode/encode-util';\n\nexport default function(spec, config, userEncode, dataRef, size) {\n  var orient = spec.orient,\n      sign = (orient === Left || orient === Top) ? -1 : 1,\n      zero = {value: 0},\n      encode, enter, exit, update, tickSize, tickPos;\n\n  encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: {value: 1}\n    },\n    exit: exit = {\n      opacity: zero\n    }\n  };\n  addEncode(encode, 'stroke',        lookup('tickColor', spec, config));\n  addEncode(encode, 'strokeOpacity', lookup('tickOpacity', spec, config));\n  addEncode(encode, 'strokeWidth',   lookup('tickWidth', spec, config));\n\n  tickSize = encoder(size);\n  tickSize.mult = sign;\n\n  tickPos = {\n    scale:  spec.scale,\n    field:  Value,\n    band:   lookup('bandPosition', spec, config),\n    round:  lookup('tickRound', spec, config),\n    extra:  lookup('tickExtra', spec, config),\n    offset: lookup('tickOffset', spec, config)\n  };\n\n  if (orient === Top || orient === Bottom) {\n    update.y = enter.y = zero;\n    update.y2 = enter.y2 = tickSize;\n    update.x = enter.x = exit.x = tickPos;\n  } else {\n    update.x = enter.x = zero;\n    update.x2 = enter.x2 = tickSize;\n    update.y = enter.y = exit.y = tickPos;\n  }\n\n  return guideMark(RuleMark, AxisTickRole, null, Value, dataRef, encode, userEncode);\n}\n","import {Top, Bottom, Left, GuideTitleStyle} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {encoder, has} from '../encode/encode-util';\nimport {TextMark} from '../marks/marktypes';\nimport {AxisTitleRole} from '../marks/roles';\nimport {addEncode} from '../encode/encode-util';\n\nexport default function(spec, config, userEncode, dataRef) {\n  var orient = spec.orient,\n      sign = (orient === Left || orient === Top) ? -1 : 1,\n      horizontal = (orient === Top || orient === Bottom),\n      zero = {value: 0},\n      encode, enter, update, titlePos;\n\n  encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: {value: 1},\n      text: encoder(spec.title)\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  titlePos = {\n    scale: spec.scale,\n    range: 0.5\n  };\n\n  if (horizontal) {\n    update.x = titlePos;\n    enter.angle = {value: 0};\n    enter.baseline = {value: orient === Top ? 'bottom' : 'top'};\n  } else {\n    update.y = titlePos;\n    enter.angle = {value: sign * 90};\n    enter.baseline = {value: 'bottom'};\n  }\n\n  addEncode(encode, 'align',       lookup('titleAlign', spec, config));\n  addEncode(encode, 'angle',       lookup('titleAngle', spec, config));\n  addEncode(encode, 'baseline',    lookup('titleBaseline', spec, config));\n  addEncode(encode, 'fill',        lookup('titleColor', spec, config));\n  addEncode(encode, 'font',        lookup('titleFont', spec, config));\n  addEncode(encode, 'fontSize',    lookup('titleFontSize', spec, config));\n  addEncode(encode, 'fontWeight',  lookup('titleFontWeight', spec, config));\n  addEncode(encode, 'limit',       lookup('titleLimit', spec, config));\n  addEncode(encode, 'fillOpacity', lookup('titleOpacity', spec, config));\n\n  !addEncode(encode, 'x', lookup('titleX', spec, config), 'update')\n    && horizontal && !has('x', userEncode)\n    && (encode.enter.auto = {value: true});\n\n  !addEncode(encode, 'y', lookup('titleY', spec, config), 'update')\n    && !horizontal && !has('y', userEncode)\n    && (encode.enter.auto = {value: true});\n\n  return guideMark(TextMark, AxisTitleRole, GuideTitleStyle, null, dataRef, encode, userEncode);\n}\n","export var Top = 'top';\nexport var Left = 'left';\nexport var Right = 'right';\nexport var Bottom = 'bottom';\nexport var Center = 'center';\n\nexport var Vertical = 'vertical';\n\nexport var Start = 'start';\nexport var Middle = 'middle';\nexport var End = 'end';\n\nexport var Index  = 'index';\nexport var Label  = 'label';\nexport var Offset = 'offset';\nexport var Perc   = 'perc';\nexport var Perc2  = 'perc2';\nexport var Size   = 'size';\nexport var Value  = 'value';\n\nexport var GuideLabelStyle = 'guide-label';\nexport var GuideTitleStyle = 'guide-title';\nexport var GroupTitleStyle = 'group-title';\n\nexport var Symbols = 'symbol';\nexport var Gradient = 'gradient';\nexport var Discrete = 'discrete';\n\n// Encoding channels supported by legends\n// In priority order of 'canonical' scale\nexport var LegendScales = [\n  'size',\n  'shape',\n  'fill',\n  'stroke',\n  'strokeDash',\n  'opacity'\n];\n\nexport var Skip = {\n  name: 1,\n  interactive: 1\n};\n","import {GroupMark} from '../marks/marktypes';\n\nexport default function(role, style, name, dataRef, interactive, encode, marks, layout) {\n  return {\n    type: GroupMark,\n    name: name,\n    role: role,\n    style: style,\n    from: dataRef,\n    interactive: interactive || false,\n    encode: encode,\n    marks: marks,\n    layout: layout\n  };\n}\n","import {Skip} from './constants';\nimport {extendEncode} from '../encode/encode-util';\n\nexport default function(type, role, style, key, dataRef, encode, extras) {\n  return {\n    type:  type,\n    name:  extras ? extras.name : undefined,\n    role:  role,\n    style: (extras && extras.style) || style,\n    key:   key,\n    from:  dataRef,\n    interactive: !!(extras && extras.interactive),\n    encode: extendEncode(encode, extras, Skip)\n  };\n}\n","import {Vertical} from './constants';\nimport {value} from '../../util';\n\nexport function lookup(name, spec, config) {\n  return value(spec[name], config[name]);\n}\n\nexport function isVertical(spec, configVal) {\n  return value(spec.direction, configVal) === Vertical;\n}\n\nexport function gradientLength(spec, config) {\n  return value(\n    spec.gradientLength,\n    config.gradientLength || config.gradientWidth\n  );\n}\n\nexport function gradientThickness(spec, config) {\n  return value(\n    spec.gradientThickness,\n    config.gradientThickness || config.gradientHeight\n  );\n}\n\nexport function entryColumns(spec, config) {\n  return value(\n    spec.columns,\n    value(config.columns, +isVertical(spec, config.symbolDirection))\n  );\n}\n\nexport function getEncoding(name, encode) {\n  var v = encode && (\n    (encode.update && encode.update[name]) ||\n    (encode.enter && encode.enter[name])\n  );\n  return v && v.signal ? v : v ? v.value : null;\n}\n\nexport function getStyle(name, scope, style) {\n  var s = scope.config.style[style];\n  return s && s[name];\n}\n","import {Value, Perc, Perc2} from './constants';\nimport guideMark from './guide-mark';\nimport {gradientLength, gradientThickness, isVertical, lookup} from './guide-util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendBandRole} from '../marks/roles';\nimport {addEncode, encoder} from '../encode/encode-util';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode, dataRef) {\n  var zero = {value: 0},\n      vertical = isVertical(spec, config.gradientDirection),\n      thickness = gradientThickness(spec, config),\n      length = gradientLength(spec, config),\n      encode, enter, u, v, uu, vv, adjust = '';\n\n  vertical\n    ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-')\n    : (u = 'x', uu = 'x2', v = 'y', vv = 'height');\n\n  enter = {\n    opacity: zero,\n    fill: {scale: scale, field: Value}\n  };\n  enter[u]  = {signal: adjust + 'datum.' + Perc, mult: length};\n  enter[v]  = zero;\n  enter[uu] = {signal: adjust + 'datum.' + Perc2, mult: length};\n  enter[vv] = encoder(thickness);\n\n  encode = {\n    enter: enter,\n    update: extend({}, enter, {opacity: {value: 1}}),\n    exit: {opacity: zero}\n  };\n  addEncode(encode, 'stroke',      lookup('gradientStrokeColor', spec, config));\n  addEncode(encode, 'strokeWidth', lookup('gradientStrokeWidth', spec, config));\n  addEncode(encode, 'opacity',     lookup('gradientOpacity', spec, config), 'update');\n\n  return guideMark(RectMark, LegendBandRole, null, Value, dataRef, encode, userEncode);\n}\n","import {Index, Label, Perc, Value, GuideLabelStyle} from './constants';\nimport guideMark from './guide-mark';\nimport {gradientLength, gradientThickness, isVertical, lookup} from './guide-util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendLabelRole} from '../marks/roles';\nimport {addEncode, encoder} from '../encode/encode-util';\nimport {value} from '../../util';\n\nvar alignExpr = 'datum.' + Perc + '<=0?\"left\"'\n  + ':datum.' + Perc + '>=1?\"right\":\"center\"';\n\nvar baselineExpr = 'datum.' + Perc + '<=0?\"bottom\"'\n  + ':datum.' + Perc + '>=1?\"top\":\"middle\"';\n\nexport default function(spec, config, userEncode, dataRef) {\n  var zero = {value: 0},\n      vertical = isVertical(spec, config.gradientDirection),\n      thickness = encoder(gradientThickness(spec, config)),\n      length = gradientLength(spec, config),\n      overlap = lookup('labelOverlap', spec, config),\n      encode, enter, update, u, v, adjust = '';\n\n  encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: {value: 1},\n      text: {field: Label}\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncode(encode, 'fill',        lookup('labelColor', spec, config));\n  addEncode(encode, 'font',        lookup('labelFont', spec, config));\n  addEncode(encode, 'fontSize',    lookup('labelFontSize', spec, config));\n  addEncode(encode, 'fontWeight',  lookup('labelFontWeight', spec, config));\n  addEncode(encode, 'fillOpacity', lookup('labelOpacity', spec, config));\n  addEncode(encode, 'limit',       value(spec.labelLimit, config.gradientLabelLimit));\n\n  if (vertical) {\n    enter.align = {value: 'left'};\n    enter.baseline = update.baseline = {signal: baselineExpr};\n    u = 'y'; v = 'x'; adjust = '1-';\n  } else {\n    enter.align = update.align = {signal: alignExpr};\n    enter.baseline = {value: 'top'};\n    u = 'x'; v = 'y';\n  }\n\n  enter[u] = update[u] = {signal: adjust + 'datum.' + Perc, mult: length};\n\n  enter[v] = update[v] = thickness;\n  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;\n\n  spec = guideMark(TextMark, LegendLabelRole, GuideLabelStyle, Value, dataRef, encode, userEncode);\n  if (overlap) spec.overlap = {method: overlap, order:  'datum.' + Index};\n  return spec;\n}\n","import guideMark from './guide-mark';\nimport {gradientLength, gradientThickness, isVertical, lookup} from './guide-util';\nimport {RectMark} from '../marks/marktypes';\nimport {LegendGradientRole} from '../marks/roles';\nimport {addEncode, encoder} from '../encode/encode-util';\nimport {extend} from 'vega-util';\n\nexport default function(spec, scale, config, userEncode) {\n  var zero = {value: 0},\n      vertical = isVertical(spec, config.gradientDirection),\n      thickness = gradientThickness(spec, config),\n      length = gradientLength(spec, config),\n      encode, enter, start, stop, width, height;\n\n  if (vertical) {\n    start = [0, 1];\n    stop = [0, 0];\n    width = thickness;\n    height = length;\n  } else {\n    start = [0, 0];\n    stop = [1, 0];\n    width = length;\n    height = thickness;\n  }\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: zero,\n      y: zero,\n      width: encoder(width),\n      height: encoder(height)\n    },\n    update: extend({}, enter, {\n      opacity: {value: 1},\n      fill: {gradient: scale, start: start, stop: stop}\n    }),\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncode(encode, 'stroke',      lookup('gradientStrokeColor', spec, config));\n  addEncode(encode, 'strokeWidth', lookup('gradientStrokeWidth', spec, config));\n  addEncode(encode, 'opacity',     lookup('gradientOpacity', spec, config), 'update');\n\n  return guideMark(RectMark, LegendGradientRole, null, undefined, undefined, encode, userEncode);\n}\n","import {\n  Index, Label, Offset, Size, Value,\n  Skip, GuideLabelStyle, LegendScales\n} from './constants';\nimport guideGroup from './guide-group';\nimport guideMark from './guide-mark';\nimport {entryColumns, isVertical, lookup} from './guide-util';\nimport {SymbolMark, TextMark} from '../marks/marktypes';\nimport {ScopeRole, LegendSymbolRole, LegendLabelRole} from '../marks/roles';\nimport {addEncode, encoder, extendEncode} from '../encode/encode-util';\n\nvar zero = {value: 0};\n\n// userEncode is top-level, includes entries, symbols, labels\nexport default function(spec, config, userEncode, dataRef, columns) {\n  var entries = userEncode.entries,\n      interactive = !!(entries && entries.interactive),\n      name = entries ? entries.name : undefined,\n      height = lookup('clipHeight', spec, config),\n      symbolOffset = lookup('symbolOffset', spec, config),\n      valueRef = {data: 'value'},\n      encode = {},\n      xSignal = columns + '?' + 'datum.' + Offset + ':' + 'datum.' + Size,\n      yEncode = height ? encoder(height) : {field: Size},\n      index = 'datum.' + Index,\n      ncols = 'max(1,' + columns + ')',\n      enter, update, labelOffset, symbols, labels, nrows, sort;\n\n  yEncode.mult = 0.5;\n\n  // -- LEGEND SYMBOLS --\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, mult: 0.5, offset: symbolOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: {value: 1},\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  if (!spec.fill) {\n    addEncode(encode, 'fill',   config.symbolBaseFillColor);\n    addEncode(encode, 'stroke', config.symbolBaseStrokeColor);\n  }\n  addEncode(encode, 'shape',       lookup('symbolType', spec, config));\n  addEncode(encode, 'size',        lookup('symbolSize', spec, config));\n  addEncode(encode, 'strokeWidth', lookup('symbolStrokeWidth', spec, config));\n  addEncode(encode, 'fill',        lookup('symbolFillColor', spec, config));\n  addEncode(encode, 'stroke',      lookup('symbolStrokeColor', spec, config));\n  addEncode(encode, 'opacity',     lookup('symbolOpacity', spec, config), 'update');\n\n  LegendScales.forEach(function(scale) {\n    if (spec[scale]) {\n      update[scale] = enter[scale] = {scale: spec[scale], field: Value};\n    }\n  });\n\n  symbols = guideMark(\n    SymbolMark, LegendSymbolRole, null,\n    Value, valueRef, encode, userEncode.symbols\n  );\n  if (height) symbols.clip = true;\n\n  // -- LEGEND LABELS --\n  labelOffset = encoder(symbolOffset);\n  labelOffset.offset = lookup('labelOffset', spec, config);\n\n  encode = {\n    enter:  enter = {\n      opacity: zero,\n      x: {signal: xSignal, offset: labelOffset},\n      y: yEncode\n    },\n    update: update = {\n      opacity: {value: 1},\n      text: {field: Label},\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  addEncode(encode, 'align',       lookup('labelAlign', spec, config));\n  addEncode(encode, 'baseline',    lookup('labelBaseline', spec, config));\n  addEncode(encode, 'fill',        lookup('labelColor', spec, config));\n  addEncode(encode, 'font',        lookup('labelFont', spec, config));\n  addEncode(encode, 'fontSize',    lookup('labelFontSize', spec, config));\n  addEncode(encode, 'fontWeight',  lookup('labelFontWeight', spec, config));\n  addEncode(encode, 'limit',       lookup('labelLimit', spec, config));\n  addEncode(encode, 'fillOpacity', lookup('labelOpacity', spec, config));\n\n  labels = guideMark(\n    TextMark, LegendLabelRole, GuideLabelStyle,\n    Value, valueRef, encode, userEncode.labels\n  );\n\n  // -- LEGEND ENTRY GROUPS --\n  encode = {\n    enter: {\n      noBound: {value: true}, // ignore width/height in bounds calc\n      width: zero,\n      height: height ? encoder(height) : zero,\n      opacity: zero\n    },\n    exit: {opacity: zero},\n    update: update = {\n      opacity: {value: 1},\n      row: {signal: null},\n      column: {signal: null}\n    }\n  };\n\n  // annotate and sort groups to ensure correct ordering\n  if (isVertical(spec, config.symbolDirection)) {\n    nrows = 'ceil(item.mark.items.length/' + ncols + ')';\n    update.row.signal = index + '%' + nrows;\n    update.column.signal = 'floor(' + index + '/' + nrows + ')';\n    sort = {field: ['row', index]};\n  } else {\n    update.row.signal = 'floor(' + index + '/' + ncols + ')';\n    update.column.signal = index + '%' + ncols;\n    sort = {field: index};\n  }\n  // handle zero column case (implies infinite columns)\n  update.column.signal = columns + '?' + update.column.signal + ':' + index;\n\n  // facet legend entries into sub-groups\n  dataRef = {facet: {data: dataRef, name: 'value', groupby: Index}};\n\n  spec = guideGroup(\n    ScopeRole, null, name, dataRef, interactive,\n    extendEncode(encode, entries, Skip), [symbols, labels]\n  );\n  spec.sort = sort;\n  return spec;\n}\n\nexport function legendSymbolLayout(spec, config) {\n  // layout parameters for legend entries\n  return {\n    align:   lookup('gridAlign', spec, config),\n    center:  {row: true, column: false},\n    columns: entryColumns(spec, config),\n    padding: {\n      row:    lookup('rowPadding', spec, config),\n      column: lookup('columnPadding', spec, config)\n    }\n  };\n}\n","import {GuideTitleStyle} from './constants';\nimport guideMark from './guide-mark';\nimport {lookup} from './guide-util';\nimport {TextMark} from '../marks/marktypes';\nimport {LegendTitleRole} from '../marks/roles';\nimport {addEncode, encoder} from '../encode/encode-util';\n\nexport default function(spec, config, userEncode, dataRef) {\n  var zero = {value: 0},\n      encode, enter;\n\n  encode = {\n    enter: enter = {\n      opacity: zero,\n      x: {field: {group: 'padding'}},\n      y: {field: {group: 'padding'}}\n    },\n    update: {\n      opacity: {value: 1},\n      text: encoder(spec.title),\n      x: enter.x,\n      y: enter.y\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n  addEncode(encode, 'align',       lookup('titleAlign', spec, config));\n  addEncode(encode, 'baseline',    lookup('titleBaseline', spec, config));\n  addEncode(encode, 'fill',        lookup('titleColor', spec, config));\n  addEncode(encode, 'font',        lookup('titleFont', spec, config));\n  addEncode(encode, 'fontSize',    lookup('titleFontSize', spec, config));\n  addEncode(encode, 'fontWeight',  lookup('titleFontWeight', spec, config));\n  addEncode(encode, 'limit',       lookup('titleLimit', spec, config));\n  addEncode(encode, 'fillOpacity', lookup('titleOpacity', spec, config));\n\n  return guideMark(TextMark, LegendTitleRole, GuideTitleStyle, null, dataRef, encode, userEncode);\n}\n","import {\n  GuideLabelStyle, Skip,\n  Symbols, Gradient, Discrete, LegendScales\n} from './guides/constants';\nimport legendGradient from './guides/legend-gradient';\nimport legendGradientDiscrete from './guides/legend-gradient-discrete';\nimport legendGradientLabels from './guides/legend-gradient-labels';\nimport {default as legendSymbolGroups, legendSymbolLayout} from './guides/legend-symbol-groups';\nimport legendTitle from './guides/legend-title';\nimport guideGroup from './guides/guide-group';\nimport {getEncoding, getStyle, gradientLength, lookup} from './guides/guide-util';\nimport parseExpression from './expression';\nimport parseMark from './mark';\nimport {isContinuous, isDiscretizing} from './scale';\nimport {LegendRole, LegendEntryRole} from './marks/roles';\nimport {addEncode, extendEncode} from './encode/encode-util';\nimport {ref, deref} from '../util';\nimport {Collect, LegendEntries} from '../transforms';\nimport {error} from 'vega-util';\n\nexport default function(spec, scope) {\n  var config = scope.config.legend,\n      encode = spec.encode || {},\n      legendEncode = encode.legend || {},\n      name = legendEncode.name || undefined,\n      interactive = legendEncode.interactive,\n      style = legendEncode.style,\n      entryEncode, entryLayout, params, children,\n      type, datum, dataRef, entryRef, group;\n\n  // resolve 'canonical' scale name\n  var scale = LegendScales.reduce(function(a, b) { return a || spec[b]; }, 0);\n  if (!scale) error('Missing valid scale for legend.');\n\n  // resolve legend type (symbol, gradient, or discrete gradient)\n  type = legendType(spec, scope.scaleType(scale));\n\n  // single-element data source for legend group\n  datum = {\n    orient: lookup('orient', spec, config),\n    title:  spec.title != null,\n    type:   type\n  };\n  dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // encoding properties for legend group\n  legendEncode = extendEncode(\n    buildLegendEncode(spec, config),legendEncode, Skip\n  );\n\n  // encoding properties for legend entry sub-group\n  entryEncode = {enter: {x: {value: 0}, y: {value: 0}}};\n\n  // data source for legend values\n  entryRef = ref(scope.add(LegendEntries(params = {\n    type:   type,\n    scale:  scope.scaleRef(scale),\n    count:  scope.objectProperty(spec.tickCount),\n    values: scope.objectProperty(spec.values),\n    formatSpecifier: scope.property(spec.format)\n  })));\n\n  // continuous gradient legend\n  if (type === Gradient) {\n    children = [\n      legendGradient(spec, scale, config, encode.gradient),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n    // adjust default tick count based on the gradient length\n    params.count = params.count || scope.signalRef(\n      'max(2,2*floor((' + deref(gradientLength(spec, config)) + ')/100))'\n    );\n  }\n\n  // discrete gradient legend\n  else if (type === Discrete) {\n    children = [\n      legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef),\n      legendGradientLabels(spec, config, encode.labels, entryRef)\n    ];\n  }\n\n  // symbol legend\n  else {\n    // determine legend symbol group layout\n    entryLayout = legendSymbolLayout(spec, config);\n    children = [\n      legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))\n    ];\n    // pass symbol size information to legend entry generator\n    params.size = sizeExpression(spec, scope, children[0].marks);\n  }\n\n  // generate legend marks\n  children = [\n    guideGroup(LegendEntryRole, null, null, dataRef, interactive,\n               entryEncode, children, entryLayout)\n  ];\n\n  // include legend title if defined\n  if (datum.title) {\n    children.push(legendTitle(spec, config, encode.title, dataRef));\n  }\n\n  // build legend specification\n  group = guideGroup(LegendRole, style, name, dataRef, interactive, legendEncode, children);\n  if (spec.zindex) group.zindex = spec.zindex;\n\n  // parse legend specification\n  return parseMark(group, scope);\n}\n\nfunction legendType(spec, scaleType) {\n  var type = spec.type || Symbols;\n\n  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {\n    type = isContinuous(scaleType) ? Gradient\n      : isDiscretizing(scaleType) ? Discrete\n      : Symbols;\n  }\n\n  return type !== Gradient ? type\n    : isDiscretizing(scaleType) ? Discrete\n    : Gradient;\n}\n\nfunction scaleCount(spec) {\n  return LegendScales.reduce(function(count, type) {\n    return count + (spec[type] ? 1 : 0);\n  }, 0);\n}\n\nfunction buildLegendEncode(spec, config) {\n  var encode = {enter: {}, update: {}};\n\n  addEncode(encode, 'offset',       lookup('offset', spec, config));\n  addEncode(encode, 'padding',      lookup('padding', spec, config));\n  addEncode(encode, 'titlePadding', lookup('titlePadding', spec, config));\n  addEncode(encode, 'fill',         lookup('fillColor', spec, config));\n  addEncode(encode, 'stroke',       lookup('strokeColor', spec, config));\n  addEncode(encode, 'strokeWidth',  lookup('strokeWidth', spec, config));\n  addEncode(encode, 'cornerRadius', lookup('cornerRadius', spec, config));\n  addEncode(encode, 'strokeDash',   config.strokeDash);\n\n  return encode;\n}\n\nfunction sizeExpression(spec, scope, marks) {\n  var fontSize, size, strokeWidth, expr;\n\n  strokeWidth = getEncoding('strokeWidth', marks[0].encode);\n\n  size = spec.size ? 'scale(\"' + spec.size + '\",datum)'\n    : getEncoding('size', marks[0].encode, scope);\n\n  fontSize = getFontSize(marks[1].encode, scope, GuideLabelStyle);\n\n  expr = 'max('\n    + 'ceil(sqrt(' + deref(size) + ')+' + deref(strokeWidth) + '),'\n    + deref(fontSize)\n    + ')';\n\n  return parseExpression(expr, scope);\n}\n\nfunction getFontSize(encode, scope, style) {\n  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);\n}\n","import clip from './marks/clip';\nimport definition from './marks/definition';\nimport interactive from './marks/interactive';\nimport parseData from './marks/data';\nimport parseFacet from './marks/facet';\nimport parseSubflow from './marks/subflow';\nimport getRole from './marks/role';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole, MarkRole, ScopeRole} from './marks/roles';\nimport {encoders} from './encode/encode-util';\nimport parseTransform from './transform';\nimport parseTrigger from './trigger';\nimport parseSpec from './spec';\nimport DataScope from '../DataScope';\nimport {fieldRef, isSignal, ref} from '../util';\nimport {error} from 'vega-util';\nimport {Bound, Collect, DataJoin, Mark, Encode, Overlap, Render, Sieve, SortItems, ViewLayout} from '../transforms';\n\nexport default function(spec, scope) {\n  var role = getRole(spec),\n      group = spec.type === GroupMark,\n      facet = spec.from && spec.from.facet,\n      layout = spec.layout || role === ScopeRole || role === FrameRole,\n      nested = role === MarkRole || layout || facet,\n      overlap = spec.overlap,\n      ops, op, input, store, bound, render, sieve, name,\n      joinRef, markRef, encodeRef, layoutRef, boundRef;\n\n  // resolve input data\n  input = parseData(spec.from, group, scope);\n\n  // data join to map tuples to visual items\n  op = scope.add(DataJoin({\n    key:   input.key || (spec.key ? fieldRef(spec.key) : undefined),\n    pulse: input.pulse,\n    clean: !group\n  }));\n  joinRef = ref(op);\n\n  // collect visual items\n  op = store = scope.add(Collect({pulse: joinRef}));\n\n  // connect visual items to scenegraph\n  op = scope.add(Mark({\n    markdef:     definition(spec),\n    interactive: interactive(spec.interactive, scope),\n    clip:        clip(spec.clip, scope),\n    context:     {$context: true},\n    groups:      scope.lookup(),\n    parent:      scope.signals.parent ? scope.signalRef('parent') : null,\n    index:       scope.markpath(),\n    pulse:       ref(op)\n  }));\n  markRef = ref(op);\n\n  // add visual encoders\n  op = scope.add(Encode(\n    encoders(spec.encode, spec.type, role, spec.style, scope, {pulse: markRef})\n  ));\n\n  // monitor parent marks to propagate changes\n  op.params.parent = scope.encode();\n\n  // add post-encoding transforms, if defined\n  if (spec.transform) {\n    spec.transform.forEach(function(_) {\n      var tx = parseTransform(_, scope);\n      if (tx.metadata.generates || tx.metadata.changes) {\n        error('Mark transforms should not generate new data.');\n      }\n      tx.params.pulse = ref(op);\n      scope.add(op = tx);\n    });\n  }\n\n  // if item sort specified, perform post-encoding\n  if (spec.sort) {\n    op = scope.add(SortItems({\n      sort:  scope.compareRef(spec.sort, true), // stable sort\n      pulse: ref(op)\n    }));\n  }\n\n  encodeRef = ref(op);\n\n  // add view layout operator if needed\n  if (facet || layout) {\n    layout = scope.add(ViewLayout({\n      layout:       scope.objectProperty(spec.layout),\n      legendMargin: scope.config.legendMargin,\n      mark:         markRef,\n      pulse:        encodeRef\n    }));\n    layoutRef = ref(layout);\n  }\n\n  // compute bounding boxes\n  bound = scope.add(Bound({mark: markRef, pulse: layoutRef || encodeRef}));\n  boundRef = ref(bound);\n\n  // if group mark, recurse to parse nested content\n  if (group) {\n    // juggle layout & bounds to ensure they run *after* any faceting transforms\n    if (nested) { ops = scope.operators; ops.pop(); if (layout) ops.pop(); }\n\n    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);\n    facet ? parseFacet(spec, scope, input)          // explicit facet\n        : nested ? parseSubflow(spec, scope, input) // standard mark group\n        : parseSpec(spec, scope); // guide group, we can avoid nested scopes\n    scope.popState();\n\n    if (nested) { if (layout) ops.push(layout); ops.push(bound); }\n  }\n\n  // if requested, add overlap removal transform\n  if (overlap) {\n    boundRef = parseOverlap(overlap, boundRef, scope);\n  }\n\n  // render / sieve items\n  render = scope.add(Render({pulse: boundRef}));\n  sieve = scope.add(Sieve({pulse: ref(render)}, undefined, scope.parent()));\n\n  // if mark is named, make accessible as reactive geometry\n  // add trigger updates if defined\n  if (spec.name != null) {\n    name = spec.name;\n    scope.addData(name, new DataScope(scope, store, render, sieve));\n    if (spec.on) spec.on.forEach(function(on) {\n      if (on.insert || on.remove || on.toggle) {\n        error('Marks only support modify triggers.');\n      }\n      parseTrigger(on, scope, name);\n    });\n  }\n}\n\nfunction parseOverlap(overlap, source, scope) {\n  var method = overlap.method,\n      bound = overlap.bound, tol;\n\n  var params = {\n    method: isSignal(method) ? scope.signalRef(method.signal) : method,\n    pulse:  source\n  };\n\n  if (overlap.order) {\n    params.sort = scope.compareRef({field: overlap.order});\n  }\n\n  if (bound) {\n    tol = bound.tolerance;\n    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;\n    params.boundScale = scope.scaleRef(bound.scale);\n    params.boundOrient = bound.orient;\n  }\n\n  return ref(scope.add(Overlap(params)));\n}\n","import {isObject, stringValue} from 'vega-util';\n\nexport default function(clip, scope) {\n  var expr;\n\n  if (isObject(clip)) {\n    if (clip.signal) {\n      expr = clip.signal;\n    } else if (clip.path) {\n      expr = 'pathShape(' + param(clip.path) + ')';\n    } else if (clip.sphere) {\n      expr = 'geoShape(' + param(clip.sphere) + ', {type: \"Sphere\"})';\n    }\n  }\n\n  return expr\n    ? scope.signalRef(expr)\n    : !!clip;\n}\n\nfunction param(value) {\n  return isObject(value) && value.signal\n    ? value.signal\n    : stringValue(value);\n}","import parseTransform from '../transform';\nimport {ref} from '../../util';\nimport {Collect} from '../../transforms';\nimport {array, error, extend} from 'vega-util';\n\nexport default function(from, group, scope) {\n  var facet, key, op, dataRef, parent;\n\n  // if no source data, generate singleton datum\n  if (!from) {\n    dataRef = ref(scope.add(Collect(null, [{}])));\n  }\n\n  // if faceted, process facet specification\n  else if (facet = from.facet) {\n    if (!group) error('Only group marks can be faceted.');\n\n    // use pre-faceted source data, if available\n    if (facet.field != null) {\n      dataRef = parent = getDataRef(facet, scope);\n    } else {\n      // generate facet aggregates if no direct data specification\n      if (!from.data) {\n        op = parseTransform(extend({\n          type:    'aggregate',\n          groupby: array(facet.groupby)\n        }, facet.aggregate), scope);\n        op.params.key = scope.keyRef(facet.groupby);\n        op.params.pulse = getDataRef(facet, scope);\n        dataRef = parent = ref(scope.add(op));\n      } else {\n        parent = ref(scope.getData(from.data).aggregate);\n      }\n\n      key = scope.keyRef(facet.groupby, true);\n    }\n  }\n\n  // if not yet defined, get source data reference\n  if (!dataRef) {\n    dataRef = getDataRef(from, scope);\n  }\n\n  return {\n    key: key,\n    pulse: dataRef,\n    parent: parent\n  };\n}\n\nexport function getDataRef(from, scope) {\n  return from.$ref ? from\n    : from.data && from.data.$ref ? from.data\n    : ref(scope.getData(from.data).output);\n}","import role from './role';\n\nexport default function(spec) {\n  return {\n    marktype:    spec.type,\n    name:        spec.name || undefined,\n    role:        spec.role || role(spec),\n    zindex:      +spec.zindex || undefined\n  };\n}\n","import {getDataRef} from './data';\nimport parseSpec from '../spec';\nimport DataScope from '../../DataScope';\nimport {ref} from '../../util';\nimport {Collect, Facet, PreFacet, Sieve} from '../../transforms';\nimport {error, stringValue} from 'vega-util';\n\nexport default function(spec, scope, group) {\n  var facet = spec.from.facet,\n      name = facet.name,\n      data = getDataRef(facet, scope),\n      subscope, source, values, op;\n\n  if (!facet.name) {\n    error('Facet must have a name: ' + stringValue(facet));\n  }\n  if (!facet.data) {\n    error('Facet must reference a data set: ' + stringValue(facet));\n  }\n\n  if (facet.field) {\n    op = scope.add(PreFacet({\n      field: scope.fieldRef(facet.field),\n      pulse: data\n    }));\n  } else if (facet.groupby) {\n    op = scope.add(Facet({\n      key:   scope.keyRef(facet.groupby),\n      group: ref(scope.proxy(group.parent)),\n      pulse: data\n    }));\n  } else {\n    error('Facet must specify groupby or field: ' + stringValue(facet));\n  }\n\n  // initialize facet subscope\n  subscope = scope.fork();\n  source = subscope.add(Collect());\n  values = subscope.add(Sieve({pulse: ref(source)}));\n  subscope.addData(name, new DataScope(subscope, source, source, values));\n  subscope.addSignal('parent', null);\n\n  // parse faceted subflow\n  op.params.subflow = {\n    $subflow: parseSpec(spec, subscope).toRuntime()\n  };\n}\n","export default function(spec, scope) {\n  return spec && spec.signal ? scope.signalRef(spec.signal)\n    : spec === false ? false\n    : true;\n}\n","export var GroupMark = 'group';\nexport var RectMark = 'rect';\nexport var RuleMark = 'rule';\nexport var SymbolMark = 'symbol';\nexport var TextMark = 'text';\n","import {GroupMark} from './marktypes';\nimport {ScopeRole, MarkRole} from './roles';\n\nexport default function(spec) {\n  var role = spec.role || '';\n  return (!role.indexOf('axis') || !role.indexOf('legend'))\n    ? role\n    : spec.type === GroupMark ? ScopeRole : (role || MarkRole);\n}\n","export var MarkRole = 'mark';\nexport var FrameRole = 'frame';\nexport var ScopeRole = 'scope';\n\nexport var AxisRole = 'axis';\nexport var AxisDomainRole = 'axis-domain';\nexport var AxisGridRole = 'axis-grid';\nexport var AxisLabelRole = 'axis-label';\nexport var AxisTickRole = 'axis-tick';\nexport var AxisTitleRole = 'axis-title';\n\nexport var LegendRole = 'legend';\nexport var LegendBandRole = 'legend-band';\nexport var LegendEntryRole = 'legend-entry';\nexport var LegendGradientRole = 'legend-gradient';\nexport var LegendLabelRole = 'legend-label';\nexport var LegendSymbolRole = 'legend-symbol';\nexport var LegendTitleRole = 'legend-title';\n\nexport var TitleRole = 'title';\n","import parseSpec from '../spec';\nimport {Sieve, PreFacet} from '../../transforms';\n\nexport default function(spec, scope, input) {\n  var op = scope.add(PreFacet({pulse: input.pulse})),\n      subscope = scope.fork();\n\n  subscope.add(Sieve());\n  subscope.addSignal('parent', null);\n\n  // parse group mark subflow\n  op.params.subflow = {\n    $subflow: parseSpec(spec, subscope).toRuntime()\n  };\n}\n","import {isObject} from 'vega-util';\n\nexport default function(spec, config) {\n  spec = spec || config.padding;\n  return isObject(spec)\n    ? {\n        top:    number(spec.top),\n        bottom: number(spec.bottom),\n        left:   number(spec.left),\n        right:  number(spec.right)\n      }\n    : paddingObject(number(spec));\n}\n\nfunction number(_) {\n  return +_ || 0;\n}\n\nfunction paddingObject(_) {\n  return {top: _, bottom: _, left: _, right: _};\n}\n","import {error, isArray, isObject, stringValue} from 'vega-util';\n\nexport default function(proj, scope) {\n  var params = {};\n\n  for (var name in proj) {\n    if (name === 'name') continue;\n    params[name] = parseParameter(proj[name], name, scope);\n  }\n\n  scope.addProjection(proj.name, params);\n}\n\nfunction parseParameter(_, name, scope) {\n  return isArray(_) ? _.map(function(_) { return parseParameter(_, name, scope); })\n    : !isObject(_) ? _\n    : _.signal ? scope.signalRef(_.signal)\n    : name === 'fit' ? _\n    : error('Unsupported parameter object: ' + stringValue(_));\n}\n","import {ref, keyFieldRef} from '../util';\nimport {Collect, Aggregate, MultiExtent, MultiValues, Sieve, Values} from '../transforms';\nimport {error, extend, isArray, isObject, isString, stringValue, toSet} from 'vega-util';\n\nvar FIELD_REF_ID = 0;\n\nvar types = [\n  'identity',\n  'ordinal', 'band', 'point',\n  'bin-linear', 'bin-ordinal',\n  'quantize', 'quantile', 'threshold',\n  'linear', 'pow', 'sqrt', 'log', 'sequential',\n  'time', 'utc'\n];\n\nvar allTypes = toSet(types),\n    discreteTypes = toSet(types.slice(4, 9)),\n    continuousTypes = toSet(types.slice(9)),\n    ordinalTypes = toSet(types.slice(1, 6));\n\nexport function isOrdinal(type) {\n  return ordinalTypes.hasOwnProperty(type);\n}\n\nexport function isDiscretizing(type) {\n  return discreteTypes.hasOwnProperty(type);\n}\n\nexport function isContinuous(type) {\n  return continuousTypes.hasOwnProperty(type);\n}\n\nexport function isQuantile(type) {\n  return type === 'quantile';\n}\n\nexport function initScale(spec, scope) {\n  var type = spec.type || 'linear';\n\n  if (!allTypes.hasOwnProperty(type)) {\n    error('Unrecognized scale type: ' + stringValue(type));\n  }\n\n  scope.addScale(spec.name, {\n    type:   type,\n    domain: undefined\n  });\n}\n\nexport function parseScale(spec, scope) {\n  var params = scope.getScale(spec.name).params,\n      key;\n\n  params.domain = parseScaleDomain(spec.domain, spec, scope);\n\n  if (spec.range != null) {\n    params.range = parseScaleRange(spec, scope, params);\n  }\n\n  if (spec.interpolate != null) {\n    parseScaleInterpolate(spec.interpolate, params);\n  }\n\n  if (spec.nice != null) {\n    parseScaleNice(spec.nice, params);\n  }\n\n  for (key in spec) {\n    if (params.hasOwnProperty(key) || key === 'name') continue;\n    params[key] = parseLiteral(spec[key], scope);\n  }\n}\n\nfunction parseLiteral(v, scope) {\n  return !isObject(v) ? v\n    : v.signal ? scope.signalRef(v.signal)\n    : error('Unsupported object: ' + stringValue(v));\n}\n\nfunction parseArray(v, scope) {\n  return v.signal\n    ? scope.signalRef(v.signal)\n    : v.map(function(v) { return parseLiteral(v, scope); });\n}\n\nfunction dataLookupError(name) {\n  error('Can not find data set: ' + stringValue(name));\n}\n\n// -- SCALE DOMAIN ----\n\nfunction parseScaleDomain(domain, spec, scope) {\n  if (!domain) {\n    if (spec.domainMin != null || spec.domainMax != null) {\n      error('No scale domain defined for domainMin/domainMax to override.');\n    }\n    return; // default domain\n  }\n\n  return domain.signal ? scope.signalRef(domain.signal)\n    : (isArray(domain) ? explicitDomain\n    : domain.fields ? multipleDomain\n    : singularDomain)(domain, spec, scope);\n}\n\nfunction explicitDomain(domain, spec, scope) {\n  return domain.map(function(v) {\n    return parseLiteral(v, scope);\n  });\n}\n\nfunction singularDomain(domain, spec, scope) {\n  var data = scope.getData(domain.data);\n  if (!data) dataLookupError(domain.data);\n\n  return isOrdinal(spec.type)\n      ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false))\n      : isQuantile(spec.type) ? data.domainRef(scope, domain.field)\n      : data.extentRef(scope, domain.field);\n}\n\nfunction multipleDomain(domain, spec, scope) {\n  var data = domain.data,\n      fields = domain.fields.reduce(function(dom, d) {\n        d = isString(d) ? {data: data, field: d}\n          : (isArray(d) || d.signal) ? fieldRef(d, scope)\n          : d;\n        dom.push(d);\n        return dom;\n      }, []);\n\n  return (isOrdinal(spec.type) ? ordinalMultipleDomain\n    : isQuantile(spec.type) ? quantileMultipleDomain\n    : numericMultipleDomain)(domain, scope, fields);\n}\n\nfunction fieldRef(data, scope) {\n  var name = '_:vega:_' + (FIELD_REF_ID++),\n      coll = Collect({});\n\n  if (isArray(data)) {\n    coll.value = {$ingest: data};\n  } else if (data.signal) {\n    var code = 'setdata(' + stringValue(name) + ',' + data.signal + ')';\n    coll.params.input = scope.signalRef(code);\n  }\n  scope.addDataPipeline(name, [coll, Sieve({})]);\n  return {data: name, field: 'data'};\n}\n\nfunction ordinalMultipleDomain(domain, scope, fields) {\n  var counts, a, c, v;\n\n  // get value counts for each domain field\n  counts = fields.map(function(f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.countsRef(scope, f.field);\n  });\n\n  // sum counts from all fields\n  a = scope.add(Aggregate({\n    groupby: keyFieldRef,\n    ops:['sum'], fields: [scope.fieldRef('count')], as:['count'],\n    pulse: counts\n  }));\n\n  // collect aggregate output\n  c = scope.add(Collect({pulse: ref(a)}));\n\n  // extract values for combined domain\n  v = scope.add(Values({\n    field: keyFieldRef,\n    sort:  scope.sortRef(parseSort(domain.sort, true)),\n    pulse: ref(c)\n  }));\n\n  return ref(v);\n}\n\nfunction parseSort(sort, multidomain) {\n  if (sort) {\n    if (!sort.field && !sort.op) {\n      if (isObject(sort)) sort.field = 'key';\n      else sort = {field: 'key'};\n    } else if (!sort.field && sort.op !== 'count') {\n      error('No field provided for sort aggregate op: ' + sort.op);\n    } else if (multidomain && sort.field) {\n      error('Multiple domain scales can not sort by field.');\n    } else if (multidomain && sort.op && sort.op !== 'count') {\n      error('Multiple domain scales support op count only.');\n    }\n  }\n  return sort;\n}\n\nfunction quantileMultipleDomain(domain, scope, fields) {\n  // get value arrays for each domain field\n  var values = fields.map(function(f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.domainRef(scope, f.field);\n  });\n\n  // combine value arrays\n  return ref(scope.add(MultiValues({values: values})));\n}\n\nfunction numericMultipleDomain(domain, scope, fields) {\n  // get extents for each domain field\n  var extents = fields.map(function(f) {\n    var data = scope.getData(f.data);\n    if (!data) dataLookupError(f.data);\n    return data.extentRef(scope, f.field);\n  });\n\n  // combine extents\n  return ref(scope.add(MultiExtent({extents: extents})));\n}\n\n// -- SCALE NICE -----\n\nfunction parseScaleNice(nice, params) {\n  params.nice = isObject(nice)\n    ? {\n        interval: parseLiteral(nice.interval),\n        step: parseLiteral(nice.step)\n      }\n    : parseLiteral(nice);\n}\n\n// -- SCALE INTERPOLATION -----\n\nfunction parseScaleInterpolate(interpolate, params) {\n  params.interpolate = parseLiteral(interpolate.type || interpolate);\n  if (interpolate.gamma != null) {\n    params.interpolateGamma = parseLiteral(interpolate.gamma);\n  }\n}\n\n// -- SCALE RANGE -----\n\nfunction parseScaleRange(spec, scope, params) {\n  var range = spec.range,\n      config = scope.config.range;\n\n  if (range.signal) {\n    return scope.signalRef(range.signal);\n  } else if (isString(range)) {\n    if (config && config.hasOwnProperty(range)) {\n      spec = extend({}, spec, {range: config[range]});\n      return parseScaleRange(spec, scope, params);\n    } else if (range === 'width') {\n      range = [0, {signal: 'width'}]\n    } else if (range === 'height') {\n      range = isOrdinal(spec.type)\n        ? [0, {signal: 'height'}]\n        : [{signal: 'height'}, 0]\n    } else {\n      error('Unrecognized scale range value: ' + stringValue(range));\n    }\n  } else if (range.scheme) {\n    params.scheme = parseLiteral(range.scheme, scope);\n    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);\n    if (range.count) params.schemeCount = parseLiteral(range.count, scope);\n    return;\n  } else if (range.step) {\n    params.rangeStep = parseLiteral(range.step, scope);\n    return;\n  } else if (isOrdinal(spec.type) && !isArray(range)) {\n    return parseScaleDomain(range, spec, scope);\n  } else if (!isArray(range)) {\n    error('Unsupported range type: ' + stringValue(range));\n  }\n\n  return range.map(function(v) {\n    return parseLiteral(v, scope);\n  });\n}\n","import parseExpression from './expression';\nimport parseUpdate from './update';\n\nexport default function(signal, scope) {\n  var op = scope.getSignal(signal.name);\n\n  if (signal.update) {\n    var expr = parseExpression(signal.update, scope);\n    op.update = expr.$expr;\n    op.params = expr.$params;\n  }\n\n  if (signal.on) {\n    signal.on.forEach(function(_) {\n      parseUpdate(_, scope, op.id);\n    });\n  }\n}\n","import {error, stringValue} from 'vega-util';\n\nvar OUTER = 'outer',\n    OUTER_INVALID = ['value', 'update', 'react', 'bind'];\n\nfunction outerError(prefix, name) {\n  error(prefix + ' for \"outer\" push: ' + stringValue(name));\n}\n\nexport default function(signal, scope) {\n  var name = signal.name;\n\n  if (signal.push === OUTER) {\n    // signal must already be defined, raise error if not\n    if (!scope.signals[name]) outerError('No prior signal definition', name);\n    // signal push must not use properties reserved for standard definition\n    OUTER_INVALID.forEach(function(prop) {\n      if (signal[prop] !== undefined) outerError('Invalid property ', prop);\n    });\n  } else {\n    // define a new signal in the current scope\n    var op = scope.addSignal(name, signal.value);\n    if (signal.react === false) op.react = false;\n    if (signal.bind) scope.addBinding(name, signal.bind);\n  }\n}\n","import parseSignalUpdates from './signal-updates';\nimport {initScale, parseScale} from './scale';\nimport parseProjection from './projection';\nimport parseLegend from './legend';\nimport parseSignal from './signal';\nimport parseTitle from './title';\nimport parseData from './data';\nimport parseMark from './mark';\nimport parseAxis from './axis';\nimport {array} from 'vega-util';\n\nexport default function(spec, scope, preprocessed) {\n  var signals = array(spec.signals),\n      scales = array(spec.scales);\n\n  if (!preprocessed) signals.forEach(function(_) {\n    parseSignal(_, scope);\n  });\n\n  array(spec.projections).forEach(function(_) {\n    parseProjection(_, scope);\n  });\n\n  scales.forEach(function(_) {\n    initScale(_, scope);\n  });\n\n  array(spec.data).forEach(function(_) {\n    parseData(_, scope);\n  });\n\n  scales.forEach(function(_) {\n    parseScale(_, scope);\n  });\n\n  signals.forEach(function(_) {\n    parseSignalUpdates(_, scope);\n  });\n\n  array(spec.axes).forEach(function(_) {\n    parseAxis(_, scope);\n  });\n\n  array(spec.marks).forEach(function(_) {\n    parseMark(_, scope);\n  });\n\n  array(spec.legends).forEach(function(_) {\n    parseLegend(_, scope);\n  });\n\n  if (spec.title) {\n    parseTitle(spec.title, scope);\n  }\n\n  scope.parseLambdas();\n  return scope;\n}\n","import parseExpression from './expression';\nimport {View, Scope} from '../util';\nimport {array, error, stringValue} from 'vega-util';\n\nvar Timer = 'timer';\n\nexport default function parseStream(stream, scope) {\n  var method = stream.merge ? mergeStream\n    : stream.stream ? nestedStream\n    : stream.type ? eventStream\n    : error('Invalid stream specification: ' + stringValue(stream));\n\n  return method(stream, scope);\n}\n\nfunction eventSource(source) {\n   return source === Scope ? View : (source || View);\n}\n\nfunction mergeStream(stream, scope) {\n  var list = stream.merge.map(function(s) {\n    return parseStream(s, scope);\n  });\n\n  var entry = streamParameters({merge: list}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction nestedStream(stream, scope) {\n  var id = parseStream(stream.stream, scope),\n      entry = streamParameters({stream: id}, stream, scope);\n  return scope.addStream(entry).id;\n}\n\nfunction eventStream(stream, scope) {\n  var id, entry;\n\n  if (stream.type === Timer) {\n    id = scope.event(Timer, stream.throttle);\n    stream = {between: stream.between, filter: stream.filter};\n  } else {\n    id = scope.event(eventSource(stream.source), stream.type);\n  }\n\n  entry = streamParameters({stream: id}, stream, scope);\n  return Object.keys(entry).length === 1\n    ? id\n    : scope.addStream(entry).id;\n}\n\nfunction streamParameters(entry, stream, scope) {\n  var param = stream.between;\n\n  if (param) {\n    if (param.length !== 2) {\n      error('Stream \"between\" parameter must have 2 entries: ' + stringValue(stream));\n    }\n    entry.between = [\n      parseStream(param[0], scope),\n      parseStream(param[1], scope)\n    ];\n  }\n\n  param = stream.filter ? array(stream.filter) : [];\n  if (stream.marktype || stream.markname || stream.markrole) {\n    // add filter for mark type, name and/or role\n    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));\n  }\n  if (stream.source === Scope) {\n    // add filter to limit events from sub-scope only\n    param.push('inScope(event.item)');\n  }\n  if (param.length) {\n    entry.filter = parseExpression('(' + param.join(')&&(') + ')').$expr;\n  }\n\n  if ((param = stream.throttle) != null) {\n    entry.throttle = +param;\n  }\n\n  if ((param = stream.debounce) != null) {\n    entry.debounce = +param;\n  }\n\n  if (stream.consume) {\n    entry.consume = true;\n  }\n\n  return entry;\n}\n\nfunction filterMark(type, name, role) {\n  var item = 'event.item';\n  return item\n    + (type && type !== '*' ? '&&' + item + '.mark.marktype===\\'' + type + '\\'' : '')\n    + (role ? '&&' + item + '.mark.role===\\'' + role + '\\'' : '')\n    + (name ? '&&' + item + '.mark.name===\\'' + name + '\\'' : '');\n}\n","import {\n  Top, Bottom, Left, Right, Center,\n  Start, End, GroupTitleStyle\n} from './guides/constants';\nimport guideMark from './guides/guide-mark';\nimport {lookup} from './guides/guide-util';\nimport parseMark from './mark';\nimport {TextMark} from './marks/marktypes';\nimport {TitleRole} from './marks/roles';\nimport {addEncode, encoder} from './encode/encode-util';\nimport {ref} from '../util';\nimport {Collect} from '../transforms';\nimport {extend, isString, stringValue} from 'vega-util';\n\nfunction anchorExpr(startValue, endValue, centerValue) {\n  return 'item.anchor===\"' + Start + '\"?' + startValue\n    + ':item.anchor===\"' + End + '\"?' + endValue\n    + ':' + centerValue;\n}\n\n// title text alignment\nvar alignExpr = anchorExpr(\n  stringValue(Left), stringValue(Right), stringValue(Center)\n);\n\n// multiplication factor for anchor positioning\nvar multExpr = anchorExpr(\n  '+(item.orient===\"' + Right + '\")',\n  '+(item.orient!==\"' + Left + '\")',\n  '0.5'\n);\n\nexport default function(spec, scope) {\n  spec = isString(spec) ? {text: spec} : spec;\n\n  var config = scope.config.title,\n      encode = extend({}, spec.encode),\n      datum, dataRef, title;\n\n  // single-element data source for group title\n  datum = {\n    orient: lookup('orient', spec, config)\n  };\n  dataRef = ref(scope.add(Collect(null, [datum])));\n\n  // build title specification\n  encode.name = spec.name;\n  encode.interactive = spec.interactive;\n  title = buildTitle(spec, config, encode, dataRef);\n  if (spec.zindex) title.zindex = spec.zindex;\n\n  // parse title specification\n  return parseMark(title, scope);\n}\n\nfunction buildTitle(spec, config, userEncode, dataRef) {\n  var zero = {value: 0},\n      title = spec.text,\n      orient = lookup('orient', spec, config),\n      anchor = lookup('anchor', spec, config),\n      sign = (orient === Left || orient === Top) ? -1 : 1,\n      horizontal = (orient === Top || orient === Bottom),\n      extent = {group: (horizontal ? 'width' : 'height')},\n      encode, enter, update, pos, opp;\n\n  // title positioning along orientation axis\n  pos = {field: extent, mult: {signal: multExpr}};\n\n  // title baseline position\n  opp = sign < 0 ? zero\n    : horizontal ? {field: {group: 'height'}}\n    : {field: {group: 'width'}};\n\n  encode = {\n    enter: enter = {\n      opacity: zero\n    },\n    update: update = {\n      opacity: {value: 1},\n      text:   encoder(title),\n      anchor: encoder(anchor),\n      orient: encoder(orient),\n      extent: {field: extent},\n      align:  {signal: alignExpr}\n    },\n    exit: {\n      opacity: zero\n    }\n  };\n\n  if (horizontal) {\n    update.x = pos;\n    update.y = opp;\n    enter.angle = zero;\n    enter.baseline = {value: orient === Top ? Bottom : Top};\n  } else {\n    update.x = opp;\n    update.y = pos;\n    enter.angle = {value: sign * 90};\n    enter.baseline = {value: Bottom};\n  }\n\n  addEncode(encode, 'align',      lookup('align', spec, config), 'update');\n  addEncode(encode, 'angle',      lookup('angle', spec, config));\n  addEncode(encode, 'baseline',   lookup('baseline', spec, config));\n  addEncode(encode, 'fill',       lookup('color', spec, config));\n  addEncode(encode, 'font',       lookup('font', spec, config));\n  addEncode(encode, 'fontSize',   lookup('fontSize', spec, config));\n  addEncode(encode, 'fontWeight', lookup('fontWeight', spec, config));\n  addEncode(encode, 'frame',      lookup('frame', spec, config));\n  addEncode(encode, 'limit',      lookup('limit', spec, config));\n  addEncode(encode, 'offset',     lookup('offset', spec, config) || 0);\n\n  return guideMark(TextMark, TitleRole, spec.style || GroupTitleStyle,\n                   null, dataRef, encode, userEncode);\n}\n","import parseExpression from './expression';\nimport {entry, fieldRef, isSignal, ref} from '../util';\nimport {Params} from '../transforms';\nimport {definition} from 'vega-dataflow';\nimport {error, extend, isArray, isString, stringValue} from 'vega-util';\n\n/**\n * Parse a data transform specification.\n */\nexport default function(spec, scope) {\n  var def = definition(spec.type);\n  if (!def) error('Unrecognized transform type: ' + stringValue(spec.type));\n\n  var t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));\n  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));\n  t.metadata = def.metadata || {};\n\n  return t;\n}\n\n/**\n * Parse all parameters of a data transform.\n */\nfunction parseParameters(def, spec, scope) {\n  var params = {}, pdef, i, n;\n  for (i=0, n=def.params.length; i<n; ++i) {\n    pdef = def.params[i];\n    params[pdef.name] = parseParameter(pdef, spec, scope);\n  }\n  return params;\n}\n\n/**\n * Parse a data transform parameter.\n */\nfunction parseParameter(def, spec, scope) {\n  var type = def.type,\n      value = spec[def.name];\n\n  if (type === 'index') {\n    return parseIndexParameter(def, spec, scope);\n  } else if (value === undefined) {\n    if (def.required) {\n      error('Missing required ' + stringValue(spec.type)\n          + ' parameter: ' + stringValue(def.name));\n    }\n    return;\n  } else if (type === 'param') {\n    return parseSubParameters(def, spec, scope);\n  } else if (type === 'projection') {\n    return scope.projectionRef(spec[def.name]);\n  }\n\n  return def.array && !isSignal(value)\n    ? value.map(function(v) { return parameterValue(def, v, scope); })\n    : parameterValue(def, value, scope);\n}\n\n/**\n * Parse a single parameter value.\n */\nfunction parameterValue(def, value, scope) {\n  var type = def.type;\n\n  if (isSignal(value)) {\n    return isExpr(type) ? error('Expression references can not be signals.')\n         : isField(type) ? scope.fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : scope.signalRef(value.signal);\n  } else {\n    var expr = def.expr || isField(type);\n    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as)\n         : expr && outerField(value) ? fieldRef(value.field, value.as)\n         : isExpr(type) ? parseExpression(value, scope)\n         : isData(type) ? ref(scope.getData(value).values)\n         : isField(type) ? fieldRef(value)\n         : isCompare(type) ? scope.compareRef(value)\n         : value;\n  }\n}\n\n/**\n * Parse parameter for accessing an index of another data set.\n */\nfunction parseIndexParameter(def, spec, scope) {\n  if (!isString(spec.from)) {\n    error('Lookup \"from\" parameter must be a string literal.');\n  }\n  return scope.getData(spec.from).lookupRef(scope, spec.key);\n}\n\n/**\n * Parse a parameter that contains one or more sub-parameter objects.\n */\nfunction parseSubParameters(def, spec, scope) {\n  var value = spec[def.name];\n\n  if (def.array) {\n    if (!isArray(value)) { // signals not allowed!\n      error('Expected an array of sub-parameters. Instead: ' + stringValue(value));\n    }\n    return value.map(function(v) {\n      return parseSubParameter(def, v, scope);\n    });\n  } else {\n    return parseSubParameter(def, value, scope);\n  }\n}\n\n/**\n * Parse a sub-parameter object.\n */\nfunction parseSubParameter(def, value, scope) {\n  var params, pdef, k, i, n;\n\n  // loop over defs to find matching key\n  for (i=0, n=def.params.length; i<n; ++i) {\n    pdef = def.params[i];\n    for (k in pdef.key) {\n      if (pdef.key[k] !== value[k]) { pdef = null; break; }\n    }\n    if (pdef) break;\n  }\n  // raise error if matching key not found\n  if (!pdef) error('Unsupported parameter: ' + stringValue(value));\n\n  // parse params, create Params transform, return ref\n  params = extend(parseParameters(pdef, value, scope), pdef.key);\n  return ref(scope.add(Params(params)));\n}\n\n// -- Utilities -----\n\nexport function outerExpr(_) {\n  return _ && _.expr;\n}\n\nexport function outerField(_) {\n  return _ && _.field;\n}\n\nexport function isData(_) {\n  return _ === 'data';\n}\n\nexport function isExpr(_) {\n  return _ === 'expr';\n}\n\nexport function isField(_) {\n  return _ === 'field';\n}\n\nexport function isCompare(_) {\n  return _ === 'compare'\n}\n","import parseExpression from './expression';\nimport {operator} from '../util';\n\nexport default function(spec, scope, name) {\n  var remove = spec.remove,\n      insert = spec.insert,\n      toggle = spec.toggle,\n      modify = spec.modify,\n      values = spec.values,\n      op = scope.add(operator()),\n      update, expr;\n\n  update = 'if(' + spec.trigger + ',modify(\"'\n    + name + '\",'\n    + [insert, remove, toggle, modify, values]\n        .map(function(_) { return _ == null ? 'null' : _; })\n        .join(',')\n    + '),0)';\n\n  expr = parseExpression(update, scope);\n  op.update = expr.$expr;\n  op.params = expr.$params;\n}\n","import parseExpression from './expression';\nimport parseStream from './stream';\nimport {Scope, View} from '../util';\nimport {selector} from 'vega-event-selector';\nimport {array, error, extend, isString, stringValue} from 'vega-util';\n\nvar preamble = 'var datum=event.item&&event.item.datum;';\n\nexport default function(spec, scope, target) {\n  var events = spec.events,\n      update = spec.update,\n      encode = spec.encode,\n      sources = [],\n      value = '', entry;\n\n  if (!events) {\n    error('Signal update missing events specification.');\n  }\n\n  // interpret as an event selector string\n  if (isString(events)) {\n    events = selector(events, scope.isSubscope() ? Scope : View);\n  }\n\n  // separate event streams from signal updates\n  events = array(events).filter(function(stream) {\n    if (stream.signal || stream.scale) {\n      sources.push(stream);\n      return 0;\n    } else {\n      return 1;\n    }\n  });\n\n  // merge event streams, include as source\n  if (events.length) {\n    sources.push(events.length > 1 ? {merge: events} : events[0]);\n  }\n\n  if (encode != null) {\n    if (update) error('Signal encode and update are mutually exclusive.');\n    update = 'encode(item(),' + stringValue(encode) + ')';\n  }\n\n  // resolve update value\n  value = isString(update) ? parseExpression(update, scope, preamble)\n    : update.expr != null ? parseExpression(update.expr, scope, preamble)\n    : update.value != null ? update.value\n    : update.signal != null ? {\n        $expr:   '_.value',\n        $params: {value: scope.signalRef(update.signal)}\n      }\n    : error('Invalid signal update specification.');\n\n  entry = {\n    target: target,\n    update: value\n  };\n\n  if (spec.force) {\n    entry.options = {force: true};\n  }\n\n  sources.forEach(function(source) {\n    scope.addUpdate(extend(streamSource(source, scope), entry));\n  });\n}\n\nfunction streamSource(stream, scope) {\n  return {\n    source: stream.signal ? scope.signalRef(stream.signal)\n          : stream.scale ? scope.scaleRef(stream.scale)\n          : parseStream(stream, scope)\n  };\n}\n","import parseAutosize from './autosize';\nimport parsePadding from './padding';\nimport parseSignal from './signal';\nimport parseSpec from './spec';\nimport {encoders, extendEncode} from './encode/encode-util';\nimport {GroupMark} from './marks/marktypes';\nimport {FrameRole} from './marks/roles';\nimport {ref, operator} from '../util';\nimport DataScope from '../DataScope';\nimport {Bound, Collect, Encode, Render, Sieve, ViewLayout} from '../transforms';\nimport {array, toSet} from 'vega-util';\n\nvar defined = toSet(['width', 'height', 'padding', 'autosize']);\n\nexport default function parseView(spec, scope) {\n  var config = scope.config,\n      op, input, encode, parent, root;\n\n  scope.background = spec.background || config.background;\n  scope.eventConfig = config.events;\n  root = ref(scope.root = scope.add(operator()));\n  scope.addSignal('width', spec.width || 0);\n  scope.addSignal('height', spec.height || 0);\n  scope.addSignal('padding', parsePadding(spec.padding, config));\n  scope.addSignal('autosize', parseAutosize(spec.autosize, config));\n\n  array(spec.signals).forEach(function(_) {\n    if (!defined[_.name]) parseSignal(_, scope);\n  });\n\n  // Store root group item\n  input = scope.add(Collect());\n\n  // Encode root group item\n  encode = extendEncode({\n    enter: { x: {value: 0}, y: {value: 0} },\n    update: { width: {signal: 'width'}, height: {signal: 'height'} }\n  }, spec.encode);\n\n  encode = scope.add(Encode(\n    encoders(encode, GroupMark, FrameRole, spec.style, scope, {pulse: ref(input)}))\n  );\n\n  // Perform view layout\n  parent = scope.add(ViewLayout({\n    layout:       scope.objectProperty(spec.layout),\n    legendMargin: config.legendMargin,\n    autosize:     scope.signalRef('autosize'),\n    mark:         root,\n    pulse:        ref(encode)\n  }));\n  scope.operators.pop();\n\n  // Parse remainder of specification\n  scope.pushState(ref(encode), ref(parent), null);\n  parseSpec(spec, scope, true);\n  scope.operators.push(parent);\n\n  // Bound / render / sieve root item\n  op = scope.add(Bound({mark: root, pulse: ref(parent)}));\n  op = scope.add(Render({pulse: ref(op)}));\n  op = scope.add(Sieve({pulse: ref(op)}));\n\n  // Track metadata for root item\n  scope.addData('root', new DataScope(scope, input, input, op));\n\n  return scope;\n}\n","import {entry} from './util';\n\nfunction transform(name) {\n  return function(params, value, parent) {\n    return entry(name, value, params || undefined, parent);\n  };\n}\n\nexport var Aggregate = transform('aggregate');\nexport var AxisTicks = transform('axisticks');\nexport var Bound = transform('bound');\nexport var Collect = transform('collect');\nexport var Compare = transform('compare');\nexport var DataJoin = transform('datajoin');\nexport var Encode = transform('encode');\nexport var Expression = transform('expression');\nexport var Extent = transform('extent');\nexport var Facet = transform('facet');\nexport var Field = transform('field');\nexport var Key = transform('key');\nexport var LegendEntries = transform('legendentries');\nexport var Load = transform('load');\nexport var Mark = transform('mark');\nexport var MultiExtent = transform('multiextent');\nexport var MultiValues = transform('multivalues');\nexport var Overlap = transform('overlap');\nexport var Params = transform('params');\nexport var PreFacet = transform('prefacet');\nexport var Projection = transform('projection');\nexport var Proxy = transform('proxy');\nexport var Relay = transform('relay');\nexport var Render = transform('render');\nexport var Scale = transform('scale');\nexport var Sieve = transform('sieve');\nexport var SortItems = transform('sortitems');\nexport var ViewLayout = transform('viewlayout');\nexport var Values = transform('values');\n","import {isObject} from 'vega-util';\n\nexport function Entry(type, value, params, parent) {\n  this.id = -1;\n  this.type = type;\n  this.value = value;\n  this.params = params;\n  if (parent) this.parent = parent;\n}\n\nexport function entry(type, value, params, parent) {\n  return new Entry(type, value, params, parent);\n}\n\nexport function operator(value, params) {\n  return entry('operator', value, params);\n}\n\n// -----\n\nexport function ref(op) {\n  var ref = {$ref: op.id};\n  // if operator not yet registered, cache ref to resolve later\n  if (op.id < 0) (op.refs = op.refs || []).push(ref);\n  return ref;\n}\n\nexport var tupleidRef = {\n  $tupleid: 1,\n  toString: function() { return ':_tupleid_:'; }\n};\n\nexport function fieldRef(field, name) {\n  return name ? {$field: field, $name: name} : {$field: field};\n}\n\nexport var keyFieldRef = fieldRef('key');\n\nexport function compareRef(fields, orders) {\n  return {$compare: fields, $order: orders};\n}\n\nexport function keyRef(fields, flat) {\n  var ref = {$key: fields};\n  if (flat) ref.$flat = true;\n  return ref;\n}\n\n// -----\n\nexport var Ascending  = 'ascending';\n\nexport var Descending = 'descending';\n\nexport function sortKey(sort) {\n  return !isObject(sort) ? ''\n    : (sort.order === Descending ? '-' : '+')\n      + aggrField(sort.op, sort.field);\n}\n\nexport function aggrField(op, field) {\n  return (op && op.signal ? '$' + op.signal : op || '')\n    + (op && field ? '_' : '')\n    + (field && field.signal ? '$' + field.signal : field || '');\n}\n\n// -----\n\nexport var Scope = 'scope';\n\nexport var View = 'view';\n\nexport function isSignal(_) {\n  return _ && _.signal;\n}\n\nexport function hasSignal(_) {\n  if (isSignal(_)) return true;\n  if (isObject(_)) for (var key in _) {\n    if (hasSignal(_[key])) return true;\n  }\n  return false;\n}\n\nexport function value(specValue, defaultValue) {\n  return specValue != null ? specValue : defaultValue;\n}\n\nexport function deref(v) {\n  return v && v.signal || v;\n}\n","export {\n  projection,\n  projectionProperties,\n  getProjectionPath\n} from './src/projections';\n","import {\n  geoAlbers,\n  geoAlbersUsa,\n  geoAzimuthalEqualArea,\n  geoAzimuthalEquidistant,\n  geoConicConformal,\n  geoConicEqualArea,\n  geoConicEquidistant,\n  geoEquirectangular,\n  geoGnomonic,\n  geoIdentity,\n  geoMercator,\n  geoNaturalEarth1,\n  geoOrthographic,\n  geoStereographic,\n  geoTransverseMercator,\n  geoPath\n} from 'd3-geo';\n\nvar defaultPath = geoPath();\n\nexport var projectionProperties = [\n  // standard properties in d3-geo\n  'clipAngle',\n  'clipExtent',\n  'scale',\n  'translate',\n  'center',\n  'rotate',\n  'parallels',\n  'precision',\n  'reflectX',\n  'reflectY',\n\n  // extended properties in d3-geo-projections\n  'coefficient',\n  'distance',\n  'fraction',\n  'lobes',\n  'parallel',\n  'radius',\n  'ratio',\n  'spacing',\n  'tilt'\n];\n\n/**\n * Augment projections with their type and a copy method.\n */\nfunction create(type, constructor) {\n  return function projection() {\n    var p = constructor();\n\n    p.type = type;\n\n    p.path = geoPath().projection(p);\n\n    p.copy = p.copy || function() {\n      var c = projection();\n      projectionProperties.forEach(function(prop) {\n        if (p.hasOwnProperty(prop)) c[prop](p[prop]());\n      });\n      c.path.pointRadius(p.path.pointRadius());\n      return c;\n    };\n\n    return p;\n  };\n}\n\nexport function projection(type, proj) {\n  if (!type || typeof type !== 'string') {\n    throw new Error('Projection type must be a name string.');\n  }\n  type = type.toLowerCase();\n  if (arguments.length > 1) {\n    projections[type] = create(type, proj);\n    return this;\n  } else {\n    return projections.hasOwnProperty(type) ? projections[type] : null;\n  }\n}\n\nexport function getProjectionPath(proj) {\n  return (proj && proj.path) || defaultPath;\n}\n\nvar projections = {\n  // base d3-geo projection types\n  albers:               geoAlbers,\n  albersusa:            geoAlbersUsa,\n  azimuthalequalarea:   geoAzimuthalEqualArea,\n  azimuthalequidistant: geoAzimuthalEquidistant,\n  conicconformal:       geoConicConformal,\n  conicequalarea:       geoConicEqualArea,\n  conicequidistant:     geoConicEquidistant,\n  equirectangular:      geoEquirectangular,\n  gnomonic:             geoGnomonic,\n  identity:             geoIdentity,\n  mercator:             geoMercator,\n  naturalEarth1:        geoNaturalEarth1,\n  orthographic:         geoOrthographic,\n  stereographic:        geoStereographic,\n  transversemercator:   geoTransverseMercator\n};\n\nfor (var key in projections) {\n  projection(key, projections[key]);\n}\n","export {default as parse} from './src/dataflow';\nexport {default as context} from './src/context';\nexport {default as expression} from './src/expression';\n","import {getState, setState} from './state';\nimport {canonicalType, isCollect} from './util';\n\n/**\n * Context objects store the current parse state.\n * Enables lookup of parsed operators, event streams, accessors, etc.\n * Provides a 'fork' method for creating child contexts for subflows.\n */\nexport default function(df, transforms, functions) {\n  return new Context(df, transforms, functions);\n}\n\nfunction Context(df, transforms, functions) {\n  this.dataflow = df;\n  this.transforms = transforms;\n  this.events = df.events.bind(df);\n  this.signals = {};\n  this.scales = {};\n  this.nodes = {};\n  this.data = {};\n  this.fn = {};\n  if (functions) {\n    this.functions = Object.create(functions);\n    this.functions.context = this;\n  }\n}\n\nfunction ContextFork(ctx) {\n  this.dataflow = ctx.dataflow;\n  this.transforms = ctx.transforms;\n  this.functions = ctx.functions;\n  this.events = ctx.events;\n  this.signals = Object.create(ctx.signals);\n  this.scales = Object.create(ctx.scales);\n  this.nodes = Object.create(ctx.nodes);\n  this.data = Object.create(ctx.data);\n  this.fn = Object.create(ctx.fn);\n  if (ctx.functions) {\n    this.functions = Object.create(ctx.functions);\n    this.functions.context = this;\n  }\n}\n\nContext.prototype = ContextFork.prototype = {\n  fork: function() {\n    var ctx = new ContextFork(this);\n    (this.subcontext || (this.subcontext = [])).push(ctx);\n    return ctx;\n  },\n  get: function(id) {\n    return this.nodes[id];\n  },\n  set: function(id, node) {\n    return this.nodes[id] = node;\n  },\n  add: function(spec, op) {\n    var ctx = this,\n        df = ctx.dataflow,\n        data;\n\n    ctx.set(spec.id, op);\n\n    if (isCollect(spec.type) && (data = spec.value)) {\n      if (data.$ingest) {\n        df.ingest(op, data.$ingest, data.$format);\n      } else if (data.$load) {\n        ctx.get(data.$load.$ref).target = op;\n      } else if (data.$request) {\n        df.request(op, data.$request, data.$format);\n      } else {\n        df.pulse(op, df.changeset().insert(data));\n      }\n    }\n\n    if (spec.root) {\n      ctx.root = op;\n    }\n\n    if (spec.parent) {\n      var p = ctx.get(spec.parent.$ref);\n      if (p) {\n        df.connect(p, [op]);\n        op.targets().add(p);\n      } else {\n        (ctx.unresolved = ctx.unresolved || []).push(function() {\n          p = ctx.get(spec.parent.$ref);\n          df.connect(p, [op]);\n          op.targets().add(p);\n        });\n      }\n    }\n\n    if (spec.signal) {\n      ctx.signals[spec.signal] = op;\n    }\n\n    if (spec.scale) {\n      ctx.scales[spec.scale] = op;\n    }\n\n    if (spec.data) {\n      for (var name in spec.data) {\n        data = ctx.data[name] || (ctx.data[name] = {});\n        spec.data[name].forEach(function(role) { data[role] = op; });\n      }\n    }\n  },\n  resolve: function() {\n    (this.unresolved || []).forEach(function(fn) { fn(); });\n    delete this.unresolved;\n    return this;\n  },\n  operator: function(spec, update, params) {\n    this.add(spec, this.dataflow.add(spec.value, update, params, spec.react));\n  },\n  transform: function(spec, type, params) {\n    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)], params));\n  },\n  stream: function(spec, stream) {\n    this.set(spec.id, stream);\n  },\n  update: function(spec, stream, target, update, params) {\n    this.dataflow.on(stream, target, update, params, spec.options);\n  },\n  getState: getState,\n  setState: setState\n};\n","import {default as parseOperator, parseOperatorParameters} from './operator';\nimport parseStream from './stream';\nimport parseUpdate from './update';\n\n/**\n * Parse a serialized dataflow specification.\n */\nexport default function(spec, ctx) {\n  var operators = spec.operators || [];\n\n  // parse background\n  if (spec.background) {\n    ctx.background = spec.background;\n  }\n\n  // parse event configuration\n  if (spec.eventConfig) {\n    ctx.eventConfig = spec.eventConfig;\n  }\n\n  // parse operators\n  operators.forEach(function(entry) {\n    parseOperator(entry, ctx);\n  });\n\n  // parse operator parameters\n  operators.forEach(function(entry) {\n    parseOperatorParameters(entry, ctx);\n  });\n\n  // parse streams\n  (spec.streams || []).forEach(function(entry) {\n    parseStream(entry, ctx);\n  });\n\n  // parse updates\n  (spec.updates || []).forEach(function(entry) {\n    parseUpdate(entry, ctx);\n  });\n\n  return ctx.resolve();\n}\n","/**\n * Parse an expression given the argument signature and body code.\n */\nexport default function expression(args, code, ctx) {\n  // wrap code in return statement if expression does not terminate\n  if (code[code.length-1] !== ';') {\n    code = 'return(' + code + ');';\n  }\n  var fn = Function.apply(null, args.concat(code));\n  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n}\n\n/**\n * Parse an expression used to update an operator value.\n */\nexport function operatorExpression(code, ctx) {\n  return expression(['_'], code, ctx);\n}\n\n/**\n * Parse an expression provided as an operator parameter value.\n */\nexport function parameterExpression(code, ctx) {\n  return expression(['datum', '_'], code, ctx);\n}\n\n/**\n * Parse an expression applied to an event stream.\n */\nexport function eventExpression(code, ctx) {\n  return expression(['event'], code, ctx);\n}\n\n/**\n * Parse an expression used to handle an event-driven operator update.\n */\nexport function handlerExpression(code, ctx) {\n  return expression(['_', 'event'], code, ctx);\n}\n\n/**\n * Parse an expression that performs visual encoding.\n */\nexport function encodeExpression(code, ctx) {\n  return expression(['item', '_'], code, ctx);\n}\n","import {operatorExpression} from './expression';\nimport parseParameters from './parameters';\nimport {isOperator} from './util';\nimport {error} from 'vega-util';\n\n/**\n * Parse a dataflow operator.\n */\nexport default function(spec, ctx) {\n  if (isOperator(spec.type) || !spec.type) {\n    ctx.operator(spec,\n      spec.update ? operatorExpression(spec.update, ctx) : null);\n  } else {\n    ctx.transform(spec, spec.type);\n  }\n}\n\n/**\n * Parse and assign operator parameters.\n */\nexport function parseOperatorParameters(spec, ctx) {\n  var op, params;\n  if (spec.params) {\n    if (!(op = ctx.get(spec.id))) {\n      error('Invalid operator id: ' + spec.id);\n    }\n    params = parseParameters(spec.params, ctx);\n    ctx.dataflow.connect(op, op.parameters(params, spec.react));\n  }\n}\n","import parseDataflow from './dataflow';\nimport {parameterExpression, encodeExpression} from './expression';\nimport {tupleid} from 'vega-dataflow';\nimport {accessor, array, compare, error, field, isArray, isObject, key} from 'vega-util';\n\n/**\n * Parse a set of operator parameters.\n */\nexport default function parseParameters(spec, ctx, params) {\n  params = params || {};\n  var key, value;\n\n  for (key in spec) {\n    value = spec[key];\n\n    params[key] = isArray(value)\n      ? value.map(function(v) { return parseParameter(v, ctx, params); })\n      : parseParameter(value, ctx, params);\n  }\n  return params;\n}\n\n/**\n * Parse a single parameter.\n */\nfunction parseParameter(spec, ctx, params) {\n  if (!spec || !isObject(spec)) return spec;\n\n  for (var i=0, n=PARSERS.length, p; i<n; ++i) {\n    p = PARSERS[i];\n    if (spec.hasOwnProperty(p.key)) {\n      return p.parse(spec, ctx, params);\n    }\n  }\n  return spec;\n}\n\n/** Reference parsers. */\nvar PARSERS = [\n  {key: '$ref',      parse: getOperator},\n  {key: '$key',      parse: getKey},\n  {key: '$expr',     parse: getExpression},\n  {key: '$field',    parse: getField},\n  {key: '$encode',   parse: getEncode},\n  {key: '$compare',  parse: getCompare},\n  {key: '$context',  parse: getContext},\n  {key: '$subflow',  parse: getSubflow},\n  {key: '$tupleid',  parse: getTupleId}\n];\n\n/**\n * Resolve an operator reference.\n */\nfunction getOperator(_, ctx) {\n  return ctx.get(_.$ref) || error('Operator not defined: ' + _.$ref);\n}\n\n/**\n * Resolve an expression reference.\n */\nfunction getExpression(_, ctx, params) {\n  if (_.$params) { // parse expression parameters\n    parseParameters(_.$params, ctx, params);\n  }\n  var k = 'e:' + _.$expr + '_' + _.$name;\n  return ctx.fn[k]\n    || (ctx.fn[k] = accessor(parameterExpression(_.$expr, ctx), _.$fields, _.$name));\n}\n\n/**\n * Resolve a key accessor reference.\n */\nfunction getKey(_, ctx) {\n  var k = 'k:' + _.$key + '_' + (!!_.$flat);\n  return ctx.fn[k] || (ctx.fn[k] = key(_.$key, _.$flat));\n}\n\n/**\n * Resolve a field accessor reference.\n */\nfunction getField(_, ctx) {\n  if (!_.$field) return null;\n  var k = 'f:' + _.$field + '_' + _.$name;\n  return ctx.fn[k] || (ctx.fn[k] = field(_.$field, _.$name));\n}\n\n/**\n * Resolve a comparator function reference.\n */\nfunction getCompare(_, ctx) {\n  var k = 'c:' + _.$compare + '_' + _.$order,\n      c = array(_.$compare).map(function(_) {\n        return (_ && _.$tupleid) ? tupleid : _;\n      });\n  return ctx.fn[k] || (ctx.fn[k] = compare(c, _.$order));\n}\n\n/**\n * Resolve an encode operator reference.\n */\nfunction getEncode(_, ctx) {\n  var spec = _.$encode,\n      encode = {}, name, enc;\n\n  for (name in spec) {\n    enc = spec[name];\n    encode[name] = accessor(encodeExpression(enc.$expr, ctx), enc.$fields);\n    encode[name].output = enc.$output;\n  }\n  return encode;\n}\n\n/**\n * Resolve a context reference.\n */\nfunction getContext(_, ctx) {\n  return ctx;\n}\n\n/**\n * Resolve a recursive subflow specification.\n */\nfunction getSubflow(_, ctx) {\n  var spec = _.$subflow;\n  return function(dataflow, key, parent) {\n    var subctx = parseDataflow(spec, ctx.fork()),\n        op = subctx.get(spec.operators[0].id),\n        p = subctx.signals.parent;\n    if (p) p.set(parent);\n    return op;\n  };\n}\n\n/**\n * Resolve a tuple id reference.\n */\nfunction getTupleId() {\n  return tupleid;\n}\n","import {truthy} from 'vega-util';\n\nvar SKIP = {skip: true};\n\nexport function getState(options) {\n  var ctx = this,\n      state = {};\n\n  if (options.signals) {\n    var signals = (state.signals = {});\n    Object.keys(ctx.signals).forEach(function(key) {\n      var op = ctx.signals[key];\n      if (options.signals(key, op)) {\n        signals[key] = op.value;\n      }\n    });\n  }\n\n  if (options.data) {\n    var data = (state.data = {});\n    Object.keys(ctx.data).forEach(function(key) {\n      var dataset = ctx.data[key];\n      if (options.data(key, dataset)) {\n        data[key] = dataset.input.value;\n      }\n    });\n  }\n\n  if (ctx.subcontext && options.recurse !== false) {\n    state.subcontext = ctx.subcontext.map(function(ctx) {\n      return ctx.getState(options);\n    });\n  }\n\n  return state;\n}\n\nexport function setState(state) {\n  var ctx = this,\n      df = ctx.dataflow,\n      data = state.data,\n      signals = state.signals;\n\n  Object.keys(signals || {}).forEach(function(key) {\n    df.update(ctx.signals[key], signals[key], SKIP);\n  });\n\n  Object.keys(data || {}).forEach(function(key) {\n    df.pulse(\n      ctx.data[key].input,\n      df.changeset().remove(truthy).insert(data[key])\n    );\n  });\n\n  (state.subcontext  || []).forEach(function(substate, i) {\n    var subctx = ctx.subcontext[i];\n    if (subctx) subctx.setState(substate);\n  });\n}\n","import {eventExpression} from './expression';\nimport {error} from 'vega-util';\n\n/**\n * Parse an event stream specification.\n */\nexport default function(spec, ctx) {\n  var filter = spec.filter != null ? eventExpression(spec.filter, ctx) : undefined,\n      stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n      args;\n\n  if (spec.source) {\n    stream = ctx.events(spec.source, spec.type, filter);\n  }\n  else if (spec.merge) {\n    args = spec.merge.map(ctx.get.bind(ctx));\n    stream = args[0].merge.apply(args[0], args.slice(1));\n  }\n\n  if (spec.between) {\n    args = spec.between.map(ctx.get.bind(ctx));\n    stream = stream.between(args[0], args[1]);\n  }\n\n  if (spec.filter) {\n    stream = stream.filter(filter);\n  }\n\n  if (spec.throttle != null) {\n    stream = stream.throttle(+spec.throttle);\n  }\n\n  if (spec.debounce != null) {\n    stream = stream.debounce(+spec.debounce);\n  }\n\n  if (stream == null) {\n    error('Invalid stream definition: ' + JSON.stringify(spec));\n  }\n\n  if (spec.consume) stream.consume(true);\n\n  ctx.stream(spec, stream);\n}\n","import {eventExpression, handlerExpression} from './expression';\nimport parseParameters from './parameters';\nimport {error, isObject} from 'vega-util';\n\n/**\n * Parse an event-driven operator update.\n */\nexport default function(spec, ctx) {\n  var srcid = isObject(srcid = spec.source) ? srcid.$ref : srcid,\n      source = ctx.get(srcid),\n      target = null,\n      update = spec.update,\n      params = undefined;\n\n  if (!source) error('Source not defined: ' + spec.source);\n\n  if (spec.target && spec.target.$expr) {\n    target = eventExpression(spec.target.$expr, ctx);\n  } else {\n    target = ctx.get(spec.target);\n  }\n\n  if (update && update.$expr) {\n    if (update.$params) {\n      params = parseParameters(update.$params, ctx);\n    }\n    update = handlerExpression(update.$expr, ctx);\n  }\n\n  ctx.update(spec, source, target, update, params);\n}\n","export function canonicalType(type) {\n  return (type + '').toLowerCase();\n}\nexport function isOperator(type) {\n   return canonicalType(type) === 'operator';\n}\n\nexport function isCollect(type) {\n  return canonicalType(type) === 'collect';\n}\n","export {default as bandSpace} from './src/bandSpace';\nexport {default as scale} from './src/scales';\nexport {interpolate, interpolateRange, scaleFraction} from './src/interpolate';\nexport {scheme, schemeDiscretized} from './src/schemes';\nexport {timeInterval, utcInterval} from './src/timeInterval';\nexport {scaleImplicit} from 'd3-scale';\n","export default function(count, paddingInner, paddingOuter) {\n  var space = count - paddingInner + paddingOuter * 2;\n  return count ? (space > 0 ? space : 1) : 0;\n}\n","import {constant, peek} from 'vega-util';\nimport * as $ from 'd3-interpolate';\n\nexport function interpolateRange(interpolator, range) {\n  var start = range[0],\n      span = peek(range) - start;\n  return function(i) { return interpolator(start + i * span); };\n}\n\nexport function scaleFraction(scale, min, max) {\n  var delta = max - min;\n  return !delta || !isFinite(delta) ? constant(0)\n    : scale.type === 'linear' || scale.type === 'sequential'\n      ? function(_) { return (_ - min) / delta; }\n      : scale.copy().domain([min, max]).range([0, 1]).interpolate(lerp);\n}\n\nfunction lerp(a, b) {\n  var span = b - a;\n  return function(i) { return a + i * span; }\n}\n\nexport function interpolate(type, gamma) {\n  var interp = $[method(type)];\n  return (gamma != null && interp && interp.gamma)\n    ? interp.gamma(gamma)\n    : interp;\n}\n\nfunction method(type) {\n  return 'interpolate' + type.toLowerCase()\n    .split('-')\n    .map(function(s) { return s[0].toUpperCase() + s.slice(1); })\n    .join('');\n}\n","export default function(scale) {\n  return function(_) {\n    var lo = _[0],\n        hi = _[1],\n        t;\n\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n\n    return [\n      scale.invert(lo),\n      scale.invert(hi)\n    ];\n  }\n}\n","export default function(scale) {\n  return function(_) {\n    var range = scale.range(),\n        lo = _[0],\n        hi = _[1],\n        min = -1, max, t, i, n;\n\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n\n    for (i=0, n=range.length; i<n; ++i) {\n      if (range[i] >= lo && range[i] <= hi) {\n        if (min < 0) min = i;\n        max = i;\n      }\n    }\n\n    if (min < 0) return undefined;\n\n    lo = scale.invertExtent(range[min]);\n    hi = scale.invertExtent(range[max]);\n\n    return [\n      lo[0] === undefined ? lo[1] : lo[0],\n      hi[1] === undefined ? hi[0] : hi[1]\n    ];\n  }\n}\n","function colors(specifier) {\n  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;\n  while (i < n) colors[i] = \"#\" + specifier.slice(i * 6, ++i * 6);\n  return colors;\n}\n\nexport var category20 = colors(\n  '1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5'\n);\n\nexport var category20b = colors(\n  '393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6'\n);\n\nexport var category20c = colors(\n  '3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9'\n);\n\nexport var tableau10 = colors(\n  '4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac'\n);\n\nexport var tableau20 = colors(\n  '4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5'\n);\n\nexport var blueOrange = new Array(3).concat(\n  \"67a9cff7f7f7f1a340\",\n  \"0571b092c5defdb863e66101\",\n  \"0571b092c5def7f7f7fdb863e66101\",\n  \"2166ac67a9cfd1e5f0fee0b6f1a340b35806\",\n  \"2166ac67a9cfd1e5f0f7f7f7fee0b6f1a340b35806\",\n  \"2166ac4393c392c5ded1e5f0fee0b6fdb863e08214b35806\",\n  \"2166ac4393c392c5ded1e5f0f7f7f7fee0b6fdb863e08214b35806\",\n  \"0530612166ac4393c392c5ded1e5f0fee0b6fdb863e08214b358067f3b08\",\n  \"0530612166ac4393c392c5ded1e5f0f7f7f7fee0b6fdb863e08214b358067f3b08\"\n).map(colors);\n","import bandSpace from './bandSpace';\nimport {range as sequence, bisectRight} from 'd3-array';\nimport {scaleOrdinal as ordinal} from 'd3-scale';\n\nexport function band() {\n  var scale = ordinal().unknown(undefined),\n      domain = scale.domain,\n      ordinalRange = scale.range,\n      range = [0, 1],\n      step,\n      bandwidth,\n      round = false,\n      paddingInner = 0,\n      paddingOuter = 0,\n      align = 0.5;\n\n  delete scale.unknown;\n\n  function rescale() {\n    var n = domain().length,\n        reverse = range[1] < range[0],\n        start = range[reverse - 0],\n        stop = range[1 - reverse],\n        space = bandSpace(n, paddingInner, paddingOuter);\n\n    step = (stop - start) / (space || 1);\n    if (round) {\n      step = Math.floor(step);\n    }\n    start += (stop - start - step * (n - paddingInner)) * align;\n    bandwidth = step * (1 - paddingInner);\n    if (round) {\n      start = Math.round(start);\n      bandwidth = Math.round(bandwidth);\n    }\n    var values = sequence(n).map(function(i) { return start + step * i; });\n    return ordinalRange(reverse ? values.reverse() : values);\n  }\n\n  scale.domain = function(_) {\n    if (arguments.length) {\n      domain(_);\n      return rescale();\n    } else {\n      return domain();\n    }\n  };\n\n  scale.range = function(_) {\n    if (arguments.length) {\n      range = [+_[0], +_[1]];\n      return rescale();\n    } else {\n      return range.slice();\n    }\n  };\n\n  scale.rangeRound = function(_) {\n    range = [+_[0], +_[1]];\n    round = true;\n    return rescale();\n  };\n\n  scale.bandwidth = function() {\n    return bandwidth;\n  };\n\n  scale.step = function() {\n    return step;\n  };\n\n  scale.round = function(_) {\n    if (arguments.length) {\n      round = !!_;\n      return rescale();\n    } else {\n      return round;\n    }\n  };\n\n  scale.padding = function(_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      paddingInner = paddingOuter;\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n\n  scale.paddingInner = function(_) {\n    if (arguments.length) {\n      paddingInner = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingInner;\n    }\n  };\n\n  scale.paddingOuter = function(_) {\n    if (arguments.length) {\n      paddingOuter = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return paddingOuter;\n    }\n  };\n\n  scale.align = function(_) {\n    if (arguments.length) {\n      align = Math.max(0, Math.min(1, _));\n      return rescale();\n    } else {\n      return align;\n    }\n  };\n\n  scale.invertRange = function(_) {\n    // bail if range has null or undefined values\n    if (_[0] == null || _[1] == null) return;\n\n    var lo = +_[0],\n        hi = +_[1],\n        reverse = range[1] < range[0],\n        values = reverse ? ordinalRange().reverse() : ordinalRange(),\n        n = values.length - 1, a, b, t;\n\n    // bail if either range endpoint is invalid\n    if (lo !== lo || hi !== hi) return;\n\n    // order range inputs, bail if outside of scale range\n    if (hi < lo) {\n      t = lo;\n      lo = hi;\n      hi = t;\n    }\n    if (hi < values[0] || lo > range[1-reverse]) return;\n\n    // binary search to index into scale range\n    a = Math.max(0, bisectRight(values, lo) - 1);\n    b = lo===hi ? a : bisectRight(values, hi) - 1;\n\n    // increment index a if lo is within padding gap\n    if (lo - values[a] > bandwidth + 1e-10) ++a;\n\n    if (reverse) {\n      // map + swap\n      t = a;\n      a = n - b;\n      b = n - t;\n    }\n    return (a > b) ? undefined : domain().slice(a, b+1);\n  };\n\n  scale.invert = function(_) {\n    var value = scale.invertRange([_, _]);\n    return value ? value[0] : value;\n  };\n\n  scale.copy = function() {\n    return band()\n        .domain(domain())\n        .range(range)\n        .round(round)\n        .paddingInner(paddingInner)\n        .paddingOuter(paddingOuter)\n        .align(align);\n  };\n\n  return rescale();\n}\n\nfunction pointish(scale) {\n  var copy = scale.copy;\n\n  scale.padding = scale.paddingOuter;\n  delete scale.paddingInner;\n\n  scale.copy = function() {\n    return pointish(copy());\n  };\n\n  return scale;\n}\n\nexport function point() {\n  return pointish(band().paddingInner(1));\n}\n","import {bisect} from 'd3-array';\nimport {scaleLinear} from 'd3-scale';\nimport {peek} from 'vega-util';\n\nvar map = Array.prototype.map,\n    slice = Array.prototype.slice;\n\nfunction numbers(_) {\n  return map.call(_, function(x) { return +x; });\n}\n\nexport function binLinear() {\n  var linear = scaleLinear(),\n      domain = [];\n\n  function scale(x) {\n    return linear(x);\n  }\n\n  function setDomain(_) {\n    domain = numbers(_);\n    linear.domain([domain[0], peek(domain)]);\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? (setDomain(_), scale) : domain.slice();\n  };\n\n  scale.range = function(_) {\n    return arguments.length ? (linear.range(_), scale) : linear.range();\n  };\n\n  scale.rangeRound = function(_) {\n    return arguments.length ? (linear.rangeRound(_), scale) : linear.rangeRound();\n  };\n\n  scale.interpolate = function(_) {\n    return arguments.length ? (linear.interpolate(_), scale) : linear.interpolate();\n  };\n\n  scale.invert = function(_) {\n    return linear.invert(_);\n  };\n\n  scale.ticks = function(count) {\n    var n = domain.length,\n        stride = ~~(n / (count || n));\n\n    return stride < 2\n      ? scale.domain()\n      : domain.filter(function(x, i) { return !(i % stride); });\n  };\n\n  scale.tickFormat = function() {\n    return linear.tickFormat.apply(linear, arguments);\n  };\n\n  scale.copy = function() {\n    return binLinear().domain(scale.domain()).range(scale.range());\n  };\n\n  return scale;\n}\n\nexport function binOrdinal() {\n  var domain = [],\n      range = [];\n\n  function scale(x) {\n    return x == null || x !== x\n      ? undefined\n      : range[(bisect(domain, x) - 1) % range.length];\n  }\n\n  scale.domain = function(_) {\n    if (arguments.length) {\n      domain = numbers(_);\n      return scale;\n    } else {\n      return domain.slice();\n    }\n  };\n\n  scale.range = function(_) {\n    if (arguments.length) {\n      range = slice.call(_);\n      return scale;\n    } else {\n      return range.slice();\n    }\n  };\n\n  // Addresses #1395, refine if/when d3-scale tickFormat is exposed\n  scale.tickFormat = function() {\n    var linear = scaleLinear().domain([domain[0], peek(domain)]);\n    return linear.tickFormat.apply(linear, arguments);\n  };\n\n  scale.copy = function() {\n    return binOrdinal().domain(scale.domain()).range(scale.range());\n  };\n\n  return scale;\n}\n","import {peek} from 'vega-util';\nimport {scaleLinear} from 'd3-scale';\n\nexport default function sequential(interpolator) {\n  var linear = scaleLinear(),\n      x0 = 0,\n      dx = 1,\n      clamp = false;\n\n  function update() {\n    var domain = linear.domain();\n    x0 = domain[0];\n    dx = peek(domain) - x0;\n  }\n\n  function scale(x) {\n    var t = (x - x0) / dx;\n    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);\n  }\n\n  scale.clamp = function(_) {\n    if (arguments.length) {\n      clamp = !!_;\n      return scale;\n    } else {\n      return clamp;\n    }\n  };\n\n  scale.domain = function(_) {\n    return arguments.length ? (linear.domain(_), update(), scale) : linear.domain();\n  };\n\n  scale.interpolator = function(_) {\n    if (arguments.length) {\n      interpolator = _;\n      return scale;\n    } else {\n      return interpolator;\n    }\n  };\n\n  scale.copy = function() {\n    return sequential().domain(linear.domain()).clamp(clamp).interpolator(interpolator);\n  };\n\n  scale.ticks = function(count) {\n    return linear.ticks(count);\n  };\n\n  scale.tickFormat = function(count, specifier) {\n    return linear.tickFormat(count, specifier);\n  };\n\n  scale.nice = function(count) {\n    return linear.nice(count), update(), scale;\n  };\n\n  return scale;\n}\n","import invertRange from './invertRange';\nimport invertRangeExtent from './invertRangeExtent';\nimport {\n  band as scaleBand,\n  point as scalePoint\n} from './scaleBand';\nimport {\n  binLinear as scaleBinLinear,\n  binOrdinal as scaleBinOrdinal\n} from './scaleBin';\nimport scaleSequential from './scaleSequential';\n\nimport * as $ from 'd3-scale';\n\n/**\n * Augment scales with their type and needed inverse methods.\n */\nfunction create(type, constructor) {\n  return function scale() {\n    var s = constructor();\n\n    if (!s.invertRange) {\n      s.invertRange = s.invert ? invertRange(s)\n        : s.invertExtent ? invertRangeExtent(s)\n        : undefined;\n    }\n\n    s.type = type;\n    return s;\n  };\n}\n\nexport default function scale(type, scale) {\n  if (arguments.length > 1) {\n    scales[type] = create(type, scale);\n    return this;\n  } else {\n    return scales.hasOwnProperty(type) ? scales[type] : undefined;\n  }\n}\n\nvar scales = {\n  // base scale types\n  identity:      $.scaleIdentity,\n  linear:        $.scaleLinear,\n  log:           $.scaleLog,\n  ordinal:       $.scaleOrdinal,\n  pow:           $.scalePow,\n  sqrt:          $.scaleSqrt,\n  quantile:      $.scaleQuantile,\n  quantize:      $.scaleQuantize,\n  threshold:     $.scaleThreshold,\n  time:          $.scaleTime,\n  utc:           $.scaleUtc,\n\n  // extended scale types\n  band:          scaleBand,\n  point:         scalePoint,\n  sequential:    scaleSequential,\n  'bin-linear':  scaleBinLinear,\n  'bin-ordinal': scaleBinOrdinal\n};\n\nfor (var key in scales) {\n  scale(key, scales[key]);\n}\n","import {\n  category20, category20b, category20c,\n  tableau10, tableau20,\n  blueOrange\n} from './palettes';\nimport * as _ from 'd3-scale-chromatic';\nimport {interpolateRgbBasis} from 'd3-interpolate';\nimport {peek} from 'vega-util';\n\nvar discretized = {\n  blueorange:  blueOrange\n};\n\nvar schemes = {\n  // d3 categorical palettes\n  category10:  _.schemeCategory10,\n  accent:      _.schemeAccent,\n  dark2:       _.schemeDark2,\n  paired:      _.schemePaired,\n  pastel1:     _.schemePastel1,\n  pastel2:     _.schemePastel2,\n  set1:        _.schemeSet1,\n  set2:        _.schemeSet2,\n  set3:        _.schemeSet3,\n\n  // additional categorical palettes\n  category20:  category20,\n  category20b: category20b,\n  category20c: category20c,\n  tableau10:   tableau10,\n  tableau20:   tableau20,\n\n  // sequential multi-hue interpolators\n  viridis:     _.interpolateViridis,\n  magma:       _.interpolateMagma,\n  inferno:     _.interpolateInferno,\n  plasma:      _.interpolatePlasma,\n\n  // cyclic interpolators\n  rainbow:     _.interpolateRainbow,\n  sinebow:     _.interpolateSinebow,\n\n  // extended interpolators\n  blueorange:  interpolateRgbBasis(peek(blueOrange))\n};\n\nfunction add(name, suffix) {\n  schemes[name] = _['interpolate' + suffix];\n  discretized[name] = _['scheme' + suffix];\n}\n\n// sequential single-hue\nadd('blues',    'Blues');\nadd('greens',   'Greens');\nadd('greys',    'Greys');\nadd('purples',  'Purples');\nadd('reds',     'Reds');\nadd('oranges',  'Oranges');\n\n// diverging\nadd('brownbluegreen',    'BrBG');\nadd('purplegreen',       'PRGn');\nadd('pinkyellowgreen',   'PiYG');\nadd('purpleorange',      'PuOr');\nadd('redblue',           'RdBu');\nadd('redgrey',           'RdGy');\nadd('redyellowblue',     'RdYlBu');\nadd('redyellowgreen',    'RdYlGn');\nadd('spectral',          'Spectral');\n\n// sequential multi-hue\nadd('bluegreen',         'BuGn');\nadd('bluepurple',        'BuPu');\nadd('greenblue',         'GnBu');\nadd('orangered',         'OrRd');\nadd('purplebluegreen',   'PuBuGn');\nadd('purpleblue',        'PuBu');\nadd('purplered',         'PuRd');\nadd('redpurple',         'RdPu');\nadd('yellowgreenblue',   'YlGnBu');\nadd('yellowgreen',       'YlGn');\nadd('yelloworangebrown', 'YlOrBr');\nadd('yelloworangered',   'YlOrRd');\n\nexport function scheme(name, scheme) {\n  if (arguments.length > 1) {\n    schemes[name] = scheme;\n    return this;\n  }\n\n  var part = name.split('-');\n  name = part[0];\n  part = +part[1] + 1;\n\n  return part && discretized.hasOwnProperty(name) ? discretized[name][part-1]\n    : !part && schemes.hasOwnProperty(name) ? schemes[name]\n    : undefined;\n}\n\nexport function schemeDiscretized(name, schemeArray, interpolator) {\n  if (arguments.length > 1) {\n    discretized[name] = schemeArray;\n    schemes[name] = interpolator || interpolateRgbBasis(peek(schemeArray));\n    return this;\n  }\n\n  return discretized.hasOwnProperty(name)\n    ? discretized[name]\n    : undefined;\n}\n","import {\n  timeMillisecond, utcMillisecond,\n  timeSecond, utcSecond,\n  timeMinute, utcMinute,\n  timeHour, utcHour,\n  timeDay, utcDay,\n  timeWeek, utcWeek,\n  timeMonth, utcMonth,\n  timeYear, utcYear\n} from 'd3-time';\n\nvar time = {\n  millisecond: timeMillisecond,\n  second:      timeSecond,\n  minute:      timeMinute,\n  hour:        timeHour,\n  day:         timeDay,\n  week:        timeWeek,\n  month:       timeMonth,\n  year:        timeYear\n};\n\nvar utc = {\n  millisecond: utcMillisecond,\n  second:      utcSecond,\n  minute:      utcMinute,\n  hour:        utcHour,\n  day:         utcDay,\n  week:        utcWeek,\n  month:       utcMonth,\n  year:        utcYear\n}\n\nexport function timeInterval(name) {\n  return time.hasOwnProperty(name) && time[name];\n}\n\nexport function utcInterval(name) {\n  return utc.hasOwnProperty(name) && utc[name];\n}\n","export {default as Bounds} from './src/Bounds';\nexport {default as Gradient} from './src/Gradient';\nexport {default as GroupItem} from './src/GroupItem';\nexport {default as ResourceLoader} from './src/ResourceLoader';\nexport {default as Item} from './src/Item';\nexport {default as Scenegraph} from './src/Scenegraph';\n\nexport {default as Handler} from './src/Handler';\nexport {default as Renderer} from './src/Renderer';\nexport {default as CanvasHandler} from './src/CanvasHandler';\nexport {default as CanvasRenderer} from './src/CanvasRenderer';\nexport {default as SVGHandler} from './src/SVGHandler';\nexport {default as SVGRenderer} from './src/SVGRenderer';\nexport {default as SVGStringRenderer} from './src/SVGStringRenderer';\nexport {RenderType, renderModule} from './src/modules';\n\nexport {default as Marks} from './src/marks/index';\n\nexport {default as boundClip} from './src/bound/boundClip';\nexport {default as boundContext} from './src/bound/boundContext';\nexport {default as boundStroke} from './src/bound/boundStroke';\nexport {default as boundItem} from './src/bound/boundItem';\nexport {default as boundMark} from './src/bound/boundMark';\n\nexport {default as pathCurves} from './src/path/curves';\nexport {default as pathSymbols} from './src/path/symbols';\nexport {default as pathRectangle} from './src/path/rectangle';\nexport {default as pathTrail} from './src/path/trail';\nexport {default as pathParse} from './src/path/parse';\nexport {default as pathRender} from './src/path/render';\n\nexport {default as point} from './src/util/point';\nexport {domCreate, domFind, domChild, domClear} from './src/util/dom';\nexport {openTag, closeTag} from './src/util/tags';\nexport {font, fontFamily, fontSize, textMetrics} from './src/util/text';\nexport {resetSVGClipId} from './src/util/svg/clip';\n\nexport {sceneEqual, pathEqual} from './src/util/equal';\nexport {sceneToJSON, sceneFromJSON} from './src/util/serialize';\nexport {\n  zorder as sceneZOrder,\n  visit as sceneVisit,\n  pickVisit as scenePickVisit\n} from './src/util/visit';\n","export default function Bounds(b) {\n  this.clear();\n  if (b) this.union(b);\n}\n\nvar prototype = Bounds.prototype;\n\nprototype.clone = function() {\n  return new Bounds(this);\n};\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.empty = function() {\n  return (\n    this.x1 === +Number.MAX_VALUE &&\n    this.y1 === +Number.MAX_VALUE &&\n    this.x2 === -Number.MAX_VALUE &&\n    this.y2 === -Number.MAX_VALUE\n  );\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  if (x2 < x1) {\n    this.x2 = x1;\n    this.x1 = x2;\n  } else {\n    this.x1 = x1;\n    this.x2 = x2;\n  }\n  if (y2 < y1) {\n    this.y2 = y1;\n    this.y1 = y2;\n  } else {\n    this.y1 = y1;\n    this.y2 = y2;\n  }\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n};\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.intersect = function(b) {\n  if (b.x1 > this.x1) this.x1 = b.x1;\n  if (b.y1 > this.y1) this.y1 = b.y1;\n  if (b.x2 < this.x2) this.x2 = b.x2;\n  if (b.y2 < this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.alignsWith = function(b) {\n  return b && (\n    this.x1 == b.x1 ||\n    this.x2 == b.x2 ||\n    this.y1 == b.y1 ||\n    this.y2 == b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n","import Handler from './Handler';\nimport Marks from './marks/index';\nimport {Events, HrefEvent, TooltipShowEvent, TooltipHideEvent} from './util/events';\nimport point from './util/point';\nimport {domFind} from './util/dom';\nimport {inherits} from 'vega-util';\n\nexport default function CanvasHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  this._down = null;\n  this._touch = null;\n  this._first = true;\n}\n\nvar prototype = inherits(CanvasHandler, Handler);\n\nprototype.initialize = function(el, origin, obj) {\n  // add event listeners\n  var canvas = this._canvas = el && domFind(el, 'canvas');\n  if (canvas) {\n    var that = this;\n    this.events.forEach(function(type) {\n      canvas.addEventListener(type, function(evt) {\n        if (prototype[type]) {\n          prototype[type].call(that, evt);\n        } else {\n          that.fire(type, evt);\n        }\n      });\n    });\n  }\n\n  return Handler.prototype.initialize.call(this, el, origin, obj);\n};\n\n// return the backing canvas instance\nprototype.canvas = function() {\n  return this._canvas;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext('2d');\n};\n\n// supported events\nprototype.events = Events;\n\n// to keep old versions of firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire('mousewheel', evt);\n};\n\nfunction move(moveEvent, overEvent, outEvent) {\n  return function(evt) {\n    var a = this._active,\n        p = this.pickEvent(evt);\n\n    if (p === a) {\n      // active item and picked item are the same\n      this.fire(moveEvent, evt); // fire move\n    } else {\n      // active item and picked item are different\n      if (!a || !a.exit) {\n        // fire out for prior active item\n        // suppress if active item was removed from scene\n        this.fire(outEvent, evt);\n      }\n      this._active = p;          // set new active item\n      this.fire(overEvent, evt); // fire over for new active item\n      this.fire(moveEvent, evt); // fire move for new active item\n    }\n  };\n}\n\nfunction inactive(type) {\n  return function(evt) {\n    this.fire(type, evt);\n    this._active = null;\n  };\n}\n\nprototype.mousemove = move('mousemove', 'mouseover', 'mouseout');\nprototype.dragover  = move('dragover', 'dragenter', 'dragleave');\n\nprototype.mouseout  = inactive('mouseout');\nprototype.dragleave = inactive('dragleave');\n\nprototype.mousedown = function(evt) {\n  this._down = this._active;\n  this.fire('mousedown', evt);\n};\n\nprototype.click = function(evt) {\n  if (this._down === this._active) {\n    this.fire('click', evt);\n    this._down = null;\n  }\n};\n\nprototype.touchstart = function(evt) {\n  this._touch = this.pickEvent(evt.changedTouches[0]);\n\n  if (this._first) {\n    this._active = this._touch;\n    this._first = false;\n  }\n\n  this.fire('touchstart', evt, true);\n};\n\nprototype.touchmove = function(evt) {\n  this.fire('touchmove', evt, true);\n};\n\nprototype.touchend = function(evt) {\n  this.fire('touchend', evt, true);\n  this._touch = null;\n};\n\n// fire an event\nprototype.fire = function(type, evt, touch) {\n  var a = touch ? this._touch : this._active,\n      h = this._handlers[type], i, len;\n\n  // set event type relative to scenegraph items\n  evt.vegaType = type;\n\n  // handle hyperlinks and tooltips first\n  if (type === HrefEvent && a && a.href) {\n    this.handleHref(evt, a, a.href);\n  } else if (type === TooltipShowEvent || type === TooltipHideEvent) {\n    this.handleTooltip(evt, a, type !== TooltipHideEvent);\n  }\n\n  // invoke all registered handlers\n  if (h) {\n    for (i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers,\n      i = this._handlerIndex(h[name], type, handler);\n\n  if (i < 0) {\n    (h[name] || (h[name] = [])).push({\n      type:    type,\n      handler: handler\n    });\n  }\n\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers[name],\n      i = this._handlerIndex(h, type, handler);\n\n  if (i >= 0) {\n    h.splice(i, 1);\n  }\n\n  return this;\n};\n\nprototype.pickEvent = function(evt) {\n  var p = point(evt, this._canvas),\n      o = this._origin;\n  return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      mark = Marks[scene.marktype];\n  return mark.pick.call(this, g, scene, x, y, gx, gy);\n};\n","import Renderer from './Renderer';\nimport Bounds from './Bounds';\nimport marks from './marks/index';\n\nimport {domClear} from './util/dom';\nimport clip from './util/canvas/clip';\nimport resize from './util/canvas/resize';\nimport {canvas} from 'vega-canvas';\nimport {inherits} from 'vega-util';\n\nexport default function CanvasRenderer(loader) {\n  Renderer.call(this, loader);\n  this._redraw = false;\n  this._dirty = new Bounds();\n}\n\nvar prototype = inherits(CanvasRenderer, Renderer),\n    base = Renderer.prototype,\n    tempBounds = new Bounds();\n\nprototype.initialize = function(el, width, height, origin, scaleFactor) {\n  this._canvas = canvas(1, 1); // instantiate a small canvas\n  if (el) {\n    domClear(el, 0).appendChild(this._canvas);\n    this._canvas.setAttribute('class', 'marks');\n  }\n  // this method will invoke resize to size the canvas appropriately\n  return base.initialize.call(this, el, width, height, origin, scaleFactor);\n};\n\nprototype.resize = function(width, height, origin, scaleFactor) {\n  base.resize.call(this, width, height, origin, scaleFactor);\n  resize(this._canvas, this._width, this._height, this._origin, this._scale);\n  this._redraw = true;\n  return this;\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.context = function() {\n  return this._canvas ? this._canvas.getContext('2d') : null;\n};\n\nprototype.dirty = function(item) {\n  var b = translate(item.bounds, item.mark.group);\n  this._dirty.union(b);\n};\n\nfunction clipToBounds(g, b, origin) {\n  // expand bounds by 1 pixel, then round to pixel boundaries\n  b.expand(1).round();\n\n  // to avoid artifacts translate if origin has fractional pixels\n  b.translate(-(origin[0] % 1), -(origin[1] % 1));\n\n  // set clipping path\n  g.beginPath();\n  g.rect(b.x1, b.y1, b.width(), b.height());\n  g.clip();\n\n  return b;\n}\n\nfunction translate(bounds, group) {\n  if (group == null) return bounds;\n  var b = tempBounds.clear().union(bounds);\n  for (; group != null; group = group.mark.group) {\n    b.translate(group.x || 0, group.y || 0);\n  }\n  return b;\n}\n\nprototype._render = function(scene) {\n  var g = this.context(),\n      o = this._origin,\n      w = this._width,\n      h = this._height,\n      b = this._dirty;\n\n  // setup\n  g.save();\n  if (this._redraw || b.empty()) {\n    this._redraw = false;\n    b = null;\n  } else {\n    b = clipToBounds(g, b, o);\n  }\n\n  this.clear(-o[0], -o[1], w, h);\n\n  // render\n  this.draw(g, scene, b);\n\n  // takedown\n  g.restore();\n\n  this._dirty.clear();\n  return this;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var mark = marks[scene.marktype];\n  if (scene.clip) clip(ctx, scene);\n  mark.draw.call(this, ctx, scene, bounds);\n  if (scene.clip) ctx.restore();\n};\n\nprototype.clear = function(x, y, w, h) {\n  var g = this.context();\n  g.clearRect(x, y, w, h);\n  if (this._bgcolor != null) {\n    g.fillStyle = this._bgcolor;\n    g.fillRect(x, y, w, h);\n  }\n};\n","var gradient_id = 0;\n\nexport default function(p0, p1) {\n  var stops = [], gradient;\n  return gradient = {\n    id: 'gradient_' + (gradient_id++),\n    x1: p0 ? p0[0] : 0,\n    y1: p0 ? p0[1] : 0,\n    x2: p1 ? p1[0] : 1,\n    y2: p1 ? p1[1] : 0,\n    stops: stops,\n    stop: function(offset, color) {\n      stops.push({offset: offset, color: color});\n      return gradient;\n    }\n  };\n}\n","import Item from './Item';\nimport {inherits} from 'vega-util';\n\nexport default function GroupItem(mark) {\n  Item.call(this, mark);\n  this.items = (this.items || []);\n}\n\ninherits(GroupItem, Item);\n","import {domCreate} from './util/dom';\nimport resolveItem from './util/resolveItem';\nimport {loader} from 'vega-loader';\n\n/**\n * Create a new Handler instance.\n * @param {object} [customLoader] - Optional loader instance for\n *   href URL sanitization. If not specified, a standard loader\n *   instance will be generated.\n * @param {function} [customTooltip] - Optional tooltip handler\n *   function for custom tooltip display.\n * @constructor\n */\nexport default function Handler(customLoader, customTooltip) {\n  this._active = null;\n  this._handlers = {};\n  this._loader = customLoader || loader();\n  this._tooltip = customTooltip || defaultTooltip;\n}\n\n// The default tooltip display handler.\n// Sets the HTML title attribute on the visualization container.\nfunction defaultTooltip(handler, event, item, value) {\n  handler.element().setAttribute('title', value || '');\n}\n\nvar prototype = Handler.prototype;\n\n/**\n * Initialize a new Handler instance.\n * @param {DOMElement} el - The containing DOM element for the display.\n * @param {Array<number>} origin - The origin of the display, in pixels.\n *   The coordinate system will be translated to this point.\n * @param {object} [obj] - Optional context object that should serve as\n *   the \"this\" context for event callbacks.\n * @return {Handler} - This handler instance.\n */\nprototype.initialize = function(el, origin, obj) {\n  this._el = el;\n  this._obj = obj || null;\n  return this.origin(origin);\n};\n\n/**\n * Returns the parent container element for a visualization.\n * @return {DOMElement} - The containing DOM element.\n */\nprototype.element = function() {\n  return this._el;\n};\n\n/**\n * Returns the scene element (e.g., canvas or SVG) of the visualization\n * Subclasses must override if the first child is not the scene element.\n * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n */\nprototype.canvas = function() {\n  return this._el && this._el.firstChild;\n};\n\n/**\n * Get / set the origin coordinates of the visualization.\n */\nprototype.origin = function(origin) {\n  if (arguments.length) {\n    this._origin = origin || [0, 0];\n    return this;\n  } else {\n    return this._origin.slice();\n  }\n};\n\n/**\n * Get / set the scenegraph root.\n */\nprototype.scene = function(scene) {\n  if (!arguments.length) return this._scene;\n  this._scene = scene;\n  return this;\n};\n\n/**\n * Add an event handler. Subclasses should override this method.\n */\nprototype.on = function(/*type, handler*/) {};\n\n/**\n * Remove an event handler. Subclasses should override this method.\n */\nprototype.off = function(/*type, handler*/) {};\n\n/**\n * Utility method for finding the array index of an event handler.\n * @param {Array} h - An array of registered event handlers.\n * @param {string} type - The event type.\n * @param {function} handler - The event handler instance to find.\n * @return {number} - The handler's array index or -1 if not registered.\n */\nprototype._handlerIndex = function(h, type, handler) {\n  for (var i = h ? h.length : 0; --i>=0;) {\n    if (h[i].type === type && (!handler || h[i].handler === handler)) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Returns an array with registered event handlers.\n * @param {string} [type] - The event type to query. Any annotations\n *   are ignored; for example, for the argument \"click.foo\", \".foo\" will\n *   be ignored and the method returns all \"click\" handlers. If type is\n *   null or unspecified, this method returns handlers for all types.\n * @return {Array} - A new array containing all registered event handlers.\n */\nprototype.handlers = function(type) {\n  var h = this._handlers, a = [], k;\n  if (type) {\n    a.push.apply(a, h[this.eventName(type)]);\n  } else {\n    for (k in h) { a.push.apply(a, h[k]); }\n  }\n  return a;\n};\n\n/**\n * Parses an event name string to return the specific event type.\n * For example, given \"click.foo\" returns \"click\"\n * @param {string} name - The input event type string.\n * @return {string} - A string with the event type only.\n */\nprototype.eventName = function(name) {\n  var i = name.indexOf('.');\n  return i < 0 ? name : name.slice(0,i);\n};\n\n/**\n * Handle hyperlink navigation in response to an item.href value.\n * @param {Event} event - The event triggering hyperlink navigation.\n * @param {Item} item - The scenegraph item.\n * @param {string} href - The URL to navigate to.\n */\nprototype.handleHref = function(event, item, href) {\n  this._loader\n    .sanitize(href, {context:'href'})\n    .then(function(opt) {\n      var e = new MouseEvent(event.type, event),\n          a = domCreate(null, 'a');\n      for (var name in opt) a.setAttribute(name, opt[name]);\n      a.dispatchEvent(e);\n    })\n    .catch(function() { /* do nothing */ });\n};\n\n/**\n * Handle tooltip display in response to an item.tooltip value.\n * @param {Event} event - The event triggering tooltip display.\n * @param {Item} item - The scenegraph item.\n * @param {boolean} show - A boolean flag indicating whether\n *   to show or hide a tooltip for the given item.\n */\nprototype.handleTooltip = function(event, item, show) {\n  if (item && item.tooltip != null) {\n    item = resolveItem(item, event, this.canvas(), this._origin);\n    var value = (show && item && item.tooltip) || null;\n    this._tooltip.call(this._obj, this, event, item, value);\n  }\n};\n\n/**\n * Returns the size of a scenegraph item and its position relative\n * to the viewport.\n * @param {Item} item - The scenegraph item.\n * @return {object} - A bounding box object (compatible with the\n *   DOMRect type) consisting of x, y, width, heigh, top, left,\n *   right, and bottom properties.\n */\nprototype.getItemBoundingClientRect = function(item) {\n  if (!(el = this.canvas())) return;\n\n  var el, rect = el.getBoundingClientRect(),\n      origin = this._origin,\n      itemBounds = item.bounds,\n      x = itemBounds.x1 + origin[0] + rect.left,\n      y = itemBounds.y1 + origin[1] + rect.top,\n      w = itemBounds.width(),\n      h = itemBounds.height();\n\n  // translate coordinate for each parent group\n  while (item.mark && (item = item.mark.group)) {\n    x += item.x || 0;\n    y += item.y || 0;\n  }\n\n  // return DOMRect-compatible bounding box\n  return {\n    x:      x,\n    y:      y,\n    width:  w,\n    height: h,\n    left:   x,\n    top:    y,\n    right:  x + w,\n    bottom: y + h\n  };\n};\n","import Bounds from './Bounds';\n\nexport default function Item(mark) {\n  this.mark = mark;\n  this.bounds = (this.bounds || new Bounds());\n}\n","import ResourceLoader from './ResourceLoader';\n\n/**\n * Create a new Renderer instance.\n * @param {object} [loader] - Optional loader instance for\n *   image and href URL sanitization. If not specified, a\n *   standard loader instance will be generated.\n * @constructor\n */\nexport default function Renderer(loader) {\n  this._el = null;\n  this._bgcolor = null;\n  this._loader = new ResourceLoader(loader);\n}\n\nvar prototype = Renderer.prototype;\n\n/**\n * Initialize a new Renderer instance.\n * @param {DOMElement} el - The containing DOM element for the display.\n * @param {number} width - The coordinate width of the display, in pixels.\n * @param {number} height - The coordinate height of the display, in pixels.\n * @param {Array<number>} origin - The origin of the display, in pixels.\n *   The coordinate system will be translated to this point.\n * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n *   the width and height to determine the final pixel size.\n * @return {Renderer} - This renderer instance.\n */\nprototype.initialize = function(el, width, height, origin, scaleFactor) {\n  this._el = el;\n  return this.resize(width, height, origin, scaleFactor);\n};\n\n/**\n * Returns the parent container element for a visualization.\n * @return {DOMElement} - The containing DOM element.\n */\nprototype.element = function() {\n  return this._el;\n};\n\n/**\n * Returns the scene element (e.g., canvas or SVG) of the visualization\n * Subclasses must override if the first child is not the scene element.\n * @return {DOMElement} - The scene (e.g., canvas or SVG) element.\n */\nprototype.canvas = function() {\n  return this._el && this._el.firstChild;\n};\n\n/**\n * Get / set the background color.\n */\nprototype.background = function(bgcolor) {\n  if (arguments.length === 0) return this._bgcolor;\n  this._bgcolor = bgcolor;\n  return this;\n};\n\n/**\n * Resize the display.\n * @param {number} width - The new coordinate width of the display, in pixels.\n * @param {number} height - The new coordinate height of the display, in pixels.\n * @param {Array<number>} origin - The new origin of the display, in pixels.\n *   The coordinate system will be translated to this point.\n * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply\n *   the width and height to determine the final pixel size.\n * @return {Renderer} - This renderer instance;\n */\nprototype.resize = function(width, height, origin, scaleFactor) {\n  this._width = width;\n  this._height = height;\n  this._origin = origin || [0, 0];\n  this._scale = scaleFactor || 1;\n  return this;\n};\n\n/**\n * Report a dirty item whose bounds should be redrawn.\n * This base class method does nothing. Subclasses that perform\n * incremental should implement this method.\n * @param {Item} item - The dirty item whose bounds should be redrawn.\n */\nprototype.dirty = function(/*item*/) {\n};\n\n/**\n * Render an input scenegraph, potentially with a set of dirty items.\n * This method will perform an immediate rendering with available resources.\n * The renderer may also need to perform image loading to perform a complete\n * render. This process can lead to asynchronous re-rendering of the scene\n * after this method returns. To receive notification when rendering is\n * complete, use the renderAsync method instead.\n * @param {object} scene - The root mark of a scenegraph to render.\n * @return {Renderer} - This renderer instance.\n */\nprototype.render = function(scene) {\n  var r = this;\n\n  // bind arguments into a render call, and cache it\n  // this function may be subsequently called for async redraw\n  r._call = function() { r._render(scene); };\n\n  // invoke the renderer\n  r._call();\n\n  // clear the cached call for garbage collection\n  // async redraws will stash their own copy\n  r._call = null;\n\n  return r;\n};\n\n/**\n * Internal rendering method. Renderer subclasses should override this\n * method to actually perform rendering.\n * @param {object} scene - The root mark of a scenegraph to render.\n */\nprototype._render = function(/*scene*/) {\n  // subclasses to override\n};\n\n/**\n * Asynchronous rendering method. Similar to render, but returns a Promise\n * that resolves when all rendering is completed. Sometimes a renderer must\n * perform image loading to get a complete rendering. The returned\n * Promise will not resolve until this process completes.\n * @param {object} scene - The root mark of a scenegraph to render.\n * @return {Promise} - A Promise that resolves when rendering is complete.\n */\nprototype.renderAsync = function(scene) {\n  var r = this.render(scene);\n  return this._ready\n    ? this._ready.then(function() { return r; })\n    : Promise.resolve(r);\n};\n\n/**\n * Internal method for asynchronous resource loading.\n * Proxies method calls to the ImageLoader, and tracks loading\n * progress to invoke a re-render once complete.\n * @param {string} method - The method name to invoke on the ImageLoader.\n * @param {string} uri - The URI for the requested resource.\n * @return {Promise} - A Promise that resolves to the requested resource.\n */\nprototype._load = function(method, uri) {\n  var r = this,\n      p = r._loader[method](uri);\n\n  if (!r._ready) {\n    // re-render the scene when loading completes\n    var call = r._call;\n    r._ready = r._loader.ready()\n      .then(function(redraw) {\n        if (redraw) call();\n        r._ready = null;\n      });\n  }\n\n  return p;\n};\n\n/**\n * Sanitize a URL to include as a hyperlink in the rendered scene.\n * This method proxies a call to ImageLoader.sanitizeURL, but also tracks\n * image loading progress and invokes a re-render once complete.\n * @param {string} uri - The URI string to sanitize.\n * @return {Promise} - A Promise that resolves to the sanitized URL.\n */\nprototype.sanitizeURL = function(uri) {\n  return this._load('sanitizeURL', uri);\n};\n\n/**\n * Requests an image to include in the rendered scene.\n * This method proxies a call to ImageLoader.loadImage, but also tracks\n * image loading progress and invokes a re-render once complete.\n * @param {string} uri - The URI string of the image.\n * @return {Promise} - A Promise that resolves to the loaded Image.\n */\nprototype.loadImage = function(uri) {\n  return this._load('loadImage', uri);\n};\n","import {image} from 'vega-canvas';\nimport {loader} from 'vega-loader';\n\nexport default function ResourceLoader(customLoader) {\n  this._pending = 0;\n  this._loader = customLoader || loader();\n}\n\nvar prototype = ResourceLoader.prototype;\n\nprototype.pending = function() {\n  return this._pending;\n};\n\nfunction increment(loader) {\n  loader._pending += 1;\n}\n\nfunction decrement(loader) {\n  loader._pending -= 1;\n}\n\nprototype.sanitizeURL = function(uri) {\n  var loader = this;\n  increment(loader);\n\n  return loader._loader.sanitize(uri, {context:'href'})\n    .then(function(opt) {\n      decrement(loader);\n      return opt;\n    })\n    .catch(function() {\n      decrement(loader);\n      return null;\n    });\n};\n\nprototype.loadImage = function(uri) {\n  var loader = this,\n      Image = image();\n  increment(loader);\n\n  return loader._loader\n    .sanitize(uri, {context: 'image'})\n    .then(function(opt) {\n      var url = opt.href;\n      if (!url || !Image) throw {url: url};\n\n      var img = new Image();\n\n      img.onload = function() {\n        decrement(loader);\n        img.loaded = true;\n      };\n\n      img.onerror = function() {\n        decrement(loader);\n        img.loaded = false;\n      }\n\n      img.src = url;\n      return img;\n    })\n    .catch(function(e) {\n      decrement(loader);\n      return {loaded: false, width: 0, height: 0, src: e && e.url || ''};\n    });\n};\n\nprototype.ready = function() {\n  var loader = this;\n  return new Promise(function(accept) {\n    function poll(value) {\n      if (!loader.pending()) accept(value);\n      else setTimeout(function() { poll(true); }, 10);\n    }\n    poll(false);\n  });\n};\n","import Handler from './Handler';\nimport {domFind} from './util/dom';\nimport {HrefEvent, TooltipShowEvent, TooltipHideEvent} from './util/events';\nimport {inherits} from 'vega-util';\n\nexport default function SVGHandler(loader, tooltip) {\n  Handler.call(this, loader, tooltip);\n  var h = this;\n  h._hrefHandler = listener(h, function(evt, item) {\n    if (item && item.href) h.handleHref(evt, item, item.href);\n  });\n  h._tooltipHandler = listener(h, function(evt, item) {\n    h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);\n  });\n}\n\nvar prototype = inherits(SVGHandler, Handler);\n\nprototype.initialize = function(el, origin, obj) {\n  var svg = this._svg;\n  if (svg) {\n    svg.removeEventListener(HrefEvent, this._hrefHandler);\n    svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);\n    svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);\n  }\n  this._svg = svg = el && domFind(el, 'svg');\n  if (svg) {\n    svg.addEventListener(HrefEvent, this._hrefHandler);\n    svg.addEventListener(TooltipShowEvent, this._tooltipHandler);\n    svg.addEventListener(TooltipHideEvent, this._tooltipHandler);\n  }\n  return Handler.prototype.initialize.call(this, el, origin, obj);\n};\n\nprototype.canvas = function() {\n  return this._svg;\n};\n\n// wrap an event listener for the SVG DOM\nfunction listener(context, handler) {\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n    evt.vegaType = evt.type;\n    item = Array.isArray(item) ? item[0] : item;\n    handler.call(context._obj, evt, item);\n  };\n}\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers,\n      i = this._handlerIndex(h[name], type, handler);\n\n  if (i < 0) {\n    var x = {\n      type:     type,\n      handler:  handler,\n      listener: listener(this, handler)\n    };\n\n    (h[name] || (h[name] = [])).push(x);\n    if (this._svg) {\n      this._svg.addEventListener(name, x.listener);\n    }\n  }\n\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = this.eventName(type),\n      h = this._handlers[name],\n      i = this._handlerIndex(h, type, handler);\n\n  if (i >= 0) {\n    if (this._svg) {\n      this._svg.removeEventListener(name, h[i].listener);\n    }\n    h.splice(i, 1);\n  }\n\n  return this;\n};\n","import Renderer from './Renderer';\nimport marks from './marks/index';\nimport {domChild, domClear, domCreate, cssClass} from './util/dom';\nimport {openTag, closeTag} from './util/tags';\nimport {fontFamily, fontSize, textValue} from './util/text';\nimport {visit} from './util/visit';\nimport clip from './util/svg/clip';\nimport metadata from './util/svg/metadata';\nimport {styles, styleProperties} from './util/svg/styles';\nimport {inherits} from 'vega-util';\n\nvar ns = metadata.xmlns;\n\nexport default function SVGRenderer(loader) {\n  Renderer.call(this, loader);\n  this._dirtyID = 1;\n  this._dirty = [];\n  this._svg = null;\n  this._root = null;\n  this._defs = null;\n}\n\nvar prototype = inherits(SVGRenderer, Renderer);\nvar base = Renderer.prototype;\n\nprototype.initialize = function(el, width, height, padding) {\n  if (el) {\n    this._svg = domChild(el, 0, 'svg', ns);\n    this._svg.setAttribute('class', 'marks');\n    domClear(el, 1);\n    // set the svg root group\n    this._root = domChild(this._svg, 0, 'g', ns);\n    domClear(this._svg, 1);\n  }\n\n  // create the svg definitions cache\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n\n  // set background color if defined\n  this.background(this._bgcolor);\n\n  return base.initialize.call(this, el, width, height, padding);\n};\n\nprototype.background = function(bgcolor) {\n  if (arguments.length && this._svg) {\n    this._svg.style.setProperty('background-color', bgcolor);\n  }\n  return base.background.apply(this, arguments);\n};\n\nprototype.resize = function(width, height, origin, scaleFactor) {\n  base.resize.call(this, width, height, origin, scaleFactor);\n\n  if (this._svg) {\n    this._svg.setAttribute('width', this._width * this._scale);\n    this._svg.setAttribute('height', this._height * this._scale);\n    this._svg.setAttribute('viewBox', '0 0 ' + this._width + ' ' + this._height);\n    this._root.setAttribute('transform', 'translate(' + this._origin + ')');\n  }\n\n  this._dirty = [];\n\n  return this;\n};\n\nprototype.canvas = function() {\n  return this._svg;\n};\n\nprototype.svg = function() {\n  if (!this._svg) return null;\n\n  var attr = {\n    class:   'marks',\n    width:   this._width * this._scale,\n    height:  this._height * this._scale,\n    viewBox: '0 0 ' + this._width + ' ' + this._height\n  };\n  for (var key in metadata) {\n    attr[key] = metadata[key];\n  }\n\n  var bg = !this._bgcolor ? ''\n    : (openTag('rect', {\n        width:  this._width,\n        height: this._height,\n        style:  'fill: ' + this._bgcolor + ';'\n      }) + closeTag('rect'));\n\n  return openTag('svg', attr) + bg + this._svg.innerHTML + closeTag('svg');\n};\n\n\n// -- Render entry point --\n\nprototype._render = function(scene) {\n  // perform spot updates and re-render markup\n  if (this._dirtyCheck()) {\n    if (this._dirtyAll) this._resetDefs();\n    this.draw(this._root, scene);\n    domClear(this._root, 1);\n  }\n\n  this.updateDefs();\n\n  this._dirty = [];\n  ++this._dirtyID;\n\n  return this;\n};\n\n// -- Manage SVG definitions ('defs') block --\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      defs = this._defs,\n      el = defs.el,\n      index = 0, id;\n\n  for (id in defs.gradient) {\n    if (!el) defs.el = (el = domChild(svg, 0, 'defs', ns));\n    updateGradient(el, defs.gradient[id], index++);\n  }\n\n  for (id in defs.clipping) {\n    if (!el) defs.el = (el = domChild(svg, 0, 'defs', ns));\n    updateClipping(el, defs.clipping[id], index++);\n  }\n\n  // clean-up\n  if (el) {\n    if (index === 0) {\n      svg.removeChild(el);\n      defs.el = null;\n    } else {\n      domClear(el, index);\n    }\n  }\n};\n\nfunction updateGradient(el, grad, index) {\n  var i, n, stop;\n\n  el = domChild(el, index, 'linearGradient', ns);\n  el.setAttribute('id', grad.id);\n  el.setAttribute('x1', grad.x1);\n  el.setAttribute('x2', grad.x2);\n  el.setAttribute('y1', grad.y1);\n  el.setAttribute('y2', grad.y2);\n\n  for (i=0, n=grad.stops.length; i<n; ++i) {\n    stop = domChild(el, i, 'stop', ns);\n    stop.setAttribute('offset', grad.stops[i].offset);\n    stop.setAttribute('stop-color', grad.stops[i].color);\n  }\n  domClear(el, i);\n}\n\nfunction updateClipping(el, clip, index) {\n  var mask;\n\n  el = domChild(el, index, 'clipPath', ns);\n  el.setAttribute('id', clip.id);\n\n  if (clip.path) {\n    mask = domChild(el, 0, 'path', ns);\n    mask.setAttribute('d', clip.path);\n  } else {\n    mask = domChild(el, 0, 'rect', ns);\n    mask.setAttribute('x', 0);\n    mask.setAttribute('y', 0);\n    mask.setAttribute('width', clip.width);\n    mask.setAttribute('height', clip.height);\n  }\n}\n\nprototype._resetDefs = function() {\n  var def = this._defs;\n  def.gradient = {};\n  def.clipping = {};\n};\n\n\n// -- Manage rendering of items marked as dirty --\n\nprototype.dirty = function(item) {\n  if (item.dirty !== this._dirtyID) {\n    item.dirty = this._dirtyID;\n    this._dirty.push(item);\n  }\n};\n\nprototype.isDirty = function(item) {\n  return this._dirtyAll\n    || !item._svg\n    || item.dirty === this._dirtyID;\n};\n\nprototype._dirtyCheck = function() {\n  this._dirtyAll = true;\n  var items = this._dirty;\n  if (!items.length) return true;\n\n  var id = ++this._dirtyID,\n      item, mark, type, mdef, i, n, o;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    mark = item.mark;\n\n    if (mark.marktype !== type) {\n      // memoize mark instance lookup\n      type = mark.marktype;\n      mdef = marks[type];\n    }\n\n    if (mark.zdirty && mark.dirty !== id) {\n      this._dirtyAll = false;\n      dirtyParents(item, id);\n      mark.items.forEach(function(i) { i.dirty = id; });\n    }\n    if (mark.zdirty) continue; // handle in standard drawing pass\n\n    if (item.exit) { // EXIT\n      if (mdef.nested && mark.items.length) {\n        // if nested mark with remaining points, update instead\n        o = mark.items[0];\n        if (o._svg) this._update(mdef, o._svg, o);\n      } else if (item._svg) {\n        // otherwise remove from DOM\n        o = item._svg.parentNode;\n        if (o) o.removeChild(item._svg);\n      }\n      item._svg = null;\n      continue;\n    }\n\n    item = (mdef.nested ? mark.items[0] : item);\n    if (item._update === id) continue; // already visited\n\n    if (!item._svg || !item._svg.ownerSVGElement) {\n      // ENTER\n      this._dirtyAll = false;\n      dirtyParents(item, id);\n    } else {\n      // IN-PLACE UPDATE\n      this._update(mdef, item._svg, item);\n    }\n    item._update = id;\n  }\n  return !this._dirtyAll;\n};\n\nfunction dirtyParents(item, id) {\n  for (; item && item.dirty !== id; item=item.mark.group) {\n    item.dirty = id;\n    if (item.mark && item.mark.dirty !== id) {\n      item.mark.dirty = id;\n    } else return;\n  }\n}\n\n\n// -- Construct & maintain scenegraph to SVG mapping ---\n\n// Draw a mark container.\nprototype.draw = function(el, scene, prev) {\n  if (!this.isDirty(scene)) return scene._svg;\n\n  var renderer = this,\n      svg = this._svg,\n      mdef = marks[scene.marktype],\n      events = scene.interactive === false ? 'none' : null,\n      isGroup = mdef.tag === 'g',\n      sibling = null,\n      i = 0,\n      parent;\n\n  parent = bind(scene, el, prev, 'g', svg);\n  parent.setAttribute('class', cssClass(scene));\n  if (!isGroup) {\n    parent.style.setProperty('pointer-events', events);\n  }\n  if (scene.clip) {\n    parent.setAttribute('clip-path', clip(renderer, scene, scene.group));\n  } else {\n    parent.removeAttribute('clip-path');\n  }\n\n  function process(item) {\n    var dirty = renderer.isDirty(item),\n        node = bind(item, parent, sibling, mdef.tag, svg);\n\n    if (dirty) {\n      renderer._update(mdef, node, item);\n      if (isGroup) recurse(renderer, node, item);\n    }\n\n    sibling = node;\n    ++i;\n  }\n\n  if (mdef.nested) {\n    if (scene.items.length) process(scene.items[0]);\n  } else {\n    visit(scene, process);\n  }\n\n  domClear(parent, i);\n  return parent;\n};\n\n// Recursively process group contents.\nfunction recurse(renderer, el, group) {\n  el = el.lastChild;\n  var prev, idx = 0;\n\n  visit(group, function(item) {\n    prev = renderer.draw(el, item, prev);\n    ++idx;\n  });\n\n  // remove any extraneous DOM elements\n  domClear(el, 1 + idx);\n}\n\n// Bind a scenegraph item to an SVG DOM element.\n// Create new SVG elements as needed.\nfunction bind(item, el, sibling, tag, svg) {\n  var node = item._svg, doc;\n\n  // create a new dom node if needed\n  if (!node) {\n    doc = el.ownerDocument;\n    node = domCreate(doc, tag, ns);\n    item._svg = node;\n\n    if (item.mark) {\n      node.__data__ = item;\n      node.__values__ = {fill: 'default'};\n\n      // if group, create background and foreground elements\n      if (tag === 'g') {\n        var bg = domCreate(doc, 'path', ns);\n        bg.setAttribute('class', 'background');\n        node.appendChild(bg);\n        bg.__data__ = item;\n\n        var fg = domCreate(doc, 'g', ns);\n        node.appendChild(fg);\n        fg.__data__ = item;\n      }\n    }\n  }\n\n  // (re-)insert if (a) not contained in SVG or (b) sibling order has changed\n  if (node.ownerSVGElement !== svg || hasSiblings(item) && node.previousSibling !== sibling) {\n    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);\n  }\n\n  return node;\n}\n\nfunction hasSiblings(item) {\n  var parent = item.mark || item.group;\n  return parent && parent.items.length > 1;\n}\n\n\n// -- Set attributes & styles on SVG elements ---\n\nvar element = null, // temp var for current SVG element\n    values = null;  // temp var for current values hash\n\n// Extra configuration for certain mark types\nvar mark_extras = {\n  group: function(mdef, el, item) {\n    values = el.__values__; // use parent's values hash\n\n    element = el.childNodes[1];\n    mdef.foreground(emit, item, this);\n\n    element = el.childNodes[0];\n    mdef.background(emit, item, this);\n\n    var value = item.mark.interactive === false ? 'none' : null;\n    if (value !== values.events) {\n      element.style.setProperty('pointer-events', value);\n      values.events = value;\n    }\n  },\n  text: function(mdef, el, item) {\n    var value;\n\n    value = textValue(item);\n    if (value !== values.text) {\n      el.textContent = value;\n      values.text = value;\n    }\n\n    setStyle(el, 'font-family', fontFamily(item));\n    setStyle(el, 'font-size', fontSize(item) + 'px');\n    setStyle(el, 'font-style', item.fontStyle);\n    setStyle(el, 'font-variant', item.fontVariant);\n    setStyle(el, 'font-weight', item.fontWeight);\n  }\n};\n\nfunction setStyle(el, name, value) {\n  if (value !== values[name]) {\n    if (value == null) {\n      el.style.removeProperty(name);\n    } else {\n      el.style.setProperty(name, value + '');\n    }\n    values[name] = value;\n  }\n}\n\nprototype._update = function(mdef, el, item) {\n  // set dom element and values cache\n  // provides access to emit method\n  element = el;\n  values = el.__values__;\n\n  // apply svg attributes\n  mdef.attr(emit, item, this);\n\n  // some marks need special treatment\n  var extra = mark_extras[mdef.type];\n  if (extra) extra.call(this, mdef, el, item);\n\n  // apply svg css styles\n  // note: element may be modified by 'extra' method\n  this.style(element, item);\n};\n\nfunction emit(name, value, ns) {\n  // early exit if value is unchanged\n  if (value === values[name]) return;\n\n  if (value != null) {\n    // if value is provided, update DOM attribute\n    if (ns) {\n      element.setAttributeNS(ns, name, value);\n    } else {\n      element.setAttribute(name, value);\n    }\n  } else {\n    // else remove DOM attribute\n    if (ns) {\n      element.removeAttributeNS(ns, name);\n    } else {\n      element.removeAttribute(name);\n    }\n  }\n\n  // note current value for future comparison\n  values[name] = value;\n}\n\nprototype.style = function(el, o) {\n  if (o == null) return;\n  var i, n, prop, name, value;\n\n  for (i=0, n=styleProperties.length; i<n; ++i) {\n    prop = styleProperties[i];\n    value = o[prop];\n\n    if (prop === 'font') {\n      value = fontFamily(o);\n    }\n\n    if (value === values[prop]) continue;\n\n    name = styles[prop];\n    if (value == null) {\n      if (name === 'fill') {\n        el.style.setProperty(name, 'none');\n      } else {\n        el.style.removeProperty(name);\n      }\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        this._defs.gradient[value.id] = value;\n        value = 'url(' + href() + '#' + value.id + ')';\n      }\n      el.style.setProperty(name, value + '');\n    }\n\n    values[prop] = value;\n  }\n};\n\nfunction href() {\n  var loc;\n  return typeof window === 'undefined' ? ''\n    : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length)\n    : loc.href;\n}\n","import Renderer from './Renderer';\nimport marks from './marks/index';\nimport {cssClass} from './util/dom';\nimport {openTag, closeTag} from './util/tags';\nimport {fontFamily, fontSize, textValue} from './util/text';\nimport {visit} from './util/visit';\nimport clip from './util/svg/clip';\nimport metadata from './util/svg/metadata';\nimport {styles, styleProperties} from './util/svg/styles';\nimport {inherits} from 'vega-util';\n\nexport default function SVGStringRenderer(loader) {\n  Renderer.call(this, loader);\n\n  this._text = {\n    head: '',\n    bg:   '',\n    root: '',\n    foot: '',\n    defs: '',\n    body: ''\n  };\n\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n}\n\nvar prototype = inherits(SVGStringRenderer, Renderer);\nvar base = Renderer.prototype;\n\nprototype.resize = function(width, height, origin, scaleFactor) {\n  base.resize.call(this, width, height, origin, scaleFactor);\n  var o = this._origin,\n      t = this._text;\n\n  var attr = {\n    class:   'marks',\n    width:   this._width * this._scale,\n    height:  this._height * this._scale,\n    viewBox: '0 0 ' + this._width + ' ' + this._height\n  };\n  for (var key in metadata) {\n    attr[key] = metadata[key];\n  }\n\n  t.head = openTag('svg', attr);\n\n  var bg = this._bgcolor;\n  if (bg === 'transparent' || bg === 'none') bg = null;\n\n  if (bg) {\n    t.bg = openTag('rect', {\n      width:  this._width,\n      height: this._height,\n      style:  'fill: ' + bg + ';'\n    }) + closeTag('rect');\n  } else {\n    t.bg = '';\n  }\n\n  t.root = openTag('g', {\n    transform: 'translate(' + o + ')'\n  });\n\n  t.foot = closeTag('g') + closeTag('svg');\n\n  return this;\n};\n\nprototype.background = function() {\n  var rv = base.background.apply(this, arguments);\n  if (arguments.length && this._text.head) {\n    this.resize(this._width, this._height, this._origin, this._scale);\n  }\n  return rv;\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.bg + t.defs + t.root + t.body + t.foot;\n};\n\nprototype._render = function(scene) {\n  this._text.body = this.mark(scene);\n  this._text.defs = this.buildDefs();\n  return this;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      defs = '',\n      i, id, def, stops;\n\n  for (id in all.gradient) {\n    def = all.gradient[id];\n    stops = def.stops;\n\n    defs += openTag('linearGradient', {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n\n    for (i=0; i<stops.length; ++i) {\n      defs += openTag('stop', {\n        offset: stops[i].offset,\n        'stop-color': stops[i].color\n      }) + closeTag('stop');\n    }\n\n    defs += closeTag('linearGradient');\n  }\n\n  for (id in all.clipping) {\n    def = all.clipping[id];\n\n    defs += openTag('clipPath', {id: id});\n\n    if (def.path) {\n      defs += openTag('path', {\n        d: def.path\n      }) + closeTag('path');\n    } else {\n      defs += openTag('rect', {\n        x: 0,\n        y: 0,\n        width: def.width,\n        height: def.height\n      }) + closeTag('rect');\n    }\n\n    defs += closeTag('clipPath');\n  }\n\n  return (defs.length > 0) ? openTag('defs') + defs + closeTag('defs') : '';\n};\n\nvar object;\n\nfunction emit(name, value, ns, prefixed) {\n  object[prefixed || name] = value;\n}\n\nprototype.attributes = function(attr, item) {\n  object = {};\n  attr(emit, item, this);\n  return object;\n};\n\nprototype.href = function(item) {\n  var that = this,\n      href = item.href,\n      attr;\n\n  if (href) {\n    if (attr = that._hrefs && that._hrefs[href]) {\n      return attr;\n    } else {\n      that.sanitizeURL(href).then(function(attr) {\n        // rewrite to use xlink namespace\n        // note that this will be deprecated in SVG 2.0\n        attr['xlink:href'] = attr.href;\n        attr.href = null;\n        (that._hrefs || (that._hrefs = {}))[href] = attr;\n      });\n    }\n  }\n  return null;\n};\n\nprototype.mark = function(scene) {\n  var renderer = this,\n      mdef = marks[scene.marktype],\n      tag  = mdef.tag,\n      defs = this._defs,\n      str = '',\n      style;\n\n  if (tag !== 'g' && scene.interactive === false) {\n    style = 'style=\"pointer-events: none;\"';\n  }\n\n  // render opening group tag\n  str += openTag('g', {\n    'class': cssClass(scene),\n    'clip-path': scene.clip ? clip(renderer, scene, scene.group) : null\n  }, style);\n\n  // render contained elements\n  function process(item) {\n    var href = renderer.href(item);\n    if (href) str += openTag('a', href);\n\n    style = (tag !== 'g') ? applyStyles(item, scene, tag, defs) : null;\n    str += openTag(tag, renderer.attributes(mdef.attr, item), style);\n\n    if (tag === 'text') {\n      str += escape_text(textValue(item));\n    } else if (tag === 'g') {\n      str += openTag('path', renderer.attributes(mdef.background, item),\n        applyStyles(item, scene, 'bgrect', defs)) + closeTag('path');\n\n      str += openTag('g', renderer.attributes(mdef.foreground, item))\n        + renderer.markGroup(item)\n        + closeTag('g');\n    }\n\n    str += closeTag(tag);\n    if (href) str += closeTag('a');\n  }\n\n  if (mdef.nested) {\n    if (scene.items && scene.items.length) process(scene.items[0]);\n  } else {\n    visit(scene, process);\n  }\n\n  // render closing group tag\n  return str + closeTag('g');\n};\n\nprototype.markGroup = function(scene) {\n  var renderer = this,\n      str = '';\n\n  visit(scene, function(item) {\n    str += renderer.mark(item);\n  });\n\n  return str;\n};\n\nfunction applyStyles(o, mark, tag, defs) {\n  if (o == null) return '';\n  var i, n, prop, name, value, s = '';\n\n  if (tag === 'bgrect' && mark.interactive === false) {\n    s += 'pointer-events: none; ';\n  }\n\n  if (tag === 'text') {\n    s += 'font-family: ' + fontFamily(o) + '; ';\n    s += 'font-size: ' + fontSize(o) + 'px; ';\n    if (o.fontStyle) s += 'font-style: ' + o.fontStyle + '; ';\n    if (o.fontVariant) s += 'font-variant: ' + o.fontVariant + '; ';\n    if (o.fontWeight) s += 'font-weight: ' + o.fontWeight + '; ';\n  }\n\n  for (i=0, n=styleProperties.length; i<n; ++i) {\n    prop = styleProperties[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === 'fill') {\n        s += 'fill: none; ';\n      }\n    } else if (value === 'transparent' && (name === 'fill' || name === 'stroke')) {\n      // transparent is not a legal SVG value, so map to none instead\n      s += name + ': none; ';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = 'url(#' + value.id + ')';\n      }\n      s += name + ': ' + value + '; ';\n    }\n  }\n\n  return s ? 'style=\"' + s.trim() + '\"' : null;\n}\n\nfunction escape_text(s) {\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n","import Bounds from './Bounds';\nimport GroupItem from './GroupItem';\nimport {sceneFromJSON, sceneToJSON} from './util/serialize';\n\nexport default function Scenegraph(scene) {\n  if (arguments.length) {\n    this.root = sceneFromJSON(scene);\n  } else {\n    this.root = createMark({\n      marktype: 'group',\n      name: 'root',\n      role: 'frame'\n    });\n    this.root.items = [new GroupItem(this.root)];\n  }\n}\n\nvar prototype = Scenegraph.prototype;\n\nprototype.toJSON = function(indent) {\n  return sceneToJSON(this.root, indent || 0);\n};\n\nprototype.mark = function(markdef, group, index) {\n  group = group || this.root.items[0];\n  var mark = createMark(markdef, group);\n  group.items[index] = mark;\n  if (mark.zindex) mark.group.zdirty = true;\n  return mark;\n};\n\nfunction createMark(def, group) {\n  return {\n    bounds:      new Bounds(),\n    clip:        !!def.clip,\n    group:       group,\n    interactive: def.interactive === false ? false : true,\n    items:       [],\n    marktype:    def.marktype,\n    name:        def.name || undefined,\n    role:        def.role || undefined,\n    zindex:      def.zindex || 0\n  };\n}\n","import Bounds from '../Bounds';\nimport boundContext from './boundContext';\nimport {isFunction} from 'vega-util';\n\nvar clipBounds = new Bounds();\n\nexport default function(mark) {\n  var clip = mark.clip;\n\n  if (isFunction(clip)) {\n    clip(boundContext(clipBounds.clear()));\n  } else if (clip) {\n    clipBounds.set(0, 0, mark.group.width, mark.group.height);\n  } else return;\n\n  mark.bounds.intersect(clipBounds);\n}\n","var bounds,\n    tau = Math.PI * 2,\n    halfPi = tau / 4,\n    circleThreshold = tau - 1e-8;\n\nexport default function context(_) {\n  bounds = _;\n  return context;\n}\n\nfunction noop() {}\n\nfunction add(x, y) { bounds.add(x, y); }\n\ncontext.beginPath = noop;\n\ncontext.closePath = noop;\n\ncontext.moveTo = add;\n\ncontext.lineTo = add;\n\ncontext.rect = function(x, y, w, h) {\n  add(x, y);\n  add(x + w, y + h);\n};\n\ncontext.quadraticCurveTo = function(x1, y1, x2, y2) {\n  add(x1, y1);\n  add(x2, y2);\n};\n\ncontext.bezierCurveTo = function(x1, y1, x2, y2, x3, y3) {\n  add(x1, y1);\n  add(x2, y2);\n  add(x3, y3);\n};\n\ncontext.arc = function(cx, cy, r, sa, ea, ccw) {\n  if (Math.abs(ea - sa) > circleThreshold) {\n    add(cx - r, cy - r);\n    add(cx + r, cy + r);\n    return;\n  }\n\n  var xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      s, i, x, y;\n\n  function update(a) {\n    x = r * Math.cos(a);\n    y = r * Math.sin(a);\n    if (x < xmin) xmin = x;\n    if (x > xmax) xmax = x;\n    if (y < ymin) ymin = y;\n    if (y > ymax) ymax = y;\n  }\n\n  // Sample end points and interior points aligned with 90 degrees\n  update(sa);\n  update(ea);\n\n  if (ea !== sa) {\n    sa = sa % tau; if (sa < 0) sa += tau;\n    ea = ea % tau; if (ea < 0) ea += tau;\n\n    if (ea < sa) {\n      ccw = !ccw; // flip direction\n      s = sa; sa = ea; ea = s; // swap end-points\n    }\n\n    if (ccw) {\n      ea -= tau;\n      s = sa - (sa % halfPi);\n      for (i=0; i<4 && s>ea; ++i, s-=halfPi) update(s);\n    } else {\n      s = sa - (sa % halfPi) + halfPi;\n      for (i=0; i<4 && s<ea; ++i, s=s+halfPi) update(s);\n    }\n  }\n\n  add(cx + xmin, cy + ymin);\n  add(cx + xmax, cy + ymax);\n};\n","import Bounds from '../Bounds';\nimport marks from '../marks/index';\n\nexport default function(item, func, opt) {\n  var type = marks[item.mark.marktype],\n      bound = func || type.bound;\n  if (type.nested) item = item.mark;\n\n  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);\n}\n","import Bounds from '../Bounds';\nimport boundItem from './boundItem';\nimport marks from '../marks/index';\n\nvar DUMMY = {mark: null};\n\nexport default function(mark, bounds, opt) {\n  var type  = marks[mark.marktype],\n      bound = type.bound,\n      items = mark.items,\n      hasItems = items && items.length,\n      i, n, item, b;\n\n  if (type.nested) {\n    if (hasItems) {\n      item = items[0];\n    } else {\n      // no items, fake it\n      DUMMY.mark = mark;\n      item = DUMMY;\n    }\n    b = boundItem(item, bound, opt);\n    bounds = bounds && bounds.union(b) || b;\n    return bounds;\n  }\n\n  bounds = bounds\n    || mark.bounds && mark.bounds.clear()\n    || new Bounds();\n\n  if (hasItems) {\n    for (i=0, n=items.length; i<n; ++i) {\n      bounds.union(boundItem(items[i], bound, opt));\n    }\n  }\n\n  return mark.bounds = bounds;\n}\n","export default function(bounds, item) {\n  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {\n    bounds.expand(item.strokeWidth != null ? +item.strokeWidth : 1);\n  }\n  return bounds;\n}\n","import {arc} from '../path/shapes';\nimport markItemPath from './markItemPath';\n\nexport default markItemPath('arc', arc);\n","import {area} from '../path/shapes';\nimport {pickArea} from '../util/pickPath';\nimport markMultiItemPath from './markMultiItemPath';\n\nexport default markMultiItemPath('area', area, pickArea);\n","import {rectangle} from '../path/shapes';\nimport boundStroke from '../bound/boundStroke';\nimport {visit, pickVisit} from '../util/visit';\nimport stroke from '../util/canvas/stroke';\nimport fill from '../util/canvas/fill';\nimport {hitPath} from '../util/canvas/pick';\nimport clip from '../util/svg/clip';\nimport translateItem from '../util/svg/translateItem';\n\nvar StrokeOffset = 0.5;\n\nfunction attr(emit, item) {\n  emit('transform', translateItem(item));\n}\n\nfunction background(emit, item) {\n  var offset = item.stroke ? StrokeOffset : 0;\n  emit('class', 'background');\n  emit('d', rectangle(null, item, offset, offset));\n}\n\nfunction foreground(emit, item, renderer) {\n  var url = item.clip ? clip(renderer, item, item) : null;\n  emit('clip-path', url);\n}\n\nfunction bound(bounds, group) {\n  if (!group.clip && group.items) {\n    var items = group.items;\n    for (var j=0, m=items.length; j<m; ++j) {\n      bounds.union(items[j].bounds);\n    }\n  }\n\n  if ((group.clip || group.width || group.height) && !group.noBound) {\n    bounds.add(0, 0).add(group.width || 0, group.height || 0);\n  }\n\n  boundStroke(bounds, group);\n\n  return bounds.translate(group.x || 0, group.y || 0);\n}\n\nfunction backgroundPath(context, group) {\n  var offset = group.stroke ? StrokeOffset : 0;\n  context.beginPath();\n  rectangle(context, group, offset, offset);\n}\n\nvar hitBackground = hitPath(backgroundPath);\n\nfunction draw(context, scene, bounds) {\n  var renderer = this;\n\n  visit(scene, function(group) {\n    var gx = group.x || 0,\n        gy = group.y || 0,\n        w = group.width || 0,\n        h = group.height || 0,\n        opacity;\n\n    // setup graphics context\n    context.save();\n    context.translate(gx, gy);\n\n    // draw group background\n    if (group.stroke || group.fill) {\n      opacity = group.opacity == null ? 1 : group.opacity;\n      if (opacity > 0) {\n        backgroundPath(context, group);\n        if (group.fill && fill(context, group, opacity)) {\n          context.fill();\n        }\n        if (group.stroke && stroke(context, group, opacity)) {\n          context.stroke();\n        }\n      }\n    }\n\n    // set clip and bounds\n    if (group.clip) {\n      context.beginPath();\n      context.rect(0, 0, w, h);\n      context.clip();\n    }\n    if (bounds) bounds.translate(-gx, -gy);\n\n    // draw group contents\n    visit(group, function(item) {\n      renderer.draw(context, item, bounds);\n    });\n\n    // restore graphics context\n    if (bounds) bounds.translate(gx, gy);\n    context.restore();\n  });\n}\n\nfunction pick(context, scene, x, y, gx, gy) {\n  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {\n    return null;\n  }\n\n  var handler = this,\n      cx = x * context.pixelRatio,\n      cy = y * context.pixelRatio;\n\n  return pickVisit(scene, function(group) {\n    var hit, dx, dy, b;\n\n    // first hit test against bounding box\n    // if a group is clipped, that should be handled by the bounds check.\n    b = group.bounds;\n    if (b && !b.contains(gx, gy)) return;\n\n    // passed bounds check, so test sub-groups\n    dx = (group.x || 0);\n    dy = (group.y || 0);\n\n    context.save();\n    context.translate(dx, dy);\n\n    dx = gx - dx;\n    dy = gy - dy;\n\n    // hit test against contained marks\n    hit = pickVisit(group, function(mark) {\n      return pickMark(mark, dx, dy)\n        ? handler.pick(mark, x, y, dx, dy)\n        : null;\n    });\n\n    // hit test against group background\n    if (!hit && scene.interactive !== false\n        && (group.fill || group.stroke)\n        && hitBackground(context, group, cx, cy)) {\n      hit = group;\n    }\n\n    context.restore();\n    return hit || null;\n  });\n}\n\nfunction pickMark(mark, x, y) {\n  return (mark.interactive !== false || mark.marktype === 'group')\n    && mark.bounds && mark.bounds.contains(x, y);\n}\n\nexport default {\n  type:       'group',\n  tag:        'g',\n  nested:     false,\n  attr:       attr,\n  bound:      bound,\n  draw:       draw,\n  pick:       pick,\n  background: background,\n  foreground: foreground\n};\n","import {visit} from '../util/visit';\nimport {pick} from '../util/canvas/pick';\nimport translate from '../util/svg/translate';\n\nfunction getImage(item, renderer) {\n  var image = item.image;\n  if (!image || image.url !== item.url) {\n    image = {loaded: false, width: 0, height: 0};\n    renderer.loadImage(item.url).then(function(image) {\n      item.image = image;\n      item.image.url = item.url;\n    });\n  }\n  return image;\n}\n\nfunction imageXOffset(align, w) {\n  return align === 'center' ? w / 2 : align === 'right' ? w : 0;\n}\n\nfunction imageYOffset(baseline, h) {\n  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;\n}\n\nfunction attr(emit, item, renderer) {\n  var image = getImage(item, renderer),\n      x = item.x || 0,\n      y = item.y || 0,\n      w = (item.width != null ? item.width : image.width) || 0,\n      h = (item.height != null ? item.height : image.height) || 0,\n      a = item.aspect === false ? 'none' : 'xMidYMid';\n\n  x -= imageXOffset(item.align, w);\n  y -= imageYOffset(item.baseline, h);\n\n  emit('href', image.src || '', 'http://www.w3.org/1999/xlink', 'xlink:href');\n  emit('transform', translate(x, y));\n  emit('width', w);\n  emit('height', h);\n  emit('preserveAspectRatio', a);\n}\n\nfunction bound(bounds, item) {\n  var image = item.image,\n      x = item.x || 0,\n      y = item.y || 0,\n      w = (item.width != null ? item.width : (image && image.width)) || 0,\n      h = (item.height != null ? item.height : (image && image.height)) || 0;\n\n  x -= imageXOffset(item.align, w);\n  y -= imageYOffset(item.baseline, h);\n\n  return bounds.set(x, y, x + w, y + h);\n}\n\nfunction draw(context, scene, bounds) {\n  var renderer = this;\n\n  visit(scene, function(item) {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n\n    var image = getImage(item, renderer),\n        x = item.x || 0,\n        y = item.y || 0,\n        w = (item.width != null ? item.width : image.width) || 0,\n        h = (item.height != null ? item.height : image.height) || 0,\n        opacity, ar0, ar1, t;\n\n    x -= imageXOffset(item.align, w);\n    y -= imageYOffset(item.baseline, h);\n\n    if (item.aspect !== false) {\n      ar0 = image.width / image.height;\n      ar1 = item.width / item.height;\n      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {\n        if (ar1 < ar0) {\n          t = w / ar0;\n          y += (h - t) / 2;\n          h = t;\n        } else {\n          t = h * ar0;\n          x += (w - t) / 2;\n          w = t;\n        }\n      }\n    }\n\n    if (image.loaded) {\n      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;\n      context.drawImage(image, x, y, w, h);\n    }\n  });\n}\n\nexport default {\n  type:     'image',\n  tag:      'image',\n  nested:   false,\n  attr:     attr,\n  bound:    bound,\n  draw:     draw,\n  pick:     pick(),\n  get:      getImage,\n  xOffset:  imageXOffset,\n  yOffset:  imageYOffset\n};\n","import arc from './arc';\nimport area from './area';\nimport group from './group';\nimport image from './image';\nimport line from './line';\nimport path from './path';\nimport rect from './rect';\nimport rule from './rule';\nimport shape from './shape';\nimport symbol from './symbol';\nimport text from './text';\nimport trail from './trail';\n\nexport default {\n  arc:     arc,\n  area:    area,\n  group:   group,\n  image:   image,\n  line:    line,\n  path:    path,\n  rect:    rect,\n  rule:    rule,\n  shape:   shape,\n  symbol:  symbol,\n  text:    text,\n  trail:   trail\n};\n","import {line} from '../path/shapes';\nimport {pickLine} from '../util/pickPath';\nimport markMultiItemPath from './markMultiItemPath';\n\nexport default markMultiItemPath('line', line, pickLine);\n","import boundStroke from '../bound/boundStroke';\nimport context from '../bound/boundContext';\nimport {drawAll} from '../util/canvas/draw';\nimport {pickPath} from '../util/canvas/pick';\nimport translateItem from '../util/svg/translateItem';\n\nexport default function(type, shape) {\n\n  function attr(emit, item) {\n    emit('transform', translateItem(item));\n    emit('d', shape(null, item));\n  }\n\n  function bound(bounds, item) {\n    shape(context(bounds), item);\n    return boundStroke(bounds, item)\n      .translate(item.x || 0, item.y || 0);\n  }\n\n  function draw(context, item) {\n    var x = item.x || 0,\n        y = item.y || 0;\n    context.translate(x, y);\n    context.beginPath();\n    shape(context, item);\n    context.translate(-x, -y);\n  }\n\n  return {\n    type:   type,\n    tag:    'path',\n    nested: false,\n    attr:   attr,\n    bound:  bound,\n    draw:   drawAll(draw),\n    pick:   pickPath(draw)\n  };\n\n}\n","import boundStroke from '../bound/boundStroke';\nimport context from '../bound/boundContext';\nimport {drawOne} from '../util/canvas/draw';\nimport {hitPath} from '../util/canvas/pick';\n\nexport default function(type, shape, tip) {\n\n  function attr(emit, item) {\n    var items = item.mark.items;\n    if (items.length) emit('d', shape(null, items));\n  }\n\n  function bound(bounds, mark) {\n    var items = mark.items;\n    if (items.length === 0) {\n      return bounds;\n    } else {\n      shape(context(bounds), items);\n      return boundStroke(bounds, items[0]);\n    }\n  }\n\n  function draw(context, items) {\n    context.beginPath();\n    shape(context, items);\n  }\n\n  var hit = hitPath(draw);\n\n  function pick(context, scene, x, y, gx, gy) {\n    var items = scene.items,\n        b = scene.bounds;\n\n    if (!items || !items.length || b && !b.contains(gx, gy)) {\n      return null;\n    }\n\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n    return hit(context, items, x, y) ? items[0] : null;\n  }\n\n  return {\n    type:   type,\n    tag:    'path',\n    nested: true,\n    attr:   attr,\n    bound:  bound,\n    draw:   drawOne(draw),\n    pick:   pick,\n    tip:    tip\n  };\n\n}\n\n\n","import boundStroke from '../bound/boundStroke';\nimport context from '../bound/boundContext';\nimport pathParse from '../path/parse';\nimport pathRender from '../path/render';\nimport {drawAll} from '../util/canvas/draw';\nimport {pickPath} from '../util/canvas/pick';\nimport translateItem from '../util/svg/translateItem';\n\nfunction attr(emit, item) {\n  emit('transform', translateItem(item));\n  emit('d', item.path);\n}\n\nfunction path(context, item) {\n  var path = item.path;\n  if (path == null) return true;\n\n  var cache = item.pathCache;\n  if (!cache || cache.path !== path) {\n    (item.pathCache = cache = pathParse(path)).path = path;\n  }\n  pathRender(context, cache, item.x, item.y);\n}\n\nfunction bound(bounds, item) {\n  return path(context(bounds), item)\n    ? bounds.set(0, 0, 0, 0)\n    : boundStroke(bounds, item);\n}\n\nexport default {\n  type:   'path',\n  tag:    'path',\n  nested: false,\n  attr:   attr,\n  bound:  bound,\n  draw:   drawAll(path),\n  pick:   pickPath(path)\n};\n","import boundStroke from '../bound/boundStroke';\nimport {rectangle} from '../path/shapes';\nimport {drawAll} from '../util/canvas/draw';\nimport {pickPath} from '../util/canvas/pick';\n\nfunction attr(emit, item) {\n  emit('d', rectangle(null, item));\n}\n\nfunction bound(bounds, item) {\n  var x, y;\n  return boundStroke(bounds.set(\n    x = item.x || 0,\n    y = item.y || 0,\n    (x + item.width) || 0,\n    (y + item.height) || 0\n  ), item);\n}\n\nfunction draw(context, item) {\n  context.beginPath();\n  rectangle(context, item);\n}\n\nexport default {\n  type:   'rect',\n  tag:    'path',\n  nested: false,\n  attr:   attr,\n  bound:  bound,\n  draw:   drawAll(draw),\n  pick:   pickPath(draw)\n};\n","import boundStroke from '../bound/boundStroke';\nimport {visit} from '../util/visit';\nimport {pick} from '../util/canvas/pick';\nimport stroke from '../util/canvas/stroke';\nimport translateItem from '../util/svg/translateItem';\n\nfunction attr(emit, item) {\n  emit('transform', translateItem(item));\n  emit('x2', item.x2 != null ? item.x2 - (item.x||0) : 0);\n  emit('y2', item.y2 != null ? item.y2 - (item.y||0) : 0);\n}\n\nfunction bound(bounds, item) {\n  var x1, y1;\n  return boundStroke(bounds.set(\n    x1 = item.x || 0,\n    y1 = item.y || 0,\n    item.x2 != null ? item.x2 : x1,\n    item.y2 != null ? item.y2 : y1\n  ), item);\n}\n\nfunction path(context, item, opacity) {\n  var x1, y1, x2, y2;\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    x1 = item.x || 0;\n    y1 = item.y || 0;\n    x2 = item.x2 != null ? item.x2 : x1;\n    y2 = item.y2 != null ? item.y2 : y1;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n    return true;\n  }\n  return false;\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, function(item) {\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n    var opacity = item.opacity == null ? 1 : item.opacity;\n    if (opacity && path(context, item, opacity)) {\n      context.stroke();\n    }\n  });\n}\n\nfunction hit(context, item, x, y) {\n  if (!context.isPointInStroke) return false;\n  return path(context, item, 1) && context.isPointInStroke(x, y);\n}\n\nexport default {\n  type:   'rule',\n  tag:    'line',\n  nested: false,\n  attr:   attr,\n  bound:  bound,\n  draw:   draw,\n  pick:   pick(hit)\n};\n","import {shape} from '../path/shapes';\nimport markItemPath from './markItemPath';\n\nexport default markItemPath('shape', shape);\n","import {symbol} from '../path/shapes';\nimport markItemPath from './markItemPath';\n\nexport default markItemPath('symbol', symbol);\n","import Bounds from '../Bounds';\nimport {font, offset, textMetrics, textValue} from '../util/text';\nimport {visit} from '../util/visit';\nimport fill from '../util/canvas/fill';\nimport {pick} from '../util/canvas/pick';\nimport stroke from '../util/canvas/stroke';\nimport translate from '../util/svg/translate';\n\nvar textAlign = {\n  'left':   'start',\n  'center': 'middle',\n  'right':  'end'\n};\n\nvar tempBounds = new Bounds();\n\nfunction attr(emit, item) {\n  var dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item),\n      x = item.x || 0,\n      y = item.y || 0,\n      a = item.angle || 0,\n      r = item.radius || 0, t;\n\n  if (r) {\n    t = (item.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  emit('text-anchor', textAlign[item.align] || 'start');\n\n  if (a) {\n    t = translate(x, y) + ' rotate('+a+')';\n    if (dx || dy) t += ' ' + translate(dx, dy);\n  } else {\n    t = translate(x + dx, y + dy);\n  }\n  emit('transform', t);\n}\n\nfunction bound(bounds, item, noRotate) {\n  var h = textMetrics.height(item),\n      a = item.align,\n      r = item.radius || 0,\n      x = item.x || 0,\n      y = item.y || 0,\n      dx = item.dx || 0,\n      dy = (item.dy || 0) + offset(item) - Math.round(0.8*h), // use 4/5 offset\n      w, t;\n\n  if (r) {\n    t = (item.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal alignment\n  w = textMetrics.width(item);\n  if (a === 'center') {\n    dx -= (w / 2);\n  } else if (a === 'right') {\n    dx -= w;\n  } else {\n    // left by default, do nothing\n  }\n\n  bounds.set(dx+=x, dy+=y, dx+w, dy+h);\n  if (item.angle && !noRotate) {\n    bounds.rotate(item.angle*Math.PI/180, x, y);\n  }\n  return bounds.expand(noRotate || !w ? 0 : 1);\n}\n\nfunction draw(context, scene, bounds) {\n  visit(scene, function(item) {\n    var opacity, x, y, r, t, str;\n    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check\n    if (!(str = textValue(item))) return; // get text string\n\n    opacity = item.opacity == null ? 1 : item.opacity;\n    if (opacity === 0) return;\n\n    context.font = font(item);\n    context.textAlign = item.align || 'left';\n\n    x = item.x || 0;\n    y = item.y || 0;\n    if ((r = item.radius)) {\n      t = (item.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (item.angle) {\n      context.save();\n      context.translate(x, y);\n      context.rotate(item.angle * Math.PI/180);\n      x = y = 0; // reset x, y\n    }\n    x += (item.dx || 0);\n    y += (item.dy || 0) + offset(item);\n\n    if (item.fill && fill(context, item, opacity)) {\n      context.fillText(str, x, y);\n    }\n    if (item.stroke && stroke(context, item, opacity)) {\n      context.strokeText(str, x, y);\n    }\n    if (item.angle) context.restore();\n  });\n}\n\nfunction hit(context, item, x, y, gx, gy) {\n  if (item.fontSize <= 0) return false;\n  if (!item.angle) return true; // bounds sufficient if no rotation\n\n  // project point into space of unrotated bounds\n  var b = bound(tempBounds, item, true),\n      a = -item.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      ix = item.x,\n      iy = item.y,\n      px = cos*gx - sin*gy + (ix - ix*cos + iy*sin),\n      py = sin*gx + cos*gy + (iy - ix*sin - iy*cos);\n\n  return b.contains(px, py);\n}\n\nexport default {\n  type:   'text',\n  tag:    'text',\n  nested: false,\n  attr:   attr,\n  bound:  bound,\n  draw:   draw,\n  pick:   pick(hit)\n};\n","import {trail} from '../path/shapes';\nimport {pickTrail} from '../util/pickPath';\nimport markMultiItemPath from './markMultiItemPath';\n\nexport default markMultiItemPath('trail', trail, pickTrail);\n","import CanvasHandler from './CanvasHandler';\nimport CanvasRenderer from './CanvasRenderer';\nimport SVGHandler from './SVGHandler';\nimport SVGRenderer from './SVGRenderer';\nimport SVGStringRenderer from './SVGStringRenderer';\n\nvar Canvas = 'canvas';\nvar PNG = 'png';\nvar SVG = 'svg';\nvar None = 'none';\n\nexport var RenderType = {\n  Canvas: Canvas,\n  PNG:    PNG,\n  SVG:    SVG,\n  None:   None\n};\n\nvar modules = {};\n\nmodules[Canvas] = modules[PNG] = {\n  renderer: CanvasRenderer,\n  headless: CanvasRenderer,\n  handler:  CanvasHandler\n};\n\nmodules[SVG] = {\n  renderer: SVGRenderer,\n  headless: SVGStringRenderer,\n  handler:  SVGHandler\n};\n\nmodules[None] = {};\n\nexport function renderModule(name, _) {\n  name = String(name || '').toLowerCase();\n  if (arguments.length > 1) {\n    modules[name] = _;\n    return this;\n  } else {\n    return modules[name];\n  }\n}\n","export var segmentCache = {};\nexport var bezierCache = {};\n\nvar join = [].join;\n\n// Copied from Inkscape svgtopdf, thanks!\nexport function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  var key = join.call(arguments);\n  if (segmentCache[key]) {\n    return segmentCache[key];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep === 1) {\n    th_arc += 2 * Math.PI;\n  } else if (th_arc > 0 && sweep === 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segs = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segs; ++i) {\n    var th2 = th0 + i * th_arc / segs;\n    var th3 = th0 + (i+1) * th_arc / segs;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (segmentCache[key] = result);\n}\n\nexport function bezier(params) {\n  var key = join.call(params);\n  if (bezierCache[key]) {\n    return bezierCache[key];\n  }\n\n  var cx = params[0],\n      cy = params[1],\n      th0 = params[2],\n      th1 = params[3],\n      rx = params[4],\n      ry = params[5],\n      sin_th = params[6],\n      cos_th = params[7];\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (bezierCache[key] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n","import {\n  curveBasis,\n  curveBasisClosed,\n  curveBasisOpen,\n  curveBundle,\n  curveCardinal,\n  curveCardinalClosed,\n  curveCardinalOpen,\n  curveCatmullRom,\n  curveCatmullRomClosed,\n  curveCatmullRomOpen,\n  curveLinear,\n  curveLinearClosed,\n  curveMonotoneX,\n  curveMonotoneY,\n  curveNatural,\n  curveStep,\n  curveStepAfter,\n  curveStepBefore\n} from 'd3-shape';\n\nvar lookup = {\n  'basis': {\n    curve: curveBasis\n  },\n  'basis-closed': {\n    curve: curveBasisClosed\n  },\n  'basis-open': {\n    curve: curveBasisOpen\n  },\n  'bundle': {\n    curve: curveBundle,\n    tension: 'beta',\n    value: 0.85\n  },\n  'cardinal': {\n    curve: curveCardinal,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-open': {\n    curve: curveCardinalOpen,\n    tension: 'tension',\n    value: 0\n  },\n  'cardinal-closed': {\n    curve: curveCardinalClosed,\n    tension: 'tension',\n    value: 0\n  },\n  'catmull-rom': {\n    curve: curveCatmullRom,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-closed': {\n    curve: curveCatmullRomClosed,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'catmull-rom-open': {\n    curve: curveCatmullRomOpen,\n    tension: 'alpha',\n    value: 0.5\n  },\n  'linear': {\n    curve: curveLinear\n  },\n  'linear-closed': {\n    curve: curveLinearClosed\n  },\n  'monotone': {\n    horizontal: curveMonotoneY,\n    vertical:   curveMonotoneX\n  },\n  'natural': {\n    curve: curveNatural\n  },\n  'step': {\n    curve: curveStep\n  },\n  'step-after': {\n    curve: curveStepAfter\n  },\n  'step-before': {\n    curve: curveStepBefore\n  }\n};\n\nexport default function curves(type, orientation, tension) {\n  var entry = lookup.hasOwnProperty(type) && lookup[type],\n      curve = null;\n\n  if (entry) {\n    curve = entry.curve || entry[orientation || 'vertical'];\n    if (entry.tension && tension != null) {\n      curve = curve[entry.tension](tension);\n    }\n  }\n\n  return curve;\n}\n","// Path parsing and rendering code adapted from fabric.js -- Thanks!\nvar cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)([-+])/g, /\\s|,|###/];\n\nexport default function(pathstr) {\n  var result = [],\n      path,\n      curr,\n      chunks,\n      parsed, param,\n      cmd, len, i, j, n, m;\n\n  // First, break path into command sequence\n  path = pathstr\n    .slice()\n    .replace(regexp[0], '###$1')\n    .split(regexp[1])\n    .slice(1);\n\n  // Next, parse each command in turn\n  for (i=0, n=path.length; i<n; ++i) {\n    curr = path[i];\n    chunks = curr\n      .slice(1)\n      .trim()\n      .replace(regexp[2],'$1###$2')\n      .split(regexp[3]);\n    cmd = curr.charAt(0);\n\n    parsed = [cmd];\n    for (j=0, m=chunks.length; j<m; ++j) {\n      if ((param = +chunks[j]) === param) { // not NaN\n        parsed.push(param);\n      }\n    }\n\n    len = cmdlen[cmd.toLowerCase()];\n    if (parsed.length-1 > len) {\n      for (j=1, m=parsed.length; j<m; j+=len) {\n        result.push([cmd].concat(parsed.slice(j, j+len)));\n      }\n    }\n    else {\n      result.push(parsed);\n    }\n  }\n\n  return result;\n}\n","import {path} from 'd3-path';\n\nfunction rectangleX(d) {\n  return d.x;\n}\n\nfunction rectangleY(d) {\n  return d.y;\n}\n\nfunction rectangleWidth(d) {\n  return d.width;\n}\n\nfunction rectangleHeight(d) {\n  return d.height;\n}\n\nfunction constant(_) {\n  return function() { return _; };\n}\n\nexport default function() {\n  var x = rectangleX,\n      y = rectangleY,\n      width = rectangleWidth,\n      height = rectangleHeight,\n      cornerRadius = constant(0),\n      context = null;\n\n  function rectangle(_, x0, y0) {\n    var buffer,\n        x1 = x0 != null ? x0 : +x.call(this, _),\n        y1 = y0 != null ? y0 : +y.call(this, _),\n        w  = +width.call(this, _),\n        h  = +height.call(this, _),\n        cr = +cornerRadius.call(this, _);\n\n    if (!context) context = buffer = path();\n\n    if (cr <= 0) {\n      context.rect(x1, y1, w, h);\n    } else {\n      var x2 = x1 + w,\n          y2 = y1 + h;\n      context.moveTo(x1 + cr, y1);\n      context.lineTo(x2 - cr, y1);\n      context.quadraticCurveTo(x2, y1, x2, y1 + cr);\n      context.lineTo(x2, y2 - cr);\n      context.quadraticCurveTo(x2, y2, x2 - cr, y2);\n      context.lineTo(x1 + cr, y2);\n      context.quadraticCurveTo(x1, y2, x1, y2 - cr);\n      context.lineTo(x1, y1 + cr);\n      context.quadraticCurveTo(x1, y1, x1 + cr, y1);\n      context.closePath();\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  rectangle.x = function(_) {\n    if (arguments.length) {\n      x = typeof _ === 'function' ? _ : constant(+_);\n      return rectangle;\n    } else {\n      return x;\n    }\n  };\n\n  rectangle.y = function(_) {\n    if (arguments.length) {\n      y = typeof _ === 'function' ? _ : constant(+_);\n      return rectangle;\n    } else {\n      return y;\n    }\n  };\n\n  rectangle.width = function(_) {\n    if (arguments.length) {\n      width = typeof _ === 'function' ? _ : constant(+_);\n      return rectangle;\n    } else {\n      return width;\n    }\n  };\n\n  rectangle.height = function(_) {\n    if (arguments.length) {\n      height = typeof _ === 'function' ? _ : constant(+_);\n      return rectangle;\n    } else {\n      return height;\n    }\n  };\n\n  rectangle.cornerRadius = function(_) {\n    if (arguments.length) {\n      cornerRadius = typeof _ === 'function' ? _ : constant(+_);\n      return rectangle;\n    } else {\n      return cornerRadius;\n    }\n  };\n\n  rectangle.context = function(_) {\n    if (arguments.length) {\n      context = _ == null ? null : _;\n      return rectangle;\n    } else {\n      return context;\n    }\n  };\n\n  return rectangle;\n}\n","import {bezier, segments} from './arc';\n\nvar temp = ['l', 0, 0, 0, 0, 0, 0, 0];\n\nfunction scale(current, s) {\n  var c = (temp[0] = current[0]);\n  if (c === 'a' || c === 'A') {\n    temp[1] = s * current[1];\n    temp[2] = s * current[2];\n    temp[3] = current[3];\n    temp[4] = current[4];\n    temp[5] = current[5];\n    temp[6] = s * current[6];\n    temp[7] = s * current[7];\n  } else {\n    for (var i=1, n=current.length; i<n; ++i) {\n      temp[i] = s * current[i];\n    }\n  }\n  return temp;\n}\n\nexport default function(context, path, l, t, s) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  if (l == null) l = 0;\n  if (t == null) t = 0;\n  if (s == null) s = 1;\n\n  if (context.beginPath) context.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n    if (s !== 1) current = scale(current, s);\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        context.lineTo(x + l, y + t);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        context.moveTo(x + l, y + t);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        context.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        context.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        context.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        // set control point to 2nd one of this command\n        // the first control point is assumed to be the reflection of\n        // the second control point on the previous command relative\n        // to the current point.\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        context.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        context.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        context.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        context.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'a':\n        drawArc(context, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ]);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(context, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ]);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        context.closePath();\n        break;\n    }\n    previous = current;\n  }\n}\n\nfunction drawArc(context, x, y, coords) {\n  var seg = segments(\n    coords[5], // end x\n    coords[6], // end y\n    coords[0], // radius x\n    coords[1], // radius y\n    coords[3], // large flag\n    coords[4], // sweep flag\n    coords[2], // rotation\n    x, y\n  );\n  for (var i=0; i<seg.length; ++i) {\n    var bez = bezier(seg[i]);\n    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);\n  }\n}\n","import curves from './curves';\nimport symbols from './symbols';\n\nimport {default as vg_rect} from './rectangle';\nimport {default as vg_trail} from './trail';\n\nimport {\n  arc as d3_arc,\n  symbol as d3_symbol,\n  area as d3_area,\n  line as d3_line\n} from 'd3-shape';\n\nfunction x(item)    { return item.x || 0; }\nfunction y(item)    { return item.y || 0; }\nfunction w(item)    { return item.width || 0; }\nfunction ts(item)   { return item.size || 1; }\nfunction h(item)    { return item.height || 0; }\nfunction xw(item)   { return (item.x || 0) + (item.width || 0); }\nfunction yh(item)   { return (item.y || 0) + (item.height || 0); }\nfunction sa(item)   { return item.startAngle || 0; }\nfunction ea(item)   { return item.endAngle || 0; }\nfunction pa(item)   { return item.padAngle || 0; }\nfunction ir(item)   { return item.innerRadius || 0; }\nfunction or(item)   { return item.outerRadius || 0; }\nfunction cr(item)   { return item.cornerRadius || 0; }\nfunction def(item)  { return !(item.defined === false); }\nfunction size(item) { return item.size == null ? 64 : item.size; }\nfunction type(item) { return symbols(item.shape || 'circle'); }\n\nvar arcShape    = d3_arc().startAngle(sa).endAngle(ea).padAngle(pa)\n                          .innerRadius(ir).outerRadius(or).cornerRadius(cr),\n    areavShape  = d3_area().x(x).y1(y).y0(yh).defined(def),\n    areahShape  = d3_area().y(y).x1(x).x0(xw).defined(def),\n    lineShape   = d3_line().x(x).y(y).defined(def),\n    rectShape   = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(cr),\n    symbolShape = d3_symbol().type(type).size(size),\n    trailShape  = vg_trail().x(x).y(y).defined(def).size(ts);\n\nexport function arc(context, item) {\n  return arcShape.context(context)(item);\n}\n\nexport function area(context, items) {\n  var item = items[0],\n      interp = item.interpolate || 'linear';\n  return (item.orient === 'horizontal' ? areahShape : areavShape)\n    .curve(curves(interp, item.orient, item.tension))\n    .context(context)(items);\n}\n\nexport function line(context, items) {\n  var item = items[0],\n      interp = item.interpolate || 'linear';\n  return lineShape.curve(curves(interp, item.orient, item.tension))\n    .context(context)(items);\n}\n\nexport function rectangle(context, item, x, y) {\n  return rectShape.context(context)(item, x, y);\n}\n\nexport function shape(context, item) {\n  return (item.mark.shape || item.shape)\n    .context(context)(item);\n}\n\nexport function symbol(context, item) {\n  return symbolShape.context(context)(item);\n}\n\nexport function trail(context, items) {\n  return trailShape.context(context)(items);\n}\n","import pathParse from './parse';\nimport pathRender from './render';\n\nvar tau = 2 * Math.PI,\n    halfSqrt3 = Math.sqrt(3) / 2;\n\nvar builtins = {\n  'circle': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2;\n      context.moveTo(r, 0);\n      context.arc(0, 0, r, 0, tau);\n    }\n  },\n  'cross': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          s = r / 2.5;\n      context.moveTo(-r, -s);\n      context.lineTo(-r, s);\n      context.lineTo(-s, s);\n      context.lineTo(-s, r);\n      context.lineTo(s, r);\n      context.lineTo(s, s);\n      context.lineTo(r, s);\n      context.lineTo(r, -s);\n      context.lineTo(s, -s);\n      context.lineTo(s, -r);\n      context.lineTo(-s, -r);\n      context.lineTo(-s, -s);\n      context.closePath();\n    }\n  },\n  'diamond': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2;\n      context.moveTo(-r, 0);\n      context.lineTo(0, -r);\n      context.lineTo(r, 0);\n      context.lineTo(0, r);\n      context.closePath();\n    }\n  },\n  'square': {\n    draw: function(context, size) {\n      var w = Math.sqrt(size),\n          x = -w / 2;\n      context.rect(x, x, w, w);\n    }\n  },\n  'triangle-up': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = halfSqrt3 * r;\n      context.moveTo(0, -h);\n      context.lineTo(-r, h);\n      context.lineTo(r, h);\n      context.closePath();\n    }\n  },\n  'triangle-down': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = halfSqrt3 * r;\n      context.moveTo(0, h);\n      context.lineTo(-r, -h);\n      context.lineTo(r, -h);\n      context.closePath();\n    }\n  },\n  'triangle-right': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = halfSqrt3 * r;\n      context.moveTo(h, 0);\n      context.lineTo(-h, -r);\n      context.lineTo(-h, r);\n      context.closePath();\n    }\n  },\n  'triangle-left': {\n    draw: function(context, size) {\n      var r = Math.sqrt(size) / 2,\n          h = halfSqrt3 * r;\n      context.moveTo(-h, 0);\n      context.lineTo(h, -r);\n      context.lineTo(h, r);\n      context.closePath();\n    }\n  }\n};\n\nexport default function symbols(_) {\n  return builtins.hasOwnProperty(_) ? builtins[_] : customSymbol(_);\n}\n\nvar custom = {};\n\nfunction customSymbol(path) {\n  if (!custom.hasOwnProperty(path)) {\n    var parsed = pathParse(path);\n    custom[path] = {\n      draw: function(context, size) {\n        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);\n      }\n    };\n  }\n  return custom[path];\n}\n","import {path} from 'd3-path';\n\nvar pi = Math.PI;\n\nexport default function() {\n  var x,\n      y,\n      size,\n      defined,\n      context = null,\n      ready, x1, y1, r1;\n\n  function point(x2, y2, w2) {\n    var r2 = w2 / 2;\n\n    if (ready) {\n      var ux = y1 - y2,\n          uy = x2 - x1;\n\n      if (ux || uy) {\n        // get normal vector\n        var ud = Math.sqrt(ux * ux + uy * uy),\n            rx = (ux /= ud) * r1,\n            ry = (uy /= ud) * r1,\n            t = Math.atan2(uy, ux);\n\n        // draw segment\n        context.moveTo(x1 - rx, y1 - ry);\n        context.lineTo(x2 - ux * r2, y2 - uy * r2);\n        context.arc(x2, y2, r2, t - pi, t);\n        context.lineTo(x1 + rx, y1 + ry);\n        context.arc(x1, y1, r1, t, t + pi);\n      } else {\n        context.arc(x2, y2, r2, 0, 2*pi);\n      }\n      context.closePath();\n    } else {\n      ready = 1;\n    }\n    x1 = x2;\n    y1 = y2;\n    r1 = r2;\n  }\n\n  function trail(data) {\n    var i,\n        n = data.length,\n        d,\n        defined0 = false,\n        buffer;\n\n    if (context == null) context = buffer = path();\n\n    for (i = 0; i <= n; ++i) {\n      if (!(i < n && defined(d = data[i], i, data)) === defined0) {\n        if (defined0 = !defined0) ready = 0;\n      }\n      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));\n    }\n\n    if (buffer) {\n      context = null;\n      return buffer + '' || null;\n    }\n  }\n\n  trail.x = function(_) {\n    if (arguments.length) {\n      x = _;\n      return trail;\n    } else {\n      return x;\n    }\n  };\n\n  trail.y = function(_) {\n    if (arguments.length) {\n      y = _;\n      return trail;\n    } else {\n      return y;\n    }\n  };\n\n  trail.size = function(_) {\n    if (arguments.length) {\n      size = _;\n      return trail;\n    } else {\n      return size;\n    }\n  };\n\n  trail.defined = function(_) {\n    if (arguments.length) {\n      defined = _;\n      return trail;\n    } else {\n      return defined;\n    }\n  };\n\n  trail.context = function(_) {\n    if (arguments.length) {\n      if (_ == null) {\n        context = null;\n      } else {\n        context = _;\n      }\n      return trail;\n    } else {\n      return context;\n    }\n  };\n\n  return trail;\n}\n","import {isFunction} from 'vega-util';\n\nexport default function(context, scene) {\n  var clip = scene.clip;\n\n  context.save();\n  context.beginPath();\n\n  if (isFunction(clip)) {\n    clip(context);\n  } else {\n    var group = scene.group;\n    context.rect(0, 0, group.width || 0, group.height || 0);\n  }\n\n  context.clip();\n}\n","import gradient from './gradient';\n\nexport default function(context, item, value) {\n  return (value.id) ?\n    gradient(context, value, item.bounds) :\n    value;\n}\n","import fill from './fill';\nimport stroke from './stroke';\nimport {visit} from '../visit';\n\nexport function drawAll(path) {\n  return function(context, scene, bounds) {\n    visit(scene, function(item) {\n      if (!bounds || bounds.intersects(item.bounds)) {\n        drawPath(path, context, item, item);\n      }\n    });\n  };\n}\n\nexport function drawOne(path) {\n  return function(context, scene, bounds) {\n    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {\n      drawPath(path, context, scene.items[0], scene.items);\n    }\n  };\n}\n\nfunction drawPath(path, context, item, items) {\n  var opacity = item.opacity == null ? 1 : item.opacity;\n  if (opacity === 0) return;\n\n  if (path(context, items)) return;\n\n  if (item.fill && fill(context, item, opacity)) {\n    context.fill();\n  }\n\n  if (item.stroke && stroke(context, item, opacity)) {\n    context.stroke();\n  }\n}\n","import color from './color';\n\nexport default function(context, item, opacity) {\n  opacity *= (item.fillOpacity==null ? 1 : item.fillOpacity);\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.fillStyle = color(context, item, item.fill);\n    return true;\n  } else {\n    return false;\n  }\n}\n","export default function(context, gradient, bounds) {\n  var w = bounds.width(),\n      h = bounds.height(),\n      x1 = bounds.x1 + gradient.x1 * w,\n      y1 = bounds.y1 + gradient.y1 * h,\n      x2 = bounds.x1 + gradient.x2 * w,\n      y2 = bounds.y1 + gradient.y2 * h,\n      stop = gradient.stops,\n      i = 0,\n      n = stop.length,\n      linearGradient = context.createLinearGradient(x1, y1, x2, y2);\n\n  for (; i<n; ++i) {\n    linearGradient.addColorStop(stop[i].offset, stop[i].color);\n  }\n\n  return linearGradient;\n}\n","import {pickVisit} from '../visit';\n\nvar trueFunc = function() { return true; };\n\nexport function pick(test) {\n  if (!test) test = trueFunc;\n\n  return function(context, scene, x, y, gx, gy) {\n    x *= context.pixelRatio;\n    y *= context.pixelRatio;\n\n    return pickVisit(scene, function(item) {\n      var b = item.bounds;\n      // first hit test against bounding box\n      if ((b && !b.contains(gx, gy)) || !b) return;\n      // if in bounding box, perform more careful test\n      if (test(context, item, x, y, gx, gy)) return item;\n    });\n  };\n}\n\nexport function hitPath(path, filled) {\n  return function(context, o, x, y) {\n    var item = Array.isArray(o) ? o[0] : o,\n        fill = (filled == null) ? item.fill : filled,\n        stroke = item.stroke && context.isPointInStroke, lw, lc;\n\n    if (stroke) {\n      lw = item.strokeWidth;\n      lc = item.strokeCap;\n      context.lineWidth = lw != null ? lw : 1;\n      context.lineCap   = lc != null ? lc : 'butt';\n    }\n\n    return path(context, o) ? false :\n      (fill && context.isPointInPath(x, y)) ||\n      (stroke && context.isPointInStroke(x, y));\n  };\n}\n\nexport function pickPath(path) {\n  return pick(hitPath(path));\n}\n","function devicePixelRatio() {\n  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;\n}\n\nvar pixelRatio = devicePixelRatio();\n\nexport default function(canvas, width, height, origin, scaleFactor) {\n  var inDOM = typeof HTMLElement !== 'undefined'\n    && canvas instanceof HTMLElement\n    && canvas.parentNode != null;\n\n  var context = canvas.getContext('2d'),\n      ratio = inDOM ? pixelRatio : scaleFactor;\n\n  canvas.width = width * ratio;\n  canvas.height = height * ratio;\n\n  if (inDOM && ratio !== 1) {\n    canvas.style.width = width + 'px';\n    canvas.style.height = height + 'px';\n  }\n\n  context.pixelRatio = ratio;\n  context.setTransform(\n    ratio, 0, 0, ratio,\n    ratio * origin[0],\n    ratio * origin[1]\n  );\n\n  return canvas;\n}\n","import color from './color';\n\nvar Empty = [];\n\nexport default function(context, item, opacity) {\n  var lw = (lw = item.strokeWidth) != null ? lw : 1;\n\n  if (lw <= 0) return false;\n\n  opacity *= (item.strokeOpacity==null ? 1 : item.strokeOpacity);\n  if (opacity > 0) {\n    context.globalAlpha = opacity;\n    context.strokeStyle = color(context, item, item.stroke);\n\n    context.lineWidth = lw;\n    context.lineCap = item.strokeCap || 'butt';\n    context.lineJoin = item.strokeJoin || 'miter';\n    context.miterLimit = item.strokeMiterLimit || 10;\n\n    if (context.setLineDash) {\n      context.setLineDash(item.strokeDash || Empty);\n      context.lineDashOffset = item.strokeDashOffset || 0;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\n","// create a new DOM element\nexport function domCreate(doc, tag, ns) {\n  if (!doc && typeof document !== 'undefined' && document.createElement) {\n    doc = document;\n  }\n  return doc\n    ? (ns ? doc.createElementNS(ns, tag) : doc.createElement(tag))\n    : null;\n}\n\n// find first child element with matching tag\nexport function domFind(el, tag) {\n  tag = tag.toLowerCase();\n  var nodes = el.childNodes, i = 0, n = nodes.length;\n  for (; i<n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {\n    return nodes[i];\n  }\n}\n\n// retrieve child element at given index\n// create & insert if doesn't exist or if tags do not match\nexport function domChild(el, index, tag, ns) {\n  var a = el.childNodes[index], b;\n  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {\n    b = a || null;\n    a = domCreate(el.ownerDocument, tag, ns);\n    el.insertBefore(a, b);\n  }\n  return a;\n}\n\n// remove all child elements at or above the given index\nexport function domClear(el, index) {\n  var nodes = el.childNodes,\n      curr = nodes.length;\n  while (curr > index) el.removeChild(nodes[--curr]);\n  return el;\n}\n\n// generate css class name for mark\nexport function cssClass(mark) {\n  return 'mark-' + mark.marktype\n    + (mark.role ? ' role-' + mark.role : '')\n    + (mark.name ? ' ' + mark.name : '');\n}\n","import pathParse from '../path/parse';\nimport {isNumber, isObject} from 'vega-util';\n\nvar TOLERANCE = 1e-9;\n\nexport function sceneEqual(a, b, key) {\n  return (a === b) ? true\n    : (key === 'path') ? pathEqual(a, b)\n    : (a instanceof Date && b instanceof Date) ? +a === +b\n    : (isNumber(a) && isNumber(b)) ? Math.abs(a - b) <= TOLERANCE\n    : (!a || !b || !isObject(a) && !isObject(b)) ? a == b\n    : (a == null || b == null) ? false\n    : objectEqual(a, b);\n}\n\nexport function pathEqual(a, b) {\n  return sceneEqual(pathParse(a), pathParse(b));\n}\n\nfunction objectEqual(a, b) {\n  var ka = Object.keys(a),\n      kb = Object.keys(b),\n      key, i;\n\n  if (ka.length !== kb.length) return false;\n\n  ka.sort();\n  kb.sort();\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i]) return false;\n  }\n\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!sceneEqual(a[key], b[key], key)) return false;\n  }\n\n  return typeof a === typeof b;\n}\n","export var Events = [\n  'keydown',\n  'keypress',\n  'keyup',\n  'dragenter',\n  'dragleave',\n  'dragover',\n  'mousedown',\n  'mouseup',\n  'mousemove',\n  'mouseout',\n  'mouseover',\n  'click',\n  'dblclick',\n  'wheel',\n  'mousewheel',\n  'touchstart',\n  'touchmove',\n  'touchend'\n];\n\nexport var TooltipShowEvent = 'mousemove';\n\nexport var TooltipHideEvent = 'mouseout';\n\nexport var HrefEvent = 'click';\n","export function pickArea(a, p) {\n  var v = a[0].orient === 'horizontal' ? p[1] : p[0],\n      z = a[0].orient === 'horizontal' ? 'y' : 'x',\n      i = a.length,\n      min = +Infinity, hit, d;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    d = Math.abs(a[i][z] - v);\n    if (d < min) {\n      min = d;\n      hit = a[i];\n    }\n  }\n\n  return hit;\n}\n\nexport function pickLine(a, p) {\n  var t = Math.pow(a[0].strokeWidth || 1, 2),\n      i = a.length, dx, dy, dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    if (dd < t) return a[i];\n  }\n\n  return null;\n}\n\nexport function pickTrail(a, p) {\n  var i = a.length, dx, dy, dd;\n\n  while (--i >= 0) {\n    if (a[i].defined === false) continue;\n    dx = a[i].x - p[0];\n    dy = a[i].y - p[1];\n    dd = dx * dx + dy * dy;\n    dx = a[i].size || 1;\n    if (dd < dx*dx) return a[i];\n  }\n\n  return null;\n}\n","export default function(event, el) {\n  var rect = el.getBoundingClientRect();\n  return [\n    event.clientX - rect.left - (el.clientLeft || 0),\n    event.clientY - rect.top - (el.clientTop || 0)\n  ];\n}\n","import marks from '../marks/index';\nimport point from './point';\n\nexport default function(item, event, el, origin) {\n  var mark = item && item.mark,\n      mdef, p;\n\n  if (mark && (mdef = marks[mark.marktype]).tip) {\n    p = point(event, el);\n    p[0] -= origin[0];\n    p[1] -= origin[1];\n    while (item = item.mark.group) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n    }\n    item = mdef.tip(mark.items, p);\n  }\n\n  return item;\n}\n","import boundMark from '../bound/boundMark';\n\nvar keys = [\n  'marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex',\n  'x', 'y', 'width', 'height', 'align', 'baseline',             // layout\n  'fill', 'fillOpacity', 'opacity',                             // fill\n  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke\n  'strokeDash', 'strokeDashOffset',                             // stroke dash\n  'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc\n  'cornerRadius', 'padAngle',                                   // arc, rect\n  'interpolate', 'tension', 'orient', 'defined',                // area, line\n  'url',                                                        // image\n  'path',                                                       // path\n  'x2', 'y2',                                                   // rule\n  'size', 'shape',                                              // symbol\n  'text', 'angle', 'theta', 'radius', 'dx', 'dy',               // text\n  'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant'  // font\n];\n\nexport function sceneToJSON(scene, indent) {\n  return JSON.stringify(scene, keys, indent);\n}\n\nexport function sceneFromJSON(json) {\n  var scene = (typeof json === 'string' ? JSON.parse(json) : json);\n  return initialize(scene);\n}\n\nfunction initialize(scene) {\n  var type = scene.marktype,\n      items = scene.items,\n      parent, i, n;\n\n  if (items) {\n    for (i=0, n=items.length; i<n; ++i) {\n      parent = type ? 'mark' : 'group';\n      items[i][parent] = scene;\n      if (items[i].zindex) items[i][parent].zdirty = true;\n      if ('group' === (type || parent)) initialize(items[i]);\n    }\n  }\n\n  if (type) boundMark(scene);\n  return scene;\n}\n","import {isFunction} from 'vega-util';\n\nvar clip_id = 1;\n\nexport function resetSVGClipId() {\n  clip_id = 1;\n}\n\nexport default function(renderer, item, size) {\n  var clip = item.clip,\n      defs = renderer._defs,\n      id = item.clip_id || (item.clip_id = 'clip' + clip_id++),\n      c = defs.clipping[id] || (defs.clipping[id] = {id: id});\n\n  if (isFunction(clip)) {\n    c.path = clip(null);\n  } else {\n    c.width = size.width || 0;\n    c.height = size.height || 0;\n  }\n\n  return 'url(#' + id + ')';\n}\n","export default {\n  'version': '1.1',\n  'xmlns': 'http://www.w3.org/2000/svg',\n  'xmlns:xlink': 'http://www.w3.org/1999/xlink'\n};","export var styles = {\n  'fill':             'fill',\n  'fillOpacity':      'fill-opacity',\n  'stroke':           'stroke',\n  'strokeOpacity':    'stroke-opacity',\n  'strokeWidth':      'stroke-width',\n  'strokeCap':        'stroke-linecap',\n  'strokeJoin':       'stroke-linejoin',\n  'strokeDash':       'stroke-dasharray',\n  'strokeDashOffset': 'stroke-dashoffset',\n  'strokeMiterLimit': 'stroke-miterlimit',\n  'opacity':          'opacity'\n};\n\nexport var styleProperties = Object.keys(styles);\n","export default function(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}","import translate from './translate';\n\nexport default function(item) {\n  return translate(item.x || 0, item.y || 0);\n}","// generate string for an opening xml tag\n// tag: the name of the xml tag\n// attr: hash of attribute name-value pairs to include\n// raw: additional raw string to include in tag markup\nexport function openTag(tag, attr, raw) {\n  var s = '<' + tag, key, val;\n  if (attr) {\n    for (key in attr) {\n      val = attr[key];\n      if (val != null) {\n        s += ' ' + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += ' ' + raw;\n  return s + '>';\n}\n\n// generate string for closing xml tag\n// tag: the name of the xml tag\nexport function closeTag(tag) {\n  return '</' + tag + '>';\n}\n","import {canvas} from 'vega-canvas';\n\nvar context,\n    currFontHeight;\n\nexport var textMetrics = {\n  height: fontSize,\n  measureWidth: measureWidth,\n  estimateWidth: estimateWidth,\n  width: estimateWidth,\n  canvas: useCanvas\n};\n\nuseCanvas(true);\n\n// make dumb, simple estimate if no canvas is available\nfunction estimateWidth(item) {\n  currFontHeight = fontSize(item);\n  return estimate(textValue(item));\n}\n\nfunction estimate(text) {\n  return ~~(0.8 * text.length * currFontHeight);\n}\n\n// measure text width if canvas is available\nfunction measureWidth(item) {\n  context.font = font(item);\n  return measure(textValue(item));\n}\n\nfunction measure(text) {\n  return context.measureText(text).width;\n}\n\nexport function fontSize(item) {\n  return item.fontSize != null ? item.fontSize : 11;\n}\n\nfunction useCanvas(use) {\n  context = use && (context = canvas(1,1)) ? context.getContext('2d') : null;\n  textMetrics.width = context ? measureWidth : estimateWidth;\n}\n\nexport function textValue(item) {\n  var s = item.text;\n  if (s == null) {\n    return '';\n  } else {\n    return item.limit > 0 ? truncate(item) : s + '';\n  }\n}\n\nexport function truncate(item) {\n  var limit = +item.limit,\n      text = item.text + '',\n      width;\n\n  if (context) {\n    context.font = font(item);\n    width = measure;\n  } else {\n    currFontHeight = fontSize(item);\n    width = estimate;\n  }\n\n  if (width(text) < limit) return text;\n\n  var ellipsis = item.ellipsis || '\\u2026',\n      rtl = item.dir === 'rtl',\n      lo = 0,\n      hi = text.length, mid;\n\n  limit -= width(ellipsis);\n\n  if (rtl) {\n    while (lo < hi) {\n      mid = (lo + hi >>> 1);\n      if (width(text.slice(mid)) > limit) lo = mid + 1;\n      else hi = mid;\n    }\n    return ellipsis + text.slice(lo);\n  } else {\n    while (lo < hi) {\n      mid = 1 + (lo + hi >>> 1);\n      if (width(text.slice(0, mid)) < limit) lo = mid;\n      else hi = mid - 1;\n    }\n    return text.slice(0, lo) + ellipsis;\n  }\n}\n\nexport function fontFamily(item, quote) {\n  var font = item.font;\n  return (quote && font\n    ? String(font).replace(/\"/g, '\\'')\n    : font) || 'sans-serif';\n}\n\nexport function font(item, quote) {\n  return '' +\n    (item.fontStyle ? item.fontStyle + ' ' : '') +\n    (item.fontVariant ? item.fontVariant + ' ' : '') +\n    (item.fontWeight ? item.fontWeight + ' ' : '') +\n    fontSize(item) + 'px ' +\n    fontFamily(item, quote);\n}\n\nexport function offset(item) {\n  // perform our own font baseline calculation\n  // why? not all browsers support SVG 1.1 'alignment-baseline' :(\n  var baseline = item.baseline,\n      h = fontSize(item);\n  return Math.round(\n    baseline === 'top'    ?  0.79*h :\n    baseline === 'middle' ?  0.30*h :\n    baseline === 'bottom' ? -0.21*h : 0\n  );\n}\n","function compare(a, b) {\n  return a.zindex - b.zindex || a.index - b.index;\n}\n\nexport function zorder(scene) {\n  if (!scene.zdirty) return scene.zitems;\n\n  var items = scene.items,\n      output = [], item, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    item.index = i;\n    if (item.zindex) output.push(item);\n  }\n\n  scene.zdirty = false;\n  return scene.zitems = output.sort(compare);\n}\n\nexport function visit(scene, visitor) {\n  var items = scene.items, i, n;\n  if (!items || !items.length) return;\n\n  var zitems = zorder(scene);\n\n  if (zitems && zitems.length) {\n    for (i=0, n=items.length; i<n; ++i) {\n      if (!items[i].zindex) visitor(items[i]);\n    }\n    items = zitems;\n  }\n\n  for (i=0, n=items.length; i<n; ++i) {\n    visitor(items[i]);\n  }\n}\n\nexport function pickVisit(scene, visitor) {\n  var items = scene.items, hit, i;\n  if (!items || !items.length) return null;\n\n  var zitems = zorder(scene);\n  if (zitems && zitems.length) items = zitems;\n\n  for (i=items.length; --i >= 0;) {\n    if (hit = visitor(items[i])) return hit;\n  }\n\n  if (items === zitems) {\n    for (items=scene.items, i=items.length; --i >= 0;) {\n      if (!items[i].zindex) {\n        if (hit = visitor(items[i])) return hit;\n      }\n    }\n  }\n\n  return null;\n}\n","export {default as bin} from './src/bin';\nexport {default as bootstrapCI} from './src/bootstrapCI';\nexport {default as quartiles} from './src/quartiles';\nexport {random, setRandom} from './src/random';\nexport {default as randomInteger} from './src/integer';\nexport {default as randomKDE} from './src/kde';\nexport {default as randomMixture} from './src/mixture';\nexport {default as randomNormal} from './src/normal';\nexport {default as randomUniform} from './src/uniform';\n","export default function(_) {\n  // determine range\n  var maxb = _.maxbins || 20,\n      base = _.base || 10,\n      logb = Math.log(base),\n      div  = _.divide || [5, 2],\n      min  = _.extent[0],\n      max  = _.extent[1],\n      span = max - min,\n      step, level, minstep, precision, v, i, n, eps;\n\n  if (_.step) {\n    // if step size is explicitly given, use that\n    step = _.step;\n  } else if (_.steps) {\n    // if provided, limit choice to acceptable step sizes\n    v = span / maxb;\n    for (i=0, n=_.steps.length; i < n && _.steps[i] < v; ++i);\n    step = _.steps[Math.max(0, i-1)];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = _.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span/step) > maxb) { step *= base; }\n\n    // decrease step size if allowed\n    for (i=0, n=div.length; i<n; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  if (_.nice || _.nice === undefined) {\n    v = Math.floor(min / step + eps) * step;\n    min = min < v ? v - step : v;\n    max = Math.ceil(max / step) * step;\n  }\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step\n  };\n}\n","import numbers from './numbers';\nimport {random} from './random';\nimport {quantile, ascending} from 'd3-array';\n\nexport default function(array, samples, alpha, f) {\n  if (!array.length) return [undefined, undefined];\n\n  var values = numbers(array, f),\n      n = values.length,\n      m = samples,\n      a, i, j, mu;\n\n  for (j=0, mu=Array(m); j<m; ++j) {\n    for (a=0, i=0; i<n; ++i) {\n      a += values[~~(random() * n)];\n    }\n    mu[j] = a / n;\n  }\n\n  return [\n    quantile(mu.sort(ascending), alpha/2),\n    quantile(mu, 1-(alpha/2))\n  ];\n}\n","import {random} from './random';\n\nexport default function(min, max) {\n  if (max == null) {\n    max = min;\n    min = 0;\n  }\n\n  var dist = {},\n      a, b, d;\n\n  dist.min = function(_) {\n    if (arguments.length) {\n      a = _ || 0;\n      d = b - a;\n      return dist;\n    } else {\n      return a;\n    }\n  };\n\n  dist.max = function(_) {\n    if (arguments.length) {\n      b = _ || 0;\n      d = b - a;\n      return dist;\n    } else {\n      return b;\n    }\n  };\n\n  dist.sample = function() {\n    return a + Math.floor(d * random());\n  };\n\n  dist.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1 / d : 0;\n  };\n\n  dist.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n\n  dist.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p * d) : NaN;\n  };\n\n  return dist.min(min).max(max);\n}\n","import gaussian from './normal';\nimport quartiles from './quartiles';\nimport {random} from './random';\nimport {variance} from 'd3-array';\n\n// TODO: support for additional kernels?\nexport default function(support, bandwidth) {\n  var kernel = gaussian(),\n      dist = {},\n      n = 0;\n\n  dist.data = function(_) {\n    if (arguments.length) {\n      support = _;\n      n = _ ? _.length : 0;\n      return dist.bandwidth(bandwidth);\n    } else {\n      return support;\n    }\n  };\n\n  dist.bandwidth = function(_) {\n    if (!arguments.length) return bandwidth;\n    bandwidth = _;\n    if (!bandwidth && support) bandwidth = estimateBandwidth(support);\n    return dist;\n  };\n\n  dist.sample = function() {\n    return support[~~(random() * n)] + bandwidth * kernel.sample();\n  };\n\n  dist.pdf = function(x) {\n    for (var y=0, i=0; i<n; ++i) {\n      y += kernel.pdf((x - support[i]) / bandwidth);\n    }\n    return y / bandwidth / n;\n  };\n\n  dist.cdf = function(x) {\n    for (var y=0, i=0; i<n; ++i) {\n      y += kernel.cdf((x - support[i]) / bandwidth);\n    }\n    return y / n;\n  };\n\n  dist.icdf = function() {\n    throw Error('KDE icdf not supported.');\n  };\n\n  return dist.data(support);\n}\n\n// Scott, D. W. (1992) Multivariate Density Estimation:\n// Theory, Practice, and Visualization. Wiley.\nfunction estimateBandwidth(array) {\n  var n = array.length,\n      q = quartiles(array),\n      h = (q[2] - q[0]) / 1.34;\n  return 1.06 * Math.min(Math.sqrt(variance(array)), h) * Math.pow(n, -0.2);\n}\n","import {random} from './random';\n\nexport default function(dists, weights) {\n  var dist = {}, m = 0, w;\n\n  function normalize(x) {\n    var w = [], sum = 0, i;\n    for (i=0; i<m; ++i) { sum += (w[i] = (x[i]==null ? 1 : +x[i])); }\n    for (i=0; i<m; ++i) { w[i] /= sum; }\n    return w;\n  }\n\n  dist.weights = function(_) {\n    if (arguments.length) {\n      w = normalize(weights = (_ || []));\n      return dist;\n    }\n    return weights;\n  };\n\n  dist.distributions = function(_) {\n    if (arguments.length) {\n      if (_) {\n        m = _.length;\n        dists = _;\n      } else {\n        m = 0;\n        dists = [];\n      }\n      return dist.weights(weights);\n    }\n    return dists;\n  };\n\n  dist.sample = function() {\n    var r = random(),\n        d = dists[m-1],\n        v = w[0],\n        i = 0;\n\n    // first select distribution\n    for (; i<m-1; v += w[++i]) {\n      if (r < v) { d = dists[i]; break; }\n    }\n    // then sample from it\n    return d.sample();\n  };\n\n  dist.pdf = function(x) {\n    for (var p=0, i=0; i<m; ++i) {\n      p += w[i] * dists[i].pdf(x);\n    }\n    return p;\n  };\n\n  dist.cdf = function(x) {\n    for (var p=0, i=0; i<m; ++i) {\n      p += w[i] * dists[i].cdf(x);\n    }\n    return p;\n  };\n\n  dist.icdf = function() {\n    throw Error('Mixture icdf not supported.');\n  };\n\n  return dist.distributions(dists).weights(weights);\n}\n","import {random} from './random';\n\nexport default function(mean, stdev) {\n  var mu,\n      sigma,\n      next = NaN,\n      dist = {};\n\n  dist.mean = function(_) {\n    if (arguments.length) {\n      mu = _ || 0;\n      next = NaN;\n      return dist;\n    } else {\n      return mu;\n    }\n  };\n\n  dist.stdev = function(_) {\n    if (arguments.length) {\n      sigma = _ == null ? 1 : _;\n      next = NaN;\n      return dist;\n    } else {\n      return sigma;\n    }\n  };\n\n  dist.sample = function() {\n    var x = 0, y = 0, rds, c;\n    if (next === next) {\n      x = next;\n      next = NaN;\n      return x;\n    }\n    do {\n      x = random() * 2 - 1;\n      y = random() * 2 - 1;\n      rds = x * x + y * y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2 * Math.log(rds) / rds); // Box-Muller transform\n    next = mu + y * c * sigma;\n    return mu + x * c * sigma;\n  };\n\n  dist.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mu, 2) / (-2 * Math.pow(sigma, 2)));\n    return (1 / (sigma * Math.sqrt(2*Math.PI))) * exp;\n  };\n\n  // Approximation from West (2009)\n  // Better Approximations to Cumulative Normal Functions\n  dist.cdf = function(x) {\n    var cd,\n        z = (x - mu) / sigma,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n\n  // Approximation of Probit function using inverse error function.\n  dist.icdf = function(p) {\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mu + sigma * Math.SQRT2 * s;\n  };\n\n  return dist.mean(mean).stdev(stdev);\n}\n","export default function(array, f) {\n  var numbers = [],\n      n = array.length,\n      i = -1, a;\n\n  if (f == null) {\n    while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);\n  } else {\n    while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);\n  }\n  return numbers;\n}\n\nfunction number(x) {\n  return x === null ? NaN : +x;\n}\n","import numbers from './numbers';\nimport {quantile, ascending} from 'd3-array';\n\nexport default function(array, f) {\n  var values = numbers(array, f);\n\n  return [\n    quantile(values.sort(ascending), 0.25),\n    quantile(values, 0.50),\n    quantile(values, 0.75)\n  ];\n}\n","export var random = Math.random;\n\nexport function setRandom(r) {\n  random = r;\n}\n","import {random} from './random';\n\nexport default function(min, max) {\n  if (max == null) {\n    max = (min == null ? 1 : min);\n    min = 0;\n  }\n\n  var dist = {},\n      a, b, d;\n\n  dist.min = function(_) {\n    if (arguments.length) {\n      a = _ || 0;\n      d = b - a;\n      return dist;\n    } else {\n      return a;\n    }\n  };\n\n  dist.max = function(_) {\n    if (arguments.length) {\n      b = _ || 0;\n      d = b - a;\n      return dist;\n    } else {\n      return b;\n    }\n  };\n\n  dist.sample = function() {\n    return a + d * random();\n  };\n\n  dist.pdf = function(x) {\n    return (x >= a && x <= b) ? 1 / d : 0;\n  };\n\n  dist.cdf = function(x) {\n    return x < a ? 0 : x > b ? 1 : (x - a) / d;\n  };\n\n  dist.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a + p * d : NaN;\n  };\n\n  return dist.min(min).max(max);\n}\n","export {default as aggregate} from './src/Aggregate';\nexport {default as bin} from './src/Bin';\nexport {default as collect} from './src/Collect';\nexport {default as compare} from './src/Compare';\nexport {default as countpattern} from './src/CountPattern';\nexport {default as cross} from './src/Cross';\nexport {default as density} from './src/Density';\nexport {default as expression} from './src/Expression';\nexport {default as extent} from './src/Extent';\nexport {default as facet} from './src/Facet';\nexport {default as field} from './src/Field';\nexport {default as filter} from './src/Filter';\nexport {default as flatten} from './src/Flatten';\nexport {default as fold} from './src/Fold';\nexport {default as formula} from './src/Formula';\nexport {default as generate} from './src/Generate';\nexport {default as impute} from './src/Impute';\nexport {default as joinaggregate} from './src/JoinAggregate';\nexport {default as key} from './src/Key';\nexport {default as load} from './src/Load';\nexport {default as lookup} from './src/Lookup';\nexport {default as multiextent} from './src/MultiExtent';\nexport {default as multivalues} from './src/MultiValues';\nexport {default as params} from './src/Params';\nexport {default as pivot} from './src/Pivot';\nexport {default as prefacet} from './src/PreFacet';\nexport {default as project} from './src/Project';\nexport {default as proxy} from './src/Proxy';\nexport {default as relay} from './src/Relay';\nexport {default as sample} from './src/Sample';\nexport {default as sequence} from './src/Sequence';\nexport {default as sieve} from './src/Sieve';\nexport {default as subflow} from './src/Subflow';\nexport {default as tupleindex} from './src/TupleIndex';\nexport {default as values} from './src/Values';\nexport {default as window} from './src/Window';\n","import {groupkey} from './util/AggregateKeys';\nimport {createMeasure, compileMeasures, measureName, ValidAggregateOps} from './util/AggregateOps';\nimport TupleStore from './util/TupleStore';\nimport {ingest, replace, Transform} from 'vega-dataflow';\nimport {accessorFields, accessorName, array, error, inherits} from 'vega-util';\n\n/**\n * Group-by aggregation operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.\n * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.\n * @param {Array<string>} [params.as] - An array of output field names for aggregated values.\n * @param {boolean} [params.cross=false] - A flag indicating that the full\n *   cross-product of groupby values should be generated, including empty cells.\n *   If true, the drop parameter is ignored and empty cells are retained.\n * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.\n */\nexport default function Aggregate(params) {\n  Transform.call(this, null, params);\n\n  this._adds = []; // array of added output tuples\n  this._mods = []; // array of modified output tuples\n  this._alen = 0;  // number of active added tuples\n  this._mlen = 0;  // number of active modified tuples\n  this._drop = true;   // should empty aggregation cells be removed\n  this._cross = false; // produce full cross-product of group-by values\n\n  this._dims = [];   // group-by dimension accessors\n  this._dnames = []; // group-by dimension names\n\n  this._measures = []; // collection of aggregation monoids\n  this._countOnly = false; // flag indicating only count aggregation\n  this._counts = null; // collection of count fields\n  this._prev = null;   // previous aggregation cells\n\n  this._inputs = null;  // array of dependent input tuple field names\n  this._outputs = null; // array of output tuple field names\n}\n\nAggregate.Definition = {\n  \"type\": \"Aggregate\",\n  \"metadata\": {\"generates\": true, \"changes\": true},\n  \"params\": [\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"ops\", \"type\": \"enum\", \"array\": true, \"values\": ValidAggregateOps },\n    { \"name\": \"fields\", \"type\": \"field\", \"null\": true, \"array\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"null\": true, \"array\": true },\n    { \"name\": \"drop\", \"type\": \"boolean\", \"default\": true },\n    { \"name\": \"cross\", \"type\": \"boolean\", \"default\": false },\n    { \"name\": \"key\", \"type\": \"field\" }\n  ]\n};\n\nvar prototype = inherits(Aggregate, Transform);\n\nprototype.transform = function(_, pulse) {\n  var aggr = this,\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      mod;\n\n  this.stamp = out.stamp;\n\n  if (this.value && ((mod = _.modified()) || pulse.modified(this._inputs))) {\n    this._prev = this.value;\n    this.value = mod ? this.init(_) : {};\n    pulse.visit(pulse.SOURCE, function(t) { aggr.add(t); });\n  } else {\n    this.value = this.value || this.init(_);\n    pulse.visit(pulse.REM, function(t) { aggr.rem(t); });\n    pulse.visit(pulse.ADD, function(t) { aggr.add(t); });\n  }\n\n  // Indicate output fields and return aggregate tuples.\n  out.modifies(this._outputs);\n\n  // Should empty cells be dropped?\n  aggr._drop = _.drop !== false;\n\n  // If domain cross-product requested, generate empty cells as needed\n  // and ensure that empty cells are not dropped\n  if (_.cross && aggr._dims.length > 1) {\n    aggr._drop = false;\n    this.cross();\n  }\n\n  return aggr.changes(out);\n};\n\nprototype.cross = function() {\n  var aggr = this,\n      curr = aggr.value,\n      dims = aggr._dnames,\n      vals = dims.map(function() { return {}; }),\n      n = dims.length;\n\n  // collect all group-by domain values\n  function collect(cells) {\n    var key, i, t, v;\n    for (key in cells) {\n      t = cells[key].tuple;\n      for (i=0; i<n; ++i) {\n        vals[i][(v = t[dims[i]])] = v;\n      }\n    }\n  }\n  collect(aggr._prev);\n  collect(curr);\n\n  // iterate over key cross-product, create cells as needed\n  function generate(base, tuple, index) {\n    var name = dims[index],\n        v = vals[index++],\n        k, key;\n\n    for (k in v) {\n      tuple[name] = v[k];\n      key = base ? base + '|' + k : k;\n      if (index < n) generate(key, tuple, index);\n      else if (!curr[key]) aggr.cell(key, tuple);\n    }\n  }\n  generate('', {}, 0);\n};\n\nprototype.init = function(_) {\n  // initialize input and output fields\n  var inputs = (this._inputs = []),\n      outputs = (this._outputs = []),\n      inputMap = {};\n\n  function inputVisit(get) {\n    var fields = array(accessorFields(get)),\n        i = 0, n = fields.length, f;\n    for (; i<n; ++i) {\n      if (!inputMap[f=fields[i]]) {\n        inputMap[f] = 1;\n        inputs.push(f);\n      }\n    }\n  }\n\n  // initialize group-by dimensions\n  this._dims = array(_.groupby);\n  this._dnames = this._dims.map(function(d) {\n    var dname = accessorName(d);\n    inputVisit(d);\n    outputs.push(dname);\n    return dname;\n  });\n  this.cellkey = _.key ? _.key : groupkey(this._dims);\n\n  // initialize aggregate measures\n  this._countOnly = true;\n  this._counts = [];\n  this._measures = [];\n\n  var fields = _.fields || [null],\n      ops = _.ops || ['count'],\n      as = _.as || [],\n      n = fields.length,\n      map = {},\n      field, op, m, mname, outname, i;\n\n  if (n !== ops.length) {\n    error('Unmatched number of fields and aggregate ops.');\n  }\n\n  for (i=0; i<n; ++i) {\n    field = fields[i];\n    op = ops[i];\n\n    if (field == null && op !== 'count') {\n      error('Null aggregate field specified.');\n    }\n    mname = accessorName(field);\n    outname = measureName(op, mname, as[i]);\n    outputs.push(outname);\n\n    if (op === 'count') {\n      this._counts.push(outname);\n      continue;\n    }\n\n    m = map[mname];\n    if (!m) {\n      inputVisit(field);\n      m = (map[mname] = []);\n      m.field = field;\n      this._measures.push(m);\n    }\n\n    if (op !== 'count') this._countOnly = false;\n    m.push(createMeasure(op, outname));\n  }\n\n  this._measures = this._measures.map(function(m) {\n    return compileMeasures(m, m.field);\n  });\n\n  return {}; // aggregation cells (this.value)\n};\n\n// -- Cell Management -----\n\nprototype.cellkey = groupkey();\n\nprototype.cell = function(key, t) {\n  var cell = this.value[key];\n  if (!cell) {\n    cell = this.value[key] = this.newcell(key, t);\n    this._adds[this._alen++] = cell;\n  } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {\n    cell.stamp = this.stamp;\n    this._adds[this._alen++] = cell;\n  } else if (cell.stamp < this.stamp) {\n    cell.stamp = this.stamp;\n    this._mods[this._mlen++] = cell;\n  }\n  return cell;\n};\n\nprototype.newcell = function(key, t) {\n  var cell = {\n    key:   key,\n    num:   0,\n    agg:   null,\n    tuple: this.newtuple(t, this._prev && this._prev[key]),\n    stamp: this.stamp,\n    store: false\n  };\n\n  if (!this._countOnly) {\n    var measures = this._measures,\n        n = measures.length, i;\n\n    cell.agg = Array(n);\n    for (i=0; i<n; ++i) {\n      cell.agg[i] = new measures[i](cell);\n    }\n  }\n\n  if (cell.store) {\n    cell.data = new TupleStore();\n  }\n\n  return cell;\n};\n\nprototype.newtuple = function(t, p) {\n  var names = this._dnames,\n      dims = this._dims,\n      x = {}, i, n;\n\n  for (i=0, n=dims.length; i<n; ++i) {\n    x[names[i]] = dims[i](t);\n  }\n\n  return p ? replace(p.tuple, x) : ingest(x);\n};\n\n// -- Process Tuples -----\n\nprototype.add = function(t) {\n  var key = this.cellkey(t),\n      cell = this.cell(key, t),\n      agg, i, n;\n\n  cell.num += 1;\n  if (this._countOnly) return;\n\n  if (cell.store) cell.data.add(t);\n\n  agg = cell.agg;\n  for (i=0, n=agg.length; i<n; ++i) {\n    agg[i].add(agg[i].get(t), t);\n  }\n};\n\nprototype.rem = function(t) {\n  var key = this.cellkey(t),\n      cell = this.cell(key, t),\n      agg, i, n;\n\n  cell.num -= 1;\n  if (this._countOnly) return;\n\n  if (cell.store) cell.data.rem(t);\n\n  agg = cell.agg;\n  for (i=0, n=agg.length; i<n; ++i) {\n    agg[i].rem(agg[i].get(t), t);\n  }\n};\n\nprototype.celltuple = function(cell) {\n  var tuple = cell.tuple,\n      counts = this._counts,\n      agg, i, n;\n\n  // consolidate stored values\n  if (cell.store) {\n    cell.data.values();\n  }\n\n  // update tuple properties\n  for (i=0, n=counts.length; i<n; ++i) {\n    tuple[counts[i]] = cell.num;\n  }\n  if (!this._countOnly) {\n    agg = cell.agg;\n    for (i=0, n=agg.length; i<n; ++i) {\n      agg[i].set(tuple);\n    }\n  }\n\n  return tuple;\n};\n\nprototype.changes = function(out) {\n  var adds = this._adds,\n      mods = this._mods,\n      prev = this._prev,\n      drop = this._drop,\n      add = out.add,\n      rem = out.rem,\n      mod = out.mod,\n      cell, key, i, n;\n\n  if (prev) for (key in prev) {\n    cell = prev[key];\n    if (!drop || cell.num) rem.push(cell.tuple);\n  }\n\n  for (i=0, n=this._alen; i<n; ++i) {\n    add.push(this.celltuple(adds[i]));\n    adds[i] = null; // for garbage collection\n  }\n\n  for (i=0, n=this._mlen; i<n; ++i) {\n    cell = mods[i];\n    (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));\n    mods[i] = null; // for garbage collection\n  }\n\n  this._alen = this._mlen = 0; // reset list of active cells\n  this._prev = null;\n  return out;\n};\n","import {Transform} from 'vega-dataflow';\nimport {bin} from 'vega-statistics';\nimport {inherits, accessor, accessorFields, accessorName} from 'vega-util';\n\n/**\n * Generates a binning function for discretizing data.\n * @constructor\n * @param {object} params - The parameters for this operator. The\n *   provided values should be valid options for the {@link bin} function.\n * @param {function(object): *} params.field - The data field to bin.\n */\nexport default function Bin(params) {\n  Transform.call(this, null, params);\n}\n\nBin.Definition = {\n  \"type\": \"Bin\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"anchor\", \"type\": \"number\" },\n    { \"name\": \"maxbins\", \"type\": \"number\", \"default\": 20 },\n    { \"name\": \"base\", \"type\": \"number\", \"default\": 10 },\n    { \"name\": \"divide\", \"type\": \"number\", \"array\": true, \"default\": [5, 2] },\n    { \"name\": \"extent\", \"type\": \"number\", \"array\": true, \"length\": 2, \"required\": true },\n    { \"name\": \"step\", \"type\": \"number\" },\n    { \"name\": \"steps\", \"type\": \"number\", \"array\": true },\n    { \"name\": \"minstep\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"nice\", \"type\": \"boolean\", \"default\": true },\n    { \"name\": \"name\", \"type\": \"string\" },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"bin0\", \"bin1\"] }\n  ]\n};\n\nvar prototype = inherits(Bin, Transform);\n\nprototype.transform = function(_, pulse) {\n  var bins = this._bins(_),\n      start = bins.start,\n      step = bins.step,\n      as = _.as || ['bin0', 'bin1'],\n      b0 = as[0],\n      b1 = as[1],\n      flag;\n\n  if (_.modified()) {\n    pulse = pulse.reflow(true);\n    flag = pulse.SOURCE;\n  } else {\n    flag = pulse.modified(accessorFields(_.field)) ? pulse.ADD_MOD : pulse.ADD;\n  }\n\n  pulse.visit(flag, function(t) {\n    var v = bins(t);\n    // minimum bin value (inclusive)\n    t[b0] = v;\n    // maximum bin value (exclusive)\n    // use convoluted math for better floating point agreement\n    // see https://github.com/vega/vega/issues/830\n    t[b1] = v == null ? null : start + step * (1 + (v - start) / step);\n  });\n\n  return pulse.modifies(as);\n};\n\nprototype._bins = function(_) {\n  if (this.value && !_.modified()) {\n    return this.value;\n  }\n\n  var field = _.field,\n      bins  = bin(_),\n      start = bins.start,\n      stop  = bins.stop,\n      step  = bins.step,\n      a, d;\n\n  if ((a = _.anchor) != null) {\n    d = a - (start + step * Math.floor((a - start) / step));\n    start += d;\n    stop += d;\n  }\n\n  var f = function(t) {\n    var v = field(t);\n    if (v == null) {\n      return null;\n    } else {\n      v = Math.max(start, Math.min(+v, stop - step));\n      return start + step * Math.floor((v - start) / step);\n    }\n  };\n\n  f.start = start;\n  f.stop = stop;\n  f.step = step;\n\n  return this.value = accessor(\n    f,\n    accessorFields(field),\n    _.name || 'bin_' + accessorName(field)\n  );\n};\n","import SortedList from './util/SortedList';\nimport {Transform, tupleid} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Collects all data tuples that pass through this operator.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for additionally sorting the collected tuples.\n */\nexport default function Collect(params) {\n  Transform.call(this, [], params);\n}\n\nCollect.Definition = {\n  \"type\": \"Collect\",\n  \"metadata\": {\"source\": true},\n  \"params\": [\n    { \"name\": \"sort\", \"type\": \"compare\" }\n  ]\n};\n\nvar prototype = inherits(Collect, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.ALL),\n      list = SortedList(tupleid, this.value, out.materialize(out.ADD).add),\n      sort = _.sort,\n      mod = pulse.changed() || (sort &&\n            (_.modified('sort') || pulse.modified(sort.fields)));\n\n  out.visit(out.REM, list.remove);\n\n  this.modified(mod);\n  this.value = out.source = list.data(sort, mod);\n\n  // propagate tree root if defined\n  if (pulse.source && pulse.source.root) {\n    this.value.root = pulse.source.root;\n  }\n\n  return out;\n};\n","import {Operator} from 'vega-dataflow';\nimport {inherits, compare} from 'vega-util';\n\n/**\n * Generates a comparator function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<string>} params.fields - The fields to compare.\n * @param {Array<string>} [params.orders] - The sort orders.\n *   Each entry should be one of \"ascending\" (default) or \"descending\".\n */\nexport default function Compare(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(Compare, Operator);\n\nfunction update(_) {\n  return (this.value && !_.modified())\n    ? this.value\n    : compare(_.fields, _.orders);\n}\n","import {ingest, Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Count regexp-defined pattern occurrences in a text field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - An accessor for the text field.\n * @param {string} [params.pattern] - RegExp string defining the text pattern.\n * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.\n * @param {string} [params.stopwords] - RegExp string of words to ignore.\n */\nexport default function CountPattern(params) {\n  Transform.call(this, null, params);\n}\n\nCountPattern.Definition = {\n  \"type\": \"CountPattern\",\n  \"metadata\": {\"generates\": true, \"changes\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"case\", \"type\": \"enum\", \"values\": [\"upper\", \"lower\", \"mixed\"], \"default\": \"mixed\" },\n    { \"name\": \"pattern\", \"type\": \"string\", \"default\": \"[\\\\w\\\"]+\" },\n    { \"name\": \"stopwords\", \"type\": \"string\", \"default\": \"\" },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"text\", \"count\"] }\n  ]\n};\n\nfunction tokenize(text, tcase, match) {\n  switch (tcase) {\n    case 'upper': text = text.toUpperCase(); break;\n    case 'lower': text = text.toLowerCase(); break;\n  }\n  return text.match(match);\n}\n\nvar prototype = inherits(CountPattern, Transform);\n\nprototype.transform = function(_, pulse) {\n  function process(update) {\n    return function(tuple) {\n      var tokens = tokenize(get(tuple), _.case, match) || [], t;\n      for (var i=0, n=tokens.length; i<n; ++i) {\n        if (!stop.test(t = tokens[i])) update(t);\n      }\n    };\n  }\n\n  var init = this._parameterCheck(_, pulse),\n      counts = this._counts,\n      match = this._match,\n      stop = this._stop,\n      get = _.field,\n      as = _.as || ['text', 'count'],\n      add = process(function(t) { counts[t] = 1 + (counts[t] || 0); }),\n      rem = process(function(t) { counts[t] -= 1; });\n\n  if (init) {\n    pulse.visit(pulse.SOURCE, add);\n  } else {\n    pulse.visit(pulse.ADD, add);\n    pulse.visit(pulse.REM, rem);\n  }\n\n  return this._finish(pulse, as); // generate output tuples\n};\n\nprototype._parameterCheck = function(_, pulse) {\n  var init = false;\n\n  if (_.modified('stopwords') || !this._stop) {\n    this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');\n    init = true;\n  }\n\n  if (_.modified('pattern') || !this._match) {\n    this._match = new RegExp((_.pattern || '[\\\\w\\']+'), 'g');\n    init = true;\n  }\n\n  if (_.modified('field') || pulse.modified(_.field.fields)) {\n    init = true;\n  }\n\n  if (init) this._counts = {};\n  return init;\n};\n\nprototype._finish = function(pulse, as) {\n  var counts = this._counts,\n      tuples = this._tuples || (this._tuples = {}),\n      text = as[0],\n      count = as[1],\n      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),\n      w, t, c;\n\n  for (w in counts) {\n    t = tuples[w];\n    c = counts[w] || 0;\n    if (!t && c) {\n      tuples[w] = (t = ingest({}));\n      t[text] = w;\n      t[count] = c;\n      out.add.push(t);\n    } else if (c === 0) {\n      if (t) out.rem.push(t);\n      counts[w] = null;\n      tuples[w] = null;\n    } else if (t[count] !== c) {\n      t[count] = c;\n      out.mod.push(t);\n    }\n  }\n\n  return out.modifies(as);\n};\n","import {ingest, Transform} from 'vega-dataflow';\nimport {inherits, truthy} from 'vega-util';\n\n/**\n * Perform a cross-product of a tuple stream with itself.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object):boolean} [params.filter] - An optional filter\n *   function for selectively including tuples in the cross product.\n * @param {Array<string>} [params.as] - The names of the output fields.\n */\nexport default function Cross(params) {\n  Transform.call(this, null, params);\n}\n\nCross.Definition = {\n  \"type\": \"Cross\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"filter\", \"type\": \"expr\" },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"a\", \"b\"] }\n  ]\n};\n\nvar prototype = inherits(Cross, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE),\n      data = this.value,\n      as = _.as || ['a', 'b'],\n      a = as[0], b = as[1],\n      reset = !data\n          || pulse.changed(pulse.ADD_REM)\n          || _.modified('as')\n          || _.modified('filter');\n\n  if (reset) {\n    if (data) out.rem = data;\n    data = pulse.materialize(pulse.SOURCE).source;\n    out.add = this.value = cross(data, a, b, _.filter || truthy);\n  } else {\n    out.mod = data;\n  }\n\n  out.source = this.value;\n  return out.modifies(as);\n};\n\nfunction cross(input, a, b, filter) {\n  var data = [],\n      t = {},\n      n = input.length,\n      i = 0,\n      j, left;\n\n  for (; i<n; ++i) {\n    t[a] = left = input[i];\n    for (j=0; j<n; ++j) {\n      t[b] = input[j];\n      if (filter(t)) {\n        data.push(ingest(t));\n        t = {};\n        t[a] = left;\n      }\n    }\n  }\n\n  return data;\n}\n","import parseDist from './util/Distributions';\nimport {ingest, Transform} from 'vega-dataflow';\nimport {error, inherits} from 'vega-util';\nimport {extent, range} from 'd3-array';\n\n/**\n * Grid sample points for a probability density. Given a distribution and\n * a sampling extent, will generate points suitable for plotting either\n * PDF (probability density function) or CDF (cumulative distribution\n * function) curves.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.distribution - The probability distribution. This\n *   is an object parameter dependent on the distribution type.\n * @param {string} [params.method='pdf'] - The distribution method to sample.\n *   One of 'pdf' or 'cdf'.\n * @param {Array<number>} [params.extent] - The [min, max] extent over which\n *   to sample the distribution. This argument is required in most cases, but\n *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method\n *   that returns numerical sample points from which the extent can be deduced.\n * @param {number} [params.steps=100] - The number of sampling steps.\n */\nexport default function Density(params) {\n  Transform.call(this, null, params);\n}\n\nvar distributions = [\n  {\n    \"key\": {\"function\": \"normal\"},\n    \"params\": [\n      { \"name\": \"mean\", \"type\": \"number\", \"default\": 0 },\n      { \"name\": \"stdev\", \"type\": \"number\", \"default\": 1 }\n    ]\n  },\n  {\n    \"key\": {\"function\": \"uniform\"},\n    \"params\": [\n      { \"name\": \"min\", \"type\": \"number\", \"default\": 0 },\n      { \"name\": \"max\", \"type\": \"number\", \"default\": 1 }\n    ]\n  },\n  {\n    \"key\": {\"function\": \"kde\"},\n    \"params\": [\n      { \"name\": \"field\", \"type\": \"field\", \"required\": true },\n      { \"name\": \"from\", \"type\": \"data\" },\n      { \"name\": \"bandwidth\", \"type\": \"number\", \"default\": 0 }\n    ]\n  }\n];\n\nvar mixture = {\n  \"key\": {\"function\": \"mixture\"},\n  \"params\": [\n    { \"name\": \"distributions\", \"type\": \"param\", \"array\": true,\n      \"params\": distributions },\n    { \"name\": \"weights\", \"type\": \"number\", \"array\": true }\n  ]\n};\n\nDensity.Definition = {\n  \"type\": \"Density\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"extent\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"steps\", \"type\": \"number\", \"default\": 100 },\n    { \"name\": \"method\", \"type\": \"string\", \"default\": \"pdf\",\n      \"values\": [\"pdf\", \"cdf\"] },\n    { \"name\": \"distribution\", \"type\": \"param\",\n      \"params\": distributions.concat(mixture) },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true,\n      \"default\": [\"value\", \"density\"] }\n  ]\n};\n\nvar prototype = inherits(Density, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n  if (!this.value || pulse.changed() || _.modified()) {\n    var dist = parseDist(_.distribution, source(pulse)),\n        method = _.method || 'pdf';\n\n    if (method !== 'pdf' && method !== 'cdf') {\n      error('Invalid density method: ' + method);\n    }\n    if (!_.extent && !dist.data) {\n      error('Missing density extent parameter.');\n    }\n    method = dist[method];\n\n    var as = _.as || ['value', 'density'],\n        domain = _.extent || extent(dist.data()),\n        step = (domain[1] - domain[0]) / (_.steps || 100),\n        values = range(domain[0], domain[1] + step/2, step)\n          .map(function(v) {\n            var tuple = {};\n            tuple[as[0]] = v;\n            tuple[as[1]] = method(v);\n            return ingest(tuple);\n          });\n\n    if (this.value) out.rem = this.value;\n    this.value = out.add = out.source = values;\n  }\n\n  return out;\n};\n\nfunction source(pulse) {\n  return function() { return pulse.materialize(pulse.SOURCE).source; };\n}\n","import {Operator} from 'vega-dataflow';\nimport {accessor, accessorFields, accessorName, inherits} from 'vega-util';\n\n/**\n * Wraps an expression function with access to external parameters.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function} params.expr - The expression function. The\n *  function should accept both a datum and a parameter object.\n *  This operator's value will be a new function that wraps the\n *  expression function with access to this operator's parameters.\n */\nexport default function Expression(params) {\n  Operator.call(this, null, update, params);\n  this.modified(true);\n}\n\ninherits(Expression, Operator);\n\nfunction update(_) {\n  var expr = _.expr;\n  return this.value && !_.modified('expr')\n    ? this.value\n    : accessor(\n        function(datum) { return expr(datum, _); },\n        accessorFields(expr),\n        accessorName(expr)\n      );\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Computes extents (min/max) for a data field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The field over which to compute extends.\n */\nexport default function Extent(params) {\n  Transform.call(this, [undefined, undefined], params);\n}\n\nExtent.Definition = {\n  \"type\": \"Extent\",\n  \"metadata\": {},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\", \"required\": true }\n  ]\n};\n\nvar prototype = inherits(Extent, Transform);\n\nprototype.transform = function(_, pulse) {\n  var extent = this.value,\n      field = _.field,\n      min = extent[0],\n      max = extent[1],\n      mod;\n\n  mod = pulse.changed()\n     || pulse.modified(field.fields)\n     || _.modified('field');\n\n  if (mod || min == null) {\n    min = +Infinity;\n    max = -Infinity;\n  }\n\n  pulse.visit(mod ? pulse.SOURCE : pulse.ADD, function(t) {\n    var v = field(t);\n    if (v != null) {\n      // coerce to number\n      v = +v;\n      // NaNs will fail all comparisons!\n      if (v < min) min = v;\n      if (v > max) max = v;\n    }\n  });\n\n  if (!isFinite(min) || !isFinite(max)) {\n    min = max = undefined;\n  }\n  this.value = [min, max];\n};\n","import Subflow from './Subflow';\nimport {Transform, tupleid} from 'vega-dataflow';\nimport {fastmap, inherits} from 'vega-util';\n\n/**\n * Facets a dataflow into a set of subflows based on a key.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Dataflow, string): Operator} params.subflow - A function\n *   that generates a subflow of operators and returns its root operator.\n * @param {function(object): *} params.key - The key field to facet by.\n */\nexport default function Facet(params) {\n  Transform.call(this, {}, params);\n  this._keys = fastmap(); // cache previously calculated key values\n\n  // keep track of active subflows, use as targets array for listeners\n  // this allows us to limit propagation to only updated subflows\n  var a = this._targets = [];\n  a.active = 0;\n  a.forEach = function(f) {\n    for (var i=0, n=a.active; i<n; ++i) f(a[i], i, a);\n  };\n}\n\nvar prototype = inherits(Facet, Transform);\n\nprototype.activate = function(flow) {\n  this._targets[this._targets.active++] = flow;\n};\n\nprototype.subflow = function(key, flow, pulse, parent) {\n  var flows = this.value,\n      sf = flows.hasOwnProperty(key) && flows[key],\n      df, p;\n\n  if (!sf) {\n    p = parent || (p = this._group[key]) && p.tuple;\n    df = pulse.dataflow;\n    sf = df.add(new Subflow(pulse.fork(pulse.NO_SOURCE), this))\n      .connect(flow(df, key, p));\n    flows[key] = sf;\n    this.activate(sf);\n  } else if (sf.value.stamp < pulse.stamp) {\n    sf.init(pulse);\n    this.activate(sf);\n  }\n\n  return sf;\n};\n\nprototype.transform = function(_, pulse) {\n  var df = pulse.dataflow,\n      self = this,\n      key = _.key,\n      flow = _.subflow,\n      cache = this._keys,\n      rekey = _.modified('key');\n\n  function subflow(key) {\n    return self.subflow(key, flow, pulse);\n  }\n\n  this._group = _.group || {};\n  this._targets.active = 0; // reset list of active subflows\n\n  pulse.visit(pulse.REM, function(t) {\n    var id = tupleid(t),\n        k = cache.get(id);\n    if (k !== undefined) {\n      cache.delete(id);\n      subflow(k).rem(t);\n    }\n  });\n\n  pulse.visit(pulse.ADD, function(t) {\n    var k = key(t);\n    cache.set(tupleid(t), k);\n    subflow(k).add(t);\n  });\n\n  if (rekey || pulse.modified(key.fields)) {\n    pulse.visit(pulse.MOD, function(t) {\n      var id = tupleid(t),\n          k0 = cache.get(id),\n          k1 = key(t);\n      if (k0 === k1) {\n        subflow(k1).mod(t);\n      } else {\n        cache.set(id, k1);\n        subflow(k0).rem(t);\n        subflow(k1).add(t);\n      }\n    });\n  } else if (pulse.changed(pulse.MOD)) {\n    pulse.visit(pulse.MOD, function(t) {\n      subflow(cache.get(tupleid(t))).mod(t);\n    });\n  }\n\n  if (rekey) {\n    pulse.visit(pulse.REFLOW, function(t) {\n      var id = tupleid(t),\n          k0 = cache.get(id),\n          k1 = key(t);\n      if (k0 !== k1) {\n        cache.set(id, k1);\n        subflow(k0).rem(t);\n        subflow(k1).add(t);\n      }\n    });\n  }\n\n  if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);\n  return pulse;\n};\n","import {Operator} from 'vega-dataflow';\nimport {array, field, inherits, isArray} from 'vega-util';\n\n/**\n * Generates one or more field accessor functions.\n * If the 'name' parameter is an array, an array of field accessors\n * will be created and the 'as' parameter will be ignored.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.name - The field name(s) to access.\n * @param {string} params.as - The accessor function name.\n */\nexport default function Field(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(Field, Operator);\n\nfunction update(_) {\n  return (this.value && !_.modified()) ? this.value\n    : isArray(_.name) ? array(_.name).map(function(f) { return field(f); })\n    : field(_.name, _.as);\n}\n","import {Transform, tupleid} from 'vega-dataflow';\nimport {fastmap, inherits} from 'vega-util';\n\n/**\n * Filters data tuples according to a predicate function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The predicate expression function\n *   that determines a tuple's filter status. Truthy values pass the filter.\n */\nexport default function Filter(params) {\n  Transform.call(this, fastmap(), params);\n}\n\nFilter.Definition = {\n  \"type\": \"Filter\",\n  \"metadata\": {\"changes\": true},\n  \"params\": [\n    { \"name\": \"expr\", \"type\": \"expr\", \"required\": true }\n  ]\n};\n\nvar prototype = inherits(Filter, Transform);\n\nprototype.transform = function(_, pulse) {\n  var df = pulse.dataflow,\n      cache = this.value, // cache ids of filtered tuples\n      output = pulse.fork(),\n      add = output.add,\n      rem = output.rem,\n      mod = output.mod,\n      test = _.expr,\n      isMod = true;\n\n  pulse.visit(pulse.REM, function(t) {\n    var id = tupleid(t);\n    if (!cache.has(id)) rem.push(t);\n    else cache.delete(id);\n  });\n\n  pulse.visit(pulse.ADD, function(t) {\n    if (test(t, _)) add.push(t);\n    else cache.set(tupleid(t), 1);\n  });\n\n  function revisit(t) {\n    var id = tupleid(t),\n        b = test(t, _),\n        s = cache.get(id);\n    if (b && s) {\n      cache.delete(id);\n      add.push(t);\n    } else if (!b && !s) {\n      cache.set(id, 1);\n      rem.push(t);\n    } else if (isMod && b && !s) {\n      mod.push(t);\n    }\n  }\n\n  pulse.visit(pulse.MOD, revisit);\n\n  if (_.modified()) {\n    isMod = false;\n    pulse.visit(pulse.REFLOW, revisit);\n  }\n\n  if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);\n  return output;\n};\n","import {fieldNames} from './util/util';\nimport {derive, Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Flattens array-typed field values into new data objects.\n * If multiple fields are specified, they are treated as parallel arrays,\n * with output values included for each matching index (or null if missing).\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *>} params.fields - An array of field\n *   accessors for the tuple fields that should be flattened.\n * @param {Array<string>} [params.as] - Output field names for flattened\n *   array fields. Any unspecified fields will use the field name provided\n *   by the fields accessors.\n */\nexport default function Flatten(params) {\n  Transform.call(this, [], params);\n}\n\nFlatten.Definition = {\n  \"type\": \"Flatten\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"required\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true }\n  ]\n};\n\nvar prototype = inherits(Flatten, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE),\n      fields = _.fields,\n      as = fieldNames(fields, _.as || []),\n      m = as.length;\n\n  // remove any previous results\n  out.rem = this.value;\n\n  // generate flattened tuples\n  pulse.visit(pulse.SOURCE, function(t) {\n    var arrays = fields.map(function(f) { return f(t); }),\n        maxlen = arrays.reduce(function(l, a) { return Math.max(l, a.length); }, 0),\n        i = 0, j, d, v;\n\n    for (; i<maxlen; ++i) {\n      d = derive(t);\n      for (j=0; j<m; ++j) {\n        d[as[j]] = (v = arrays[j][i]) == null ? null : v;\n      }\n      out.add.push(d);\n    }\n  });\n\n  this.value = out.source = out.add;\n  return out.modifies(as);\n};\n","import {derive, Transform} from 'vega-dataflow';\nimport {inherits, accessorName} from 'vega-util';\n\n/**\n * Folds one more tuple fields into multiple tuples in which the field\n * name and values are available under new 'key' and 'value' fields.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.fields - An array of field accessors\n *   for the tuple fields that should be folded.\n * @param {Array<string>} [params.as] - Output field names for folded key\n *   and value fields, defaults to ['key', 'value'].\n */\nexport default function Fold(params) {\n  Transform.call(this, [], params);\n}\n\nFold.Definition = {\n  \"type\": \"Fold\",\n  \"metadata\": {\"generates\": true},\n  \"params\": [\n    { \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"required\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 2, \"default\": [\"key\", \"value\"] }\n  ]\n};\n\nvar prototype = inherits(Fold, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE),\n      fields = _.fields,\n      fnames = fields.map(accessorName),\n      as = _.as || ['key', 'value'],\n      k = as[0],\n      v = as[1],\n      n = fields.length;\n\n  out.rem = this.value;\n\n  pulse.visit(pulse.SOURCE, function(t) {\n    for (var i=0, d; i<n; ++i) {\n      d = derive(t);\n      d[k] = fnames[i];\n      d[v] = fields[i](t);\n      out.add.push(d);\n    }\n  });\n\n  this.value = out.source = out.add;\n  return out.modifies(as);\n};\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Invokes a function for each data tuple and saves the results as a new field.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.expr - The formula function to invoke for each tuple.\n * @param {string} params.as - The field name under which to save the result.\n * @param {boolean} [params.initonly=false] - If true, the formula is applied to\n *   added tuples only, and does not update in response to modifications.\n */\nexport default function Formula(params) {\n  Transform.call(this, null, params);\n}\n\nFormula.Definition = {\n  \"type\": \"Formula\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"expr\", \"type\": \"expr\", \"required\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"required\": true },\n    { \"name\": \"initonly\", \"type\": \"boolean\" }\n  ]\n};\n\nvar prototype = inherits(Formula, Transform);\n\nprototype.transform = function(_, pulse) {\n  var func = _.expr,\n      as = _.as,\n      mod = _.modified(),\n      flag = _.initonly ? pulse.ADD\n        : mod ? pulse.SOURCE\n        : pulse.modified(func.fields) ? pulse.ADD_MOD\n        : pulse.ADD;\n\n  function set(t) {\n    t[as] = func(t, _);\n  }\n\n  if (mod) {\n    // parameters updated, need to reflow\n    pulse = pulse.materialize().reflow(true);\n  }\n\n  if (!_.initonly) {\n    pulse.modifies(as);\n  }\n\n  return pulse.visit(flag, set);\n};\n","import {ingest, Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Generates data tuples using a provided generator function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Parameters): object} params.generator - A tuple generator\n *   function. This function is given the operator parameters as input.\n *   Changes to any additional parameters will not trigger re-calculation\n *   of previously generated tuples. Only future tuples are affected.\n * @param {number} params.size - The number of tuples to produce.\n */\nexport default function Generate(params) {\n  Transform.call(this, [], params);\n}\n\nvar prototype = inherits(Generate, Transform);\n\nprototype.transform = function(_, pulse) {\n  var data = this.value,\n      out = pulse.fork(pulse.ALL),\n      num = _.size - data.length,\n      gen = _.generator,\n      add, rem, t;\n\n  if (num > 0) {\n    // need more tuples, generate and add\n    for (add=[]; --num >= 0;) {\n      add.push(t = ingest(gen(_)));\n      data.push(t);\n    }\n    out.add = out.add.length\n      ? out.materialize(out.ADD).add.concat(add)\n      : add;\n  } else {\n    // need fewer tuples, remove\n    rem = data.slice(0, -num);\n    out.rem = out.rem.length\n      ? out.materialize(out.REM).rem.concat(rem)\n      : rem;\n    data = data.slice(-num);\n  }\n\n  out.source = this.value = data;\n  return out;\n};\n","import {ingest, Transform} from 'vega-dataflow';\nimport {accessorName, error, inherits} from 'vega-util';\nimport {mean, min, max, median} from 'd3-array';\n\nvar Methods = {\n  value: 'value',\n  median: median,\n  mean: mean,\n  min: min,\n  max: max\n};\n\nvar Empty = [];\n\n/**\n * Impute missing values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The value field to impute.\n * @param {Array<function(object): *>} [params.groupby] - An array of\n *   accessors to determine series within which to perform imputation.\n * @param {function(object): *} params.key - An accessor for a key value.\n *   Each key value should be unique within a group. New tuples will be\n *   imputed for any key values that are not found within a group.\n * @param {Array<*>} [params.keyvals] - Optional array of required key\n *   values. New tuples will be imputed for any key values that are not\n *   found within a group. In addition, these values will be automatically\n *   augmented with the key values observed in the input data.\n * @param {string} [method='value'] - The imputation method to use. One of\n *   'value', 'mean', 'median', 'max', 'min'.\n * @param {*} [value=0] - The constant value to use for imputation\n *   when using method 'value'.\n */\nexport default function Impute(params) {\n  Transform.call(this, [], params);\n}\n\nImpute.Definition = {\n  \"type\": \"Impute\",\n  \"metadata\": {\"changes\": true},\n  \"params\": [\n    { \"name\": \"field\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"key\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"keyvals\", \"array\": true },\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"method\", \"type\": \"enum\", \"default\": \"value\",\n      \"values\": [\"value\", \"mean\", \"median\", \"max\", \"min\"] },\n    { \"name\": \"value\", \"default\": 0 }\n  ]\n};\n\nvar prototype = inherits(Impute, Transform);\n\nfunction getValue(_) {\n  var m = _.method || Methods.value, v;\n\n  if (Methods[m] == null) {\n    error('Unrecognized imputation method: ' + m);\n  } else if (m === Methods.value) {\n    v = _.value !== undefined ? _.value : 0;\n    return function() { return v; };\n  } else {\n    return Methods[m];\n  }\n}\n\nfunction getField(_) {\n  var f = _.field;\n  return function(t) { return t ? f(t) : NaN; };\n}\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.ALL),\n      impute = getValue(_),\n      field = getField(_),\n      fName = accessorName(_.field),\n      kName = accessorName(_.key),\n      gNames = (_.groupby || []).map(accessorName),\n      groups = partition(pulse.source, _.groupby, _.key, _.keyvals),\n      curr = [],\n      prev = this.value,\n      m = groups.domain.length,\n      group, value, gVals, kVal, g, i, j, l, n, t;\n\n  for (g=0, l=groups.length; g<l; ++g) {\n    group = groups[g];\n    gVals = group.values;\n    value = NaN;\n\n    // add tuples for missing values\n    for (j=0; j<m; ++j) {\n      if (group[j] != null) continue;\n      kVal = groups.domain[j];\n\n      t = {_impute: true};\n      for (i=0, n=gVals.length; i<n; ++i) t[gNames[i]] = gVals[i];\n      t[kName] = kVal;\n      t[fName] = isNaN(value) ? (value = impute(group, field)) : value;\n\n      curr.push(ingest(t));\n    }\n  }\n\n  // update pulse with imputed tuples\n  if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);\n  if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);\n  this.value = curr;\n\n  return out;\n};\n\nfunction partition(data, groupby, key, keyvals) {\n  var get = function(f) { return f(t); },\n      groups = [],\n      domain = keyvals ? keyvals.slice() : [],\n      kMap = {},\n      gMap = {}, gVals, gKey,\n      group, i, j, k, n, t;\n\n  domain.forEach(function(k, i) { kMap[k] = i + 1; });\n\n  for (i=0, n=data.length; i<n; ++i) {\n    t = data[i];\n    k = key(t);\n    j = kMap[k] || (kMap[k] = domain.push(k));\n\n    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';\n    if (!(group = gMap[gKey])) {\n      group = (gMap[gKey] = []);\n      groups.push(group);\n      group.values = gVals;\n    }\n    group[j-1] = t;\n  }\n\n  groups.domain = domain;\n  return groups;\n}\n","import Aggregate from './Aggregate';\nimport {ValidAggregateOps} from './util/AggregateOps';\nimport {extend, inherits} from 'vega-util';\n\n/**\n * Extend input tuples with aggregate values.\n * Calcuates aggregate values and joins them with the input stream.\n * @constructor\n */\nexport default function JoinAggregate(params) {\n  Aggregate.call(this, params);\n}\n\nJoinAggregate.Definition = {\n  \"type\": \"JoinAggregate\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"fields\", \"type\": \"field\", \"null\": true, \"array\": true },\n    { \"name\": \"ops\", \"type\": \"enum\", \"array\": true, \"values\": ValidAggregateOps },\n    { \"name\": \"as\", \"type\": \"string\", \"null\": true, \"array\": true },\n    { \"name\": \"key\", \"type\": \"field\" }\n  ]\n};\n\nvar prototype = inherits(JoinAggregate, Aggregate);\n\nprototype.transform = function(_, pulse) {\n  var aggr = this,\n      mod = _.modified(),\n      cells;\n\n  // process all input tuples to calculate aggregates\n  if (aggr.value && (mod || pulse.modified(aggr._inputs))) {\n    cells = aggr.value = mod ? aggr.init(_) : {};\n    pulse.visit(pulse.SOURCE, function(t) { aggr.add(t); });\n  } else {\n    cells = aggr.value = aggr.value || this.init(_);\n    pulse.visit(pulse.REM, function(t) { aggr.rem(t); });\n    pulse.visit(pulse.ADD, function(t) { aggr.add(t); });\n  }\n\n  // update aggregation cells\n  aggr.changes();\n\n  // write aggregate values to input tuples\n  pulse.visit(pulse.SOURCE, function(t) {\n    extend(t, cells[aggr.cellkey(t)].tuple);\n  });\n\n  return pulse.reflow(mod).modifies(this._outputs);\n};\n\nprototype.changes = function() {\n  var adds = this._adds,\n      mods = this._mods,\n      i, n;\n\n  for (i=0, n=this._alen; i<n; ++i) {\n    this.celltuple(adds[i]);\n    adds[i] = null; // for garbage collection\n  }\n\n  for (i=0, n=this._mlen; i<n; ++i) {\n    this.celltuple(mods[i]);\n    mods[i] = null; // for garbage collection\n  }\n\n  this._alen = this._mlen = 0; // reset list of active cells\n};\n","import {Operator} from 'vega-dataflow';\nimport {inherits, key} from 'vega-util';\n\n/**\n * Generates a key function.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<string>} params.fields - The field name(s) for the key function.\n * @param {boolean} params.flat - A boolean flag indicating if the field names\n *  should be treated as flat property names, side-stepping nested field\n *  lookups normally indicated by dot or bracket notation.\n */\nexport default function Key(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(Key, Operator);\n\nfunction update(_) {\n  return (this.value && !_.modified()) ? this.value : key(_.fields, _.flat);\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Load and parse data from an external source. Marshalls parameter\n * values and then invokes the Dataflow request method.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.url - The URL to load from.\n * @param {object} params.format - The data format options.\n */\nexport default function Load(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Load, Transform);\n\nprototype.transform = function(_, pulse) {\n  pulse.dataflow.request(this.target, _.url, _.format);\n};\n","import {Transform} from 'vega-dataflow';\nimport {accessorName, error, inherits} from 'vega-util';\n\n/**\n * Extend tuples by joining them with values from a lookup table.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Map} params.index - The lookup table map.\n * @param {Array<function(object): *} params.fields - The fields to lookup.\n * @param {Array<string>} params.as - Output field names for each lookup value.\n * @param {*} [params.default] - A default value to use if lookup fails.\n */\nexport default function Lookup(params) {\n  Transform.call(this, {}, params);\n}\n\nLookup.Definition = {\n  \"type\": \"Lookup\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"index\", \"type\": \"index\", \"params\": [\n        {\"name\": \"from\", \"type\": \"data\", \"required\": true },\n        {\"name\": \"key\", \"type\": \"field\", \"required\": true }\n      ] },\n    { \"name\": \"values\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"fields\", \"type\": \"field\", \"array\": true, \"required\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true },\n    { \"name\": \"default\", \"default\": null }\n  ]\n};\n\nvar prototype = inherits(Lookup, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse,\n      as = _.as,\n      keys = _.fields,\n      index = _.index,\n      values = _.values,\n      defaultValue = _.default==null ? null : _.default,\n      reset = _.modified(),\n      flag = reset ? pulse.SOURCE : pulse.ADD,\n      n = keys.length,\n      set, m, mods;\n\n  if (values) {\n    m = values.length;\n\n    if (n > 1 && !as) {\n      error('Multi-field lookup requires explicit \"as\" parameter.');\n    }\n    if (as && as.length !== n * m) {\n      error('The \"as\" parameter has too few output field names.');\n    }\n    as = as || values.map(accessorName);\n\n    set = function(t) {\n      for (var i=0, k=0, j, v; i<n; ++i) {\n        v = index.get(keys[i](t));\n        if (v == null) for (j=0; j<m; ++j, ++k) t[as[k]] = defaultValue;\n        else for (j=0; j<m; ++j, ++k) t[as[k]] = values[j](v);\n      }\n    };\n  } else {\n    if (!as) {\n      error('Missing output field names.');\n    }\n\n    set = function(t) {\n      for (var i=0, v; i<n; ++i) {\n        v = index.get(keys[i](t));\n        t[as[i]] = v==null ? defaultValue : v;\n      }\n    };\n  }\n\n  if (reset) {\n    out = pulse.reflow(true);\n  } else {\n    mods = keys.some(function(k) { return pulse.modified(k.fields); });\n    flag |= (mods ? pulse.MOD : 0);\n  }\n  pulse.visit(flag, set);\n\n  return out.modifies(as);\n};\n","import {Operator} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Computes global min/max extents over a collection of extents.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<Array<number>>} params.extents - The input extents.\n */\nexport default function MultiExtent(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(MultiExtent, Operator);\n\nfunction update(_) {\n  if (this.value && !_.modified()) {\n    return this.value;\n  }\n\n  var min = +Infinity,\n      max = -Infinity,\n      ext = _.extents,\n      i, n, e;\n\n  for (i=0, n=ext.length; i<n; ++i) {\n    e = ext[i];\n    if (e[0] < min) min = e[0];\n    if (e[1] > max) max = e[1];\n  }\n  return [min, max];\n}\n","import {Operator} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Merge a collection of value arrays.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<Array<*>>} params.values - The input value arrrays.\n */\nexport default function MultiValues(params) {\n  Operator.call(this, null, update, params);\n}\n\ninherits(MultiValues, Operator);\n\nfunction update(_) {\n  return (this.value && !_.modified())\n    ? this.value\n    : _.values.reduce(function(data, _) { return data.concat(_); }, []);\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Operator whose value is simply its parameter hash. This operator is\n * useful for enabling reactive updates to values of nested objects.\n * @constructor\n * @param {object} params - The parameters for this operator.\n */\nexport default function Params(params) {\n  Transform.call(this, null, params);\n}\n\ninherits(Params, Transform);\n\nParams.prototype.transform = function(_, pulse) {\n  this.modified(_.modified());\n  this.value = _;\n  return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples\n};\n","import Aggregate from './Aggregate';\nimport {ValidAggregateOps} from './util/AggregateOps';\nimport {accessor, accessorFields, inherits} from 'vega-util';\n\n/**\n * Aggregate and pivot selected field values to become new fields.\n * This operator is useful to construction cross-tabulations.\n * @constructor\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors\n *  to groupby. These fields act just like groupby fields of an Aggregate transform.\n * @param {function(object): *} params.field - The field to pivot on. The unique\n *  values of this field become new field names in the output stream.\n * @param {function(object): *} params.value - The field to populate pivoted fields.\n *  The aggregate values of this field become the values of the new pivoted fields.\n * @param {string} [params.op] - The aggregation operation for the value field,\n *  applied per cell in the output stream. The default is \"sum\".\n * @param {number} [params.limit] - An optional parameter indicating the maximum\n *  number of pivoted fields to generate. The pivoted field names are sorted in\n *  ascending order prior to enforcing the limit.\n */\nexport default function Pivot(params) {\n  Aggregate.call(this, params);\n}\n\nPivot.Definition = {\n  \"type\": \"Pivot\",\n  \"metadata\": {\"generates\": true, \"changes\": true},\n  \"params\": [\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"field\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"value\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"op\", \"type\": \"enum\", \"values\": ValidAggregateOps, \"default\": \"sum\" },\n    { \"name\": \"limit\", \"type\": \"number\", \"default\": 0 },\n    { \"name\": \"key\", \"type\": \"field\" }\n  ]\n};\n\nvar prototype = inherits(Pivot, Aggregate);\n\nprototype._transform = prototype.transform;\n\nprototype.transform = function(_, pulse) {\n  return this._transform(aggregateParams(_, pulse), pulse);\n};\n\n// Shoehorn a pivot transform into an aggregate transform!\n// First collect all unique pivot field values.\n// Then generate aggregate fields for each output pivot field.\nfunction aggregateParams(_, pulse) {\n  var key    = _.field,\n  value  = _.value,\n      op     = (_.op === 'count' ? '__count__' : _.op) || 'sum',\n      fields = accessorFields(key).concat(accessorFields(value)),\n      keys   = pivotKeys(key, _.limit || 0, pulse);\n\n  return {\n    key:      _.key,\n    groupby:  _.groupby,\n    ops:      keys.map(function() { return op; }),\n    fields:   keys.map(function(k) { return get(k, key, value, fields); }),\n    as:       keys.map(function(k) { return k + ''; }),\n    modified: _.modified.bind(_)\n  };\n}\n\n// Generate aggregate field accessor.\n// Output NaN for non-existent values; aggregator will ignore!\nfunction get(k, key, value, fields) {\n  return accessor(\n    function(d) { return key(d) === k ? value(d) : NaN; },\n    fields,\n    k + ''\n  );\n}\n\n// Collect (and optionally limit) all unique pivot values.\nfunction pivotKeys(key, limit, pulse) {\n  var map = {},\n      list = [];\n\n  pulse.visit(pulse.SOURCE, function(t) {\n    var k = key(t);\n    if (!map[k]) {\n      map[k] = 1;\n      list.push(k);\n    }\n  });\n\n  // TODO? Move this comparator to vega-util?\n  list.sort(function(u, v) {\n    return (u<v||u==null) && v!=null ? -1\n      : (u>v||v==null) && u!=null ? 1\n      : ((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))!==u && v===v ? -1\n      : v!==v && u===u ? 1 : 0;\n  });\n\n  return limit ? list.slice(0, limit) : list;\n}\n","import Facet from './Facet';\nimport {ingest, tupleid} from 'vega-dataflow';\nimport {accessorFields, error, inherits} from 'vega-util';\n\n/**\n * Partitions pre-faceted data into tuple subflows.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(Dataflow, string): Operator} params.subflow - A function\n *   that generates a subflow of operators and returns its root operator.\n * @param {function(object): Array<object>} params.field - The field\n *   accessor for an array of subflow tuple objects.\n */\nexport default function PreFacet(params) {\n  Facet.call(this, params);\n}\n\nvar prototype = inherits(PreFacet, Facet);\n\nprototype.transform = function(_, pulse) {\n  var self = this,\n      flow = _.subflow,\n      field = _.field;\n\n  if (_.modified('field') || field && pulse.modified(accessorFields(field))) {\n    error('PreFacet does not support field modification.');\n  }\n\n  this._targets.active = 0; // reset list of active subflows\n\n  pulse.visit(pulse.MOD, function(t) {\n    var sf = self.subflow(tupleid(t), flow, pulse, t);\n    field ? field(t).forEach(function(_) { sf.mod(_); }) : sf.mod(t);\n  });\n\n  pulse.visit(pulse.ADD, function(t) {\n    var sf = self.subflow(tupleid(t), flow, pulse, t);\n    field ? field(t).forEach(function(_) { sf.add(ingest(_)); }) : sf.add(t);\n  });\n\n  pulse.visit(pulse.REM, function(t) {\n    var sf = self.subflow(tupleid(t), flow, pulse, t);\n    field ? field(t).forEach(function(_) { sf.rem(_); }) : sf.rem(t);\n  });\n\n  return pulse;\n};\n","import {fieldNames} from './util/util';\nimport {ingest, rederive, Transform, tupleid} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Performs a relational projection, copying selected fields from source\n * tuples to a new set of derived tuples.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {Array<function(object): *} params.fields - The fields to project,\n *   as an array of field accessors. If unspecified, all fields will be\n *   copied with names unchanged.\n * @param {Array<string>} [params.as] - Output field names for each projected\n *   field. Any unspecified fields will use the field name provided by\n *   the field accessor.\n */\nexport default function Project(params) {\n  Transform.call(this, null, params);\n}\n\nProject.Definition = {\n  \"type\": \"Project\",\n  \"metadata\": {\"generates\": true, \"changes\": true},\n  \"params\": [\n    { \"name\": \"fields\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"null\": true, \"array\": true },\n  ]\n};\n\nvar prototype = inherits(Project, Transform);\n\nprototype.transform = function(_, pulse) {\n  var fields = _.fields,\n      as = fieldNames(_.fields, _.as || []),\n      derive = fields\n        ? function(s, t) { return project(s, t, fields, as); }\n        : rederive,\n      out, lut;\n\n  if (this.value) {\n    lut = this.value;\n  } else {\n    pulse = pulse.addAll();\n    lut = this.value = {};\n  }\n\n  out = pulse.fork(pulse.NO_SOURCE);\n\n  pulse.visit(pulse.REM, function(t) {\n    var id = tupleid(t);\n    out.rem.push(lut[id]);\n    lut[id] = null;\n  });\n\n  pulse.visit(pulse.ADD, function(t) {\n    var dt = derive(t, ingest({}));\n    lut[tupleid(t)] = dt;\n    out.add.push(dt);\n  });\n\n  pulse.visit(pulse.MOD, function(t) {\n    out.mod.push(derive(t, lut[tupleid(t)]));\n  });\n\n  return out;\n};\n\nfunction project(s, t, fields, as) {\n  for (var i=0, n=fields.length; i<n; ++i) {\n    t[as[i]] = fields[i](s);\n  }\n  return t;\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Proxy the value of another operator as a pure signal value.\n * Ensures no tuples are propagated.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {*} params.value - The value to proxy, becomes the value of this operator.\n */\nexport default function Proxy(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Proxy, Transform);\n\nprototype.transform = function(_, pulse) {\n  this.value = _.value;\n  return _.modified('value')\n    ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS)\n    : pulse.StopPropagation;\n};\n","import {derive, rederive, Transform, tupleid} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Relays a data stream between data processing pipelines.\n * If the derive parameter is set, this transform will create derived\n * copies of observed tuples. This provides derived data streams in which\n * modifications to the tuples do not pollute an upstream data source.\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.derive=false] - Boolean flag indicating if\n *   the transform should make derived copies of incoming tuples.\n * @constructor\n */\nexport default function Relay(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Relay, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out, lut;\n\n  if (this.value) {\n    lut = this.value;\n  } else {\n    out = pulse = pulse.addAll();\n    lut = this.value = {};\n  }\n\n  if (_.derive) {\n    out = pulse.fork(pulse.NO_SOURCE);\n\n    pulse.visit(pulse.REM, function(t) {\n      var id = tupleid(t);\n      out.rem.push(lut[id]);\n      lut[id] = null;\n    });\n\n    pulse.visit(pulse.ADD, function(t) {\n      var dt = derive(t);\n      lut[tupleid(t)] = dt;\n      out.add.push(dt);\n    });\n\n    pulse.visit(pulse.MOD, function(t) {\n      out.mod.push(rederive(t, lut[tupleid(t)]));\n    });\n  }\n\n  return out;\n};\n","import {Transform, tupleid} from 'vega-dataflow';\nimport {random} from 'vega-statistics';\nimport {inherits} from 'vega-util';\n\n/**\n * Samples tuples passing through this operator.\n * Uses reservoir sampling to maintain a representative sample.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {number} [params.size=1000] - The maximum number of samples.\n */\nexport default function Sample(params) {\n  Transform.call(this, [], params);\n  this.count = 0;\n}\n\nSample.Definition = {\n  \"type\": \"Sample\",\n  \"metadata\": {},\n  \"params\": [\n    { \"name\": \"size\", \"type\": \"number\", \"default\": 1000 }\n  ]\n};\n\nvar prototype = inherits(Sample, Transform);\n\nprototype.transform = function(_, pulse) {\n  var out = pulse.fork(pulse.NO_SOURCE),\n      mod = _.modified('size'),\n      num = _.size,\n      res = this.value,\n      cnt = this.count,\n      cap = 0,\n      map = res.reduce(function(m, t) {\n        m[tupleid(t)] = 1;\n        return m;\n      }, {});\n\n  // sample reservoir update function\n  function update(t) {\n    var p, idx;\n\n    if (res.length < num) {\n      res.push(t);\n    } else {\n      idx = ~~((cnt + 1) * random());\n      if (idx < res.length && idx >= cap) {\n        p = res[idx];\n        if (map[tupleid(p)]) out.rem.push(p); // eviction\n        res[idx] = t;\n      }\n    }\n    ++cnt;\n  }\n\n  if (pulse.rem.length) {\n    // find all tuples that should be removed, add to output\n    pulse.visit(pulse.REM, function(t) {\n      var id = tupleid(t);\n      if (map[id]) {\n        map[id] = -1;\n        out.rem.push(t);\n      }\n      --cnt;\n    });\n\n    // filter removed tuples out of the sample reservoir\n    res = res.filter(function(t) { return map[tupleid(t)] !== -1; });\n  }\n\n  if ((pulse.rem.length || mod) && res.length < num && pulse.source) {\n    // replenish sample if backing data source is available\n    cap = cnt = res.length;\n    pulse.visit(pulse.SOURCE, function(t) {\n      // update, but skip previously sampled tuples\n      if (!map[tupleid(t)]) update(t);\n    });\n    cap = -1;\n  }\n\n  if (mod && res.length > num) {\n    for (var i=0, n=res.length-num; i<n; ++i) {\n      map[tupleid(res[i])] = -1;\n      out.rem.push(res[i]);\n    }\n    res = res.slice(n);\n  }\n\n  if (pulse.mod.length) {\n    // propagate modified tuples in the sample reservoir\n    pulse.visit(pulse.MOD, function(t) {\n      if (map[tupleid(t)]) out.mod.push(t);\n    });\n  }\n\n  if (pulse.add.length) {\n    // update sample reservoir\n    pulse.visit(pulse.ADD, update);\n  }\n\n  if (pulse.add.length || cap < 0) {\n    // output newly added tuples\n    out.add = res.filter(function(t) { return !map[tupleid(t)]; });\n  }\n\n  this.count = cnt;\n  this.value = out.source = res;\n  return out;\n};\n","import {ingest, Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\nimport {range} from 'd3-array';\n\n/**\n * Generates data tuples for a specified sequence range of numbers.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {number} params.start - The first number in the sequence.\n * @param {number} params.stop - The last number (exclusive) in the sequence.\n * @param {number} [params.step=1] - The step size between numbers in the sequence.\n */\nexport default function Sequence(params) {\n  Transform.call(this, null, params);\n}\n\nSequence.Definition = {\n  \"type\": \"Sequence\",\n  \"metadata\": {\"changes\": true},\n  \"params\": [\n    { \"name\": \"start\", \"type\": \"number\", \"required\": true },\n    { \"name\": \"stop\", \"type\": \"number\", \"required\": true },\n    { \"name\": \"step\", \"type\": \"number\", \"default\": 1 },\n    { \"name\": \"as\", \"type\": \"string\", \"default\": \"data\" }\n  ]\n};\n\nvar prototype = inherits(Sequence, Transform);\n\nprototype.transform = function(_, pulse) {\n  if (this.value && !_.modified()) return;\n\n  var out = pulse.materialize().fork(pulse.MOD),\n      as = _.as || 'data';\n\n  out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;\n\n  this.value = range(_.start, _.stop, _.step || 1).map(function(v) {\n    var t = {};\n    t[as] = v;\n    return ingest(t);\n  });\n\n  out.add = pulse.add.concat(this.value);\n\n  return out;\n};\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Propagates a new pulse without any tuples so long as the input\n * pulse contains some added, removed or modified tuples.\n * @param {object} params - The parameters for this operator.\n * @constructor\n */\nexport default function Sieve(params) {\n  Transform.call(this, null, params);\n  this.modified(true); // always treat as modified\n}\n\nvar prototype = inherits(Sieve, Transform);\n\nprototype.transform = function(_, pulse) {\n  this.value = pulse.source;\n  return pulse.changed()\n    ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS)\n    : pulse.StopPropagation;\n};\n","import {Operator} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Provides a bridge between a parent transform and a target subflow that\n * consumes only a subset of the tuples that pass through the parent.\n * @constructor\n * @param {Pulse} pulse - A pulse to use as the value of this operator.\n * @param {Transform} parent - The parent transform (typically a Facet instance).\n * @param {Transform} target - A transform that receives the subflow of tuples.\n */\nexport default function Subflow(pulse, parent) {\n  Operator.call(this, pulse);\n  this.parent = parent;\n}\n\nvar prototype = inherits(Subflow, Operator);\n\nprototype.connect = function(target) {\n  this.targets().add(target);\n  return (target.source = this);\n};\n\n/**\n * Add an 'add' tuple to the subflow pulse.\n * @param {Tuple} t - The tuple being added.\n */\nprototype.add = function(t) {\n  this.value.add.push(t);\n};\n\n/**\n * Add a 'rem' tuple to the subflow pulse.\n * @param {Tuple} t - The tuple being removed.\n */\nprototype.rem = function(t) {\n  this.value.rem.push(t);\n};\n\n/**\n * Add a 'mod' tuple to the subflow pulse.\n * @param {Tuple} t - The tuple being modified.\n */\nprototype.mod = function(t) {\n  this.value.mod.push(t);\n};\n\n/**\n * Re-initialize this operator's pulse value.\n * @param {Pulse} pulse - The pulse to copy from.\n * @see Pulse.init\n */\nprototype.init = function(pulse) {\n  this.value.init(pulse, pulse.NO_SOURCE);\n};\n\n/**\n * Evaluate this operator. This method overrides the\n * default behavior to simply return the contained pulse value.\n * @return {Pulse}\n */\nprototype.evaluate = function() {\n  // assert: this.value.stamp === pulse.stamp\n  return this.value;\n};\n","import {Transform} from 'vega-dataflow';\nimport {fastmap, inherits} from 'vega-util';\n\n/**\n * An index that maps from unique, string-coerced, field values to tuples.\n * Assumes that the field serves as a unique key with no duplicate values.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The field accessor to index.\n */\nexport default function TupleIndex(params) {\n  Transform.call(this, fastmap(), params);\n}\n\nvar prototype = inherits(TupleIndex, Transform);\n\nprototype.transform = function(_, pulse) {\n  var df = pulse.dataflow,\n      field = _.field,\n      index = this.value,\n      mod = true;\n\n  function set(t) { index.set(field(t), t); }\n\n  if (_.modified('field') || pulse.modified(field.fields)) {\n    index.clear();\n    pulse.visit(pulse.SOURCE, set);\n  } else if (pulse.changed()) {\n    pulse.visit(pulse.REM, function(t) { index.delete(field(t)); });\n    pulse.visit(pulse.ADD, set);\n  } else {\n    mod = false;\n  }\n\n  this.modified(mod);\n  if (index.empty > df.cleanThreshold) df.runAfter(index.clean);\n  return pulse.fork();\n};\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Extracts an array of values. Assumes the source data has already been\n * reduced as needed (e.g., by an upstream Aggregate transform).\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(object): *} params.field - The domain field to extract.\n * @param {function(*,*): number} [params.sort] - An optional\n *   comparator function for sorting the values. The comparator will be\n *   applied to backing tuples prior to value extraction.\n */\nexport default function Values(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Values, Transform);\n\nprototype.transform = function(_, pulse) {\n  var run = !this.value\n    || _.modified('field')\n    || _.modified('sort')\n    || pulse.changed()\n    || (_.sort && pulse.modified(_.sort.fields));\n\n  if (run) {\n    this.value = (_.sort\n      ? pulse.source.slice().sort(_.sort)\n      : pulse.source).map(_.field);\n  }\n};\n","import {groupkey} from './util/AggregateKeys';\nimport {ValidAggregateOps} from './util/AggregateOps';\nimport SortedList from './util/SortedList';\nimport {ValidWindowOps} from './util/WindowOps';\nimport WindowState from './util/WindowState';\nimport {Transform, tupleid} from 'vega-dataflow';\nimport {constant, inherits} from 'vega-util';\nimport {bisector} from 'd3-array';\n\n/**\n * Perform window calculations and write results to the input stream.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.\n * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.\n * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.\n * @param {Array<function(object): *>} [params.fields] - An array of accessors\n *   for data fields to use as inputs to window operations.\n * @param {Array<*>} [params.params] - An array of parameter values for window operations.\n * @param {Array<string>} [params.as] - An array of output field names for window operations.\n * @param {Array<number>} [params.frame] - Window frame definition as two-element array.\n * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row\n *   number alone, ignoring peers with identical sort values. If false (default),\n *   the window boundaries will be adjusted to include peer values.\n */\nexport default function Window(params) {\n  Transform.call(this, {}, params);\n  this._mlen = 0;\n  this._mods = [];\n}\n\nWindow.Definition = {\n  \"type\": \"Window\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"sort\", \"type\": \"compare\" },\n    { \"name\": \"groupby\", \"type\": \"field\", \"array\": true },\n    { \"name\": \"ops\", \"type\": \"enum\", \"array\": true, \"values\": ValidWindowOps.concat(ValidAggregateOps) },\n    { \"name\": \"params\", \"type\": \"number\", \"null\": true, \"array\": true },\n    { \"name\": \"fields\", \"type\": \"field\", \"null\": true, \"array\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"null\": true, \"array\": true },\n    { \"name\": \"frame\", \"type\": \"number\", \"null\": true, \"array\": true, \"length\": 2, \"default\": [null, 0] },\n    { \"name\": \"ignorePeers\", \"type\": \"boolean\", \"default\": false }\n  ]\n};\n\nvar prototype = inherits(Window, Transform);\n\nprototype.transform = function(_, pulse) {\n  var self = this,\n      state = self.state,\n      mod = _.modified(),\n      i, n;\n\n  this.stamp = pulse.stamp;\n\n  // initialize window state\n  if (!state || mod) {\n    state = self.state = new WindowState(_);\n  }\n\n  // retrieve group for a tuple\n  var key = groupkey(_.groupby);\n  function group(t) { return self.group(key(t)); }\n\n  // partition input tuples\n  if (mod || pulse.modified(state.inputs)) {\n    self.value = {};\n    pulse.visit(pulse.SOURCE, function(t) { group(t).add(t); });\n  } else {\n    pulse.visit(pulse.REM, function(t) { group(t).remove(t); });\n    pulse.visit(pulse.ADD, function(t) { group(t).add(t); });\n  }\n\n  // perform window calculations for each modified partition\n  for (i=0, n=self._mlen; i<n; ++i) {\n    processPartition(self._mods[i], state, _);\n  }\n  self._mlen = 0;\n  self._mods = [];\n\n  // TODO don't reflow everything?\n  return pulse.reflow(mod).modifies(state.outputs);\n};\n\nprototype.group = function(key) {\n  var self = this,\n      group = self.value[key];\n\n  if (!group) {\n    group = self.value[key] = SortedList(tupleid);\n    group.stamp = -1;\n  }\n\n  if (group.stamp < self.stamp) {\n    group.stamp = self.stamp;\n    self._mods[self._mlen++] = group;\n  }\n\n  return group;\n};\n\nfunction processPartition(list, state, _) {\n  var sort = _.sort,\n      range = sort && !_.ignorePeers,\n      frame = _.frame || [null, 0],\n      data = list.data(sort),\n      n = data.length,\n      i = 0,\n      b = range ? bisector(sort) : null,\n      w = {\n        i0: 0, i1: 0, p0: 0, p1: 0, index: 0,\n        data: data, compare: sort || constant(-1)\n      };\n\n  for (state.init(); i<n; ++i) {\n    setWindow(w, frame, i, n);\n    if (range) adjustRange(w, b);\n    state.update(w, data[i]);\n  }\n}\n\nfunction setWindow(w, f, i, n) {\n  w.p0 = w.i0;\n  w.p1 = w.i1;\n  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));\n  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);\n  w.index = i;\n}\n\n// if frame type is 'range', adjust window for peer values\nfunction adjustRange(w, bisect) {\n  var r0 = w.i0,\n      r1 = w.i1 - 1,\n      c = w.compare,\n      d = w.data,\n      n = d.length - 1;\n\n  if (r0 > 0 && !c(d[r0], d[r0-1])) w.i0 = bisect.left(d, d[r0]);\n  if (r1 < n && !c(d[r1], d[r1+1])) w.i1 = bisect.right(d, d[r1]);\n}\n","export function multikey(f) {\n  return function(x) {\n    var n = f.length,\n        i = 1,\n        k = String(f[0](x));\n\n    for (; i<n; ++i) {\n      k += '|' + f[i](x);\n    }\n\n    return k;\n  };\n}\n\nexport function groupkey(fields) {\n  return !fields || !fields.length ? function() { return ''; }\n    : fields.length === 1 ? fields[0]\n    : multikey(fields);\n}\n","import {extend, identity} from 'vega-util';\n\nexport function measureName(op, field, as) {\n  return as || (op + (!field ? '' : '_' + field));\n}\n\nexport var AggregateOps = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.store = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  '__count__': measure({\n    name: 'count',\n    set:  'this.missing + this.valid'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += +v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= this.valid ? d / this.valid : this.mean;',\n    set:  'this.valid ? this.mean : undefined'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.valid ? this.mean : undefined',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.valid > 1 ? this.dev / (this.valid-1) : undefined',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.valid > 1 ? this.dev / this.valid : undefined',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid-1)) : undefined',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / this.valid) : undefined',\n    req:  ['variance'], idx: 2\n  }),\n  'stderr': measure({\n    name: 'stderr',\n    set:  'this.valid > 1 ? Math.sqrt(this.dev / (this.valid * (this.valid-1))) : undefined',\n    req:  ['variance'], idx: 2\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'cell.data.distinct(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'ci0': measure({\n    name: 'ci0',\n    set:  'cell.data.ci0(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'ci1': measure({\n    name: 'ci1',\n    set:  'cell.data.ci1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    init: 'this.argmin = undefined;',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = undefined;',\n    set:  'this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    init: 'this.argmax = undefined;',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = undefined;',\n    set:  'this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = undefined;',\n    add:  'if (v < this.min || this.min === undefined) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = undefined;',\n    add:  'if (v > this.max || this.max === undefined) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  })\n};\n\nexport var ValidAggregateOps = Object.keys(AggregateOps);\n\nexport function createMeasure(op, name) {\n  return AggregateOps[op](name);\n}\n\nfunction measure(base) {\n  return function(out) {\n    var m = extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction compareIndex(a, b) {\n  return a.idx - b.idx;\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = AggregateOps[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) {\n      m[a.name] = a;\n      return m;\n    }, {})\n  );\n  var values = [], key;\n  for (key in map) values.push(map[key]);\n  return values.sort(compareIndex);\n}\n\nexport function compileMeasures(agg, field) {\n  var get = field || identity,\n      all = resolve(agg, true), // assume streaming removes may occur\n      init = 'var cell = this.cell; this.valid = 0; this.missing = 0;',\n      ctr = 'this.cell = cell; this.init();',\n      add = 'if(v==null){++this.missing; return;} if(v!==v) return; ++this.valid;',\n      rem = 'if(v==null){--this.missing; return;} if(v!==v) return; --this.valid;',\n      set = 'var cell = this.cell;';\n\n  all.forEach(function(a) {\n    init += a.init;\n    add += a.add;\n    rem += a.rem;\n  });\n  agg.slice().sort(compareIndex).forEach(function(a) {\n    set += 't[\\'' + a.out + '\\']=' + a.set + ';';\n  });\n  set += 'return t;';\n\n  ctr = Function('cell', ctr);\n  ctr.prototype.init = Function(init);\n  ctr.prototype.add = Function('v', 't', add);\n  ctr.prototype.rem = Function('v', 't', rem);\n  ctr.prototype.set = Function('t', set);\n  ctr.prototype.get = get;\n  ctr.fields = agg.map(function(_) { return _.out; });\n  return ctr;\n}\n","import {\n  randomKDE,\n  randomMixture,\n  randomNormal,\n  randomUniform\n} from 'vega-statistics';\n\nimport {error} from 'vega-util';\n\nvar Distributions = {\n  kde:     randomKDE,\n  mixture: randomMixture,\n  normal:  randomNormal,\n  uniform: randomUniform\n};\n\nvar DISTRIBUTIONS = 'distributions',\n    FUNCTION = 'function',\n    FIELD = 'field';\n\n/**\n * Parse a parameter object for a probability distribution.\n * @param {object} def - The distribution parameter object.\n * @param {function():Array<object>} - A method for requesting\n *   source data. Used for distributions (such as KDE) that\n *   require sample data points. This method will only be\n *   invoked if the 'from' parameter for a target data source\n *   is not provided. Typically this method returns backing\n *   source data for a Pulse object.\n * @return {object} - The output distribution object.\n */\nexport default function parse(def, data) {\n  var func = def[FUNCTION];\n  if (!Distributions.hasOwnProperty(func)) {\n    error('Unknown distribution function: ' + func);\n  }\n\n  var d = Distributions[func]();\n\n  for (var name in def) {\n    // if data field, extract values\n    if (name === FIELD) {\n      d.data((def.from || data()).map(def[name]));\n    }\n\n    // if distribution mixture, recurse to parse each definition\n    else if (name === DISTRIBUTIONS) {\n      d[name](def[name].map(function(_) { return parse(_, data); }));\n    }\n\n    // otherwise, simply set the parameter\n    else if (typeof d[name] === FUNCTION) {\n      d[name](def[name]);\n    }\n  }\n\n  return d;\n}\n","import {merge} from 'vega-util';\n\nexport default function(idFunc, source, input) {\n  var $ = idFunc,\n      data = source || [],\n      add = input || [],\n      rem = {},\n      cnt = 0;\n\n  return {\n    add: function(t) { add.push(t); },\n    remove: function(t) { rem[$(t)] = ++cnt; },\n    size: function() { return data.length; },\n    data: function(compare, resort) {\n      if (cnt) {\n        data = data.filter(function(t) { return !rem[$(t)]; });\n        rem = {};\n        cnt = 0;\n      }\n      if (resort && compare) {\n        data.sort(compare);\n      }\n      if (add.length) {\n        data = compare\n          ? merge(compare, data, add.sort(compare))\n          : data.concat(add);\n        add = [];\n      }\n      return data;\n    }\n  }\n}","import {tupleid} from 'vega-dataflow';\nimport {bootstrapCI, quartiles} from 'vega-statistics';\nimport {extentIndex, field} from 'vega-util';\n\nexport default function TupleStore(key) {\n  this._key = key ? field(key) : tupleid;\n  this.reset();\n}\n\nvar prototype = TupleStore.prototype;\n\nprototype.reset = function() {\n  this._add = [];\n  this._rem = [];\n  this._ext = null;\n  this._get = null;\n  this._q = null;\n};\n\nprototype.add = function(v) {\n  this._add.push(v);\n};\n\nprototype.rem = function(v) {\n  this._rem.push(v);\n};\n\nprototype.values = function() {\n  this._get = null;\n  if (this._rem.length === 0) return this._add;\n\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      n = a.length,\n      m = r.length,\n      x = Array(n - m),\n      map = {}, i, j, v;\n\n  // use unique key field to clear removed values\n  for (i=0; i<m; ++i) {\n    map[k(r[i])] = 1;\n  }\n  for (i=0, j=0; i<n; ++i) {\n    if (map[k(v = a[i])]) {\n      map[k(v)] = 0;\n    } else {\n      x[j++] = v;\n    }\n  }\n\n  this._rem = [];\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nprototype.distinct = function(get) {\n  var v = this.values(),\n      n = v.length,\n      map = {},\n      count = 0, s;\n\n  while (--n >= 0) {\n    s = get(v[n]) + '';\n    if (!map.hasOwnProperty(s)) {\n      map[s] = 1;\n      ++count;\n    }\n  }\n\n  return count;\n};\n\nprototype.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = extentIndex(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;\n  }\n  return this._ext;\n};\n\nprototype.argmin = function(get) {\n  return this.extent(get)[0] || {};\n};\n\nprototype.argmax = function(get) {\n  return this.extent(get)[1] || {};\n};\n\nprototype.min = function(get) {\n  var m = this.extent(get)[0];\n  return m != null ? get(m) : undefined;\n};\n\nprototype.max = function(get) {\n  var m = this.extent(get)[1];\n  return m != null ? get(m) : undefined;\n};\n\nprototype.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = quartiles(this.values(), get);\n    this._get = get;\n  }\n  return this._q;\n};\n\nprototype.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nprototype.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nprototype.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nprototype.ci = function(get) {\n  if (this._get !== get || !this._ci) {\n    this._ci = bootstrapCI(this.values(), 1000, 0.05, get);\n    this._get = get;\n  }\n  return this._ci;\n};\n\nprototype.ci0 = function(get) {\n  return this.ci(get)[0];\n};\n\nprototype.ci1 = function(get) {\n  return this.ci(get)[1];\n};\n","import {error, zero} from 'vega-util';\n\nexport function WindowOp(op, field, param, as) {\n  var fn = WindowOps[op](field, param);\n  return {\n    init:   fn.init || zero,\n    update: function(w, t) { t[as] = fn.next(w); }\n  };\n}\n\nexport var WindowOps = {\n  row_number: function() {\n    return {\n      next: function(w) { return w.index + 1; }\n    };\n  },\n  rank: function() {\n    var rank;\n    return {\n      init: function() { rank = 1; },\n      next: function(w) {\n        var i = w.index,\n            data = w.data;\n        return (i && w.compare(data[i - 1], data[i])) ? (rank = i + 1) : rank;\n      }\n    };\n  },\n  dense_rank: function() {\n    var drank;\n    return {\n      init: function() { drank = 1; },\n      next: function(w) {\n        var i = w.index,\n            d = w.data;\n        return (i && w.compare(d[i - 1], d[i])) ? ++drank : drank;\n      }\n    };\n  },\n  percent_rank: function() {\n    var rank = WindowOps.rank(),\n        next = rank.next;\n    return {\n      init: rank.init,\n      next: function(w) {\n        return (next(w) - 1) / (w.data.length - 1);\n      }\n    };\n  },\n  cume_dist: function() {\n    var cume;\n    return {\n      init: function() { cume = 0; },\n      next: function(w) {\n        var i = w.index,\n            d = w.data,\n            c = w.compare;\n        if (cume < i) {\n          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;\n          cume = i;\n        }\n        return (1 + cume) / d.length;\n      }\n    };\n  },\n  ntile: function(field, num) {\n    num = +num;\n    if (!(num > 0)) error('ntile num must be greater than zero.');\n    var cume = WindowOps.cume_dist(),\n        next = cume.next;\n    return {\n      init: cume.init,\n      next: function(w) { return Math.ceil(num * next(w)); }\n    };\n  },\n\n  lag: function(field, offset) {\n    offset = +offset || 1;\n    return {\n      next: function(w) {\n        var i = w.index - offset;\n        return i >= 0 ? field(w.data[i]) : null;\n      }\n    };\n  },\n  lead: function(field, offset) {\n    offset = +offset || 1;\n    return {\n      next: function(w) {\n        var i = w.index + offset,\n            d = w.data;\n        return i < d.length ? field(d[i]) : null;\n      }\n    };\n  },\n\n  first_value: function(field) {\n    return {\n      next: function(w) { return field(w.data[w.i0]); }\n    };\n  },\n  last_value: function(field) {\n    return {\n      next: function(w) { return field(w.data[w.i1 - 1]); }\n    }\n  },\n  nth_value: function(field, nth) {\n    nth = +nth;\n    if (!(nth > 0)) error('nth_value nth must be greater than zero.');\n    return {\n      next: function(w) {\n        var i = w.i0 + (nth - 1);\n        return i < w.i1 ? field(w.data[i]) : null;\n      }\n    }\n  }\n};\n\nexport var ValidWindowOps = Object.keys(WindowOps);\n","import {createMeasure, compileMeasures, measureName} from './AggregateOps';\nimport TupleStore from './TupleStore';\nimport {WindowOp, WindowOps} from './WindowOps';\nimport {accessorFields, accessorName, array, error} from 'vega-util';\n\nexport default function WindowState(_) {\n  var self = this,\n      ops = array(_.ops),\n      fields = array(_.fields),\n      params = array(_.params),\n      as = array(_.as),\n      outputs = self.outputs = [],\n      windows = self.windows = [],\n      inputs = {},\n      map = {},\n      countOnly = true,\n      counts = [],\n      measures = [];\n\n  function visitInputs(f) {\n    array(accessorFields(f)).forEach(function(_) { inputs[_] = 1; });\n  }\n  visitInputs(_.sort);\n\n  ops.forEach(function(op, i) {\n    var field = fields[i],\n        mname = accessorName(field),\n        name = measureName(op, mname, as[i]);\n\n    visitInputs(field);\n    outputs.push(name);\n\n    // Window operation\n    if (WindowOps.hasOwnProperty(op)) {\n      windows.push(WindowOp(op, fields[i], params[i], name));\n    }\n\n    // Aggregate operation\n    else {\n      if (field == null && op !== 'count') {\n        error('Null aggregate field specified.');\n      }\n      if (op === 'count') {\n        counts.push(name);\n        return;\n      }\n\n      countOnly = false;\n      var m = map[mname];\n      if (!m) {\n        m = (map[mname] = []);\n        m.field = field;\n        measures.push(m);\n      }\n      m.push(createMeasure(op, name));\n    }\n  });\n\n  if (counts.length || measures.length) {\n    self.cell = cell(measures, counts, countOnly);\n  }\n\n  self.inputs = Object.keys(inputs);\n}\n\nvar prototype = WindowState.prototype;\n\nprototype.init = function() {\n  this.windows.forEach(function(_) { _.init(); });\n  if (this.cell) this.cell.init();\n};\n\nprototype.update = function(w, t) {\n  var self = this,\n      cell = self.cell,\n      wind = self.windows,\n      data = w.data,\n      m = wind && wind.length,\n      j;\n\n  if (cell) {\n    for (j=w.p0; j<w.i0; ++j) cell.rem(data[j]);\n    for (j=w.p1; j<w.i1; ++j) cell.add(data[j]);\n    cell.set(t);\n  }\n  for (j=0; j<m; ++j) wind[j].update(w, t);\n};\n\nfunction cell(measures, counts, countOnly) {\n  measures = measures.map(function(m) {\n    return compileMeasures(m, m.field);\n  });\n\n  var cell = {\n    num:   0,\n    agg:   null,\n    store: false,\n    count: counts\n  };\n\n  if (!countOnly) {\n    var n = measures.length,\n        a = cell.agg = Array(n),\n        i = 0;\n    for (; i<n; ++i) a[i] = new measures[i](cell);\n  }\n\n  if (cell.store) {\n    var store = cell.data = new TupleStore();\n  }\n\n  cell.add = function(t) {\n    cell.num += 1;\n    if (countOnly) return;\n    if (store) store.add(t);\n    for (var i=0; i<n; ++i) {\n      a[i].add(a[i].get(t), t);\n    }\n  };\n\n  cell.rem = function(t) {\n    cell.num -= 1;\n    if (countOnly) return;\n    if (store) store.rem(t);\n    for (var i=0; i<n; ++i) {\n      a[i].rem(a[i].get(t), t);\n    }\n  };\n\n  cell.set = function(t) {\n    var i, n;\n\n    // consolidate stored values\n    if (store) store.values();\n\n    // update tuple properties\n    for (i=0, n=counts.length; i<n; ++i) t[counts[i]] = cell.num;\n    if (!countOnly) for (i=0, n=a.length; i<n; ++i) a[i].set(t);\n  };\n\n  cell.init = function() {\n    cell.num = 0;\n    if (store) store.reset();\n    for (var i=0; i<n; ++i) a[i].init();\n  };\n\n  return cell;\n}\n","import {accessorName} from 'vega-util';\n\n// use either provided alias or accessor field name\nexport function fieldNames(fields, as) {\n  if (!fields) return null;\n  return fields.map(function(f, i) {\n    return as[i] || accessorName(f);\n  });\n}\n","export {\n  default as accessor,\n  accessorName,\n  accessorFields\n} from './src/accessor';\n\nexport {\n  id,\n  identity,\n  zero,\n  one,\n  truthy,\n  falsy\n} from './src/accessors';\n\nexport {\n  default as logger,\n  None,\n  Error,\n  Warn,\n  Info,\n  Debug\n} from './src/logger';\n\nexport {\n  panLinear,\n  panLog,\n  panPow,\n  zoomLinear,\n  zoomLog,\n  zoomPow\n} from './src/transform';\n\nexport {default as array} from './src/array';\nexport {default as compare} from './src/compare';\nexport {default as constant} from './src/constant';\nexport {default as debounce} from './src/debounce';\nexport {default as error} from './src/error';\nexport {default as extend} from './src/extend';\nexport {default as extentIndex} from './src/extentIndex';\nexport {default as fastmap} from './src/fastmap';\nexport {default as field} from './src/field';\nexport {default as inherits} from './src/inherits';\nexport {default as isArray} from './src/isArray';\nexport {default as isBoolean} from './src/isBoolean';\nexport {default as isDate} from './src/isDate';\nexport {default as isFunction} from './src/isFunction';\nexport {default as isNumber} from './src/isNumber';\nexport {default as isObject} from './src/isObject';\nexport {default as isRegExp} from './src/isRegExp';\nexport {default as isString} from './src/isString';\nexport {default as key} from './src/key';\nexport {default as merge} from './src/merge';\nexport {default as pad} from './src/pad';\nexport {default as peek} from './src/peek';\nexport {default as repeat} from './src/repeat';\nexport {default as splitAccessPath} from './src/splitAccessPath';\nexport {default as stringValue} from './src/stringValue';\nexport {default as toBoolean} from './src/toBoolean';\nexport {default as toDate} from './src/toDate';\nexport {default as toNumber} from './src/toNumber';\nexport {default as toString} from './src/toString';\nexport {default as toSet} from './src/toSet';\nexport {default as truncate} from './src/truncate';\nexport {default as visitArray} from './src/visitArray';\n","export default function(fn, fields, name) {\n  fn.fields = fields || [];\n  fn.fname = name;\n  return fn;\n}\n\nexport function accessorName(fn) {\n  return fn == null ? null : fn.fname;\n}\n\nexport function accessorFields(fn) {\n  return fn == null ? null : fn.fields;\n}\n","import accessor from './accessor';\nimport field from './field';\n\nvar empty = [];\n\nexport var id = field('id');\n\nexport var identity = accessor(function(_) { return _; }, empty, 'identity');\n\nexport var zero = accessor(function() { return 0; }, empty, 'zero');\n\nexport var one = accessor(function() { return 1; }, empty, 'one');\n\nexport var truthy = accessor(function() { return true; }, empty, 'true');\n\nexport var falsy = accessor(function() { return false; }, empty, 'false');\n","import isArray from './isArray';\n\nexport default function(_) {\n  return _ != null ? (isArray(_) ? _ : [_]) : [];\n}\n","import {default as accessor, accessorFields} from './accessor';\nimport array from './array';\nimport isFunction from './isFunction';\nimport splitAccessPath from './splitAccessPath';\nimport stringValue from './stringValue';\n\nexport default function(fields, orders) {\n  var idx = [],\n      cmp = (fields = array(fields)).map(function(f, i) {\n        if (f == null) {\n          return null;\n        } else {\n          idx.push(i);\n          return isFunction(f) ? f\n            : splitAccessPath(f).map(stringValue).join('][');\n        }\n      }),\n      n = idx.length - 1,\n      ord = array(orders),\n      code = 'var u,v;return ',\n      i, j, f, u, v, d, t, lt, gt;\n\n  if (n < 0) return null;\n\n  for (j=0; j<=n; ++j) {\n    i = idx[j];\n    f = cmp[i];\n\n    if (isFunction(f)) {\n      d = 'f' + i;\n      u = '(u=this.' + d + '(a))';\n      v = '(v=this.' + d + '(b))';\n      (t = t || {})[d] = f;\n    } else {\n      u = '(u=a['+f+'])';\n      v = '(v=b['+f+'])';\n    }\n\n    d = '((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))';\n\n    if (ord[i] !== 'descending') {\n      gt = 1;\n      lt = -1;\n    } else {\n      gt = -1;\n      lt = 1;\n    }\n\n    code += '(' + u+'<'+v+'||u==null)&&v!=null?' + lt\n      + ':(u>v||v==null)&&u!=null?' + gt\n      + ':'+d+'!==u&&v===v?' + lt\n      + ':v!==v&&u===u?' + gt\n      + (i < n ? ':' : ':0');\n  }\n\n  f = Function('a', 'b', code + ';');\n  if (t) f = f.bind(t);\n\n  fields = fields.reduce(function(map, field) {\n    if (isFunction(field)) {\n      (accessorFields(field) || []).forEach(function(_) { map[_] = 1; });\n    } else if (field != null) {\n      map[field + ''] = 1;\n    }\n    return map;\n  }, {});\n\n  return accessor(f, Object.keys(fields));\n}\n","import isFunction from './isFunction';\n\nexport default function(_) {\n  return isFunction(_) ? _ : function() { return _; };\n}\n","export default function(delay, handler) {\n  var tid, evt;\n\n  function callback() {\n    handler(evt);\n    tid = evt = null;\n  }\n\n  return function(e) {\n    evt = e;\n    if (tid) clearTimeout(tid);\n    tid = setTimeout(callback, delay);\n  };\n}\n","export default function(message) {\n  throw Error(message);\n}\n","export default function(_) {\n  for (var x, k, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (k in x) { _[k] = x[k]; }\n  }\n  return _;\n}\n","export default function(array, f) {\n  var i = -1,\n      n = array.length,\n      a, b, c, u, v;\n\n  if (f == null) {\n    while (++i < n) {\n      b = array[i];\n      if (b != null && b >= b) {\n        a = c = b;\n        break;\n      }\n    }\n    u = v = i;\n    while (++i < n) {\n      b = array[i];\n      if (b != null) {\n        if (a > b) {\n          a = b;\n          u = i;\n        }\n        if (c < b) {\n          c = b;\n          v = i;\n        }\n      }\n    }\n  } else {\n    while (++i < n) {\n      b = f(array[i], i, array);\n      if (b != null && b >= b) {\n        a = c = b;\n        break;\n      }\n    }\n    u = v = i;\n    while (++i < n) {\n      b = f(array[i], i, array);\n      if (b != null) {\n        if (a > b) {\n          a = b;\n          u = i;\n        }\n        if (c < b) {\n          c = b;\n          v = i;\n        }\n      }\n    }\n  }\n\n  return [u, v];\n}\n","var NULL = {};\n\nexport default function(input) {\n  var obj = {},\n      map,\n      test;\n\n  function has(key) {\n    return obj.hasOwnProperty(key) && obj[key] !== NULL;\n  }\n\n  map = {\n    size: 0,\n    empty: 0,\n    object: obj,\n    has: has,\n    get: function(key) {\n      return has(key) ? obj[key] : undefined;\n    },\n    set: function(key, value) {\n      if (!has(key)) {\n        ++map.size;\n        if (obj[key] === NULL) --map.empty;\n      }\n      obj[key] = value;\n      return this;\n    },\n    delete: function(key) {\n      if (has(key)) {\n        --map.size;\n        ++map.empty;\n        obj[key] = NULL;\n      }\n      return this;\n    },\n    clear: function() {\n      map.size = map.empty = 0;\n      map.object = obj = {};\n    },\n    test: function(_) {\n      if (arguments.length) {\n        test = _;\n        return map;\n      } else {\n        return test;\n      }\n    },\n    clean: function() {\n      var next = {},\n          size = 0,\n          key, value;\n      for (key in obj) {\n        value = obj[key];\n        if (value !== NULL && (!test || !test(value))) {\n          next[key] = value;\n          ++size;\n        }\n      }\n      map.size = size;\n      map.empty = 0;\n      map.object = (obj = next);\n    }\n  };\n\n  if (input) Object.keys(input).forEach(function(key) {\n    map.set(key, input[key]);\n  });\n\n  return map;\n}\n","import accessor from './accessor';\nimport splitAccessPath from './splitAccessPath';\nimport stringValue from './stringValue';\n\nexport default function(field, name) {\n  var path = splitAccessPath(field),\n      code = 'return _[' + path.map(stringValue).join('][') + '];';\n\n  return accessor(\n    Function('_', code),\n    [(field = path.length===1 ? path[0] : field)],\n    name || field\n  );\n}\n","export default function(child, parent) {\n  var proto = (child.prototype = Object.create(parent.prototype));\n  proto.constructor = child;\n  return proto;\n}\n","export default Array.isArray;\n","export default function(_) {\n  return typeof _ === 'boolean';\n}\n","export default function(_) {\n  return Object.prototype.toString.call(_) === '[object Date]';\n}\n","export default function(_) {\n  return typeof _ === 'function';\n}\n","export default function(_) {\n  return typeof _ === 'number';\n}\n","export default function(_) {\n  return _ === Object(_);\n}\n","export default function(_) {\n  return Object.prototype.toString.call(_) === '[object RegExp]';\n}\n","export default function(_) {\n  return typeof _ === 'string';\n}\n","import accessor from './accessor';\nimport array from './array';\nimport splitAccessPath from './splitAccessPath';\nimport stringValue from './stringValue';\n\nexport default function(fields, flat) {\n  if (fields) {\n    fields = flat\n      ? array(fields).map(function(f) { return f.replace(/\\\\(.)/g, '$1'); })\n      : array(fields);\n  }\n\n  var fn = !(fields && fields.length)\n    ? function() { return ''; }\n    : Function('_', 'return \\'\\'+' +\n        fields.map(function(f) {\n          return '_[' + (flat\n              ? stringValue(f)\n              : splitAccessPath(f).map(stringValue).join('][')\n            ) + ']';\n        }).join('+\\'|\\'+') + ';');\n\n  return accessor(fn, fields, 'key');\n}\n","function log(method, level, input) {\n  var args = [level].concat([].slice.call(input));\n  console[method].apply(console, args); // eslint-disable-line no-console\n}\n\nexport var None  = 0;\nexport var Error = 1;\nexport var Warn  = 2;\nexport var Info  = 3;\nexport var Debug = 4;\n\nexport default function(_) {\n  var level = _ || None;\n  return {\n    level: function(_) {\n      if (arguments.length) {\n        level = +_;\n        return this;\n      } else {\n        return level;\n      }\n    },\n    error: function() {\n      if (level >= Error) log('error', 'ERROR', arguments);\n      return this;\n    },\n    warn: function() {\n      if (level >= Warn) log('warn', 'WARN', arguments);\n      return this;\n    },\n    info: function() {\n      if (level >= Info) log('log', 'INFO', arguments);\n      return this;\n    },\n    debug: function() {\n      if (level >= Debug) log('log', 'DEBUG', arguments);\n      return this;\n    }\n  }\n}\n","export default function(compare, array0, array1, output) {\n  var n0 = array0.length,\n      n1 = array1.length;\n\n  if (!n1) return array0;\n  if (!n0) return array1;\n\n  var merged = output || new array0.constructor(n0 + n1),\n      i0 = 0, i1 = 0, i = 0;\n\n  for (; i0<n0 && i1<n1; ++i) {\n    merged[i] = compare(array0[i0], array1[i1]) > 0\n       ? array1[i1++]\n       : array0[i0++];\n  }\n\n  for (; i0<n0; ++i0, ++i) {\n    merged[i] = array0[i0];\n  }\n\n  for (; i1<n1; ++i1, ++i) {\n    merged[i] = array1[i1];\n  }\n\n  return merged;\n}\n","import repeat from './repeat';\n\nexport default function(str, length, padchar, align) {\n  var c = padchar || ' ',\n      s = str + '',\n      n = length - s.length;\n\n  return n <= 0 ? s\n    : align === 'left' ? repeat(c, n) + s\n    : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))\n    : s + repeat(c, n);\n}\n","export default function(array) {\n  return array[array.length - 1];\n}\n","export default function(str, reps) {\n  var s = '';\n  while (--reps >= 0) s += str;\n  return s;\n}\n","import error from './error';\n\nexport default function(p) {\n  var path = [],\n      q = null,\n      b = 0,\n      n = p.length,\n      s = '',\n      i, j, c;\n\n  p = p + '';\n\n  function push() {\n    path.push(s + p.substring(i, j));\n    s = '';\n    i = j + 1;\n  }\n\n  for (i=j=0; j<n; ++j) {\n    c = p[j];\n    if (c === '\\\\') {\n      s += p.substring(i, j);\n      i = ++j;\n    } else if (c === q) {\n      push();\n      q = null;\n      b = -1;\n    } else if (q) {\n      continue;\n    } else if (i === b && c === '\"') {\n      i = j + 1;\n      q = c;\n    } else if (i === b && c === \"'\") {\n      i = j + 1;\n      q = c;\n    } else if (c === '.' && !b) {\n      if (j > i) {\n        push();\n      } else {\n        i = j + 1;\n      }\n    } else if (c === '[') {\n      if (j > i) push();\n      b = i = j + 1;\n    } else if (c === ']') {\n      if (!b) error('Access path missing open bracket: ' + p);\n      if (b > 0) push();\n      b = 0;\n      i = j + 1;\n    }\n  }\n\n  if (b) error('Access path missing closing bracket: ' + p);\n  if (q) error('Access path missing closing quote: ' + p);\n\n  if (j > i) {\n    j++;\n    push();\n  }\n\n  return path;\n}\n","import isArray from './isArray';\nimport isObject from './isObject';\nimport isString from './isString';\n\nexport default function $(x) {\n  return isArray(x) ? '[' + x.map($) + ']'\n    : isObject(x) || isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n}\n","export default function(_) {\n  return _ == null || _ === '' ? null : !_ || _ === 'false' || _ === '0' ? false : !!_;\n}\n","import isDate from './isDate';\nimport isNumber from './isNumber';\n\nfunction defaultParser(_) {\n  return isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);\n}\n\nexport default function(_, parser) {\n  parser = parser || defaultParser;\n  return _ == null || _ === '' ? null : parser(_);\n}\n","export default function(_) {\n  return _ == null || _ === '' ? null : +_;\n}\n","export default function(_) {\n  for (var s={}, i=0, n=_.length; i<n; ++i) s[_[i]] = true;\n  return s;\n}\n","export default function(_) {\n  return _ == null || _ === '' ? null : _ + '';\n}\n","import {identity} from './accessors';\nimport peek from './peek';\nimport toNumber from './toNumber';\n\nfunction exp(sign) {\n  return function(x) { return sign * Math.exp(x); };\n}\n\nfunction log(sign) {\n  return function(x) { return Math.log(sign * x); };\n}\n\nfunction pow(exponent) {\n  return function(x) {\n    return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);\n  };\n}\n\nfunction pan(domain, delta, lift, ground) {\n  var d0 = lift(domain[0]),\n      d1 = lift(peek(domain)),\n      dd = (d1 - d0) * delta;\n\n  return [\n    ground(d0 - dd),\n    ground(d1 - dd)\n  ];\n}\n\nexport function panLinear(domain, delta) {\n  return pan(domain, delta, toNumber, identity);\n}\n\nexport function panLog(domain, delta) {\n  var sign = Math.sign(domain[0]);\n  return pan(domain, delta, log(sign), exp(sign));\n}\n\nexport function panPow(domain, delta, exponent) {\n  return pan(domain, delta, pow(exponent), pow(1/exponent));\n}\n\nfunction zoom(domain, anchor, scale, lift, ground) {\n  var d0 = lift(domain[0]),\n      d1 = lift(peek(domain)),\n      da = anchor != null ? lift(anchor) : (d0 + d1) / 2;\n\n  return [\n    ground(da + (d0 - da) * scale),\n    ground(da + (d1 - da) * scale)\n  ];\n}\n\nexport function zoomLinear(domain, anchor, scale) {\n  return zoom(domain, anchor, scale, toNumber, identity);\n}\n\nexport function zoomLog(domain, anchor, scale) {\n  var sign = Math.sign(domain[0]);\n  return zoom(domain, anchor, scale, log(sign), exp(sign));\n}\n\nexport function zoomPow(domain, anchor, scale, exponent) {\n  return zoom(domain, anchor, scale, pow(exponent), pow(1/exponent));\n}\n","export default function(str, length, align, ellipsis) {\n  var e = ellipsis != null ? ellipsis : '\\u2026',\n      s = str + '',\n      n = s.length,\n      l = Math.max(0, length - e.length);\n\n  return n <= length ? s\n    : align === 'left' ? e + s.slice(n - l)\n    : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))\n    : s.slice(0, l) + e;\n}\n","export default function(array, filter, visitor) {\n  if (array) {\n    var i = 0, n = array.length, t;\n    if (filter) {\n      for (; i<n; ++i) {\n        if (t = filter(array[i])) visitor(t, i, array);\n      }\n    } else {\n      array.forEach(visitor);\n    }\n  }\n}\n","export {default as bound} from './src/Bound';\nexport {default as identifier} from './src/Identifier';\nexport {default as mark} from './src/Mark';\nexport {default as overlap} from './src/Overlap';\nexport {default as render} from './src/Render';\nexport {default as viewlayout} from './src/ViewLayout';\n","import {Group, LegendRole} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {boundClip, Marks} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Calculate bounding boxes for scenegraph items.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - The scenegraph mark instance to bound.\n */\nexport default function Bound(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Bound, Transform);\n\nprototype.transform = function(_, pulse) {\n  var view = pulse.dataflow,\n      mark = _.mark,\n      type = mark.marktype,\n      entry = Marks[type],\n      bound = entry.bound,\n      markBounds = mark.bounds, rebound;\n\n  if (entry.nested) {\n    // multi-item marks have a single bounds instance\n    if (mark.items.length) view.dirty(mark.items[0]);\n    markBounds = boundItem(mark, bound);\n    mark.items.forEach(function(item) {\n      item.bounds.clear().union(markBounds);\n    });\n  }\n\n  else if (type === Group || _.modified()) {\n    // operator parameters modified -> re-bound all items\n    // updates group bounds in response to modified group content\n    pulse.visit(pulse.MOD, function(item) { view.dirty(item); });\n    markBounds.clear();\n    mark.items.forEach(function(item) {\n      markBounds.union(boundItem(item, bound));\n    });\n\n    // force reflow for legends to propagate any layout changes\n    // suppress other types to prevent overall layout jumpiness\n    if (mark.role === LegendRole) pulse.reflow();\n  }\n\n  else {\n    // incrementally update bounds, re-bound mark as needed\n    rebound = pulse.changed(pulse.REM);\n\n    pulse.visit(pulse.ADD, function(item) {\n      markBounds.union(boundItem(item, bound));\n    });\n\n    pulse.visit(pulse.MOD, function(item) {\n      rebound = rebound || markBounds.alignsWith(item.bounds);\n      view.dirty(item);\n      markBounds.union(boundItem(item, bound));\n    });\n\n    if (rebound) {\n      markBounds.clear();\n      mark.items.forEach(function(item) { markBounds.union(item.bounds); });\n    }\n  }\n\n  // ensure mark bounds do not exceed any clipping region\n  boundClip(mark);\n\n  return pulse.modifies('bounds');\n};\n\nfunction boundItem(item, bound, opt) {\n  return bound(item.bounds.clear(), item, opt);\n}\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\nvar COUNTER_NAME = ':vega_identifier:';\n\n/**\n * Adds a unique identifier to all added tuples.\n * This transform creates a new signal that serves as an id counter.\n * As a result, the id counter is shared across all instances of this\n * transform, generating unique ids across multiple data streams. In\n * addition, this signal value can be included in a snapshot of the\n * dataflow state, enabling correct resumption of id allocation.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {string} params.as - The field name for the generated identifier.\n */\nexport default function Identifier(params) {\n  Transform.call(this, 0, params);\n}\n\nIdentifier.Definition = {\n  \"type\": \"Identifier\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"as\", \"type\": \"string\", \"required\": true }\n  ]\n};\n\nvar prototype = inherits(Identifier, Transform);\n\nprototype.transform = function(_, pulse) {\n  var counter = getCounter(pulse.dataflow),\n      id = counter.value,\n      as = _.as;\n\n  pulse.visit(pulse.ADD, function(t) {\n    if (!t[as]) t[as] = ++id;\n  });\n\n  counter.set(this.value = id);\n  return pulse;\n};\n\nfunction getCounter(view) {\n  var counter = view._signals[COUNTER_NAME];\n  if (!counter) {\n    view._signals[COUNTER_NAME] = (counter = view.add(0));\n  }\n  return counter;\n}\n","import {Group} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {Item, GroupItem} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\n/**\n * Bind scenegraph items to a scenegraph mark instance.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.markdef - The mark definition for creating the mark.\n *   This is an object of legal scenegraph mark properties which *must* include\n *   the 'marktype' property.\n */\nexport default function Mark(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Mark, Transform);\n\nprototype.transform = function(_, pulse) {\n  var mark = this.value;\n\n  // acquire mark on first invocation, bind context and group\n  if (!mark) {\n    mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup(_), _.index);\n    mark.group.context = _.context;\n    if (!_.context.group) _.context.group = mark.group;\n    mark.source = this;\n    mark.clip = _.clip;\n    mark.interactive = _.interactive;\n    this.value = mark;\n  }\n\n  // initialize entering items\n  var Init = mark.marktype === Group ? GroupItem : Item;\n  pulse.visit(pulse.ADD, function(item) { Init.call(item, mark); });\n\n  // update clipping and/or interactive status\n  if (_.modified('clip') || _.modified('interactive')) {\n    mark.clip = _.clip;\n    mark.interactive = !!_.interactive;\n    mark.zdirty = true; // force scenegraph re-eval\n    pulse.reflow();\n  }\n\n  // bind items array to scenegraph mark\n  mark.items = pulse.source;\n  return pulse;\n};\n\nfunction lookup(_) {\n  var g = _.groups, p = _.parent;\n  return g && g.size === 1 ? g.get(Object.keys(g.object)[0])\n    : g && p ? g.lookup(p)\n    : null;\n}\n","import {Top, Bottom} from './constants';\nimport {Transform} from 'vega-dataflow';\nimport {Bounds} from 'vega-scenegraph';\nimport {inherits, peek} from 'vega-util';\n\n/**\n * Analyze items for overlap, changing opacity to hide items with\n * overlapping bounding boxes. This transform will preserve at least\n * two items (e.g., first and last) even if overlap persists.\n * @param {object} params - The parameters for this operator.\n * @param {function(*,*): number} [params.sort] - A comparator\n *   function for sorting items.\n * @param {object} [params.method] - The overlap removal method to apply.\n *   One of 'parity' (default, hide every other item until there is no\n *   more overlap) or 'greedy' (sequentially scan and hide and items that\n *   overlap with the last visible item).\n * @param {object} [params.boundScale] - A scale whose range should be used\n *   to bound the items. Items exceeding the bounds of the scale range\n *   will be treated as overlapping. If null or undefined, no bounds check\n *   will be applied.\n * @param {object} [params.boundOrient] - The orientation of the scale\n *   (top, bottom, left, or right) used to bound items. This parameter is\n *   ignored if boundScale is null or undefined.\n * @param {object} [params.boundTolerance] - The tolerance in pixels for\n *   bound inclusion testing (default 1). This specifies by how many pixels\n *   an item's bounds may exceed the scale range bounds and not be culled.\n * @constructor\n */\nexport default function Overlap(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Overlap, Transform);\n\nvar methods = {\n  parity: function(items) {\n    return items.filter(function(item, i) {\n      return i % 2 ? (item.opacity = 0) : 1;\n    });\n  },\n  greedy: function(items) {\n    var a;\n    return items.filter(function(b, i) {\n      if (!i || !intersect(a.bounds, b.bounds)) {\n        a = b;\n        return 1;\n      } else {\n        return b.opacity = 0;\n      }\n    });\n  }\n};\n\n// compute bounding box intersection\n// allow 1 pixel of overlap tolerance\nfunction intersect(a, b) {\n  return !(\n    a.x2 - 1 < b.x1 ||\n    a.x1 + 1 > b.x2 ||\n    a.y2 - 1 < b.y1 ||\n    a.y1 + 1 > b.y2\n  );\n}\n\nfunction hasOverlap(items) {\n  for (var i=1, n=items.length, a=items[0].bounds, b; i<n; a=b, ++i) {\n    if (intersect(a, b = items[i].bounds)) return true;\n  }\n}\n\nfunction hasBounds(item) {\n  var b = item.bounds;\n  return b.width() > 1 && b.height() > 1;\n}\n\nfunction boundTest(scale, orient, tolerance) {\n  var range = scale.range(),\n      b = new Bounds();\n\n  if (orient === Top || orient === Bottom) {\n    b.set(range[0], -Infinity, range[1], +Infinity);\n  } else {\n    b.set(-Infinity, range[0], +Infinity, range[1]);\n  }\n  b.expand(tolerance || 1);\n\n  return function(item) {\n    return b.encloses(item.bounds);\n  };\n}\n\n// reset all items to be fully opaque\nfunction reset(source) {\n  source.forEach(function(item) { item.opacity = 1; });\n  return source;\n}\n\n// add all tuples to mod, fork pulse if parameters were modified\n// fork prevents cross-stream tuple pollution (e.g., pulse from scale)\nfunction reflow(pulse, _) {\n  return pulse.reflow(_.modified()).modifies('opacity');\n}\n\nprototype.transform = function(_, pulse) {\n  var reduce = methods[_.method] || methods.parity,\n      source = pulse.materialize(pulse.SOURCE).source,\n      items, test;\n\n  if (!source) return;\n\n  if (!_.method) {\n    // early exit if method is falsy\n    if (_.modified('method')) {\n      reset(source);\n      pulse = reflow(pulse, _);\n    }\n    return pulse;\n  }\n\n  if (_.sort) {\n    source = source.slice().sort(_.sort);\n  }\n\n  if (_.method === 'greedy') {\n    source = source.filter(hasBounds);\n  }\n\n  items = reset(source);\n  pulse = reflow(pulse, _);\n\n  if (items.length >= 3 && hasOverlap(items)) {\n    do {\n      items = reduce(items);\n    } while (items.length >= 3 && hasOverlap(items));\n\n    if (items.length < 3 && !peek(source).opacity) {\n      if (items.length > 1) peek(items).opacity = 0;\n      peek(source).opacity = 1;\n    }\n  }\n\n  if (_.boundScale && _.boundTolerance >= 0) {\n    test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);\n    source.forEach(function(item) {\n      if (!test(item)) item.opacity = 0;\n    })\n  }\n\n  return pulse;\n};\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\n\n/**\n * Queue modified scenegraph items for rendering.\n * @constructor\n */\nexport default function Render(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(Render, Transform);\n\nprototype.transform = function(_, pulse) {\n  var view = pulse.dataflow;\n\n  pulse.visit(pulse.ALL, function(item) { view.dirty(item); });\n\n  // set z-index dirty flag as needed\n  if (pulse.fields && pulse.fields['zindex']) {\n    var item = pulse.source && pulse.source[0];\n    if (item) item.mark.zdirty = true;\n  }\n};\n","import {\n  Group, AxisRole, LegendRole, TitleRole, FrameRole, ScopeRole,\n  RowHeader, RowFooter, RowTitle, ColHeader, ColFooter, ColTitle,\n  Top, Bottom, Left, Right, Start, End,\n  TopLeft, TopRight, BottomLeft, BottomRight,\n  Fit, FitX, FitY, Pad, None, Padding, Symbols\n} from './constants';\nimport {gridLayout} from './gridLayout';\nimport {Transform} from 'vega-dataflow';\nimport {Bounds, boundStroke} from 'vega-scenegraph';\nimport {inherits} from 'vega-util';\n\nvar AxisOffset = 0.5,\n    tempBounds = new Bounds();\n\n/**\n * Layout view elements such as axes and legends.\n * Also performs size adjustments.\n * @constructor\n * @param {object} params - The parameters for this operator.\n * @param {object} params.mark - Scenegraph mark of groups to layout.\n */\nexport default function ViewLayout(params) {\n  Transform.call(this, null, params);\n}\n\nvar prototype = inherits(ViewLayout, Transform);\n\nprototype.transform = function(_, pulse) {\n  // TODO incremental update, output?\n  var view = pulse.dataflow;\n  _.mark.items.forEach(function(group) {\n    if (_.layout) gridLayout(view, group, _.layout);\n    layoutGroup(view, group, _);\n  });\n  if (_.modified()) pulse.reflow();\n  return pulse;\n};\n\nfunction layoutGroup(view, group, _) {\n  var items = group.items,\n      width = Math.max(0, group.width || 0),\n      height = Math.max(0, group.height || 0),\n      viewBounds = new Bounds().set(0, 0, width, height),\n      xBounds = viewBounds.clone(),\n      yBounds = viewBounds.clone(),\n      legends = [], title,\n      mark, flow, b, i, n;\n\n  // layout axes, gather legends, collect bounds\n  for (i=0, n=items.length; i<n; ++i) {\n    mark = items[i];\n    switch (mark.role) {\n      case AxisRole:\n        b = isYAxis(mark) ? xBounds : yBounds;\n        b.union(axisLayout(view, mark, width, height));\n        break;\n      case TitleRole:\n        title = mark; break;\n      case LegendRole:\n        legends.push(mark); break;\n      case FrameRole:\n      case ScopeRole:\n      case RowHeader:\n      case RowFooter:\n      case RowTitle:\n      case ColHeader:\n      case ColFooter:\n      case ColTitle:\n        xBounds.union(mark.bounds);\n        yBounds.union(mark.bounds);\n        break;\n      default:\n        viewBounds.union(mark.bounds);\n    }\n  }\n\n  // layout legends, adjust viewBounds\n  if (legends.length) {\n    flow = {\n      leftWidth: legendPreprocess(view, legends),\n      margin: _.legendMargin || 8,\n      left: 0, right: 0, top: 0, bottom: 0\n    };\n\n    for (i=0, n=legends.length; i<n; ++i) {\n      b = legendLayout(view, legends[i], flow, xBounds, yBounds, width, height);\n      if (_.autosize && _.autosize.type === Fit) {\n        // For autosize fit, incorporate the orthogonal dimension only.\n        // Legends that overrun the chart area will then be clipped;\n        // otherwise the chart area gets reduced to nothing!\n        var orient = legends[i].items[0].datum.orient;\n        if (orient === Left || orient === Right) {\n          viewBounds.add(b.x1, 0).add(b.x2, 0);\n        } else if (orient === Top || orient === Bottom) {\n          viewBounds.add(0, b.y1).add(0, b.y2);\n        }\n      } else {\n        viewBounds.union(b);\n      }\n    }\n  }\n\n  // combine bounding boxes\n  viewBounds.union(xBounds).union(yBounds);\n\n  // layout title, adjust bounds\n  if (title) {\n    viewBounds.union(titleLayout(view, title, width, height, viewBounds));\n  }\n\n  // perform size adjustment\n  viewSizeLayout(view, group, viewBounds, _);\n}\n\nfunction set(item, property, value) {\n  if (item[property] === value) {\n    return 0;\n  } else {\n    item[property] = value;\n    return 1;\n  }\n}\n\nfunction isYAxis(mark) {\n  var orient = mark.items[0].datum.orient;\n  return orient === Left || orient === Right;\n}\n\nfunction axisIndices(datum) {\n  var index = +datum.grid;\n  return [\n    datum.ticks  ? index++ : -1, // ticks index\n    datum.labels ? index++ : -1, // labels index\n    index + (+datum.domain)      // title index\n  ];\n}\n\nfunction axisLayout(view, axis, width, height) {\n  var item = axis.items[0],\n      datum = item.datum,\n      orient = datum.orient,\n      indices = axisIndices(datum),\n      range = item.range,\n      offset = item.offset,\n      position = item.position,\n      minExtent = item.minExtent,\n      maxExtent = item.maxExtent,\n      title = datum.title && item.items[indices[2]].items[0],\n      titlePadding = item.titlePadding,\n      bounds = item.bounds,\n      x = 0, y = 0, i, s;\n\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n  if ((i=indices[0]) > -1) bounds.union(item.items[i].bounds);\n  if ((i=indices[1]) > -1) bounds.union(item.items[i].bounds);\n\n  // position axis group and title\n  switch (orient) {\n    case Top:\n      x = position || 0;\n      y = -offset;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));\n      if (title) s = axisTitleLayout(title, s, titlePadding, 0, -1, bounds);\n      bounds.add(0, -s).add(range, 0);\n      break;\n    case Left:\n      x = -offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));\n      if (title) s = axisTitleLayout(title, s, titlePadding, 1, -1, bounds);\n      bounds.add(-s, 0).add(0, range);\n      break;\n    case Right:\n      x = width + offset;\n      y = position || 0;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));\n      if (title) s = axisTitleLayout(title, s, titlePadding, 1, 1, bounds);\n      bounds.add(0, 0).add(s, range);\n      break;\n    case Bottom:\n      x = position || 0;\n      y = height + offset;\n      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));\n      if (title) s = axisTitleLayout(title, s, titlePadding, 0, 1, bounds);\n      bounds.add(0, 0).add(range, s);\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  // update bounds\n  boundStroke(bounds.translate(x, y), item);\n\n  if (set(item, 'x', x + AxisOffset) | set(item, 'y', y + AxisOffset)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction axisTitleLayout(title, offset, pad, isYAxis, sign, bounds) {\n  var b = title.bounds, dx = 0, dy = 0;\n\n  if (title.auto) {\n    offset += pad;\n\n    isYAxis\n      ? dx = (title.x || 0) - (title.x = sign * offset)\n      : dy = (title.y || 0) - (title.y = sign * offset);\n\n    b.translate(-dx, -dy);\n    title.mark.bounds.set(b.x1, b.y1, b.x2, b.y2);\n\n    if (isYAxis) {\n      bounds.add(0, b.y1).add(0, b.y2);\n      offset += b.width();\n    } else {\n      bounds.add(b.x1, 0).add(b.x2, 0);\n      offset += b.height();\n    }\n  } else {\n    bounds.union(b);\n  }\n\n  return offset;\n}\n\nfunction titleLayout(view, title, width, height, viewBounds) {\n  var item = title.items[0],\n      orient = item.orient,\n      frame = item.frame,\n      anchor = item.anchor,\n      offset = item.offset,\n      bounds = item.bounds,\n      vertical = (orient === Left || orient === Right),\n      start = 0,\n      end = vertical ? height : width,\n      x = 0, y = 0, pos;\n\n  if (frame !== Group) {\n    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1)\n      : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2)\n      : (start = viewBounds.x1, end = viewBounds.x2);\n  } else if (orient === Left) {\n    start = height, end = 0;\n  }\n\n  pos = (anchor === Start) ? start\n    : (anchor === End) ? end\n    : (start + end) / 2;\n\n  tempBounds.clear().union(bounds);\n\n  // position title text\n  switch (orient) {\n    case Top:\n      x = pos;\n      y = viewBounds.y1 - offset;\n      break;\n    case Left:\n      x = viewBounds.x1 - offset;\n      y = pos;\n      break;\n    case Right:\n      x = viewBounds.x2 + offset;\n      y = pos;\n      break;\n    case Bottom:\n      x = pos;\n      y = viewBounds.y2 + offset;\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  bounds.translate(x - item.x, y - item.y);\n  if (set(item, 'x', x) | set(item, 'y', y)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  // update bounds\n  return title.bounds.clear().union(bounds);\n}\n\nfunction legendPreprocess(view, legends) {\n  return legends.reduce(function(w, legend) {\n    var item = legend.items[0];\n\n    // adjust entry to accommodate padding and title\n    legendGroupLayout(view, item, item.items[0].items[0]);\n\n    if (item.datum.orient === Left) {\n      var b = tempBounds.clear();\n      item.items.forEach(function(_) { b.union(_.bounds); });\n      w = Math.max(w, Math.ceil(b.width() + 2 * item.padding - 1));\n    }\n\n    return w;\n  }, 0);\n}\n\nfunction legendGroupLayout(view, item, entry) {\n  var x = item.padding - entry.x,\n      y = item.padding - entry.y;\n\n  if (item.datum.title) {\n    var title = item.items[1].items[0];\n    y += item.titlePadding + title.fontSize;\n  }\n\n  if (x || y) {\n    entry.x += x;\n    entry.y += y;\n    entry.bounds.translate(x, y);\n    entry.mark.bounds.translate(x, y);\n    view.dirty(entry);\n  }\n}\n\nfunction legendLayout(view, legend, flow, xBounds, yBounds, width, height) {\n  var item = legend.items[0],\n      datum = item.datum,\n      orient = datum.orient,\n      offset = item.offset,\n      bounds = item.bounds,\n      x = 0,\n      y = 0,\n      w, h, axisBounds;\n\n  if (orient === Top || orient === Bottom) {\n    axisBounds = yBounds,\n    x = flow[orient];\n  } else if (orient === Left || orient === Right) {\n    axisBounds = xBounds;\n    y = flow[orient];\n  }\n\n  tempBounds.clear().union(bounds);\n  bounds.clear();\n\n  // aggregate bounds to determine size\n  // shave off 1 pixel because it looks better...\n  item.items.forEach(function(_) { bounds.union(_.bounds); });\n  w = 2 * item.padding - 1;\n  h = 2 * item.padding - 1;\n  if (!bounds.empty()) {\n    w = Math.ceil(bounds.width() + w);\n    h = Math.ceil(bounds.height() + h);\n  }\n\n  if (datum.type === Symbols) {\n    legendEntryLayout(item.items[0].items[0].items[0].items);\n  }\n\n  switch (orient) {\n    case Left:\n      x -= flow.leftWidth + offset - Math.floor(axisBounds.x1);\n      flow.left += h + flow.margin;\n      break;\n    case Right:\n      x += offset + Math.ceil(axisBounds.x2);\n      flow.right += h + flow.margin;\n      break;\n    case Top:\n      y -= h + offset - Math.floor(axisBounds.y1);\n      flow.top += w + flow.margin;\n      break;\n    case Bottom:\n      y += offset + Math.ceil(axisBounds.y2);\n      flow.bottom += w + flow.margin;\n      break;\n    case TopLeft:\n      x += offset;\n      y += offset;\n      break;\n    case TopRight:\n      x += width - w - offset;\n      y += offset;\n      break;\n    case BottomLeft:\n      x += offset;\n      y += height - h - offset;\n      break;\n    case BottomRight:\n      x += width - w - offset;\n      y += height - h - offset;\n      break;\n    default:\n      x = item.x;\n      y = item.y;\n  }\n\n  // update bounds\n  boundStroke(bounds.set(x, y, x + w, y + h), item);\n\n  // update legend layout\n  if (set(item, 'x', x) | set(item, 'width', w) |\n      set(item, 'y', y) | set(item, 'height', h)) {\n    item.bounds = tempBounds;\n    view.dirty(item);\n    item.bounds = bounds;\n    view.dirty(item);\n  }\n\n  return item.mark.bounds.clear().union(bounds);\n}\n\nfunction legendEntryLayout(entries) {\n  // get max widths for each column\n  var widths = entries.reduce(function(w, g) {\n    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);\n    return w;\n  }, {});\n\n  // set dimensions of legend entry groups\n  entries.forEach(function(g) {\n    g.width  = widths[g.column];\n    g.height = g.bounds.y2 - g.y;\n  });\n}\n\nfunction viewSizeLayout(view, group, viewBounds, _) {\n  var auto = _.autosize || {},\n      type = auto.type,\n      viewWidth = view._width,\n      viewHeight = view._height,\n      padding = view.padding();\n\n  if (view._autosize < 1 || !type) return;\n\n  var width  = Math.max(0, group.width || 0),\n      left   = Math.max(0, Math.ceil(-viewBounds.x1)),\n      right  = Math.max(0, Math.ceil(viewBounds.x2 - width)),\n      height = Math.max(0, group.height || 0),\n      top    = Math.max(0, Math.ceil(-viewBounds.y1)),\n      bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));\n\n  if (auto.contains === Padding) {\n    viewWidth -= padding.left + padding.right;\n    viewHeight -= padding.top + padding.bottom;\n  }\n\n  if (type === None) {\n    left = 0;\n    top = 0;\n    width = viewWidth;\n    height = viewHeight;\n  }\n\n  else if (type === Fit) {\n    width = Math.max(0, viewWidth - left - right);\n    height = Math.max(0, viewHeight - top - bottom);\n  }\n\n  else if (type === FitX) {\n    width = Math.max(0, viewWidth - left - right);\n    viewHeight = height + top + bottom;\n  }\n\n  else if (type === FitY) {\n    viewWidth = width + left + right;\n    height = Math.max(0, viewHeight - top - bottom);\n  }\n\n  else if (type === Pad) {\n    viewWidth = width + left + right;\n    viewHeight = height + top + bottom;\n  }\n\n  view._resizeView(\n    viewWidth, viewHeight,\n    width, height,\n    [left, top],\n    auto.resize\n  );\n}\n","export var Top = 'top';\nexport var Left = 'left';\nexport var Right = 'right';\nexport var Bottom = 'bottom';\n\nexport var TopLeft = 'top-left';\nexport var TopRight = 'top-right';\nexport var BottomLeft = 'bottom-left';\nexport var BottomRight = 'bottom-right';\n\nexport var Start = 'start';\nexport var Middle = 'middle';\nexport var End = 'end';\n\nexport var Group = 'group';\n\nexport var AxisRole = 'axis';\nexport var TitleRole = 'title';\nexport var FrameRole = 'frame';\nexport var ScopeRole = 'scope';\nexport var LegendRole = 'legend';\n\nexport var RowHeader = 'row-header';\nexport var RowFooter = 'row-footer';\nexport var RowTitle  = 'row-title';\nexport var ColHeader = 'column-header';\nexport var ColFooter = 'column-footer';\nexport var ColTitle  = 'column-title';\n\nexport var Padding = 'padding';\n\nexport var Symbols = 'symbol';\n\nexport var Fit  = 'fit';\nexport var FitX = 'fit-x';\nexport var FitY = 'fit-y';\nexport var Pad  = 'pad';\nexport var None = 'none';\n\nexport var All = 'all';\nexport var Each = 'each';\nexport var Flush = 'flush';\n\nexport var Column = 'column';\nexport var Row = 'row';\n\n\n","import {\n  All, Each, Flush, Column, Row,\n  Group, AxisRole, LegendRole,\n  RowHeader, RowFooter, RowTitle,\n  ColHeader, ColFooter, ColTitle\n} from './constants';\nimport {isObject} from 'vega-util';\nimport {Bounds} from 'vega-scenegraph';\n\nfunction extractGroups(group) {\n  var groups = group.items,\n      n = groups.length,\n      i = 0, mark, items;\n\n  var views = {\n    marks:      [],\n    rowheaders: [],\n    rowfooters: [],\n    colheaders: [],\n    colfooters: [],\n    rowtitle: null,\n    coltitle: null\n  };\n\n  // layout axes, gather legends, collect bounds\n  for (; i<n; ++i) {\n    mark = groups[i];\n    items = mark.items;\n    if (mark.marktype === Group) {\n      switch (mark.role) {\n        case AxisRole:\n        case LegendRole:\n          break;\n        case RowHeader: addAll(items, views.rowheaders); break;\n        case RowFooter: addAll(items, views.rowfooters); break;\n        case ColHeader: addAll(items, views.colheaders); break;\n        case ColFooter: addAll(items, views.colfooters); break;\n        case RowTitle:  views.rowtitle = items[0]; break;\n        case ColTitle:  views.coltitle = items[0]; break;\n        default:        addAll(items, views.marks);\n      }\n    }\n  }\n\n  return views;\n}\n\nfunction addAll(items, array) {\n  for (var i=0, n=items.length; i<n; ++i) {\n    array.push(items[i]);\n  }\n}\n\nfunction bboxFlush(item) {\n  return {x1: 0, y1: 0, x2: item.width || 0, y2: item.height || 0};\n}\n\nfunction bboxFull(item) {\n  var b = item.bounds.clone();\n  return b.empty()\n    ? b.set(0, 0, 0, 0)\n    : b.translate(-(item.x||0), -(item.y||0));\n}\n\nfunction boundFlush(item, field) {\n  return field === 'x1' ? (item.x || 0)\n    : field === 'y1' ? (item.y || 0)\n    : field === 'x2' ? (item.x || 0) + (item.width || 0)\n    : field === 'y2' ? (item.y || 0) + (item.height || 0)\n    : undefined;\n}\n\nfunction boundFull(item, field) {\n  return item.bounds[field];\n}\n\nfunction get(opt, key, d) {\n  var v = isObject(opt) ? opt[key] : opt;\n  return v != null ? v : (d !== undefined ? d : 0);\n}\n\nfunction offsetValue(v) {\n  return v < 0 ? Math.ceil(-v) : 0;\n}\n\nexport function gridLayout(view, group, opt) {\n  var views = extractGroups(group, opt),\n      groups = views.marks,\n      flush = opt.bounds === Flush,\n      bbox = flush ? bboxFlush : bboxFull,\n      bounds = new Bounds(0, 0, 0, 0),\n      alignCol = get(opt.align, Column),\n      alignRow = get(opt.align, Row),\n      padCol = get(opt.padding, Column),\n      padRow = get(opt.padding, Row),\n      off = opt.offset,\n      ncols = group.columns || opt.columns || groups.length,\n      nrows = ncols < 0 ? 1 : Math.ceil(groups.length / ncols),\n      cells = nrows * ncols,\n      xOffset = [], xExtent = [], xMax = 0, xInit = 0,\n      yOffset = [], yExtent = [], yMax = 0, yInit = 0,\n      n = groups.length,\n      m, i, c, r, b, g, px, py, x, y, band, offset;\n\n  for (i=0; i<ncols; ++i) {\n    xExtent[i] = 0;\n  }\n  for (i=0; i<nrows; ++i) {\n    yExtent[i] = 0;\n  }\n\n  // determine offsets for each group\n  for (i=0; i<n; ++i) {\n    b = bbox(groups[i]);\n    c = i % ncols;\n    r = ~~(i / ncols);\n    px = Math.ceil(bbox(groups[i]).x2);\n    py = Math.ceil(bbox(groups[i]).y2);\n    xMax = Math.max(xMax, px);\n    yMax = Math.max(yMax, py);\n    xExtent[c] = Math.max(xExtent[c], px);\n    yExtent[r] = Math.max(yExtent[r], py);\n    xOffset.push(padCol + offsetValue(b.x1));\n    yOffset.push(padRow + offsetValue(b.y1));\n    view.dirty(groups[i]);\n  }\n\n  // set initial alignment offsets\n  for (i=0; i<n; ++i) {\n    if (i % ncols === 0) xOffset[i] = xInit;\n    if (i < ncols) yOffset[i] = yInit;\n  }\n\n  // enforce column alignment constraints\n  if (alignCol === Each) {\n    for (c=1; c<ncols; ++c) {\n      for (offset=0, i=c; i<n; i += ncols) {\n        if (offset < xOffset[i]) offset = xOffset[i];\n      }\n      for (i=c; i<n; i += ncols) {\n        xOffset[i] = offset + xExtent[c-1];\n      }\n    }\n  } else if (alignCol === All) {\n    for (offset=0, i=0; i<n; ++i) {\n      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];\n    }\n    for (i=0; i<n; ++i) {\n      if (i % ncols) xOffset[i] = offset + xMax;\n    }\n  } else {\n    for (alignCol=false, c=1; c<ncols; ++c) {\n      for (i=c; i<n; i += ncols) {\n        xOffset[i] += xExtent[c-1];\n      }\n    }\n  }\n\n  // enforce row alignment constraints\n  if (alignRow === Each) {\n    for (r=1; r<nrows; ++r) {\n      for (offset=0, i=r*ncols, m=i+ncols; i<m; ++i) {\n        if (offset < yOffset[i]) offset = yOffset[i];\n      }\n      for (i=r*ncols; i<m; ++i) {\n        yOffset[i] = offset + yExtent[r-1];\n      }\n    }\n  } else if (alignRow === All) {\n    for (offset=0, i=ncols; i<n; ++i) {\n      if (offset < yOffset[i]) offset = yOffset[i];\n    }\n    for (i=ncols; i<n; ++i) {\n      yOffset[i] = offset + yMax;\n    }\n  } else {\n    for (alignRow=false, r=1; r<nrows; ++r) {\n      for (i=r*ncols, m=i+ncols; i<m; ++i) {\n        yOffset[i] += yExtent[r-1];\n      }\n    }\n  }\n\n  // perform horizontal grid layout\n  for (x=0, i=0; i<n; ++i) {\n    g = groups[i];\n    px = g.x || 0;\n    g.x = (x = xOffset[i] + (i % ncols ? x : 0));\n    g.bounds.translate(x - px, 0);\n  }\n\n  // perform vertical grid layout\n  for (c=0; c<ncols; ++c) {\n    for (y=0, i=c; i<n; i += ncols) {\n      g = groups[i];\n      py = g.y || 0;\n      g.y = (y += yOffset[i]);\n      g.bounds.translate(0, y - py);\n    }\n  }\n\n  // perform horizontal centering\n  if (get(opt.center, Column) && nrows > 1 && alignCol) {\n    for (i=0; i<n; ++i) {\n      g = groups[i];\n      b = alignCol === All ? xMax : xExtent[i % ncols];\n      x = b - bbox(g).x2;\n      if (x > 0) {\n        g.x += (px = x / 2);\n        g.bounds.translate(px, 0);\n      }\n    }\n  }\n\n  // perform vertical centering\n  if (get(opt.center, Row) && ncols !== 1 && alignRow) {\n    for (i=0; i<n; ++i) {\n      g = groups[i];\n      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];\n      y = b - bbox(g).y2;\n      if (y > 0) {\n        g.y += (py = y / 2);\n        g.bounds.translate(0, py);\n      }\n    }\n  }\n\n  // update mark bounds, mark dirty\n  for (i=0; i<n; ++i) groups[i].mark.bounds.clear();\n  for (i=0; i<n; ++i) {\n    g = groups[i];\n    view.dirty(g);\n    bounds.union(g.mark.bounds.union(g.bounds));\n  }\n\n  // -- layout grid headers and footers --\n\n  // aggregation functions for grid margin determination\n  function min(a, b) { return Math.floor(Math.min(a, b)); }\n  function max(a, b) { return Math.ceil(Math.max(a, b)); }\n\n  // bounding box calculation methods\n  bbox = flush ? boundFlush : boundFull;\n\n  // perform row header layout\n  band = get(opt.headerBand, Row, null);\n  x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'),    min, 0, bbox, 'x1', 0, ncols, 1, band);\n\n  // perform column header layout\n  band = get(opt.headerBand, Column, null);\n  y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);\n\n  // perform row footer layout\n  band = get(opt.footerBand, Row, null);\n  layoutHeaders(    view, views.rowfooters, groups, ncols, nrows,  get(off, 'rowFooter'),    max, 0, bbox, 'x2', ncols-1, ncols, 1, band);\n\n  // perform column footer layout\n  band = get(opt.footerBand, Column, null);\n  layoutHeaders(    view, views.colfooters, groups, ncols, ncols,  get(off, 'columnFooter'), max, 1, bbox, 'y2', cells-ncols, 1, ncols, band);\n\n  // perform row title layout\n  if (views.rowtitle) {\n    offset = x - get(off, 'rowTitle');\n    band = get(opt.titleBand, Row, 0.5);\n    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);\n  }\n\n  // perform column title layout\n  if (views.coltitle) {\n    offset = y - get(off, 'columnTitle');\n    band = get(opt.titleBand, Column, 0.5);\n    layoutTitle(view, views.coltitle, offset, 1, bounds, band);\n  }\n}\n\nfunction layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {\n  var n = groups.length,\n      init = 0,\n      edge = 0,\n      i, j, k, m, b, h, g, x, y;\n\n  // if no groups, early exit and return 0\n  if (!n) return init;\n\n  // compute margin\n  for (i=start; i<n; i+=stride) {\n    if (groups[i]) init = agg(init, bound(groups[i], bf));\n  }\n\n  // if no headers, return margin calculation\n  if (!headers.length) return init;\n\n  // check if number of headers exceeds number of rows or columns\n  if (headers.length > limit) {\n    view.warn('Grid headers exceed limit: ' + limit);\n    headers = headers.slice(0, limit);\n  }\n\n  // apply offset\n  init += offset;\n\n  // clear mark bounds for all headers\n  for (j=0, m=headers.length; j<m; ++j) {\n    view.dirty(headers[j]);\n    headers[j].mark.bounds.clear();\n  }\n\n  // layout each header\n  for (i=start, j=0, m=headers.length; j<m; ++j, i+=stride) {\n    h = headers[j];\n    b = h.mark.bounds;\n\n    // search for nearest group to align to\n    // necessary if table has empty cells\n    for (k=i; k >= 0 && (g = groups[k]) == null; k-=back);\n\n    // assign coordinates and update bounds\n    if (isX) {\n      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());\n      y = init;\n    } else {\n      x = init;\n      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());\n    }\n    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));\n    h.x = x;\n    h.y = y;\n    view.dirty(h);\n\n    // update current edge of layout bounds\n    edge = agg(edge, b[bf]);\n  }\n\n  return edge;\n}\n\nfunction layoutTitle(view, g, offset, isX, bounds, band) {\n  if (!g) return;\n  view.dirty(g);\n\n  // compute title coordinates\n  var x = offset, y = offset;\n  isX\n    ? (x = Math.round(bounds.x1 + band * bounds.width()))\n    : (y = Math.round(bounds.y1 + band * bounds.height()));\n\n  // assign coordinates and update bounds\n  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));\n  g.mark.bounds.clear().union(g.bounds);\n  g.x = x;\n  g.y = y;\n\n  // queue title for redraw\n  view.dirty(g);\n}\n","export {default as View} from './src/View';\n","import cursor from './cursor';\nimport {data, dataref, change, insert, remove} from './data';\nimport {initializeEventConfig, events} from './events';\nimport hover from './hover';\nimport finalize from './finalize';\nimport initialize from './initialize';\nimport renderToImageURL from './render-to-image-url';\nimport renderToCanvas from './render-to-canvas';\nimport renderToSVG from './render-to-svg';\nimport {resizeRenderer} from './render-size';\nimport runtime from './runtime';\nimport {scale} from './scale';\nimport {resizeView, initializeResize, viewWidth, viewHeight} from './size';\nimport {getState, setState} from './state';\nimport timer from './timer';\nimport defaultTooltip from './tooltip';\nimport trap from './trap';\n\nimport {Dataflow} from 'vega-dataflow';\nimport {error, extend, inherits, stringValue} from 'vega-util';\nimport {\n  CanvasHandler, Scenegraph,\n  renderModule, RenderType\n} from 'vega-scenegraph';\n\n/**\n * Create a new View instance from a Vega dataflow runtime specification.\n * The generated View will not immediately be ready for display. Callers\n * should also invoke the initialize method (e.g., to set the parent\n * DOM element in browser-based deployment) and then invoke the run\n * method to evaluate the dataflow graph. Rendering will automatically\n * be peformed upon dataflow runs.\n * @constructor\n * @param {object} spec - The Vega dataflow runtime specification.\n */\nexport default function View(spec, options) {\n  var view = this;\n  options = options || {};\n\n  Dataflow.call(view);\n  view.loader(options.loader || view._loader);\n  view.logLevel(options.logLevel || 0);\n\n  view._el = null;\n  view._renderType = options.renderer || RenderType.Canvas;\n  view._scenegraph = new Scenegraph();\n  var root = view._scenegraph.root;\n\n  // initialize renderer, handler and event management\n  view._renderer = null;\n  view._tooltip = options.tooltip || defaultTooltip,\n  view._redraw = true;\n  view._handler = new CanvasHandler().scene(root);\n  view._preventDefault = false;\n  view._timers = [];\n  view._eventListeners = [];\n  view._resizeListeners = [];\n\n  // initialize dataflow graph\n  var ctx = runtime(view, spec, options.functions);\n  view._runtime = ctx;\n  view._signals = ctx.signals;\n  view._bind = (spec.bindings || []).map(function(_) {\n    return {\n      state: null,\n      param: extend({}, _)\n    };\n  });\n\n  // initialize scenegraph\n  if (ctx.root) ctx.root.set(root);\n  root.source = ctx.data.root.input;\n  view.pulse(\n    ctx.data.root.input,\n    view.changeset().insert(root.items)\n  );\n\n  // initialize background color\n  view._background = ctx.background || null;\n\n  // initialize event configuration\n  view._eventConfig = initializeEventConfig(ctx.eventConfig);\n\n  // initialize view size\n  view._width = view.width();\n  view._height = view.height();\n  view._viewWidth = viewWidth(view, view._width);\n  view._viewHeight = viewHeight(view, view._height);\n  view._origin = [0, 0];\n  view._resize = 0;\n  view._autosize = 1;\n  initializeResize(view);\n\n  // initialize cursor\n  cursor(view);\n}\n\nvar prototype = inherits(View, Dataflow);\n\n// -- DATAFLOW / RENDERING ----\n\nprototype.run = function(encode) {\n  // evaluate dataflow\n  Dataflow.prototype.run.call(this, encode);\n\n  if (this._pending) {\n    // resize next cycle if loading data sets\n    this.resize();\n  } else if (this._redraw || this._resize) {\n    // render as needed\n    try {\n      this.render();\n    } catch (e) {\n      this.error(e);\n    }\n  }\n\n  return this;\n};\n\nprototype.render = function() {\n  if (this._renderer) {\n    if (this._resize) {\n      this._resize = 0;\n      resizeRenderer(this);\n    }\n    this._renderer.render(this._scenegraph.root);\n  }\n  this._redraw = false;\n  return this;\n};\n\nprototype.dirty = function(item) {\n  this._redraw = true;\n  this._renderer && this._renderer.dirty(item);\n};\n\n// -- GET / SET ----\n\nprototype.container = function() {\n  return this._el;\n};\n\nprototype.scenegraph = function() {\n  return this._scenegraph;\n};\n\nprototype.origin = function() {\n  return this._origin.slice();\n};\n\nfunction lookupSignal(view, name) {\n  return view._signals.hasOwnProperty(name)\n    ? view._signals[name]\n    : error('Unrecognized signal name: ' + stringValue(name));\n}\n\nprototype.signal = function(name, value, options) {\n  var op = lookupSignal(this, name);\n  return arguments.length === 1\n    ? op.value\n    : this.update(op, value, options);\n};\n\nprototype.background = function(_) {\n  if (arguments.length) {\n    this._background = _;\n    this._resize = 1;\n    return this;\n  } else {\n    return this._background;\n  }\n};\n\nprototype.width = function(_) {\n  return arguments.length ? this.signal('width', _) : this.signal('width');\n};\n\nprototype.height = function(_) {\n  return arguments.length ? this.signal('height', _) : this.signal('height');\n};\n\nprototype.padding = function(_) {\n  return arguments.length ? this.signal('padding', _) : this.signal('padding');\n};\n\nprototype.autosize = function(_) {\n  return arguments.length ? this.signal('autosize', _) : this.signal('autosize');\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderType;\n  if (!renderModule(type)) error('Unrecognized renderer type: ' + type);\n  if (type !== this._renderType) {\n    this._renderType = type;\n    this._resetRenderer();\n  }\n  return this;\n};\n\nprototype.tooltip = function(handler) {\n  if (!arguments.length) return this._tooltip;\n  if (handler !== this._tooltip) {\n    this._tooltip = handler;\n    this._resetRenderer();\n  }\n  return this;\n};\n\nprototype.loader = function(loader) {\n  if (!arguments.length) return this._loader;\n  if (loader !== this._loader) {\n    Dataflow.prototype.loader.call(this, loader);\n    this._resetRenderer();\n  }\n  return this;\n};\n\nprototype.resize = function() {\n  // set flag to perform autosize\n  this._autosize = 1;\n  // touch autosize signal to ensure top-level ViewLayout runs\n  return this.touch(lookupSignal(this, 'autosize'));\n};\n\nprototype._resetRenderer = function() {\n  if (this._renderer) {\n    this._renderer = null;\n    this.initialize(this._el);\n  }\n};\n\n// -- SIZING ----\nprototype._resizeView = resizeView;\n\n// -- EVENT HANDLING ----\n\nprototype.addEventListener = function(type, handler, options) {\n  var callback = handler;\n  if (!(options && options.trap === false)) {\n    // wrap callback in error handler\n    callback = trap(this, handler);\n    callback.raw = handler;\n  }\n  this._handler.on(type, callback);\n  return this;\n};\n\nprototype.removeEventListener = function(type, handler) {\n  var handlers = this._handler.handlers(type),\n      i = handlers.length, h, t;\n\n  // search registered handlers, remove if match found\n  while (--i >= 0) {\n    t = handlers[i].type;\n    h = handlers[i].handler;\n    if (type === t && (handler === h || handler === h.raw)) {\n      this._handler.off(t, h);\n      break;\n    }\n  }\n  return this;\n};\n\nprototype.addResizeListener = function(handler) {\n  var l = this._resizeListeners;\n  if (l.indexOf(handler) < 0) {\n    // add handler if it isn't already registered\n    // note: error trapping handled elsewhere, so\n    // no need to wrap handlers here\n    l.push(handler);\n  }\n  return this;\n};\n\nprototype.removeResizeListener = function(handler) {\n  var l = this._resizeListeners,\n      i = l.indexOf(handler);\n  if (i >= 0) {\n    l.splice(i, 1);\n  }\n  return this;\n};\n\nfunction findOperatorHandler(op, handler) {\n  var t = op._targets || [],\n      h = t.filter(function(op) {\n            var u = op._update;\n            return u && u.handler === handler;\n          });\n  return h.length ? h[0] : null;\n}\n\nfunction addOperatorListener(view, name, op, handler) {\n  var h = findOperatorHandler(op, handler);\n  if (!h) {\n    h = trap(this, function() { handler(name, op.value); });\n    h.handler = handler;\n    view.on(op, null, h);\n  }\n  return view;\n}\n\nfunction removeOperatorListener(view, op, handler) {\n  var h = findOperatorHandler(op, handler);\n  if (h) op._targets.remove(h);\n  return view;\n}\n\nprototype.addSignalListener = function(name, handler) {\n  return addOperatorListener(this, name, lookupSignal(this, name), handler);\n};\n\nprototype.removeSignalListener = function(name, handler) {\n  return removeOperatorListener(this, lookupSignal(this, name), handler);\n};\n\nprototype.addDataListener = function(name, handler) {\n  return addOperatorListener(this, name, dataref(this, name).values, handler);\n};\n\nprototype.removeDataListener = function(name, handler) {\n  return removeOperatorListener(this, dataref(this, name).values, handler);\n};\n\nprototype.preventDefault = function(_) {\n  if (arguments.length) {\n    this._preventDefault = _;\n    return this;\n  } else {\n    return this._preventDefault;\n  }\n};\n\nprototype.timer = timer;\nprototype.events = events;\nprototype.finalize = finalize;\nprototype.hover = hover;\n\n// -- DATA ----\nprototype.data = data;\nprototype.change = change;\nprototype.insert = insert;\nprototype.remove = remove;\n\n// -- SCALES --\nprototype.scale = scale;\n\n// -- INITIALIZATION ----\nprototype.initialize = initialize;\n\n// -- HEADLESS RENDERING ----\nprototype.toImageURL = renderToImageURL;\nprototype.toCanvas = renderToCanvas;\nprototype.toSVG = renderToSVG;\n\n// -- SAVE / RESTORE STATE ----\nprototype.getState = getState;\nprototype.setState = setState;\n","import element from './element';\nimport {debounce} from 'vega-util';\nimport {tickStep} from 'd3-array';\n\nvar BindClass = 'vega-bind',\n    NameClass = 'vega-bind-name',\n    RadioClass = 'vega-bind-radio',\n    OptionClass = 'vega-option-';\n\n/**\n * Bind a signal to an external HTML input element. The resulting two-way\n * binding will propagate input changes to signals, and propagate signal\n * changes to the input element state. If this view instance has no parent\n * element, we assume the view is headless and no bindings are created.\n * @param {Element|string} el - The parent DOM element to which the input\n *   element should be appended as a child. If string-valued, this argument\n *   will be treated as a CSS selector. If null or undefined, the parent\n *   element of this view will be used as the element.\n * @param {object} param - The binding parameters which specify the signal\n *   to bind to, the input element type, and type-specific configuration.\n * @return {View} - This view instance.\n */\nexport default function(view, el, binding) {\n  if (!el) return;\n\n  var param = binding.param,\n      bind = binding.state;\n\n  if (!bind) {\n    bind = binding.state = {\n      elements: null,\n      active: false,\n      set: null,\n      update: function(value) {\n        if (value !== view.signal(param.signal)) {\n          bind.source = true;\n          view.signal(param.signal, value).run();\n        }\n      }\n    };\n    if (param.debounce) {\n      bind.update = debounce(param.debounce, bind.update);\n    }\n  }\n\n  generate(bind, el, param, view.signal(param.signal));\n\n  if (!bind.active) {\n    view.on(view._signals[param.signal], null, function() {\n      bind.source\n        ? (bind.source = false)\n        : bind.set(view.signal(param.signal));\n    });\n    bind.active = true;\n  }\n\n  return bind;\n}\n\n/**\n * Generate an HTML input form element and bind it to a signal.\n */\nfunction generate(bind, el, param, value) {\n  var div = element('div', {'class': BindClass});\n\n  div.appendChild(element('span',\n    {'class': NameClass},\n    (param.name || param.signal)\n  ));\n\n  el.appendChild(div);\n\n  var input = form;\n  switch (param.input) {\n    case 'checkbox': input = checkbox; break;\n    case 'select':   input = select; break;\n    case 'radio':    input = radio; break;\n    case 'range':    input = range; break;\n  }\n\n  input(bind, div, param, value);\n}\n\n/**\n * Generates an arbitrary input form element.\n * The input type is controlled via user-provided parameters.\n */\nfunction form(bind, el, param, value) {\n  var node = element('input');\n\n  for (var key in param) {\n    if (key !== 'signal' && key !== 'element') {\n      node.setAttribute(key === 'input' ? 'type' : key, param[key]);\n    }\n  }\n  node.setAttribute('name', param.signal);\n  node.value = value;\n\n  el.appendChild(node);\n\n  node.addEventListener('input', function() {\n    bind.update(node.value);\n  });\n\n  bind.elements = [node];\n  bind.set = function(value) { node.value = value; };\n}\n\n/**\n * Generates a checkbox input element.\n */\nfunction checkbox(bind, el, param, value) {\n  var attr = {type: 'checkbox', name: param.signal};\n  if (value) attr.checked = true;\n  var node = element('input', attr);\n\n  el.appendChild(node);\n\n  node.addEventListener('change', function() {\n    bind.update(node.checked);\n  });\n\n  bind.elements = [node];\n  bind.set = function(value) { node.checked = !!value || null; }\n}\n\n/**\n * Generates a selection list input element.\n */\nfunction select(bind, el, param, value) {\n  var node = element('select', {name: param.signal});\n\n  param.options.forEach(function(option) {\n    var attr = {value: option};\n    if (valuesEqual(option, value)) attr.selected = true;\n    node.appendChild(element('option', attr, option+''));\n  });\n\n  el.appendChild(node);\n\n  node.addEventListener('change', function() {\n    bind.update(param.options[node.selectedIndex]);\n  });\n\n  bind.elements = [node];\n  bind.set = function(value) {\n    for (var i=0, n=param.options.length; i<n; ++i) {\n      if (valuesEqual(param.options[i], value)) {\n        node.selectedIndex = i; return;\n      }\n    }\n  };\n}\n\n/**\n * Generates a radio button group.\n */\nfunction radio(bind, el, param, value) {\n  var group = element('span', {'class': RadioClass});\n\n  el.appendChild(group);\n\n  bind.elements = param.options.map(function(option) {\n    var id = OptionClass + param.signal + '-' + option;\n\n    var attr = {\n      id:    id,\n      type:  'radio',\n      name:  param.signal,\n      value: option\n    };\n    if (valuesEqual(option, value)) attr.checked = true;\n\n    var input = element('input', attr);\n\n    input.addEventListener('change', function() {\n      bind.update(option);\n    });\n\n    group.appendChild(input);\n    group.appendChild(element('label', {'for': id}, option+''));\n\n    return input;\n  });\n\n  bind.set = function(value) {\n    var nodes = bind.elements,\n        i = 0,\n        n = nodes.length;\n    for (; i<n; ++i) {\n      if (valuesEqual(nodes[i].value, value)) nodes[i].checked = true;\n    }\n  };\n}\n\n/**\n * Generates a slider input element.\n */\nfunction range(bind, el, param, value) {\n  value = value !== undefined ? value : ((+param.max) + (+param.min)) / 2;\n\n  var min = param.min || Math.min(0, +value) || 0,\n      max = param.max || Math.max(100, +value) || 100,\n      step = param.step || tickStep(min, max, 100);\n\n  var node = element('input', {\n    type:  'range',\n    name:  param.signal,\n    min:   min,\n    max:   max,\n    step:  step\n  });\n  node.value = value;\n\n  var label = element('label', {}, +value);\n\n  el.appendChild(node);\n  el.appendChild(label);\n\n  function update() {\n    label.textContent = node.value;\n    bind.update(+node.value);\n  }\n\n  // subscribe to both input and change\n  node.addEventListener('input', update);\n  node.addEventListener('change', update);\n\n  bind.elements = [node];\n  bind.set = function(value) {\n    node.value = value;\n    label.textContent = value;\n  };\n}\n\nfunction valuesEqual(a, b) {\n  return a === b || (a+'' === b+'');\n}\n","import {isString} from 'vega-util';\n\nvar Default = 'default';\n\nexport default function(view) {\n  var cursor = view._signals.cursor;\n\n  // add cursor signal to dataflow, if needed\n  if (!cursor) {\n    view._signals.cursor = (cursor = view.add({user: Default, item: null}));\n  }\n\n  // evaluate cursor on each mousemove event\n  view.on(view.events('view', 'mousemove'), cursor,\n    function(_, event) {\n      var value = cursor.value,\n          user = value ? (isString(value) ? value : value.user) : Default,\n          item = event.item && event.item.cursor || null;\n\n      return (value && user === value.user && item == value.item) ? value\n        : {user: user, item: item};\n    }\n  );\n\n  // when cursor signal updates, set visible cursor\n  view.add(null, function(_) {\n    var user = _.cursor,\n        item = this.value;\n\n    if (!isString(user)) {\n      item = user.item;\n      user = user.user;\n    }\n\n    setCursor(user && user !== Default ? user : (item || user));\n\n    return item;\n  }, {cursor: cursor});\n}\n\nfunction setCursor(cursor) {\n  // set cursor on document body\n  // this ensures cursor applies even if dragging out of view\n  if (typeof document !== 'undefined' && document.body) {\n    document.body.style.cursor = cursor;\n  }\n}\n","import {changeset, isChangeSet} from 'vega-dataflow';\nimport {error} from 'vega-util';\n\nexport function dataref(view, name) {\n  var data = view._runtime.data;\n  if (!data.hasOwnProperty(name)) {\n    error('Unrecognized data set: ' + name);\n  }\n  return data[name];\n}\n\nexport function data(name) {\n  return dataref(this, name).values.value;\n}\n\nexport function change(name, changes) {\n  if (!isChangeSet(changes)) {\n    error('Second argument to changes must be a changeset.');\n  }\n  var dataset = dataref(this, name);\n  dataset.modified = true;\n  return this.pulse(dataset.input, changes);\n}\n\nexport function insert(name, _) {\n  return change.call(this, name, changeset().insert(_));\n}\n\nexport function remove(name, _) {\n  return change.call(this, name, changeset().remove(_));\n}\n","export default function(tag, attr, text) {\n  var el = document.createElement(tag);\n  for (var key in attr) el.setAttribute(key, attr[key]);\n  if (text != null) el.textContent = text;\n  return el;\n}\n","import {offset} from './render-size';\nimport {constant, isString} from 'vega-util';\nimport {point} from 'vega-scenegraph';\n\n/**\n * Extend an event with additional view-specific methods.\n * Adds a new property ('vega') to an event that provides a number\n * of methods for querying information about the current interaction.\n * The vega object provides the following methods:\n *   view - Returns the backing View instance.\n *   item - Returns the currently active scenegraph item (if any).\n *   group - Returns the currently active scenegraph group (if any).\n *     This method accepts a single string-typed argument indicating the name\n *     of the desired parent group. The scenegraph will be traversed from\n *     the item up towards the root to search for a matching group. If no\n *     argument is provided the enclosing group for the active item is\n *     returned, unless the item it itself a group, in which case it is\n *     returned directly.\n *   xy - Returns a two-element array containing the x and y coordinates for\n *     mouse or touch events. For touch events, this is based on the first\n *     elements in the changedTouches array. This method accepts a single\n *     argument: either an item instance or mark name that should serve as\n *     the reference coordinate system. If no argument is provided the\n *     top-level view coordinate system is assumed.\n *   x - Returns the current x-coordinate, accepts the same arguments as xy.\n *   y - Returns the current y-coordinate, accepts the same arguments as xy.\n * @param {Event} event - The input event to extend.\n * @param {Item} item - The currently active scenegraph item (if any).\n * @return {Event} - The extended input event.\n */\nexport default function(view, event, item) {\n  var el = view._renderer.canvas(),\n      p, e, translate;\n\n  if (el) {\n    translate = offset(view);\n    e = event.changedTouches ? event.changedTouches[0] : event;\n    p = point(e, el);\n    p[0] -= translate[0];\n    p[1] -= translate[1];\n  }\n\n  event.dataflow = view;\n  event.vega = extension(view, item, p);\n  event.item = item;\n  return event;\n}\n\nfunction extension(view, item, point) {\n  var itemGroup = item\n    ? item.mark.marktype === 'group' ? item : item.mark.group\n    : null;\n\n  function group(name) {\n    var g = itemGroup, i;\n    if (name) for (i = item; i; i = i.mark.group) {\n      if (i.mark.name === name) { g = i; break; }\n    }\n    return g && g.mark && g.mark.interactive ? g : {};\n  }\n\n  function xy(item) {\n    if (!item) return point;\n    if (isString(item)) item = group(item);\n\n    var p = point.slice();\n    while (item) {\n      p[0] -= item.x || 0;\n      p[1] -= item.y || 0;\n      item = item.mark && item.mark.group;\n    }\n    return p;\n  }\n\n  return {\n    view:  constant(view),\n    item:  constant(item || {}),\n    group: group,\n    xy:    xy,\n    x:     function(item) { return xy(item)[0]; },\n    y:     function(item) { return xy(item)[1]; }\n  };\n}\n","import eventExtend from './events-extend';\nimport {EventStream} from 'vega-dataflow';\nimport {extend, isArray, toSet} from 'vega-util';\n\nvar VIEW = 'view',\n    TIMER = 'timer',\n    WINDOW = 'window',\n    NO_TRAP = {trap: false};\n\n/**\n * Initialize event handling configuration.\n * @param {object} config - The configuration settings.\n * @return {object}\n */\nexport function initializeEventConfig(config) {\n  config = extend({}, config);\n\n  var def = config.defaults;\n  if (def) {\n    if (isArray(def.prevent)) {\n      def.prevent = toSet(def.prevent);\n    }\n    if (isArray(def.allow)) {\n      def.allow = toSet(def.allow);\n    }\n  }\n\n  return config;\n}\n\nfunction prevent(view, type) {\n  var def = view._eventConfig.defaults,\n      prevent = def && def.prevent,\n      allow = def && def.allow;\n\n  return prevent === false || allow === true ? false\n    : prevent === true || allow === false ? true\n    : prevent ? prevent[type]\n    : allow ? !allow[type]\n    : view.preventDefault();\n}\n\n/**\n * Create a new event stream from an event source.\n * @param {object} source - The event source to monitor.\n * @param {string} type - The event type.\n * @param {function(object): boolean} [filter] - Event filter function.\n * @return {EventStream}\n */\nexport function events(source, type, filter) {\n  var view = this,\n      s = new EventStream(filter),\n      send = function(e, item) {\n        if (source === VIEW && prevent(view, type)) {\n          e.preventDefault();\n        }\n        try {\n          s.receive(eventExtend(view, e, item));\n        } catch (error) {\n          view.error(error);\n        } finally {\n          view.run();\n        }\n      },\n      sources;\n\n  if (source === TIMER) {\n    view.timer(send, type);\n  }\n\n  else if (source === VIEW) {\n    // send traps errors, so use {trap: false} option\n    view.addEventListener(type, send, NO_TRAP);\n  }\n\n  else {\n    if (source === WINDOW) {\n      if (typeof window !== 'undefined') sources = [window];\n    } else if (typeof document !== 'undefined') {\n      sources = document.querySelectorAll(source);\n    }\n\n    if (!sources) {\n      view.warn('Can not resolve event source: ' + source);\n    } else {\n      for (var i=0, n=sources.length; i<n; ++i) {\n        sources[i].addEventListener(type, send);\n      }\n\n      view._eventListeners.push({\n        type:    type,\n        sources: sources,\n        handler: send\n      });\n    }\n  }\n\n  return s;\n}\n","/**\n * Finalize a View instance that is being removed.\n * Cancel any running timers.\n * Remove all external event listeners.\n * Remove any currently displayed tooltip.\n */\nexport default function() {\n  var tooltip = this._tooltip,\n      timers = this._timers,\n      listeners = this._eventListeners,\n      n, m, e;\n\n  n = timers.length;\n  while (--n >= 0) {\n    timers[n].stop();\n  }\n\n  n = listeners.length;\n  while (--n >= 0) {\n    e = listeners[n];\n    m = e.sources.length;\n    while (--m >= 0) {\n      e.sources[m].removeEventListener(e.type, e.handler);\n    }\n  }\n\n  if (tooltip) {\n    tooltip.call(this, this._handler, null, null, null);\n  }\n\n  return this;\n}\n","function itemFilter(event) {\n  return event.item;\n}\n\nfunction markTarget(event) {\n  // grab upstream collector feeding the mark operator\n  var source = event.item.mark.source;\n  return source.source || source;\n}\n\nfunction invoke(name) {\n  return function(_, event) {\n    return event.vega.view()\n      .changeset()\n      .encode(event.item, name);\n  };\n}\n\nexport default function(hoverSet, leaveSet) {\n  hoverSet = [hoverSet || 'hover'];\n  leaveSet = [leaveSet || 'update', hoverSet[0]];\n\n  // invoke hover set upon mouseover\n  this.on(\n    this.events('view', 'mouseover', itemFilter),\n    markTarget,\n    invoke(hoverSet)\n  );\n\n  // invoke leave set upon mouseout\n  this.on(\n    this.events('view', 'mouseout', itemFilter),\n    markTarget,\n    invoke(leaveSet)\n  );\n\n  return this;\n}\n","import {offset} from './render-size';\nimport trap from './trap';\n\nexport default function(view, prevHandler, el, constructor) {\n  // instantiate scenegraph handler\n  var handler = new constructor(view.loader(), trap(view, view.tooltip()))\n    .scene(view.scenegraph().root)\n    .initialize(el, offset(view), view);\n\n  // transfer event handlers\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      handler.on(h.type, h.handler);\n    });\n  }\n\n  return handler;\n}\n","import {width, height, offset} from './render-size';\n\nexport default function(view, r, el, constructor, scaleFactor) {\n  r = r || new constructor(view.loader());\n  return r\n    .initialize(el, width(view), height(view), offset(view), scaleFactor)\n    .background(view._background);\n}\n","import bind from './bind';\nimport element from './element';\nimport initializeRenderer from './initialize-renderer';\nimport initializeHandler from './initialize-handler';\nimport {CanvasHandler, renderModule} from 'vega-scenegraph';\n\nexport default function(el, elBind) {\n  var view = this,\n      type = view._renderType,\n      module = renderModule(type),\n      Handler, Renderer;\n\n  // containing dom element\n  el = view._el = el ? lookup(view, el) : null;\n\n  // select appropriate renderer & handler\n  if (!module) view.error('Unrecognized renderer type: ' + type);\n  Handler = module.handler || CanvasHandler;\n  Renderer = (el ? module.renderer : module.headless);\n\n  // initialize renderer and input handler\n  view._renderer = !Renderer ? null\n    : initializeRenderer(view, view._renderer, el, Renderer);\n  view._handler = initializeHandler(view, view._handler, el, Handler);\n  view._redraw = true;\n\n  // initialize signal bindings\n  if (el) {\n    elBind = elBind ? lookup(view, elBind)\n      : el.appendChild(element('div', {'class': 'vega-bindings'}));\n\n    view._bind.forEach(function(_) {\n      if (_.param.element) {\n        _.element = lookup(view, _.param.element);\n      }\n    });\n\n    view._bind.forEach(function(_) {\n      bind(view, _.element || elBind, _);\n    });\n  }\n\n  return view;\n}\n\nfunction lookup(view, el) {\n  if (typeof el === 'string') {\n    if (typeof document !== 'undefined') {\n      el = document.querySelector(el);\n      if (!el) {\n        view.error('Signal bind element not found: ' + el);\n        return null;\n      }\n    } else {\n      view.error('DOM document instance not found.');\n      return null;\n    }\n  }\n  if (el) {\n    try {\n      el.innerHTML = '';\n    } catch (e) {\n      el = null;\n      view.error(e);\n    }\n  }\n  return el;\n}\n","import initializeRenderer from './initialize-renderer';\nimport {renderModule} from 'vega-scenegraph';\n\n/**\n * Render the current scene in a headless fashion.\n * This method is asynchronous, returning a Promise instance.\n * @return {Promise} - A Promise that resolves to a renderer.\n */\nexport default function(view, type, scaleFactor) {\n  var module = renderModule(type),\n      ctr = module && module.headless;\n  return !ctr\n    ? Promise.reject('Unrecognized renderer type: ' + type)\n    : view.runAsync().then(function() {\n        return initializeRenderer(view, null, null, ctr, scaleFactor)\n          .renderAsync(view._scenegraph.root);\n      });\n}\n","export function width(view) {\n  var padding = view.padding();\n  return Math.max(0, view._viewWidth + padding.left + padding.right);\n}\n\nexport function height(view) {\n  var padding = view.padding();\n  return Math.max(0, view._viewHeight + padding.top + padding.bottom);\n}\n\nexport function offset(view) {\n  var padding = view.padding(),\n      origin = view._origin;\n  return [\n    padding.left + origin[0],\n    padding.top + origin[1]\n  ];\n}\n\nexport function resizeRenderer(view) {\n  var origin = offset(view),\n      w = width(view),\n      h = height(view);\n\n  view._renderer.background(view._background);\n  view._renderer.resize(w, h, origin);\n  view._handler.origin(origin);\n\n  view._resizeListeners.forEach(function(handler) {\n    try {\n      handler(w, h);\n    } catch (error) {\n      view.error(error);\n    }\n  });\n}\n","import renderHeadless from './render-headless';\nimport {RenderType} from 'vega-scenegraph';\n\n/**\n * Produce a Canvas instance containing a rendered visualization.\n * This method is asynchronous, returning a Promise instance.\n * @return {Promise} - A promise that resolves to a Canvas instance.\n */\nexport default function(scaleFactor) {\n  return renderHeadless(this, RenderType.Canvas, scaleFactor)\n    .then(function(renderer) { return renderer.canvas(); });\n}\n","import renderHeadless from './render-headless';\nimport {RenderType as Type} from 'vega-scenegraph';\n\n/**\n * Produce an image URL for the visualization. Depending on the type\n * parameter, the generated URL contains data for either a PNG or SVG image.\n * The URL can be used (for example) to download images of the visualization.\n * This method is asynchronous, returning a Promise instance.\n * @param {string} type - The image type. One of 'svg', 'png' or 'canvas'.\n *   The 'canvas' and 'png' types are synonyms for a PNG image.\n * @return {Promise} - A promise that resolves to an image URL.\n */\nexport default function(type, scaleFactor) {\n  return (type !== Type.Canvas && type !== Type.SVG && type !== Type.PNG)\n    ? Promise.reject('Unrecognized image type: ' + type)\n    : renderHeadless(this, type, scaleFactor).then(function(renderer) {\n        return type === Type.SVG\n          ? toBlobURL(renderer.svg(), 'image/svg+xml')\n          : renderer.canvas().toDataURL('image/png');\n      });\n}\n\nfunction toBlobURL(data, mime) {\n  var blob = new Blob([data], {type: mime});\n  return window.URL.createObjectURL(blob);\n}\n","import renderHeadless from './render-headless';\nimport {RenderType} from 'vega-scenegraph';\n\n/**\n * Produce a rendered SVG string of the visualization.\n * This method is asynchronous, returning a Promise instance.\n * @return {Promise} - A promise that resolves to an SVG string.\n */\nexport default function(scaleFactor) {\n  return renderHeadless(this, RenderType.SVG, scaleFactor)\n    .then(function(renderer) { return renderer.svg(); });\n}\n","import {transforms} from 'vega-dataflow';\nimport {functionContext} from 'vega-parser';\nimport {parse, context} from 'vega-runtime';\n\nexport default function(view, spec, functions) {\n  var fn = functions || functionContext;\n  return parse(spec, context(view, transforms, fn));\n}\n","import {error} from 'vega-util';\n\nexport function scale(name) {\n  var scales = this._runtime.scales;\n  if (!scales.hasOwnProperty(name)) {\n    error('Unrecognized scale or projection: ' + name);\n  }\n  return scales[name].value;\n}\n","var Width = 'width',\n    Height = 'height',\n    Padding = 'padding',\n    Skip = {skip: true};\n\nexport function viewWidth(view, width) {\n  var a = view.autosize(),\n      p = view.padding();\n  return width - (a && a.contains === Padding ? p.left + p.right : 0);\n}\n\nexport function viewHeight(view, height) {\n  var a = view.autosize(),\n      p = view.padding();\n  return height - (a && a.contains === Padding ? p.top + p.bottom : 0);\n}\n\nexport function initializeResize(view) {\n  var s = view._signals,\n      w = s[Width],\n      h = s[Height],\n      p = s[Padding];\n\n  function resetSize() {\n    view._autosize = view._resize = 1;\n  }\n\n  // respond to width signal\n  view._resizeWidth = view.add(null,\n    function(_) {\n      view._width = _.size;\n      view._viewWidth = viewWidth(view, _.size);\n      resetSize();\n    },\n    {size: w}\n  );\n\n  // respond to height signal\n  view._resizeHeight = view.add(null,\n    function(_) {\n      view._height = _.size;\n      view._viewHeight = viewHeight(view, _.size);\n      resetSize();\n    },\n    {size: h}\n  );\n\n  // respond to padding signal\n  var resizePadding = view.add(null, resetSize, {pad: p});\n\n  // set rank to run immediately after source signal\n  view._resizeWidth.rank = w.rank + 1;\n  view._resizeHeight.rank = h.rank + 1;\n  resizePadding.rank = p.rank + 1;\n}\n\nexport function resizeView(viewWidth, viewHeight, width, height, origin, auto) {\n  this.runAfter(function(view) {\n    var rerun = 0;\n\n    // reset autosize flag\n    view._autosize = 0;\n\n    // width value changed: update signal, skip resize op\n    if (view.width() !== width) {\n      rerun = 1;\n      view.signal(Width, width, Skip); // set width, skip update calc\n      view._resizeWidth.skip(true); // skip width resize handler\n    }\n\n    // height value changed: update signal, skip resize op\n    if (view.height() !== height) {\n      rerun = 1;\n      view.signal(Height, height, Skip); // set height, skip update calc\n      view._resizeHeight.skip(true); // skip height resize handler\n    }\n\n    // view width changed: update view property, set resize flag\n    if (view._viewWidth !== viewWidth) {\n      view._resize = 1;\n      view._viewWidth = viewWidth;\n    }\n\n    // view height changed: update view property, set resize flag\n    if (view._viewHeight !== viewHeight) {\n      view._resize = 1;\n      view._viewHeight = viewHeight;\n    }\n\n    // origin changed: update view property, set resize flag\n    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {\n      view._resize = 1;\n      view._origin = origin;\n    }\n\n    // run dataflow on width/height signal change\n    if (rerun) view.run('enter');\n    if (auto) view.runAfter(function() { view.resize(); });\n  }, false, 1);\n}\n","import {transforms} from 'vega-dataflow';\nimport {isArray} from 'vega-util';\n\n/**\n * Get the current view state, consisting of signal values and/or data sets.\n * @param {object} [options] - Options flags indicating which state to export.\n *   If unspecified, all signals and data sets will be exported.\n * @param {function(string, Operator):boolean} [options.signals] - Optional\n *   predicate function for testing if a signal should be included in the\n *   exported state. If unspecified, all signals will be included, except for\n *   those named 'parent' or those which refer to a Transform value.\n * @param {function(string, object):boolean} [options.data] - Optional\n *   predicate function for testing if a data set's input should be included\n *   in the exported state. If unspecified, all data sets that have been\n *   explicitly modified will be included.\n * @param {boolean} [options.recurse=true] - Flag indicating if the exported\n *   state should recursively include state from group mark sub-contexts.\n * @return {object} - An object containing the exported state values.\n */\nexport function getState(options) {\n  return this._runtime.getState(options || {\n    data:    dataTest,\n    signals: signalTest,\n    recurse: true\n  });\n}\n\nfunction dataTest(name, data) {\n  return data.modified\n      && isArray(data.input.value)\n      && name.indexOf('_:vega:_');\n}\n\nfunction signalTest(name, op) {\n  return !(name === 'parent' || op instanceof transforms.proxy);\n}\n\n/**\n * Sets the current view state and updates the view by invoking run.\n * @param {object} state - A state object containing signal and/or\n *   data set values, following the format used by the getState method.\n * @return {View} - This view instance.\n */\nexport function setState(state) {\n  var view = this;\n  view.runAfter(function() {\n    view._trigger = false;\n    view._runtime.setState(state);\n    view.run().runAfter(function() { view._trigger = true; });\n  });\n  return this;\n}\n","import {interval} from 'd3-timer';\n\nexport default function(callback, delay) {\n  function tick(elapsed) {\n    callback({timestamp: Date.now(), elapsed: elapsed});\n  }\n  this._timers.push(interval(tick, delay));\n}\n","import {isArray, isDate, isObject} from 'vega-util';\n\nexport default function(handler, event, item, value) {\n  var el = handler.element();\n  if (el) el.setAttribute('title', formatTooltip(value));\n}\n\nfunction formatTooltip(value) {\n  return value == null ? ''\n    : isArray(value) ? formatArray(value)\n    : isObject(value) && !isDate(value) ? formatObject(value)\n    : value + '';\n}\n\nfunction formatObject(obj) {\n  return Object.keys(obj).map(function(key) {\n    var v = obj[key];\n    return key + ': ' + (isArray(v) ? formatArray(v) : formatValue(v));\n  }).join('\\n');\n}\n\nfunction formatArray(value) {\n  return '[' + value.map(formatValue).join(', ') + ']';\n}\n\nfunction formatValue(value) {\n  return isArray(value) ? '[\\u2026]'\n    : isObject(value) && !isDate(value) ? '{\\u2026}'\n    : value;\n}\n","export default function(view, fn) {\n  return !fn ? null : function() {\n    try {\n      fn.apply(this, arguments);\n    } catch (error) {\n      view.error(error);\n    }\n  };\n}\n","export {default as voronoi} from './src/Voronoi';\n","import {Transform} from 'vega-dataflow';\nimport {inherits} from 'vega-util';\nimport {voronoi} from 'd3-voronoi';\n\nexport default function Voronoi(params) {\n  Transform.call(this, null, params);\n}\n\nVoronoi.Definition = {\n  \"type\": \"Voronoi\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"x\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"y\", \"type\": \"field\", \"required\": true },\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"extent\", \"type\": \"array\", \"array\": true, \"length\": 2,\n      \"default\": [[-1e5, -1e5], [1e5, 1e5]],\n      \"content\": {\"type\": \"number\", \"array\": true, \"length\": 2} },\n    { \"name\": \"as\", \"type\": \"string\", \"default\": \"path\" }\n  ]\n};\n\nvar prototype = inherits(Voronoi, Transform);\n\nvar defaultExtent = [[-1e5, -1e5], [1e5, 1e5]];\n\nprototype.transform = function(_, pulse) {\n  var as = _.as || 'path',\n      data = pulse.source,\n      diagram, polygons, i, n;\n\n  // configure and construct voronoi diagram\n  diagram = voronoi().x(_.x).y(_.y);\n  if (_.size) diagram.size(_.size);\n  else diagram.extent(_.extent || defaultExtent);\n\n  this.value = (diagram = diagram(data));\n\n  // map polygons to paths\n  polygons = diagram.polygons();\n  for (i=0, n=data.length; i<n; ++i) {\n    data[i][as] = polygons[i]\n      ? 'M' + polygons[i].join('L') + 'Z'\n      : null;\n  }\n\n  return pulse.reflow(_.modified()).modifies(as);\n};\n","export {default as wordcloud} from './src/Wordcloud';\n","import {canvas} from 'vega-canvas';\n\n/*\nCopyright (c) 2013, Jason Davies.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n  * The name Jason Davies may not be used to endorse or promote products\n    derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\nOR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\nADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\n\nvar cloudRadians = Math.PI / 180,\n    cw = 1 << 11 >> 5,\n    ch = 1 << 11;\n\nexport default function() {\n  var size = [256, 256],\n      text,\n      font,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      rotate,\n      padding,\n      spiral = archimedeanSpiral,\n      words = [],\n      random = Math.random,\n      cloud = {};\n\n  cloud.layout = function() {\n    var contextAndRatio = getContext(canvas()),\n        board = zeroArray((size[0] >> 5) * size[1]),\n        bounds = null,\n        n = words.length,\n        i = -1,\n        tags = [],\n        data = words.map(function(d) {\n          return {\n            text: text(d),\n            font: font(d),\n            style: fontStyle(d),\n            weight: fontWeight(d),\n            rotate: rotate(d),\n            size: ~~fontSize(d),\n            padding: padding(d),\n            xoff: 0,\n            yoff: 0,\n            x1: 0,\n            y1: 0,\n            x0: 0,\n            y0: 0,\n            hasText: false,\n            sprite: null,\n            datum: d\n          };\n        }).sort(function(a, b) { return b.size - a.size; });\n\n    while (++i < n) {\n      var d = data[i];\n      d.x = (size[0] * (random() + .5)) >> 1;\n      d.y = (size[1] * (random() + .5)) >> 1;\n      cloudSprite(contextAndRatio, d, data, i);\n      if (d.hasText && place(board, d, bounds)) {\n        tags.push(d);\n        if (bounds) cloudBounds(bounds, d);\n        else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];\n        // Temporary hack\n        d.x -= size[0] >> 1;\n        d.y -= size[1] >> 1;\n      }\n    }\n\n    return tags;\n  };\n\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    var ratio = Math.sqrt(canvas.getContext(\"2d\").getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n\n    var context = canvas.getContext(\"2d\");\n    context.fillStyle = context.strokeStyle = \"red\";\n    context.textAlign = \"center\";\n\n    return {context: context, ratio: ratio};\n  }\n\n  function place(board, tag, bounds) {\n    var startX = tag.x,\n        startY = tag.y,\n        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n        s = spiral(size),\n        dt = random() < .5 ? 1 : -1,\n        t = -dt,\n        dxdy,\n        dx,\n        dy;\n\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||\n          tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\n      // TODO only check for collisions within current bounds.\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          var sprite = tag.sprite,\n              w = tag.width >> 5,\n              sw = size[0] >> 5,\n              lx = tag.x - (w << 4),\n              sx = lx & 0x7f,\n              msx = 32 - sx,\n              h = tag.y1 - tag.y0,\n              x = (tag.y + tag.y0) * sw + (lx >> 5),\n              last;\n          for (var j = 0; j < h; j++) {\n            last = 0;\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n            x += sw;\n          }\n          tag.sprite = null;\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  cloud.words = function(_) {\n    if (arguments.length) {\n      words = _;\n      return cloud;\n    } else {\n      return words;\n    }\n  };\n\n  cloud.size = function(_) {\n    if (arguments.length) {\n      size = [+_[0], +_[1]];\n      return cloud;\n    } else {\n      return size;\n    }\n  };\n\n  cloud.font = function(_) {\n    if (arguments.length) {\n      font = functor(_);\n      return cloud;\n    } else {\n      return font;\n    }\n  };\n\n  cloud.fontStyle = function(_) {\n    if (arguments.length) {\n      fontStyle = functor(_);\n      return cloud;\n    } else {\n      return fontStyle;\n    }\n  };\n\n  cloud.fontWeight = function(_) {\n    if (arguments.length) {\n      fontWeight = functor(_);\n      return cloud;\n    } else {\n      return fontWeight;\n    }\n  };\n\n  cloud.rotate = function(_) {\n    if (arguments.length) {\n      rotate = functor(_);\n      return cloud;\n    } else {\n      return rotate;\n    }\n  };\n\n  cloud.text = function(_) {\n    if (arguments.length) {\n      text = functor(_);\n      return cloud;\n    } else {\n      return text;\n    }\n  };\n\n  cloud.spiral = function(_) {\n    if (arguments.length) {\n      spiral = spirals[_] || _;\n      return cloud;\n    } else {\n      return spiral;\n    }\n  };\n\n  cloud.fontSize = function(_) {\n    if (arguments.length) {\n      fontSize = functor(_);\n      return cloud;\n    } else {\n      return fontSize;\n    }\n  };\n\n  cloud.padding = function(_) {\n    if (arguments.length) {\n      padding = functor(_);\n      return cloud;\n    } else {\n      return padding;\n    }\n  };\n\n  cloud.random = function(_) {\n    if (arguments.length) {\n      random = _;\n      return cloud;\n    } else {\n      return random;\n    }\n  };\n\n  return cloud;\n}\n\n// Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n      ratio = contextAndRatio.ratio;\n\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n      y = 0,\n      maxh = 0,\n      n = data.length,\n      w, w32, h, i, j;\n  --di;\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + \" \" + d.weight + \" \" + ~~((d.size + 1) / ratio) + \"px \" + d.font;\n    w = c.measureText(d.text + \"m\").width * ratio;\n    h = d.size << 1;\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * cloudRadians),\n          cr = Math.cos(d.rotate * cloudRadians),\n          wcr = w * cr,\n          wsr = w * sr,\n          hcr = h * cr,\n          hsr = h * sr;\n      w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = (w + 0x1f) >> 5 << 5;\n    }\n    if (h > maxh) maxh = h;\n    if (x + w >= (cw << 5)) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n    if (d.padding) {\n      c.lineWidth = 2 * d.padding;\n      c.strokeText(d.text, 0, 0);\n    }\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n      sprite = [];\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    w = d.width;\n    w32 = w >> 5;\n    h = d.y1 - d.y0;\n    // Zero the buffer\n    for (i = 0; i < h * w32; i++) sprite[i] = 0;\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n        seenRow = -1;\n    for (j = 0; j < h; j++) {\n      for (i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n            m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n      if (seen) seenRow = j;\n      else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n}\n\n// Use mask-based collision detection.\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n      w = tag.width >> 5,\n      lx = tag.x - (w << 4),\n      sx = lx & 0x7f,\n      msx = 32 - sx,\n      h = tag.y1 - tag.y0,\n      x = (tag.y + tag.y0) * sw + (lx >> 5),\n      last;\n  for (var j = 0; j < h; j++) {\n    last = 0;\n    for (var i = 0; i <= w; i++) {\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))\n          & board[x + i]) return true;\n    }\n    x += sw;\n  }\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n      b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\n\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function(t) {\n    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  var dy = 4,\n      dx = dy * size[0] / size[1],\n      x = 0,\n      y = 0;\n  return function(t) {\n    var sign = t < 0 ? -1 : 1;\n    // See triangular numbers: T_n = n * (n + 1) / 2.\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\n      case 0:  x += dx; break;\n      case 1:  y += dy; break;\n      case 2:  x -= dx; break;\n      default: y -= dy; break;\n    }\n    return [x, y];\n  };\n}\n\n// TODO reuse arrays?\nfunction zeroArray(n) {\n  var a = [],\n      i = -1;\n  while (++i < n) a[i] = 0;\n  return a;\n}\n\nfunction functor(d) {\n  return typeof d === \"function\" ? d : function() { return d; };\n}\n\nvar spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\n","import cloud from './CloudLayout';\nimport {Transform} from 'vega-dataflow';\nimport {constant, inherits, isFunction} from 'vega-util';\nimport {scale} from 'vega-scale';\nimport {random} from 'vega-statistics';\n\nvar Output = ['x', 'y', 'font', 'fontSize', 'fontStyle', 'fontWeight', 'angle'];\n\nvar Params = ['text', 'font', 'rotate', 'fontSize', 'fontStyle', 'fontWeight'];\n\nexport default function Wordcloud(params) {\n  Transform.call(this, cloud(), params);\n}\n\nWordcloud.Definition = {\n  \"type\": \"Wordcloud\",\n  \"metadata\": {\"modifies\": true},\n  \"params\": [\n    { \"name\": \"size\", \"type\": \"number\", \"array\": true, \"length\": 2 },\n    { \"name\": \"font\", \"type\": \"string\", \"expr\": true, \"default\": \"sans-serif\" },\n    { \"name\": \"fontStyle\", \"type\": \"string\", \"expr\": true, \"default\": \"normal\" },\n    { \"name\": \"fontWeight\", \"type\": \"string\", \"expr\": true, \"default\": \"normal\" },\n    { \"name\": \"fontSize\", \"type\": \"number\", \"expr\": true, \"default\": 14 },\n    { \"name\": \"fontSizeRange\", \"type\": \"number\", \"array\": \"nullable\", \"default\": [10, 50] },\n    { \"name\": \"rotate\", \"type\": \"number\", \"expr\": true, \"default\": 0 },\n    { \"name\": \"text\", \"type\": \"field\" },\n    { \"name\": \"spiral\", \"type\": \"string\", \"values\": [\"archimedean\", \"rectangular\"] },\n    { \"name\": \"padding\", \"type\": \"number\", \"expr\": true },\n    { \"name\": \"as\", \"type\": \"string\", \"array\": true, \"length\": 7, \"default\": Output }\n  ]\n};\n\nvar prototype = inherits(Wordcloud, Transform);\n\nprototype.transform = function(_, pulse) {\n  function modp(param) {\n    var p = _[param];\n    return isFunction(p) && pulse.modified(p.fields);\n  }\n\n  var mod = _.modified();\n  if (!(mod || pulse.changed(pulse.ADD_REM) || Params.some(modp))) return;\n\n  var data = pulse.materialize(pulse.SOURCE).source,\n      layout = this.value,\n      as = _.as || Output,\n      fontSize = _.fontSize || 14,\n      range;\n\n  isFunction(fontSize)\n    ? (range = _.fontSizeRange)\n    : (fontSize = constant(fontSize));\n\n  // create font size scaling function as needed\n  if (range) {\n    var fsize = fontSize,\n        sizeScale = scale('sqrt')()\n          .domain(extent(fsize, data))\n          .range(range);\n    fontSize = function(x) { return sizeScale(fsize(x)); };\n  }\n\n  data.forEach(function(t) {\n    t[as[0]] = NaN;\n    t[as[1]] = NaN;\n    t[as[3]] = 0;\n  });\n\n  // configure layout\n  var words = layout\n    .words(data)\n    .text(_.text)\n    .size(_.size || [500, 500])\n    .padding(_.padding || 1)\n    .spiral(_.spiral || 'archimedean')\n    .rotate(_.rotate || 0)\n    .font(_.font || 'sans-serif')\n    .fontStyle(_.fontStyle || 'normal')\n    .fontWeight(_.fontWeight || 'normal')\n    .fontSize(fontSize)\n    .random(random)\n    .layout();\n\n  var size = layout.size(),\n      dx = size[0] >> 1,\n      dy = size[1] >> 1,\n      i = 0,\n      n = words.length,\n      w, t;\n\n  for (; i<n; ++i) {\n    w = words[i];\n    t = w.datum;\n    t[as[0]] = w.x + dx;\n    t[as[1]] = w.y + dy;\n    t[as[2]] = w.font;\n    t[as[3]] = w.size;\n    t[as[4]] = w.style;\n    t[as[5]] = w.weight;\n    t[as[6]] = w.rotate;\n  }\n\n  return pulse.reflow(mod).modifies(as);\n};\n\nfunction extent(field, data) {\n  var min = +Infinity,\n      max = -Infinity,\n      i = 0,\n      n = data.length,\n      v;\n\n  for (; i<n; ++i) {\n    v = field(data[i]);\n    if (v < min) min = v;\n    if (v > max) max = v;\n  }\n\n  return [min, max];\n}\n","/**\n * Copyright 2014-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n'use strict';\n\n/**\n * Similar to invariant but only logs a warning if the condition is not met.\n * This can be used to log issues in development environments in critical\n * paths. Removing the logging code for production environments will keep the\n * same logic and follow the same code paths.\n */\n\nvar warning = function() {};\n\nif (process.env.NODE_ENV !== 'production') {\n  warning = function(condition, format, args) {\n    var len = arguments.length;\n    args = new Array(len > 2 ? len - 2 : 0);\n    for (var key = 2; key < len; key++) {\n      args[key - 2] = arguments[key];\n    }\n    if (format === undefined) {\n      throw new Error(\n        '`warning(condition, format, ...args)` requires a warning ' +\n        'message argument'\n      );\n    }\n\n    if (format.length < 10 || (/^[s\\W]*$/).test(format)) {\n      throw new Error(\n        'The warning format should be able to uniquely identify this ' +\n        'warning. Please, use a more descriptive format than: ' + format\n      );\n    }\n\n    if (!condition) {\n      var argIndex = 0;\n      var message = 'Warning: ' +\n        format.replace(/%s/g, function() {\n          return args[argIndex++];\n        });\n      if (typeof console !== 'undefined') {\n        console.error(message);\n      }\n      try {\n        // This error was thrown as a convenience so that you can use this stack\n        // to find the callsite that caused this warning to fire.\n        throw new Error(message);\n      } catch(x) {}\n    }\n  };\n}\n\nmodule.exports = warning;\n","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n","import * as React from \"react\";\n// Importing desktop containers\nimport Homepage from \"./routes/homepage\";\n\nexport default class App extends React.Component {\n  public render() {\n    return (\n      <div>\n        <Homepage />\n      </div>\n    );\n  }\n}\n","// Importing modules\r\nimport * as React from \"react\";\r\nimport Map from \"./Map\";\r\nimport \"./dashboard.scss\";\r\n\r\nexport default class Dashboard extends React.Component {\r\n  public render() {\r\n    return (\r\n      <div className=\"desktop-page-container\">\r\n        <Map />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import * as React from \"react\";\nimport * as VegaLite from \"react-vega-lite\";\n\nconst spec = {\n  $schema: \"https://vega.github.io/schema/vega-lite/v2.json\",\n  width: 700,\n  height: 500,\n  config: {\n    view: {\n      stroke: \"transparent\"\n    }\n  },\n  layer: [\n    {\n      data: {\n        url: \"http://localhost:8000/datasets/hk.json\",\n        format: {\n          type: \"topojson\",\n          feature: \"districts\"\n        }\n      },\n      layer: [\n        {\n          mark: {\n            type: \"geoshape\",\n            stroke: \"white\",\n            strokeWidth: 2\n          },\n          encoding: {\n            color: {\n              value: \"#eee\"\n            }\n          }\n        }\n      ]\n    }\n  ]\n};\n\nclass Map extends React.Component<any, any> {\n  public render() {\n    return (\n      <div>\n        <h1>Hello From Map</h1>\n        <VegaLite spec={spec} />\n      </div>\n    );\n  }\n}\n\nexport default Map;\n","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./dashboard.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {\"hmr\":true}\noptions.transform = transform\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/style-loader/lib/addStyles.js\")(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./dashboard.scss\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/sass-loader/lib/loader.js!./dashboard.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}","import * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <Router>\n    <Switch>\n      <Route path=\"/\" component={App} />\n    </Switch>\n  </Router>,\n  document.getElementById(\"app\") as HTMLElement\n);\n","import * as React from \"react\";\r\nimport { Route, Switch } from \"react-router-dom\";\r\nimport Dashboard from \"../Page/Dashboard/Dashboard\";\r\n\r\nexport default class MobileRoutes extends React.Component {\r\n  public render() {\r\n    return (\r\n      <div>\r\n        <Switch>\r\n          <Route path=\"/\" component={Dashboard} />\r\n        </Switch>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","/* (ignored) */","/* (ignored) */"],"sourceRoot":""}